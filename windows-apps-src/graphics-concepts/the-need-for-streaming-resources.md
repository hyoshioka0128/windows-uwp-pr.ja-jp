---
title: ストリーミング リソースのニーズ
description: ストリーミング リソースは、アクセスされないサーフェスの領域を保存して GPU メモリを無駄にしないために、また、隣接するタイルをまたいでフィルター処理する方法をハードウェアに伝えるために必要です。
ms.assetid: A88BE65B-104F-4176-9809-C12580A3684C
keywords:
- ストリーミング リソースのニーズ
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: 0e0354b0e727e84d562bf63779e74be72f87198f
ms.sourcegitcommit: a3dc929858415b933943bba5aa7487ffa721899f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/07/2018
ms.locfileid: "8801475"
---
# <a name="the-need-for-streaming-resources"></a><span data-ttu-id="02323-104">ストリーミング リソースのニーズ</span><span class="sxs-lookup"><span data-stu-id="02323-104">The need for streaming resources</span></span>


<span data-ttu-id="02323-105">ストリーミング リソースは、アクセスされないサーフェスの領域を保存して GPU メモリを無駄にしないために、また、隣接するタイルをまたいでフィルター処理する方法をハードウェアに伝えるために必要です。</span><span class="sxs-lookup"><span data-stu-id="02323-105">Streaming resources are needed so GPU memory isn't wasted storing regions of surfaces that won't be accessed, and to tell the hardware how to filter across adjacent tiles.</span></span>

## <a name="span-idstreamingresourcesorsparsetexturesspanspan-idstreamingresourcesorsparsetexturesspanspan-idstreamingresourcesorsparsetexturesspanstreaming-resources-or-sparse-textures"></a><span data-ttu-id="02323-106"><span id="Streaming_resources_or_sparse_textures"></span><span id="streaming_resources_or_sparse_textures"></span><span id="STREAMING_RESOURCES_OR_SPARSE_TEXTURES"></span>ストリーミング リソースまたはスパース テクスチャ</span><span class="sxs-lookup"><span data-stu-id="02323-106"><span id="Streaming_resources_or_sparse_textures"></span><span id="streaming_resources_or_sparse_textures"></span><span id="STREAMING_RESOURCES_OR_SPARSE_TEXTURES"></span>Streaming resources or sparse textures</span></span>


<span data-ttu-id="02323-107">*ストリーミング リソース* (Direct3D 11 では*タイル リソース*と呼ばれます) は、少量の物理メモリを使用する大規模な論理リソースです。</span><span class="sxs-lookup"><span data-stu-id="02323-107">*Streaming resources* (called *tiled resources* in Direct3D 11), are large logical resources that use small amounts of physical memory.</span></span>

<span data-ttu-id="02323-108">ストリーミング リソースの別の名前が*スパース テクスチャ*です。</span><span class="sxs-lookup"><span data-stu-id="02323-108">Another name for streaming resources is *sparse textures*.</span></span> <span data-ttu-id="02323-109">"スパース" には、リソースがタイルに分割されることと、それらすべてが一度にマップされないと予測されること (タイルに分割される主な理由) の両方の意味が含まれます。</span><span class="sxs-lookup"><span data-stu-id="02323-109">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="02323-110">実際、アプリケーションは、意図的にリソースのすべての領域およびミップス用にデータが作成されないストリーミング リソースを作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="02323-110">In fact, an application could conceivably author a streaming resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="02323-111">そのため、コンテンツ自体がスパースである可能性があり、特定時点でのグラフィックス処理装置 (GPU) のメモリ内のコンテンツのマッピングはそれのサブセットになります (さらにスパースになります)。</span><span class="sxs-lookup"><span data-stu-id="02323-111">So, the content itself could be sparse, and the mapping of the content in graphics processing unit (GPU) memory at a given time would be a subset of that (even more sparse).</span></span>

## <a name="span-idwithouttilingmemoryallocationsaremanagedatsubresourcegranularityspanspan-idwithouttilingmemoryallocationsaremanagedatsubresourcegranularityspanspan-idwithouttilingmemoryallocationsaremanagedatsubresourcegranularityspanwithout-tiling-memory-allocations-are-managed-at-subresource-granularity"></a><span data-ttu-id="02323-112"><span id="Without_tiling__memory_allocations_are_managed_at_subresource_granularity"></span><span id="without_tiling__memory_allocations_are_managed_at_subresource_granularity"></span><span id="WITHOUT_TILING__MEMORY_ALLOCATIONS_ARE_MANAGED_AT_SUBRESOURCE_GRANULARITY"></span>タイル表示を行わない場合、メモリ割り当てはサブリソースの詳細レベルで管理される</span><span class="sxs-lookup"><span data-stu-id="02323-112"><span id="Without_tiling__memory_allocations_are_managed_at_subresource_granularity"></span><span id="without_tiling__memory_allocations_are_managed_at_subresource_granularity"></span><span id="WITHOUT_TILING__MEMORY_ALLOCATIONS_ARE_MANAGED_AT_SUBRESOURCE_GRANULARITY"></span>Without tiling, memory allocations are managed at subresource granularity</span></span>


<span data-ttu-id="02323-113">ストリーミング リソースのサポートがないグラフィックス システム (オペレーティング システム、ディスプレイ ドライバー、およびグラフィックス ハードウェア) では、グラフィックス システムは、すべての Direct3D のメモリ割り当てをサブリソースの詳細レベルで管理します。</span><span class="sxs-lookup"><span data-stu-id="02323-113">In a graphics system (that is, the operating system, display driver, and graphics hardware) without streaming resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span>

<span data-ttu-id="02323-114">[バッファー](introduction-to-buffers.md)の場合、バッファー全体がサブリソースです。</span><span class="sxs-lookup"><span data-stu-id="02323-114">For a [buffer](introduction-to-buffers.md), the entire buffer is the subresource.</span></span>

<span data-ttu-id="02323-115">[テクスチャ](textures.md) ([**Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff471525) など) の場合、各ミップ レベルがサブリソースです。テクスチャ配列 ([**Texture2DArray**](https://msdn.microsoft.com/library/windows/desktop/ff471526) など) の場合、特定の配列スライスの各ミップ レベルがサブリソースです。</span><span class="sxs-lookup"><span data-stu-id="02323-115">For a [Texture](textures.md), (for example, [**Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff471525)), each mip level is a subresource; for a texture array, (for example, [**Texture2DArray**](https://msdn.microsoft.com/library/windows/desktop/ff471526)) each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="02323-116">グラフィックス システムは、このサブリソースの詳細レベルで割り当てのマッピングを管理できることだけを公開します。</span><span class="sxs-lookup"><span data-stu-id="02323-116">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="02323-117">ストリーミング リソースのコンテキストでは、"マッピング" はデータを GPU に見えるようにすることを指します。</span><span class="sxs-lookup"><span data-stu-id="02323-117">In the context of streaming resources, "mapping" refers to making data visible to the GPU.</span></span>

## <a name="span-idwithouttilingcantaccessonlyasmallportionofmipmapchainspanspan-idwithouttilingcantaccessonlyasmallportionofmipmapchainspanspan-idwithouttilingcantaccessonlyasmallportionofmipmapchainspanwithout-tiling-cant-access-only-a-small-portion-of-mipmap-chain"></a><span data-ttu-id="02323-118"><span id="Without_tiling__can_t_access_only_a_small_portion_of_mipmap_chain"></span><span id="without_tiling__can_t_access_only_a_small_portion_of_mipmap_chain"></span><span id="WITHOUT_TILING__CAN_T_ACCESS_ONLY_A_SMALL_PORTION_OF_MIPMAP_CHAIN"></span>タイル表示を行わない場合、ミップマップ チェーンの一部にのみアクセスすることはできない</span><span class="sxs-lookup"><span data-stu-id="02323-118"><span id="Without_tiling__can_t_access_only_a_small_portion_of_mipmap_chain"></span><span id="without_tiling__can_t_access_only_a_small_portion_of_mipmap_chain"></span><span id="WITHOUT_TILING__CAN_T_ACCESS_ONLY_A_SMALL_PORTION_OF_MIPMAP_CHAIN"></span>Without tiling, can't access only a small portion of mipmap chain</span></span>


<span data-ttu-id="02323-119">特定のレンダリング操作で、画像のミップマップ チェーンの一部 (特定のミップマップの全領域でもない) にのみアクセスする必要があることがアプリケーションにわかっているとします。</span><span class="sxs-lookup"><span data-stu-id="02323-119">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="02323-120">理想的には、アプリはこの必要性についてグラフィックス システムに通知できます。</span><span class="sxs-lookup"><span data-stu-id="02323-120">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="02323-121">そして、グラフィックス システムは、大量のメモリでページングせず、必要なメモリが GPU にマップされることだけを考えればよくなります。</span><span class="sxs-lookup"><span data-stu-id="02323-121">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span>

<span data-ttu-id="02323-122">実際には、ストリーミング リソースのサポートがないと、グラフィックス システムには、サブリソースの詳細レベルで GPU にマップする必要があるメモリに関してのみ通知されます (たとえば、アクセスできる全体のミップマップ レベルの範囲)。</span><span class="sxs-lookup"><span data-stu-id="02323-122">In reality, without streaming resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="02323-123">グラフィックス システムにはデマンド フォールトがないため、潜在的にはメモリのいずれかの部分を参照するレンダリング コマンドが実行される前に、サブリソースの完全なマッピングを行うために余分な GPU メモリを大量に使用することが必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02323-123">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="02323-124">これは、ストリーミング リソースのサポートがないときに、Direct3D で大量のメモリの割り当てを使用することを難しくする問題の 1 つにすぎません。</span><span class="sxs-lookup"><span data-stu-id="02323-124">This is just one issue that makes the use of large memory allocations difficult in Direct3D without streaming resource support.</span></span>

## <a name="span-idsoftwarepagingtobreakthesurfaceintosmallertilesspanspan-idsoftwarepagingtobreakthesurfaceintosmallertilesspanspan-idsoftwarepagingtobreakthesurfaceintosmallertilesspansoftware-paging-to-break-the-surface-into-smaller-tiles"></a><span data-ttu-id="02323-125"><span id="Software_paging_to_break_the_surface_into_smaller_tiles"></span><span id="software_paging_to_break_the_surface_into_smaller_tiles"></span><span id="SOFTWARE_PAGING_TO_BREAK_THE_SURFACE_INTO_SMALLER_TILES"></span>サーフェスを小さいタイルに分割するソフトウェア ページング</span><span class="sxs-lookup"><span data-stu-id="02323-125"><span id="Software_paging_to_break_the_surface_into_smaller_tiles"></span><span id="software_paging_to_break_the_surface_into_smaller_tiles"></span><span id="SOFTWARE_PAGING_TO_BREAK_THE_SURFACE_INTO_SMALLER_TILES"></span>Software paging to break the surface into smaller tiles</span></span>


<span data-ttu-id="02323-126">ソフトウェア ページングを使用して、サーフェスをハードウェアが処理できる小さいタイルに分割することができます。</span><span class="sxs-lookup"><span data-stu-id="02323-126">Software paging can be used to break the surface into tiles that are small enough for the hardware to handle.</span></span>

<span data-ttu-id="02323-127">Direct3D は、特定の辺で最大 16384 ピクセルある [**Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff471525) サーフェスをサポートします。</span><span class="sxs-lookup"><span data-stu-id="02323-127">Direct3D supports [**Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff471525) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="02323-128">幅 16384 × 高さ 16384、1 ピクセルあたり 4 バイトの画像は、1 GB のビデオ メモリを消費します (ミップマップを追加すると、その量の倍になります)。</span><span class="sxs-lookup"><span data-stu-id="02323-128">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="02323-129">実際には、1 つのレンダリング操作で 1 GB 全体の参照が必要になることはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="02323-129">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="02323-130">一部のゲーム開発者は、地形のサーフェスを 128 K × 128 K の大きさでモデル化します。</span><span class="sxs-lookup"><span data-stu-id="02323-130">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="02323-131">彼らがこれを既存の GPU で動作させる方法は、サーフェスをハードウェアが処理できる小さいタイルに分割することです。</span><span class="sxs-lookup"><span data-stu-id="02323-131">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="02323-132">アプリケーションは、どのタイルが必要になるかを調べて、それらを GPU でテクスチャのキャッシュに読み込む必要があります。これがソフトウェア ページング システムです。</span><span class="sxs-lookup"><span data-stu-id="02323-132">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span>

<span data-ttu-id="02323-133">その方法の大きな欠点は、ハードウェアが進行中のページングについて何もわからないことから生じます。画面に表示する必要がある画像の一部がタイルをまたいでいるとき、ハードウェアにはタイルをまたいで効率的にフィルター処理する固定関数を実行する方法がわかりません。</span><span class="sxs-lookup"><span data-stu-id="02323-133">A significant downside to that approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="02323-134">つまり、ソフトウェアのタイル処理を管理しているアプリケーションが、シェーダー コードでテクスチャのフィルター処理を手動で行うか (これは、高品質の異方性フィルターが必要な場合に非常に高価になります)、固定関数によるハードウェア フィルター処理が補助し続けられるように、メモリを浪費して隣接するタイルのデータを格納するガターをタイルの周囲に作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="02323-134">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

## <a name="span-idmakingtiledrepresentationofsurfaceallocationsafirst-classfeaturespanspan-idmakingtiledrepresentationofsurfaceallocationsafirst-classfeaturespanspan-idmakingtiledrepresentationofsurfaceallocationsafirst-classfeaturespanmaking-tiled-representation-of-surface-allocations-a-first-class-feature"></a><span data-ttu-id="02323-135"><span id="Making_tiled_representation_of_surface_allocations_a_first-class_feature"></span><span id="making_tiled_representation_of_surface_allocations_a_first-class_feature"></span><span id="MAKING_TILED_REPRESENTATION_OF_SURFACE_ALLOCATIONS_A_FIRST-CLASS_FEATURE"></span>サーフェスの割り当てのタイル表現を最上位の機能にする</span><span class="sxs-lookup"><span data-stu-id="02323-135"><span id="Making_tiled_representation_of_surface_allocations_a_first-class_feature"></span><span id="making_tiled_representation_of_surface_allocations_a_first-class_feature"></span><span id="MAKING_TILED_REPRESENTATION_OF_SURFACE_ALLOCATIONS_A_FIRST-CLASS_FEATURE"></span>Making tiled representation of surface allocations a first-class feature</span></span>


<span data-ttu-id="02323-136">サーフェスの割り当てのタイル表現がグラフィックス システムで最上位の機能であれば、アプリケーションはどのタイルを利用できるようにするかをハードウェアに伝えることができます。</span><span class="sxs-lookup"><span data-stu-id="02323-136">If a tiled representation of surface allocations is a first-class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="02323-137">この方法で、アクセスされないことがアプリケーションにわかっているサーフェイスの領域を保存するために浪費する GPU メモリが少なくなり、ハードウェアは隣接するタイルにわたってフィルター処理する方法を理解でき、ソフトウェアのタイル処理を実行している開発者が経験する問題点の一部が軽減されます。</span><span class="sxs-lookup"><span data-stu-id="02323-137">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="02323-138">しかし、完全なソリューションを提供するには、サーフェス内のタイル処理がサポートされるかどうかに関係なく、サーフェスの現在の最大サイズは既にアプリケーションが必要としている 128 K 以上にはほど遠い 16384 であることに対応するために何かをする必要があります。</span><span class="sxs-lookup"><span data-stu-id="02323-138">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="02323-139">ハードウェアにより大きいテクスチャ サイズをサポートするように求めることも 1 つの方法ですが、その方向に進むことには大きなコスト増やトレードオフがあります。</span><span class="sxs-lookup"><span data-stu-id="02323-139">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span>

<span data-ttu-id="02323-140">Direct3D のテクスチャ フィルター パスとレンダリング パスは、16 K テクスチャのサポートでの精度に関しては、レンダリング中にサーフェスから離れるビューポートの範囲のサポートや、フィルター処理中のサーフェスのエッジからのテクスチャの折り返しのサポートなど他の要求で既に飽和状態です。</span><span class="sxs-lookup"><span data-stu-id="02323-140">Direct3D's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="02323-141">可能な方法は、テクスチャ サイズが 16K を超えて増えるにつれて、機能/精度をある程度落とすようにトレードオフを定義することです。</span><span class="sxs-lookup"><span data-stu-id="02323-141">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="02323-142">ただし、ここで譲歩しても、より大きいテクスチャ サイズに移行できるようにハードウェア システム全体にわたる能力を増強するためには、追加のハードウェア コストが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="02323-142">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

## <a name="span-idissuewithlargetexturesprecisionforlocationsonsurfacespanspan-idissuewithlargetexturesprecisionforlocationsonsurfacespanspan-idissuewithlargetexturesprecisionforlocationsonsurfacespanissue-with-large-textures-precision-for-locations-on-surface"></a><span data-ttu-id="02323-143"><span id="Issue_with_large_textures__precision_for_locations_on_surface"></span><span id="issue_with_large_textures__precision_for_locations_on_surface"></span><span id="ISSUE_WITH_LARGE_TEXTURES__PRECISION_FOR_LOCATIONS_ON_SURFACE"></span>大きいテクスチャの問題: サーフェス上の位置の精度</span><span class="sxs-lookup"><span data-stu-id="02323-143"><span id="Issue_with_large_textures__precision_for_locations_on_surface"></span><span id="issue_with_large_textures__precision_for_locations_on_surface"></span><span id="ISSUE_WITH_LARGE_TEXTURES__PRECISION_FOR_LOCATIONS_ON_SURFACE"></span>Issue with large textures: precision for locations on surface</span></span>


<span data-ttu-id="02323-144">テクスチャが非常に大きくなるにつれて出てくる問題の 1 つは、単精度浮動小数点のテクスチャ座標 (およびラスター化をサポートするための関連する補間操作) では、サーフェス上の位置を正確に指定する精度が足りなくなることです。</span><span class="sxs-lookup"><span data-stu-id="02323-144">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="02323-145">テクスチャのフィルター処理が不安定になります。</span><span class="sxs-lookup"><span data-stu-id="02323-145">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="02323-146">高価なオプションの 1 つは倍精度の補間操作のサポートを求めることですが、妥当な代替案としては過剰になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="02323-146">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

## <a name="span-idenablingmultipleresourcesofdifferentdimensionstosharememoryspanspan-idenablingmultipleresourcesofdifferentdimensionstosharememoryspanspan-idenablingmultipleresourcesofdifferentdimensionstosharememoryspanenabling-multiple-resources-of-different-dimensions-to-share-memory"></a><span data-ttu-id="02323-147"><span id="Enabling_multiple_resources_of_different_dimensions_to_share_memory"></span><span id="enabling_multiple_resources_of_different_dimensions_to_share_memory"></span><span id="ENABLING_MULTIPLE_RESOURCES_OF_DIFFERENT_DIMENSIONS_TO_SHARE_MEMORY"></span>さまざまなサイズの複数のリソースがメモリを共有できるようにする</span><span class="sxs-lookup"><span data-stu-id="02323-147"><span id="Enabling_multiple_resources_of_different_dimensions_to_share_memory"></span><span id="enabling_multiple_resources_of_different_dimensions_to_share_memory"></span><span id="ENABLING_MULTIPLE_RESOURCES_OF_DIFFERENT_DIMENSIONS_TO_SHARE_MEMORY"></span>Enabling multiple resources of different dimensions to share memory</span></span>


<span data-ttu-id="02323-148">ストリーミング リソースによって処理できるもう 1 つのシナリオは、さまざまなサイズ/形式の複数のリソースが同じメモリを共有できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="02323-148">Another scenario that could be served by streaming resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="02323-149">アプリケーションで、同時に使用しないことがわかっている排他的なリソースのセットや、非常に短時間だけ使用するために作成されて破棄されるリソース (その後に他のリソースが作成される) を処理することがあります。</span><span class="sxs-lookup"><span data-stu-id="02323-149">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="02323-150">"ストリーミング リソース" から離れることが可能な一般論として、ユーザーが同じ (重なり合う) メモリにある複数の異なるリソースを指すことを許可することができます。</span><span class="sxs-lookup"><span data-stu-id="02323-150">A form of generality that can fall out of "streaming resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="02323-151">つまり、"リソース" の作成と破棄 (サイズ/形式を定義するなど) は、アプリケーションの視点からリソースの基になるメモリの管理から切り離すことができます。</span><span class="sxs-lookup"><span data-stu-id="02323-151">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="span-idrelated-topicsspanrelated-topics"></a><span data-ttu-id="02323-152"><span id="related-topics"></span>関連トピック</span><span class="sxs-lookup"><span data-stu-id="02323-152"><span id="related-topics"></span>Related topics</span></span>


[<span data-ttu-id="02323-153">ストリーミング リソース</span><span class="sxs-lookup"><span data-stu-id="02323-153">Streaming resources</span></span>](streaming-resources.md)

 

 




