---
title: ピクセル シェーダー (PS) ステージ
description: ピクセル シェーダー (PS) ステージはプリミティブの補間データを受信し、カラーなどのピクセル単位のデータを生成します。
ms.assetid: 0AEBFDFB-0AD8-4633-AE4E-A44004B57745
keywords:
- ピクセル シェーダー (PS) ステージ
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: e1f7e787f2ee80a3168d38a9afd9a249dc0e6de0
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2019
ms.locfileid: "57603067"
---
# <a name="pixel-shader-ps-stage"></a><span data-ttu-id="fc015-104">ピクセル シェーダー (PS) ステージ</span><span class="sxs-lookup"><span data-stu-id="fc015-104">Pixel Shader (PS) stage</span></span>


<span data-ttu-id="fc015-105">ピクセル シェーダー (PS) ステージはプリミティブの補間データを受信し、カラーなどのピクセル単位のデータを生成します。</span><span class="sxs-lookup"><span data-stu-id="fc015-105">The Pixel Shader (PS) stage receives interpolated data for a primitive, and generates per-pixel data such as color.</span></span>

<span data-ttu-id="fc015-106">これはプログラム可能なシェーダー ステージであり、[グラフィックス パイプライン](graphics-pipeline.md)図では角丸ブロックとして示されます。</span><span class="sxs-lookup"><span data-stu-id="fc015-106">This is a programmable shader stage; it is shown as a rounded block in the [graphics pipeline](graphics-pipeline.md) diagram.</span></span> <span data-ttu-id="fc015-107">このシェーダー ステージは、シェーダー モデル 4.0 の[共通シェーダー コア](https://msdn.microsoft.com/library/windows/desktop/bb509580)に基づいて構築された、独自の機能を公開します。</span><span class="sxs-lookup"><span data-stu-id="fc015-107">This shader stage exposes its own unique functionality, built on the shader model 4.0 [common-shader core](https://msdn.microsoft.com/library/windows/desktop/bb509580).</span></span>

<span data-ttu-id="fc015-108">ピクセル シェーダー ステージ (PS) では、ピクセル単位の照明や後処理など、豊富なシェーディング手法を使用できます。</span><span class="sxs-lookup"><span data-stu-id="fc015-108">The Pixel Shader (PS) stage enables rich shading techniques such as per-pixel lighting and post-processing.</span></span> <span data-ttu-id="fc015-109">ピクセル シェーダーは、定数変数、テクスチャ データ、補間された頂点単位の値などのデータを組み合わせて、ピクセル単位の出力を生成するプログラムです。</span><span class="sxs-lookup"><span data-stu-id="fc015-109">A pixel shader is a program that combines constant variables, texture data, interpolated per-vertex values, and other data to produce per-pixel outputs.</span></span> <span data-ttu-id="fc015-110">[ラスタライザー (RS) ステージ](rasterizer-stage--rs-.md)では、プリミティブによってカバーされたピクセルごとにピクセル シェーダーが 1 回呼び出されます。ただし、**NULL** シェーダーを指定して、シェーダーを実行しないようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="fc015-110">The [Rasterizer (RS) stage](rasterizer-stage--rs-.md) invokes a pixel shader once for each pixel covered by a primitive, however, it is possible to specify a **NULL** shader to avoid running a shader.</span></span>

<span data-ttu-id="fc015-111">テクスチャをマルチサンプリングする場合、カバーされたピクセルごとにピクセル シェーダーが 1 回呼び出され、カバーされた各マルチサンプルについて深度/ステンシル テストが発生します。</span><span class="sxs-lookup"><span data-stu-id="fc015-111">When multisampling a texture, a pixel shader is invoked once per-covered pixel while a depth/stencil test occurs for each covered multisample.</span></span> <span data-ttu-id="fc015-112">深度/ステンシル テストを通過したサンプルは、ピクセル シェーダーの出力色で更新されます。</span><span class="sxs-lookup"><span data-stu-id="fc015-112">Samples that pass the depth/stencil test are updated with the pixel shader output color.</span></span>

<span data-ttu-id="fc015-113">ピクセル シェーダーの組み込み関数は、画面領域 x および y についての数量の微分係数を生成したり、使用したりします。</span><span class="sxs-lookup"><span data-stu-id="fc015-113">The pixel shader intrinsic functions produce or use derivatives of quantities with respect to screen space x and y.</span></span> <span data-ttu-id="fc015-114">微分係数の最も一般的な用途は、テクスチャ サンプリングの詳細レベルの計算や、異方性フィルタリングにおいて、異方性の軸に沿ったサンプルを選択するための計算などです。</span><span class="sxs-lookup"><span data-stu-id="fc015-114">The most common use for derivatives is to compute level-of-detail calculations for texture sampling and in the case of anisotropic filtering, selecting samples along the axis of anisotropy.</span></span> <span data-ttu-id="fc015-115">通常、ハードウェアの実装では、複数のピクセル (たとえば 2x2 グリッド) に対して同時にピクセル シェーダーが実行されます。そのため、ピクセル シェーダーで計算された数量の微分係数を、隣接ピクセルの同じ実行時点における値の差分として合理的に近似させることができます。</span><span class="sxs-lookup"><span data-stu-id="fc015-115">Typically, a hardware implementation runs a pixel shader on multiple pixels (for example a 2x2 grid) simultaneously, so that derivatives of quantities computed in the pixel shader can be reasonably approximated as deltas of the values at the same point of execution in adjacent pixels.</span></span>

## <a name="span-idinputsspanspan-idinputsspanspan-idinputsspaninputs"></a><span data-ttu-id="fc015-116"><span id="Inputs"></span><span id="inputs"></span><span id="INPUTS"></span>入力</span><span class="sxs-lookup"><span data-stu-id="fc015-116"><span id="Inputs"></span><span id="inputs"></span><span id="INPUTS"></span>Inputs</span></span>


<span data-ttu-id="fc015-117">パイプラインがジオメトリ シェーダーなしに構成されている場合、ピクセル シェーダーは 16 個の 32 ビット、4 成分の入力に制限されます。</span><span class="sxs-lookup"><span data-stu-id="fc015-117">When the pipeline is configured without a geometry shader, a pixel shader is limited to 16, 32-bit, 4-component inputs.</span></span> <span data-ttu-id="fc015-118">それ以外の場合、ピクセル シェーダーは 32 ビット、4 成分の入力を 32 個まで受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="fc015-118">Otherwise, a pixel shader can take up to 32, 32-bit, 4-component inputs.</span></span>

<span data-ttu-id="fc015-119">ピクセル シェーダーの入力データには (パースペクティブ補正あり/なしで補間可能な) 頂点属性が含まれます。または、ピクセル シェーダーの入力データをプリミティブ単位の定数として処理することもできます。</span><span class="sxs-lookup"><span data-stu-id="fc015-119">Pixel shader input data includes vertex attributes (that can be interpolated with or without perspective correction) or can be treated as per-primitive constants.</span></span> <span data-ttu-id="fc015-120">ピクセル シェーダー入力は、宣言された補間モードに基づき、ラスター化されているプリミティブの頂点属性から補間されます。</span><span class="sxs-lookup"><span data-stu-id="fc015-120">Pixel shader inputs are interpolated from the vertex attributes of the primitive being rasterized, based on the interpolation mode declared.</span></span> <span data-ttu-id="fc015-121">プリミティブがラスター化前にクリップされた場合は、クリッピング処理中に補間モードが受け入れられます。</span><span class="sxs-lookup"><span data-stu-id="fc015-121">If a primitive gets clipped before rasterization, the interpolation mode is honored during the clipping process as well.</span></span>

<span data-ttu-id="fc015-122">頂点属性は、ピクセル シェーダーの中心位置で補間 (または評価) されます。</span><span class="sxs-lookup"><span data-stu-id="fc015-122">Vertex attributes are interpolated (or evaluated) at pixel shader center locations.</span></span> <span data-ttu-id="fc015-123">ピクセル シェーダーの属性補間モードは、入力レジスタ宣言において、[引数](https://msdn.microsoft.com/library/windows/desktop/bb509606)または[入力構造体](https://msdn.microsoft.com/library/windows/desktop/bb509668)の要素単位で宣言します。</span><span class="sxs-lookup"><span data-stu-id="fc015-123">Pixel shader attribute interpolation modes are declared in an input register declaration, on a per-element basis in either an [argument](https://msdn.microsoft.com/library/windows/desktop/bb509606) or an [input structure](https://msdn.microsoft.com/library/windows/desktop/bb509668).</span></span> <span data-ttu-id="fc015-124">属性は、線形補間することも、重心サンプリングによって補間することもできます。</span><span class="sxs-lookup"><span data-stu-id="fc015-124">Attributes can be interpolated linearly, or with centroid sampling.</span></span> <span data-ttu-id="fc015-125">「[ラスター化ルール](rasterization-rules.md)」の「マルチサンプル アンチエイリアシング時の属性の重心サンプリング」セクションをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fc015-125">See the section "Centroid Sampling of Attributes when Multisample Antialiasing" in [Rasterization rules](rasterization-rules.md).</span></span> <span data-ttu-id="fc015-126">重心評価はマルチサンプリング時のみに関連し、ピクセルがプリミティブによってカバーされているが、ピクセルの重心はカバーされていない場合に対応するためのものです。重心評価は、(カバーされていない) ピクセルの重心のできるだけ近くで行われます。</span><span class="sxs-lookup"><span data-stu-id="fc015-126">Centroid evaluation is relevant only during multisampling to cover cases where a pixel is covered by a primitive but a pixel center may not be; centroid evaluation occurs as close as possible to the (non-covered) pixel center.</span></span>

<span data-ttu-id="fc015-127">入力はシステム値セマンティクスで宣言することもできます。[システム値セマンティクス](https://msdn.microsoft.com/library/windows/desktop/bb509647)は、他のパイプライン ステージで使用されるパラメーターをマークします。</span><span class="sxs-lookup"><span data-stu-id="fc015-127">Inputs may also be declared with a [system-value semantic](https://msdn.microsoft.com/library/windows/desktop/bb509647), which marks a parameter that is consumed by other pipeline stages.</span></span> <span data-ttu-id="fc015-128">たとえば、SV でピクセルの位置をマークする必要があります\_セマンティックの位置。</span><span class="sxs-lookup"><span data-stu-id="fc015-128">For instance, a pixel position should be marked with the SV\_Position semantic.</span></span> <span data-ttu-id="fc015-129">[入力アセンブラー (IA) ステージ](input-assembler-stage--ia-.md)ピクセル シェーダーの 1 つのスカラーを生成することができます (SV を使用して\_PrimitiveID)、 [(RS) ラスタライザー ステージ](rasterizer-stage--rs-.md)(SVを使用してピクセルシェーダーのも、1つのスカラーを生成できます\_IsFrontFace)。</span><span class="sxs-lookup"><span data-stu-id="fc015-129">The [Input Assembler (IA) stage](input-assembler-stage--ia-.md) can produce one scalar for a pixel shader (using SV\_PrimitiveID); the [Rasterizer (RS) stage](rasterizer-stage--rs-.md) can also generate one scalar for a pixel shader (using SV\_IsFrontFace).</span></span>

## <a name="span-idoutputsspanspan-idoutputsspanspan-idoutputsspanoutputs"></a><span data-ttu-id="fc015-130"><span id="Outputs"></span><span id="outputs"></span><span id="OUTPUTS"></span>出力</span><span class="sxs-lookup"><span data-stu-id="fc015-130"><span id="Outputs"></span><span id="outputs"></span><span id="OUTPUTS"></span>Outputs</span></span>


<span data-ttu-id="fc015-131">ピクセル シェーダーは、32 ビット、4 成分の色を 8 つまで出力できます。ピクセルが破棄された場合は色を出力することはできません。</span><span class="sxs-lookup"><span data-stu-id="fc015-131">A pixel shader can output up to 8, 32-bit, 4-component colors, or no color if the pixel is discarded.</span></span> <span data-ttu-id="fc015-132">ピクセル シェーダーの出力レジスタの成分は、使用前に宣言する必要があります。レジスタごとに異なる出力書き込みマスクを使用できます。</span><span class="sxs-lookup"><span data-stu-id="fc015-132">Pixel shader output register components must be declared before they can be used; each register is allowed a distinct output-write mask.</span></span>

<span data-ttu-id="fc015-133">深度バッファーに深度データを書き込むかどうかは、([出力結合 (OM) ステージ](output-merger-stage--om-.md)で) 深度書き込みの有効化ステートを使用して制御します (または、破棄命令を使用して、そのピクセルのデータを破棄します)。</span><span class="sxs-lookup"><span data-stu-id="fc015-133">Use the depth-write-enable state (in the [Output Merger (OM) stage](output-merger-stage--om-.md)) to control whether depth data gets written to a depth buffer (or use the discard instruction to discard data for that pixel).</span></span> <span data-ttu-id="fc015-134">ピクセル シェーダーに綿密にテストの省略可能な 32 ビット、1 コンポーネント、浮動小数点、深さの値を出力もできます (SV を使用して\_セマンティックの深さ)。</span><span class="sxs-lookup"><span data-stu-id="fc015-134">A pixel shader can also output an optional 32-bit, 1-component, floating-point, depth value for depth testing (using the SV\_Depth semantic).</span></span> <span data-ttu-id="fc015-135">深度値は、oDepth レジスタに出力され、深度テスト用の補間された深度値と置き換えられます (深度テストが有効化されていると想定しています)。</span><span class="sxs-lookup"><span data-stu-id="fc015-135">The depth value is output in the oDepth register, and replaces the interpolated depth value for depth testing (assuming depth testing is enabled).</span></span> <span data-ttu-id="fc015-136">固定関数深度またはシェーダー oDepth の使用を動的に変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="fc015-136">There is no way to dynamically change between using fixed-function depth or shader oDepth.</span></span>

<span data-ttu-id="fc015-137">ピクセル シェーダーはステンシル値を出力できません。</span><span class="sxs-lookup"><span data-stu-id="fc015-137">A pixel shader cannot output a stencil value.</span></span>

## <a name="span-idrelated-topicsspanrelated-topics"></a><span data-ttu-id="fc015-138"><span id="related-topics"></span>関連トピック</span><span class="sxs-lookup"><span data-stu-id="fc015-138"><span id="related-topics"></span>Related topics</span></span>


[<span data-ttu-id="fc015-139">グラフィックス パイプライン</span><span class="sxs-lookup"><span data-stu-id="fc015-139">Graphics pipeline</span></span>](graphics-pipeline.md)

 

 




