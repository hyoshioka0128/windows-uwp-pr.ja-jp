---
title: C# および Visual Basic での Windows ランタイム コンポーネントの作成
description: .NET Framework 4.5 以降では、マネージ コードを使って独自の Windows ランタイム型を作成し、Windows ランタイム コンポーネントにパッケージ化することができます。
ms.assetid: A5672966-74DF-40AB-B01E-01E3FCD0AD7A
ms.date: 12/04/2018
ms.topic: article
dev_langs:
- csharp
- vb
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 5a7f2d2db5670b0102f589fcd6d764a239d3bb3f
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2019
ms.locfileid: "57619967"
---
# <a name="creating-windows-runtime-components-in-c-and-visual-basic"></a><span data-ttu-id="33cb3-104">C# および Visual Basic での Windows ランタイム コンポーネントの作成</span><span class="sxs-lookup"><span data-stu-id="33cb3-104">Creating Windows Runtime Components in C# and Visual Basic</span></span>
<span data-ttu-id="33cb3-105">以降、.NET Framework 4.5 では、マネージ コードを使用して、独自の Windows ランタイム型を作成し、Windows ランタイム コンポーネントにパッケージ化します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-105">Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types and package them in a Windows Runtime component.</span></span> <span data-ttu-id="33cb3-106">C++、JavaScript、Visual Basic で記述されているユニバーサル Windows プラットフォーム (UWP) アプリで、コンポーネントを使用するか、C#します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-106">You can use your component in Universal Windows Platform (UWP) apps that are written in C++, JavaScript, Visual Basic, or C#.</span></span> <span data-ttu-id="33cb3-107">このトピックでは、コンポーネントを作成するための規則を示し、Windows ランタイム向けの .NET Framework のサポートをいくつか説明します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-107">This topic outlines the rules for creating a component, and discusses some aspects of .NET Framework support for the Windows Runtime.</span></span> <span data-ttu-id="33cb3-108">このサポートは、通常、.NET Framework のプログラマが意識しなくても利用できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="33cb3-108">In general, that support is designed to be transparent to the .NET Framework programmer.</span></span> <span data-ttu-id="33cb3-109">ただし、JavaScript や C++ で使うコンポーネントを作成する場合は、これらの言語が Windows ランタイムをサポートする方法の違いに注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-109">However, when you create a component to use with JavaScript or C++, you need to be aware of differences in the way those languages support the Windows Runtime.</span></span>

<span data-ttu-id="33cb3-110">Visual Basic で記述された UWP アプリでのみ使用するコンポーネントを作成する場合またはC#、UWP のコントロール、onsider を使用して、コンポーネントが含まれていない、**クラス ライブラリ**テンプレートの代わりに、 **Windowsランタイム コンポーネント**Microsoft Visual Studio でプロジェクト テンプレート。</span><span class="sxs-lookup"><span data-stu-id="33cb3-110">If you are creating a component for use only in UWP apps that are written in Visual Basic or C#, and the component does not contain UWP controls, then onsider using the **Class Library** template instead of the **Windows Runtime Component** project template in Microsoft Visual Studio.</span></span> <span data-ttu-id="33cb3-111">単純なクラス ライブラリでは、制限は少なくなります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-111">There are fewer restrictions on a simple class library.</span></span>

## <a name="declaring-types-in-windows-runtime-components"></a><span data-ttu-id="33cb3-112">Windows ランタイム コンポーネントでの型の宣言</span><span class="sxs-lookup"><span data-stu-id="33cb3-112">Declaring types in Windows Runtime Components</span></span>

<span data-ttu-id="33cb3-113">内部的には、コンポーネントでは Windows ランタイム型では、UWP アプリで許可されている .NET Framework の機能を使用できます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-113">Internally, the Windows Runtime types in your component can use any .NET Framework functionality that's allowed in a UWP app.</span></span> <span data-ttu-id="33cb3-114">詳細については、次を参照してください。 [UWP アプリ用 .NET](https://msdn.microsoft.com/library/windows/apps/mt185501)します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-114">For more info, see [.NET for UWP apps](https://msdn.microsoft.com/library/windows/apps/mt185501).</span></span>

<span data-ttu-id="33cb3-115">外部で、型のメンバーは、そのパラメーターの Windows ランタイム型のみを公開および戻り値。</span><span class="sxs-lookup"><span data-stu-id="33cb3-115">Externally, the members of your types can expose only Windows Runtime types for their parameters and return values.</span></span> <span data-ttu-id="33cb3-116">次の一覧では、Windows ランタイム コンポーネントから公開されている .NET Framework 型の制限事項について説明します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-116">The following list describes the limitations on .NET Framework types that are exposed from a Windows Runtime Component.</span></span>

- <span data-ttu-id="33cb3-117">コンポーネント内にあるすべてのパブリック型とメンバーのフィールド、パラメーター、戻り値は、Windows ランタイム型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-117">The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.</span></span> <span data-ttu-id="33cb3-118">この制限には、Windows ランタイム型と Windows ランタイム自体によって提供される型を作成するが含まれます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-118">This restriction includes the Windows Runtime types that you author as well as types that are provided by the Windows Runtime itself.</span></span> <span data-ttu-id="33cb3-119">また、さまざまな .NET Framework 型も対象となります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-119">It also includes a number of .NET Framework types.</span></span> <span data-ttu-id="33cb3-120">これらの型を含めることは、一部のサポートは、.NET Framework は、マネージ コードで、Windows ランタイムの自然な使用を有効にする&mdash;基になる Windows ランタイム型ではなく、使い慣れた .NET Framework の型を使用するユーザー コードが表示されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-120">The inclusion of these types is part of the support the .NET Framework provides to enable the natural use of the Windows Runtime in managed code&mdash;your code appears to use familiar .NET Framework types instead of the underlying Windows Runtime types.</span></span> <span data-ttu-id="33cb3-121">たとえば、.NET Framework のプリミティブ型をなどに使用できます**Int32**と**二重**などの特定の基本型**DateTimeOffset**と**Uri**、よく使用されるジェネリック インターフェイスの種類など**IEnumerable&lt;T&gt;**  (Visual Basic では IEnumerable (Of T)) と**IDictionary&lt;TKey, TValue&gt;** します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-121">For example, you can use .NET Framework primitive types such as **Int32** and **Double**, certain fundamental types such as **DateTimeOffset** and **Uri**, and some commonly used generic interface types such as **IEnumerable&lt;T&gt;** (IEnumerable(Of T) in Visual Basic) and **IDictionary&lt;TKey,TValue&gt;**.</span></span> <span data-ttu-id="33cb3-122">これらのジェネリック型の型引数は Windows ランタイム型である必要がありますに注意してください。</span><span class="sxs-lookup"><span data-stu-id="33cb3-122">Note that the type arguments of these generic types must be Windows Runtime types.</span></span> <span data-ttu-id="33cb3-123">これについてのセクションでは説明[マネージ コードに渡すことの Windows ランタイム型](#passing-windows-runtime-types-to-managed-code)と[マネージ型の Windows ランタイムへの引き渡し](#passing-managed-types-to-the-windows-runtime)、このトピックで後述します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-123">This is discussed in the sections [Passing Windows Runtime types to managed code](#passing-windows-runtime-types-to-managed-code) and [Passing managed types to the Windows Runtime](#passing-managed-types-to-the-windows-runtime), later in this topic.</span></span>

- <span data-ttu-id="33cb3-124">パブリック クラスとインターフェイスには、メソッド、プロパティ、イベントを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-124">Public classes and interfaces can contain methods, properties, and events.</span></span> <span data-ttu-id="33cb3-125">イベントのデリゲートを宣言したり、使用して、 **EventHandler&lt;T&gt;** を委任します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-125">You can declare delegates for your events, or use the **EventHandler&lt;T&gt;** delegate.</span></span> <span data-ttu-id="33cb3-126">パブリック クラスまたはインターフェイスは使用できません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-126">A public class or interface can't:</span></span>
    - <span data-ttu-id="33cb3-127">ジェネリックにする。</span><span class="sxs-lookup"><span data-stu-id="33cb3-127">Be generic.</span></span>
    - <span data-ttu-id="33cb3-128">インターフェイスは、Windows ランタイム インターフェイスを実装する (ただし、独自の Windows ランタイム インターフェイスを作成およびそれらを実装できます)。</span><span class="sxs-lookup"><span data-stu-id="33cb3-128">Implement an interface that is not a Windows Runtime interface (however, you can create your own Windows Runtime interfaces and implement them).</span></span>
    - <span data-ttu-id="33cb3-129">など、Windows ランタイムでない型から派生する**System.Exception**と**System.EventArgs**します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-129">Derive from types that are not in the Windows Runtime, such as **System.Exception** and **System.EventArgs**.</span></span>

- <span data-ttu-id="33cb3-130">すべてのパブリック型にはアセンブリ名に一致するルート名前空間が必要になります。ただし、アセンブリ名の先頭には "Windows" を付けることはできません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-130">All public types must have a root namespace that matches the assembly name, and the assembly name must not begin with "Windows".</span></span>

    > <span data-ttu-id="33cb3-131">**ヒント:** します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-131">**Tip**.</span></span> <span data-ttu-id="33cb3-132">既定では、Visual Studio プロジェクトは、アセンブリ名に一致する名前空間の名前があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-132">By default, Visual Studio projects have namespace names that match the assembly name.</span></span> <span data-ttu-id="33cb3-133">Visual Basic では、この既定の名前空間の Namespace ステートメントはコードに表示されません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-133">In Visual Basic, the Namespace statement for this default namespace is not shown in your code.</span></span>

- <span data-ttu-id="33cb3-134">パブリック構造体はパブリック フィールド以外のメンバーを持つことができません。また、それらのフィールドは値型または文字列であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="33cb3-134">Public structures can't have any members other than public fields, and those fields must be value types or strings.</span></span>
- <span data-ttu-id="33cb3-135">パブリック クラスは **sealed** (Visual Basic では **NotInheritable**) であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="33cb3-135">Public classes must be **sealed** (**NotInheritable** in Visual Basic).</span></span> <span data-ttu-id="33cb3-136">プログラミング モデルがポリモーフィズムを必要とできますインターフェイスは、パブリック インターフェイスを作成し、ポリモーフィックをする必要があるクラスにそのインターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-136">If your programming model requires polymorphism, then you can create a public interface, and implement that interface on the classes that must be polymorphic.</span></span>

## <a name="debugging-your-component"></a><span data-ttu-id="33cb3-137">コンポーネントのデバッグ</span><span class="sxs-lookup"><span data-stu-id="33cb3-137">Debugging your component</span></span>

<span data-ttu-id="33cb3-138">UWP アプリとコンポーネントの両方がマネージ コードに組み込まれている場合、それらをデバッグできます両方同時に。</span><span class="sxs-lookup"><span data-stu-id="33cb3-138">If both your UWP app and your component are built with managed code, then you can debug them both at the same time.</span></span>

<span data-ttu-id="33cb3-139">C++ を使った UWP アプリの一部としてコンポーネントをテストする際に、同時にマネージ コードとネイティブ コードをデバッグできます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-139">When you're testing your component as part of a UWP app using C++, you can debug managed and native code at the same time.</span></span> <span data-ttu-id="33cb3-140">既定では、ネイティブ コードのみになります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-140">The default is native code only.</span></span>

## <a name="to-debug-both-native-c-code-and-managed-code"></a><span data-ttu-id="33cb3-141">ネイティブ C++ コードとマネージ コードの両方をデバッグするには</span><span class="sxs-lookup"><span data-stu-id="33cb3-141">To debug both native C++ code and managed code</span></span>
1.  <span data-ttu-id="33cb3-142">Visual C++ プロジェクトのショートカット メニューを開き、**[プロパティ]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="33cb3-142">Open the shortcut menu for your Visual C++ project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="33cb3-143">プロパティ ページの **[構成プロパティ]** で、**[デバッグ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-143">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="33cb3-144">**[デバッガーの種類]** を選び、ドロップダウン リスト ボックスで、**[ネイティブのみ]** を **[混合 (マネージとネイティブ)]** に変更します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-144">Choose **Debugger Type**, and in the drop-down list box change **Native Only** to **Mixed (Managed and Native)**.</span></span> <span data-ttu-id="33cb3-145">**[OK]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="33cb3-145">Choose **OK**.</span></span>
4.  <span data-ttu-id="33cb3-146">ネイティブ コードとマネージ コードのブレークポイントを設定します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-146">Set breakpoints in native and managed code.</span></span>

<span data-ttu-id="33cb3-147">JavaScript を使用して UWP アプリの一部としてコンポーネントをテストするときに既定では、ソリューションは JavaScript デバッグ モード。</span><span class="sxs-lookup"><span data-stu-id="33cb3-147">When you're testing your component as part of a UWP app using JavaScript, by default the solution is in JavaScript debugging mode.</span></span> <span data-ttu-id="33cb3-148">Visual Studio では、JavaScript とマネージ コードを同時にデバッグすることはできません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-148">In Visual Studio, you can't debug JavaScript and managed code at the same time.</span></span>

## <a name="to-debug-managed-code-instead-of-javascript"></a><span data-ttu-id="33cb3-149">JavaScript ではなくマネージ コードをデバッグするには</span><span class="sxs-lookup"><span data-stu-id="33cb3-149">To debug managed code instead of JavaScript</span></span>
1.  <span data-ttu-id="33cb3-150">JavaScript プロジェクトのショートカット メニューを開き、**[プロパティ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-150">Open the shortcut menu for your JavaScript project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="33cb3-151">プロパティ ページの **[構成プロパティ]** で、**[デバッグ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-151">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="33cb3-152">**[デバッガーの種類]** を選び、ドロップダウン リスト ボックスで、**[スクリプトのみ]** を **[マネージのみ]** に変更します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-152">Choose **Debugger Type**, and in the drop-down list box change **Script Only** to **Managed Only**.</span></span> <span data-ttu-id="33cb3-153">**[OK]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="33cb3-153">Choose **OK**.</span></span>
4.  <span data-ttu-id="33cb3-154">マネージ コードのブレークポイントを設定し、通常どおりにデバッグします。</span><span class="sxs-lookup"><span data-stu-id="33cb3-154">Set breakpoints in managed code and debug as usual.</span></span>

## <a name="passing-windows-runtime-types-to-managed-code"></a><span data-ttu-id="33cb3-155">マネージ コードへの Windows ランタイム型の引き渡し</span><span class="sxs-lookup"><span data-stu-id="33cb3-155">Passing Windows Runtime types to managed code</span></span>
<span data-ttu-id="33cb3-156">セクションで説明したよう[Windows ランタイム コンポーネントの宣言型](#declaring-types-in-windows-runtime-components)、特定の .NET Framework の型がパブリック クラスのメンバーのシグネチャに表示できます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-156">As mentioned previously in the section [Declaring types in Windows Runtime Components](#declaring-types-in-windows-runtime-components), certain .NET Framework types can appear in the signatures of members of public classes.</span></span> <span data-ttu-id="33cb3-157">これは、マネージ コードで Windows ランタイムを通常どおりに使うことができるようにするために、.NET Framework が提供するサポートの一部です。</span><span class="sxs-lookup"><span data-stu-id="33cb3-157">This is part of the support that the .NET Framework provides to enable the natural use of the Windows Runtime in managed code.</span></span> <span data-ttu-id="33cb3-158">これには、プリミティブ型と一部のクラスやインターフェイスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-158">It includes primitive types and some classes and interfaces.</span></span> <span data-ttu-id="33cb3-159">、JavaScript または C++ コードからコンポーネントを使用する場合は、呼び出し元に、.NET Framework の型がどのように表示されるかを知る必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-159">When your component is used from JavaScript, or from C++ code, it's important to know how your .NET Framework types appear to the caller.</span></span> <span data-ttu-id="33cb3-160">参照してください[チュートリアル。単純なコンポーネントを作成するC#または Visual Basic、および JavaScript による呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)の JavaScript の例。</span><span class="sxs-lookup"><span data-stu-id="33cb3-160">See [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md) for examples with JavaScript.</span></span> <span data-ttu-id="33cb3-161">このセクションでは、よく使われる型について説明します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-161">This section discusses commonly used types.</span></span>

<span data-ttu-id="33cb3-162">.NET Framework のプリミティブ型など、 **Int32**構造がある多くの便利なプロパティおよびメソッドなど、 **TryParse**メソッド。</span><span class="sxs-lookup"><span data-stu-id="33cb3-162">In the .NET Framework, primitive types such as the **Int32** structure have many useful properties and methods, such as the **TryParse** method.</span></span> <span data-ttu-id="33cb3-163">これに対して、Windows ランタイムのプリミティブ型と構造体は、フィールドしか保持していません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-163">By contrast, primitive types and structures in the Windows Runtime only have fields.</span></span> <span data-ttu-id="33cb3-164">これらの型をマネージ コードに渡すと、.NET Framework 型のように表示され、通常どおりに .NET Framework のプロパティとメソッドを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-164">When you pass these types to managed code, they appear to be .NET Framework types, and you can use the properties and methods of the .NET Framework types as you normally would.</span></span> <span data-ttu-id="33cb3-165">IDE で自動的に行われる置き換えの概要を次に示します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-165">The following list summarizes the substitutions that are made automatically in the IDE:</span></span>

-   <span data-ttu-id="33cb3-166">Windows ランタイムのプリミティブの**Int32**、 **Int64**、**単一**、**二重**、**ブール**、 **文字列**(変更できないコレクションの Unicode 文字)、 **Enum**、 **UInt32**、 **UInt64**、および**Guid**、System 名前空間で同じ名前の型を使用します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-166">For the Windows Runtime primitives **Int32**, **Int64**, **Single**, **Double**, **Boolean**, **String** (an immutable collection of Unicode characters), **Enum**, **UInt32**, **UInt64**, and **Guid**, use the type of the same name in the System namespace.</span></span>
-   <span data-ttu-id="33cb3-167">**UInt8**を使用して、 **System.Byte**します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-167">For **UInt8**, use **System.Byte**.</span></span>
-   <span data-ttu-id="33cb3-168">**Char16**を使用して、 **System.Char**します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-168">For **Char16**, use **System.Char**.</span></span>
-   <span data-ttu-id="33cb3-169">**IInspectable**インターフェイスを使用して**System.Object**します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-169">For the **IInspectable** interface, use **System.Object**.</span></span>

<span data-ttu-id="33cb3-170">場合C#または Visual Basic がこれらの種類のいずれかの言語のキーワードを提供し、代わりに、言語キーワードを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-170">If C# or Visual Basic provides a language keyword for any of these types, then you can use the language keyword instead.</span></span>

<span data-ttu-id="33cb3-171">プリミティブ型に加えて、よく使用される基本的な Windows ランタイム型が、同等の .NET Framework 型としてマネージ コードに表示されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-171">In addition to primitive types, some basic, commonly used Windows Runtime types appear in managed code as their .NET Framework equivalents.</span></span> <span data-ttu-id="33cb3-172">たとえば、JavaScript のコードで使用して、 **Windows.Foundation.Uri**クラスしたい場合に渡す、C#または Visual Basic のメソッド。</span><span class="sxs-lookup"><span data-stu-id="33cb3-172">For example, suppose your JavaScript code uses the **Windows.Foundation.Uri** class, and you want to pass it to a C# or Visual Basic method.</span></span> <span data-ttu-id="33cb3-173">マネージ コードの等価の型は .NET Framework **System.Uri**クラス、メソッド パラメーターに使用する型です。</span><span class="sxs-lookup"><span data-stu-id="33cb3-173">The equivalent type in managed code is the .NET Framework **System.Uri** class, and that's the type to use for the method parameter.</span></span> <span data-ttu-id="33cb3-174">マネージ コードを記述するとき、Visual Studio の IntelliSense によって Windows ランタイム型が表示されなくなり、同等の .NET Framework 型が示されるため、Windows ランタイム型が .NET Framework 型として表示されていることがわかります </span><span class="sxs-lookup"><span data-stu-id="33cb3-174">You can tell when a Windows Runtime type appears as a .NET Framework type, because IntelliSense in Visual Studio hides the Windows Runtime type when you're writing managed code, and presents the equivalent .NET Framework type.</span></span> <span data-ttu-id="33cb3-175">(通常、2 つの型の名前は同じです。</span><span class="sxs-lookup"><span data-stu-id="33cb3-175">(Usually the two types have the same name.</span></span> <span data-ttu-id="33cb3-176">ただし、注意、 **Windows.Foundation.DateTime**としてマネージ コードの構造が表示されます**System.DateTimeOffset**ではなく**System.DateTime**。)。</span><span class="sxs-lookup"><span data-stu-id="33cb3-176">However, note that the **Windows.Foundation.DateTime** structure appears in managed code as **System.DateTimeOffset** and not as **System.DateTime**.)</span></span>

<span data-ttu-id="33cb3-177">よく使われるコレクション型の一部では、Windows ランタイム型によって実装されるインターフェイスと、対応する .NET Framework 型によって実装されるインターフェイスと間で対応付けが行われます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-177">For some commonly used collection types, the mapping is between the interfaces that are implemented by a Windows Runtime type and the interfaces that are implemented by the corresponding .NET Framework type.</span></span> <span data-ttu-id="33cb3-178">上で説明した型と同じように、.NET Framework 型を使ってパラメーターの型を宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-178">As with the types mentioned above, you declare parameter types by using the .NET Framework type.</span></span> <span data-ttu-id="33cb3-179">これにより、型の間にある相違点を意識せずに、.NET Framework コードを通常どおりに記述することができます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-179">This hides some differences between the types and makes writing .NET Framework code more natural.</span></span>

<span data-ttu-id="33cb3-180">次の表は、最も一般的なジェネリック インターフェイスの型、および他の一般的なクラスやインターフェイスに関する対応付けを示しています。</span><span class="sxs-lookup"><span data-stu-id="33cb3-180">The following table lists the most common of these generic interface types, along with other common class and interface mappings.</span></span> <span data-ttu-id="33cb3-181">.NET Framework がマップされる Windows ランタイム型の完全な一覧を参照してください。 [Windows ランタイム型の .NET Framework のマッピング](net-framework-mappings-of-windows-runtime-types.md)します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-181">For a complete list of Windows Runtime types that the .NET Framework maps, see [.NET Framework mappings of Windows Runtime types](net-framework-mappings-of-windows-runtime-types.md).</span></span>

| <span data-ttu-id="33cb3-182">Windows ランタイム</span><span class="sxs-lookup"><span data-stu-id="33cb3-182">Windows Runtime</span></span>                                  | <span data-ttu-id="33cb3-183">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="33cb3-183">.NET Framework</span></span>                                    |
|-|-|
| <span data-ttu-id="33cb3-184">IIterable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-184">IIterable&lt;T&gt;</span></span>                               | <span data-ttu-id="33cb3-185">IEnumerable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-185">IEnumerable&lt;T&gt;</span></span>                              |
| <span data-ttu-id="33cb3-186">IVector&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-186">IVector&lt;T&gt;</span></span>                                 | <span data-ttu-id="33cb3-187">IList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-187">IList&lt;T&gt;</span></span>                                    |
| <span data-ttu-id="33cb3-188">IVectorView&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-188">IVectorView&lt;T&gt;</span></span>                             | <span data-ttu-id="33cb3-189">IReadOnlyList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-189">IReadOnlyList&lt;T&gt;</span></span>                            |
| <span data-ttu-id="33cb3-190">IMap&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-190">IMap&lt;K, V&gt;</span></span>                                 | <span data-ttu-id="33cb3-191">IDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-191">IDictionary&lt;TKey, TValue&gt;</span></span>                   |
| <span data-ttu-id="33cb3-192">IMapView&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-192">IMapView&lt;K, V&gt;</span></span>                             | <span data-ttu-id="33cb3-193">IReadOnlyDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-193">IReadOnlyDictionary&lt;TKey, TValue&gt;</span></span>           |
| <span data-ttu-id="33cb3-194">IKeyValuePair&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-194">IKeyValuePair&lt;K, V&gt;</span></span>                        | <span data-ttu-id="33cb3-195">KeyValuePair&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="33cb3-195">KeyValuePair&lt;TKey, TValue&gt;</span></span>                  |
| <span data-ttu-id="33cb3-196">IBindableIterable</span><span class="sxs-lookup"><span data-stu-id="33cb3-196">IBindableIterable</span></span>                                | <span data-ttu-id="33cb3-197">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="33cb3-197">IEnumerable</span></span>                                       |
| <span data-ttu-id="33cb3-198">IBindableVector</span><span class="sxs-lookup"><span data-stu-id="33cb3-198">IBindableVector</span></span>                                  | <span data-ttu-id="33cb3-199">IList</span><span class="sxs-lookup"><span data-stu-id="33cb3-199">IList</span></span>                                             |
| <span data-ttu-id="33cb3-200">Windows.UI.Xaml.Data.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="33cb3-200">Windows.UI.Xaml.Data.INotifyPropertyChanged</span></span>      | <span data-ttu-id="33cb3-201">System.ComponentModel.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="33cb3-201">System.ComponentModel.INotifyPropertyChanged</span></span>      |
| <span data-ttu-id="33cb3-202">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="33cb3-202">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span></span> | <span data-ttu-id="33cb3-203">System.ComponentModel.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="33cb3-203">System.ComponentModel.PropertyChangedEventHandler</span></span> |
| <span data-ttu-id="33cb3-204">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="33cb3-204">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span></span>    | <span data-ttu-id="33cb3-205">System.ComponentModel.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="33cb3-205">System.ComponentModel.PropertyChangedEventArgs</span></span>    |

<span data-ttu-id="33cb3-206">型によって複数のインターフェイスが実装される場合、メンバーのパラメーターの型または戻り値の型として実装されるインターフェイスをすべて使うことができます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-206">When a type implements more than one interface, you can use any of the interfaces it implements as a parameter type or return type of a member.</span></span> <span data-ttu-id="33cb3-207">たとえば、渡すか返す、**ディクショナリ&lt;int、文字列&gt;** (**Dictionary (Of Integer, String)** Visual Basic で) として**IDictionary&lt;int、文字列&gt;**、 **IReadOnlyDictionary&lt;int、文字列&gt;**、または**IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;** します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-207">For example, you can pass or return a **Dictionary&lt;int, string&gt;** (**Dictionary(Of Integer, String)** in Visual Basic) as **IDictionary&lt;int, string&gt;**, **IReadOnlyDictionary&lt;int, string&gt;**, or **IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;**.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="33cb3-208">JavaScript では、マネージ型を実装するインターフェイスの一覧の先頭に表示されるインターフェイスを使用します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-208">JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</span></span> <span data-ttu-id="33cb3-209">たとえば、値を返す場合**ディクショナリ&lt;int、文字列&gt;** として表示される JavaScript コードに**IDictionary&lt;int、文字列&gt;** 関係なく戻り値の型として指定するインターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="33cb3-209">For example, if you return **Dictionary&lt;int, string&gt;** to JavaScript code, it appears as **IDictionary&lt;int, string&gt;** no matter which interface you specify as the return type.</span></span> <span data-ttu-id="33cb3-210">つまり、後のインターフェイスにメンバーが最初のインターフェイスに含まれていない場合、そのメンバーは JavaScript では認識されません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-210">This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</span></span>

<span data-ttu-id="33cb3-211">Windows ランタイムで**IMap&lt;K, V&gt;** と**IMapView&lt;K, V&gt;**  IKeyValuePair を使用して反復されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-211">In the Windows Runtime, **IMap&lt;K, V&gt;** and **IMapView&lt;K, V&gt;** are iterated by using IKeyValuePair.</span></span> <span data-ttu-id="33cb3-212">として表示されるときに、マネージ コードに渡す、 **IDictionary&lt;TKey, TValue&gt;** と**IReadOnlyDictionary&lt;TKey, TValue&gt;** ので、使用する自然**System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;** それらを列挙します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-212">When you pass them to managed code, they appear as **IDictionary&lt;TKey, TValue&gt;** and **IReadOnlyDictionary&lt;TKey, TValue&gt;**, so naturally you use **System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;** to enumerate them.</span></span>

<span data-ttu-id="33cb3-213">インターフェイスがマネージ コード内に表示される方法によって、これらのインターフェイスを実装する型の表示方法が決まります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-213">The way interfaces appear in managed code affects the way types that implement these interfaces appear.</span></span> <span data-ttu-id="33cb3-214">たとえば、 **PropertySet**クラスが実装する**IMap&lt;K, V&gt;**、としてマネージ コードに表示される**IDictionary&lt;TKey、TValue&gt;**.</span><span class="sxs-lookup"><span data-stu-id="33cb3-214">For example, the **PropertySet** class implements **IMap&lt;K, V&gt;**, which appears in managed code as **IDictionary&lt;TKey, TValue&gt;**.</span></span> <span data-ttu-id="33cb3-215">**PropertySet**が実装された場合のように見える**IDictionary&lt;TKey, TValue&gt;** の代わりに**IMap&lt;K, V&gt;** 管理で、コードが表示されます、**追加**メソッドのような動作、**追加**メソッド .NET Framework のディクショナリ。</span><span class="sxs-lookup"><span data-stu-id="33cb3-215">**PropertySet** appears as if it implemented **IDictionary&lt;TKey, TValue&gt;** instead of **IMap&lt;K, V&gt;**, so in managed code it appears to have an **Add** method, which behaves like the **Add** method on .NET Framework dictionaries.</span></span> <span data-ttu-id="33cb3-216">ないように見えます、**挿入**メソッド。</span><span class="sxs-lookup"><span data-stu-id="33cb3-216">It doesn't appear to have an **Insert** method.</span></span> <span data-ttu-id="33cb3-217">この例では、トピックを確認できます[チュートリアル。単純なコンポーネントを作成するC#または Visual Basic、および JavaScript による呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-217">You can see this example in the topic [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="passing-managed-types-to-the-windows-runtime"></a><span data-ttu-id="33cb3-218">Windows ランタイムへのマネージ型の引き渡し</span><span class="sxs-lookup"><span data-stu-id="33cb3-218">Passing managed types to the Windows Runtime</span></span>

<span data-ttu-id="33cb3-219">前のセクションで説明したように、一部の Windows ランタイム型は、コンポーネントのメンバーのシグニチャ内、または IDE で使う場合は Windows ランタイム メンバーのシグニチャ内で、.NET Framework 型として表示される場合があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-219">As discussed in the previous section, some Windows Runtime types can appear as .NET Framework types in the signatures of your component's members, or in the signatures of Windows Runtime members when you use them in the IDE.</span></span> <span data-ttu-id="33cb3-220">.NET Framework 型をこれらのメンバーに渡すか、またはコンポーネントのメンバーの戻り値として使うと、対応する Windows ランタイム型として Windows ランタイム側のコードに表示されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-220">When you pass .NET Framework types to these members or use them as the return values of your component's members, they appear to the code on the other side as the corresponding Windows Runtime type.</span></span> <span data-ttu-id="33cb3-221">コンポーネントが JavaScript から呼び出されたときにこのことがあります、効果の例については、マネージ型を返すコンポーネントから"のセクションで[チュートリアル。単純なコンポーネントを作成するC#または Visual Basic、および JavaScript による呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-221">For examples of the effects this can have when your component is called from JavaScript, see the "Returning managed types from your component" section in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="overloaded-methods"></a><span data-ttu-id="33cb3-222">オーバー ロードされたメソッド</span><span class="sxs-lookup"><span data-stu-id="33cb3-222">Overloaded methods</span></span>

<span data-ttu-id="33cb3-223">Windows ランタイムでは、メソッドはオーバーロードできます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-223">In the Windows Runtime, methods can be overloaded.</span></span> <span data-ttu-id="33cb3-224">ただし場合に、同じ数のパラメーターを持つ複数のオーバー ロードを宣言すると、適用、 [ **Windows.Foundation.Metadata.DefaultOverloadAttribute** ](/uwp/api/windows.foundation.metadata.defaultoverloadattribute)属性をこれらのオーバー ロードの 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="33cb3-224">However, if you declare multiple overloads with the same number of parameters, you must apply the [**Windows.Foundation.Metadata.DefaultOverloadAttribute**](/uwp/api/windows.foundation.metadata.defaultoverloadattribute) attribute to only one of those overloads.</span></span> <span data-ttu-id="33cb3-225">この属性が適用されるオーバーロードが、JavaScript から呼び出すことができる唯一のオーバーロードになります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-225">That overload is the only one you can call from JavaScript.</span></span> <span data-ttu-id="33cb3-226">たとえば、次のコードでは、**int** (Visual Basic では **Integer**) を受け取るオーバーロードが既定のオーバーロードです。</span><span class="sxs-lookup"><span data-stu-id="33cb3-226">For example, in the following code the overload that takes an **int** (**Integer** in Visual Basic) is the default overload.</span></span>

```csharp
public string OverloadExample(string s)
{
    return s;
}

[Windows.Foundation.Metadata.DefaultOverload()]
public int OverloadExample(int x)
{
    return x;
}
```

```vb
Public Function OverloadExample(ByVal s As String) As String
    Return s
End Function

<Windows.Foundation.Metadata.DefaultOverload> _
Public Function OverloadExample(ByVal x As Integer) As Integer
    Return x
End Function
```

> <span data-ttu-id="33cb3-227">[重要]JavaScript を使用すると、任意の値を渡す**OverloadExample**、および値パラメーターで必要な型を強制します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-227">[IMPORTANT] JavaScript allows you to pass any value to **OverloadExample**, and coerces the value to the type that is required by the parameter.</span></span> <span data-ttu-id="33cb3-228">呼び出すことができます**OverloadExample**を"forty-two"、「42」、または 42.3、ですが、すべての値が既定のオーバー ロードに渡されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-228">You can call **OverloadExample** with "forty-two", "42", or 42.3, but all those values are passed to the default overload.</span></span> <span data-ttu-id="33cb3-229">前の例では既定のオーバー ロードは、0、42、および 42 をそれぞれ返します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-229">The default overload in the previous example returns 0, 42, and 42, respectively.</span></span>

<span data-ttu-id="33cb3-230">適用することはできません、 **DefaultOverloadAttribut**e 属性コンストラクターにします。</span><span class="sxs-lookup"><span data-stu-id="33cb3-230">You can't apply the **DefaultOverloadAttribut**e attribute to constructors.</span></span> <span data-ttu-id="33cb3-231">クラスのすべてのコンストラクターは、異なる数のパラメーターを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-231">All the constructors in a class must have different numbers of parameters.</span></span>

## <a name="implementing-istringable"></a><span data-ttu-id="33cb3-232">IStringable の実装</span><span class="sxs-lookup"><span data-stu-id="33cb3-232">Implementing IStringable</span></span>

<span data-ttu-id="33cb3-233">Windows 8.1 以降、Windows ランタイムが含まれています、 **IStringable**インターフェイスの 1 つのメソッドを持つ**IStringable.ToString**、によって提供されるのと同等の基本的な書式設定サポートを提供します。**Object.ToString**します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-233">Starting with Windows 8.1, the Windows Runtime includes an **IStringable** interface whose single method, **IStringable.ToString**, provides basic formatting support comparable to that provided by **Object.ToString**.</span></span> <span data-ttu-id="33cb3-234">実装することを選択する場合**IStringable**で Windows ランタイム コンポーネントでエクスポートしたパブリック マネージ型を次の制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-234">If you do choose to implement **IStringable** in a public managed type that is exported in a Windows Runtime component, the following restrictions apply:</span></span>

-   <span data-ttu-id="33cb3-235">定義することができます、 **IStringable**インターフェイスでは、次のコードなどの「クラスが実装する」関係でしかC#:</span><span class="sxs-lookup"><span data-stu-id="33cb3-235">You can define the **IStringable** interface only in a "class implements" relationship, such as the following code in C#:</span></span>

    ```cs
    public class NewClass : IStringable
    ```

    <span data-ttu-id="33cb3-236">Visual Basic では、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-236">Or the following Visual Basic code:</span></span>

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   <span data-ttu-id="33cb3-237">実装することはできません**IStringable**インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="33cb3-237">You can't implement **IStringable** on an interface.</span></span>
-   <span data-ttu-id="33cb3-238">型パラメーターを宣言することはできません**IStringable**します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-238">You can't declare a parameter to be of type **IStringable**.</span></span>
-   <span data-ttu-id="33cb3-239">**IStringable**メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-239">**IStringable** can't be the return type of a method, property, or field.</span></span>
-   <span data-ttu-id="33cb3-240">非表示にすることはできません、 **IStringable**次などのメソッド定義を使用して基底クラスから実装します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-240">You can't hide your **IStringable** implementation from base classes by using a method definition such as the following:</span></span>

    ```cs
    public class NewClass : IStringable
    {
       public new string ToString()
       {
          return "New ToString in NewClass";
       }
    }
    ```

    <span data-ttu-id="33cb3-241">代わりに、 **IStringable.ToString**実装は、基本クラスの実装を常にオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-241">Instead, the **IStringable.ToString** implementation must always override the base class implementation.</span></span> <span data-ttu-id="33cb3-242">非表示にすることができます、 **ToString**厳密に型指定されたクラスのインスタンスで呼び出すによってのみ実装します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-242">You can hide a **ToString** implementation only by invoking it on a strongly typed class instance.</span></span>

> [!NOTE]
> <span data-ttu-id="33cb3-243">さまざまな条件、ネイティブ コードから呼び出すを実装するマネージ型に**IStringable**の表示と非その**ToString**実装は、予期しない動作を引き起こすことができます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-243">Under a variety of conditions, calls from native code to a managed type that implements **IStringable** or hides its **ToString** implementation can produce unexpected behavior.</span></span>

## <a name="asynchronous-operations"></a><span data-ttu-id="33cb3-244">非同期操作</span><span class="sxs-lookup"><span data-stu-id="33cb3-244">Asynchronous operations</span></span>

<span data-ttu-id="33cb3-245">コンポーネントでは、非同期メソッドを実装するには、メソッド名の末尾に"Async"を追加し、非同期アクションまたは非同期操作を表す Windows ランタイム インターフェイスのいずれかを返します。**IAsyncAction**、 **IAsyncActionWithProgress&lt;TProgress&gt;**、 **IAsyncOperation&lt;TResult&gt;**、または**IAsyncOperationWithProgress&lt;TResult, TProgress&gt;** します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-245">To implement an asynchronous method in your component, add "Async" to the end of the method name and return one of the Windows Runtime interfaces that represent asynchronous actions or operations: **IAsyncAction**, **IAsyncActionWithProgress&lt;TProgress&gt;**, **IAsyncOperation&lt;TResult&gt;**, or **IAsyncOperationWithProgress&lt;TResult, TProgress&gt;**.</span></span>

<span data-ttu-id="33cb3-246">.NET Framework のタスクを使用することができます (、 [**タスク**](/dotnet/api/system.threading.tasks.task)クラスとジェネリック[**タスク&lt;TResult&gt;**  ](/dotnet/api/system.threading.tasks.task-1)クラス) に非同期メソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-246">You can use .NET Framework tasks (the [**Task**](/dotnet/api/system.threading.tasks.task) class and generic [**Task&lt;TResult&gt;**](/dotnet/api/system.threading.tasks.task-1) class) to implement your asynchronous method.</span></span> <span data-ttu-id="33cb3-247">記述された非同期のメソッドから返されたタスクなどの実行中の操作を表すタスクを返す必要がありますC#または Visual Basic、またはタスクから返される、 [ **Task.Run** ](/dotnet/api/system.threading.tasks.task.run)メソッド。</span><span class="sxs-lookup"><span data-stu-id="33cb3-247">You must return a task that represents an ongoing operation, such as a task that is returned from an asynchronous method written in C# or Visual Basic, or a task that is returned from the [**Task.Run**](/dotnet/api/system.threading.tasks.task.run) method.</span></span> <span data-ttu-id="33cb3-248">コンストラクターを使ってタスクを作成する場合、その [Task.Start](/dotnet/api/system.threading.tasks.task.start) メソッドを呼び出してから戻す必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-248">If you use a constructor to create the task, you must call its [Task.Start](/dotnet/api/system.threading.tasks.task.start) method before returning it.</span></span>

<span data-ttu-id="33cb3-249">使用するメソッド`await`(`Await` Visual Basic で) 必要があります、`async`キーワード (`Async` Visual Basic で)。</span><span class="sxs-lookup"><span data-stu-id="33cb3-249">A method that uses `await` (`Await` in Visual Basic) requires the `async` keyword (`Async` in Visual Basic).</span></span> <span data-ttu-id="33cb3-250">Windows ランタイム コンポーネントからこれらのメソッドを公開する場合は、適用、`async`キーワードをデリゲートに渡す、**実行**メソッド。</span><span class="sxs-lookup"><span data-stu-id="33cb3-250">If you expose such a method from a Windows Runtime component, apply the `async` keyword to the delegate that you pass to the **Run** method.</span></span>

<span data-ttu-id="33cb3-251">取り消しや進行状況の報告をサポートしない非同期アクションと非同期操作では、タスクを適切なインターフェイスにラップするために、[WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) または [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) の拡張メソッドを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-251">For asynchronous actions and operations that do not support cancellation or progress reporting, you can use the [WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) or [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) extension method to wrap the task in the appropriate interface.</span></span> <span data-ttu-id="33cb3-252">使用して、次のコードが非同期メソッドを実装するなど、 **Task.Run&lt;TResult&gt;** タスクを開始するメソッド。</span><span class="sxs-lookup"><span data-stu-id="33cb3-252">For example, the following code implements an asynchronous method by using the **Task.Run&lt;TResult&gt;** method to start a task.</span></span> <span data-ttu-id="33cb3-253">**AsAsyncOperation&lt;TResult&gt;** 拡張メソッドは、Windows ランタイムの非同期操作としてタスクを返します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-253">The **AsAsyncOperation&lt;TResult&gt;** extension method returns the task as a Windows Runtime asynchronous operation.</span></span>

```csharp
public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
{
    return Task.Run<IList<string>>(async () =>
    {
        var data = await DownloadDataAsync(id);
        return ExtractStrings(data);
    }).AsAsyncOperation();
}
```

```vb
Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
     As IAsyncOperation(Of IList(Of String))

    Return Task.Run(Of IList(Of String))(
        Async Function()
            Dim data = Await DownloadDataAsync(id)
            Return ExtractStrings(data)
        End Function).AsAsyncOperation()
End Function
```

<span data-ttu-id="33cb3-254">次の JavaScript コードを使用して、メソッドを呼び出す方法を示しています、 [ **WinJS.Promise** ](https://msdn.microsoft.com/library/windows/apps/br211867.aspx)オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="33cb3-254">The following JavaScript code shows how the method could be called by using a [**WinJS.Promise**](https://msdn.microsoft.com/library/windows/apps/br211867.aspx) object.</span></span> <span data-ttu-id="33cb3-255">then メソッドに渡される関数は、非同期呼び出しが完了したときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-255">The function that is passed to the then method is executed when the asynchronous call completes.</span></span> <span data-ttu-id="33cb3-256">StringList パラメーターにはによって返される文字列のリストが含まれています、 **DownloadAsStringAsync**メソッド、および関数は、すべての処理が必要です。</span><span class="sxs-lookup"><span data-stu-id="33cb3-256">The stringList parameter contains the list of strings that is returned by the **DownloadAsStringAsync** method, and the function does whatever processing is required.</span></span>

```javascript
function asyncExample(id) {

    var result = SampleComponent.Example.downloadAsStringAsync(id).then(
        function (stringList) {
            // Place code that uses the returned list of strings here.
        });
}
```

<span data-ttu-id="33cb3-257">非同期アクションおよび操作のキャンセルをサポートまたは進行状況レポートを使用、 [ **AsyncInfo** ](/dotnet/api/system.runtime.interopservices.windowsruntime)開始されたタスクの生成とフック、キャンセルして、進行状況レポートをクラスタスクのキャンセルと進行状況レポート機能を適切な Windows ランタイム インターフェイスの機能です。</span><span class="sxs-lookup"><span data-stu-id="33cb3-257">For asynchronous actions and operations that support cancellation or progress reporting, use the [**AsyncInfo**](/dotnet/api/system.runtime.interopservices.windowsruntime) class to generate a started task and to hook up the cancellation and progress reporting features of the task with the cancellation and progress reporting features of the appropriate Windows Runtime interface.</span></span> <span data-ttu-id="33cb3-258">キャンセルと進行状況レポートの両方をサポートする例について、次を参照してください。[チュートリアル。単純なコンポーネントを作成するC#または Visual Basic、および JavaScript による呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-258">For an example that supports both cancellation and progress reporting, see [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

<span data-ttu-id="33cb3-259">メソッドを使用することに注意してください、 **AsyncInfo**クラスの場合でも、非同期メソッドがキャンセルをサポートまたは進行状況レポートしません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-259">Note that you can use the methods of the **AsyncInfo** class even if your asynchronous method doesn't support cancellation or progress reporting.</span></span> <span data-ttu-id="33cb3-260">Visual Basic のラムダ関数を使用する場合またはC#匿名メソッドは、トークンのパラメーターを指定しないと[ **IProgress&lt;T&gt;**  ](https://msdn.microsoft.com/library/hh138298.aspx)インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="33cb3-260">If you use a Visual Basic lambda function or a C# anonymous method, don't supply parameters for the token and [**IProgress&lt;T&gt;**](https://msdn.microsoft.com/library/hh138298.aspx) interface.</span></span> <span data-ttu-id="33cb3-261">C# のラムダ関数を使う場合は、トークンのパラメーターを指定しますが、無視されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-261">If you use a C# lambda function, supply a token parameter but ignore it.</span></span> <span data-ttu-id="33cb3-262">前の例で使用、AsAsyncOperation&lt;TResult&gt;メソッドでは、次のようを使用する場合、 [ **AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;&gt;**](https://msdn.microsoft.com/library/hh779740.aspx)) メソッド オーバー ロードを代用します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-262">The previous example, which used the AsAsyncOperation&lt;TResult&gt; method, looks like this when you use the [**AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;&gt;**](https://msdn.microsoft.com/library/hh779740.aspx)) method overload instead.</span></span>

```csharp
public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
{
    return AsyncInfo.Run<IList<string>>(async (token) =>
    {
        var data = await DownloadDataAsync(id);
        return ExtractStrings(data);
    });
}
```

```vb
Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
    As IAsyncOperation(Of IList(Of String))

    Return AsyncInfo.Run(Of IList(Of String))(
        Async Function()
            Dim data = Await DownloadDataAsync(id)
            Return ExtractStrings(data)
        End Function)
End Function
```

<span data-ttu-id="33cb3-263">必要に応じてキャンセルまたは進行状況レポートをサポートする非同期メソッドを作成する場合は、キャンセル トークンのパラメーターがないオーバー ロードを追加することを検討してくださいまたは**IProgress&lt;T&gt;** インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="33cb3-263">If you create an asynchronous method that optionally supports cancellation or progress reporting, consider adding overloads that don't have parameters for a cancellation token or the **IProgress&lt;T&gt;** interface.</span></span>

## <a name="throwing-exceptions"></a><span data-ttu-id="33cb3-264">例外のスロー</span><span class="sxs-lookup"><span data-stu-id="33cb3-264">Throwing exceptions</span></span>

<span data-ttu-id="33cb3-265">Windows アプリ用 .NET に含まれている例外の型は、どれでもスローすることができます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-265">You can throw any exception type that is included in the .NET for Windows apps.</span></span> <span data-ttu-id="33cb3-266">Windows ランタイム コンポーネントで独自のパブリック型の例外を宣言することはできませんが、非パブリック型を宣言し、スローすることはできます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-266">You can't declare your own public exception types in a Windows Runtime component, but you can declare and throw non-public types.</span></span>

<span data-ttu-id="33cb3-267">コンポーネントが例外を処理しない場合は、コンポーネントを呼び出したコードで対応する例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-267">If your component doesn't handle the exception, a corresponding exception is raised in the code that called your component.</span></span> <span data-ttu-id="33cb3-268">例外が呼び出し元に表示される方法は、呼び出し元の言語が Windows ランタイムをサポートする方法によって異なります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-268">The way the exception appears to the caller depends on the way the calling language supports the Windows Runtime.</span></span>

-   <span data-ttu-id="33cb3-269">JavaScript では、例外はオブジェクトとして表示され、例外メッセージがスタック トレースで置き換えられています。</span><span class="sxs-lookup"><span data-stu-id="33cb3-269">In JavaScript, the exception appears as an object in which the exception message is replaced by a stack trace.</span></span> <span data-ttu-id="33cb3-270">Visual Studio でアプリをデバッグするとき、デバッガーの例外ダイアログ ボックスに、"WinRT 情報" として元のメッセージ テキストが表示されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-270">When you debug your app in Visual Studio, you can see the original message text displayed in the debugger exception dialog box, identified as "WinRT Information".</span></span> <span data-ttu-id="33cb3-271">JavaScript コードから元のメッセージ テキストにアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-271">You can't access the original message text from JavaScript code.</span></span>

    > <span data-ttu-id="33cb3-272">**ヒント:** します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-272">**Tip**.</span></span><span data-ttu-id="33cb3-273"> 現時点では、スタック トレースには、マネージ例外の種類が含まれていますが、例外の種類を識別するためにトレースを解析はお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-273"> Currently, the stack trace contains the managed exception type, but we don't recommend parsing the trace to identify the exception type.</span></span> <span data-ttu-id="33cb3-274">このセクションの後半で説明するように、代わりに HRESULT 値を使ってください。</span><span class="sxs-lookup"><span data-stu-id="33cb3-274">Instead, use an HRESULT value as described later in this section.</span></span>

-   <span data-ttu-id="33cb3-275">C++ では、例外はプラットフォーム例外として表示されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-275">In C++, the exception appears as a platform exception.</span></span> <span data-ttu-id="33cb3-276">マネージ例外の HResult プロパティは、特定のプラットフォーム例外の HRESULT にマップできる場合、は、特定の例外が使用されます。それ以外の場合、 [ **platform::comexception** ](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx)例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-276">If the managed exception's HResult property can be mapped to the HRESULT of a specific platform exception, the specific exception is used; otherwise, a [**Platform::COMException**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx) exception is thrown.</span></span> <span data-ttu-id="33cb3-277">マネージ例外のメッセージ テキストは、C++ コードでは利用できません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-277">The message text of the managed exception is not available to C++ code.</span></span> <span data-ttu-id="33cb3-278">特定のプラットフォーム例外がスローされた場合、その例外の型に関する既定のメッセージ テキストが表示されます。それ以外の場合は、メッセージ テキストは表示されません。</span><span class="sxs-lookup"><span data-stu-id="33cb3-278">If a specific platform exception was thrown, the default message text for that exception type appears; otherwise, no message text appears.</span></span> <span data-ttu-id="33cb3-279">「[例外 (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="33cb3-279">See [Exceptions (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx).</span></span>
-   <span data-ttu-id="33cb3-280">C# または Visual Basic では、例外は通常のマネージ例外です。</span><span class="sxs-lookup"><span data-stu-id="33cb3-280">In C# or Visual Basic, the exception is a normal managed exception.</span></span>

<span data-ttu-id="33cb3-281">コンポーネントから例外をスローする場合、コンポーネントに固有の HResult プロパティ値を持つ非パブリック型の例外をスローすることにより、JavaScript や C++ の呼び出し元で例外を簡単に処理できるようになります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-281">When you throw an exception from your component, you can make it easier for a JavaScript or C++ caller to handle the exception by throwing a non-public exception type whose HResult property value is specific to your component.</span></span> <span data-ttu-id="33cb3-282">HRESULT は JavaScript の呼び出し元は例外オブジェクトの数値プロパティを使用して、C++ の呼び出し元で使用可能な[ **comexception::hresult** ](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx)プロパティ。</span><span class="sxs-lookup"><span data-stu-id="33cb3-282">The HRESULT is available to a JavaScript caller through the exception object's number property, and to a C++ caller through the [**COMException::HResult**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx) property.</span></span>

> [!NOTE]
> <span data-ttu-id="33cb3-283">負の値を HRESULT を使用します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-283">Use a negative value for your HRESULT.</span></span> <span data-ttu-id="33cb3-284">正の値は成功と解釈されるので、JavaScript や C++ の呼び出し元で例外がスローされなくなります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-284">A positive value is interpreted as success, and no exception is thrown in the JavaScript or C++ caller.</span></span>

## <a name="declaring-and-raising-events"></a><span data-ttu-id="33cb3-285">イベントの宣言と発生</span><span class="sxs-lookup"><span data-stu-id="33cb3-285">Declaring and raising events</span></span>

<span data-ttu-id="33cb3-286">イベントのデータを保持する型を宣言する場合、EventArgs は Windows ランタイム型ではないので、EventArgs の代わりに Object から派生させます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-286">When you declare a type to hold the data for your event, derive from Object instead of from EventArgs, because EventArgs is not a Windows Runtime type.</span></span> <span data-ttu-id="33cb3-287">使用して、 [ **EventHandler&lt;TEventArgs&gt;**  ](https://msdn.microsoft.com/library/db0etb8x.aspx)イベント、および使用してジェネリック型引数としてイベント引数の型の型として。</span><span class="sxs-lookup"><span data-stu-id="33cb3-287">Use [**EventHandler&lt;TEventArgs&gt;**](https://msdn.microsoft.com/library/db0etb8x.aspx) as the type of the event, and use your event argument type as the generic type argument.</span></span> <span data-ttu-id="33cb3-288">イベントは .NET Framework アプリケーションの場合と同様に発生させます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-288">Raise the event just as you would in a .NET Framework application.</span></span>

<span data-ttu-id="33cb3-289">Windows ランタイム コンポーネントが JavaScript や C++ で使われる場合、イベントはそれらの言語で想定されている Windows ランタイムのイベント パターンに従います。</span><span class="sxs-lookup"><span data-stu-id="33cb3-289">When your Windows Runtime component is used from JavaScript or C++, the event follows the Windows Runtime event pattern that those languages expect.</span></span> <span data-ttu-id="33cb3-290">C# や Visual Basic でコンポーネントを使う場合、イベントは通常の .NET Framework のイベントとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-290">When you use the component from C# or Visual Basic, the event appears as an ordinary .NET Framework event.</span></span> <span data-ttu-id="33cb3-291">例が提供される[チュートリアル。単純なコンポーネントを作成するC#または Visual Basic、および JavaScript による呼び出し](/windows/uwp/winrt-components/walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript)します。</span><span class="sxs-lookup"><span data-stu-id="33cb3-291">An example is provided in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](/windows/uwp/winrt-components/walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript).</span></span>

<span data-ttu-id="33cb3-292">カスタム イベント アクセサーを実装する場合 (Visual Basic では **Custom** キーワードでイベントを宣言する場合) は、実装で Windows ランタイムのイベント パターンに従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-292">If you implement custom event accessors (declare an event with the **Custom** keyword, in Visual Basic), you must follow the Windows Runtime event pattern in your implementation.</span></span> <span data-ttu-id="33cb3-293">「[Windows ランタイム コンポーネントのカスタム イベントおよびイベント アクセサー](custom-events-and-event-accessors-in-windows-runtime-components.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="33cb3-293">See [Custom events and event accessors in Windows Runtime Components](custom-events-and-event-accessors-in-windows-runtime-components.md).</span></span> <span data-ttu-id="33cb3-294">C# や Visual Basic コードでイベントを処理する場合でも、通常の .NET Framework のイベントとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="33cb3-294">Note that when you handle the event from C# or Visual Basic code, it still appears to be an ordinary .NET Framework event.</span></span>

## <a name="next-steps"></a><span data-ttu-id="33cb3-295">次のステップ</span><span class="sxs-lookup"><span data-stu-id="33cb3-295">Next steps</span></span>

<span data-ttu-id="33cb3-296">ユーザーが独自に使う Windows ランタイム コンポーネントを作成した後で、そのコンポーネントにカプセル化されている機能が他の開発者の役に立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-296">After you’ve created a Windows Runtime component for your own use, you may find that the functionality it encapsulates is useful to other developers.</span></span> <span data-ttu-id="33cb3-297">他の開発者に配布するためにコンポーネントをパッケージ化する方法は 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="33cb3-297">You have two options for packaging a component for distribution to other developers.</span></span> <span data-ttu-id="33cb3-298">「[マネージ Windows ランタイム コンポーネントの配布](https://msdn.microsoft.com/library/jj614475.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="33cb3-298">See [Distributing a managed Windows Runtime component](https://msdn.microsoft.com/library/jj614475.aspx).</span></span>

<span data-ttu-id="33cb3-299">Visual Basic と C# の言語の機能、および Windows ランタイムに関する .NET Framework のサポートについて詳しくは、「[Visual Basic および C# 言語リファレンス](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="33cb3-299">For more information about Visual Basic and C# language features, and .NET Framework support for the Windows Runtime, see [Visual Basic and C# language reference](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx).</span></span>

## <a name="related-topics"></a><span data-ttu-id="33cb3-300">関連トピック</span><span class="sxs-lookup"><span data-stu-id="33cb3-300">Related topics</span></span>
* [<span data-ttu-id="33cb3-301">UWP アプリ用 .NET</span><span class="sxs-lookup"><span data-stu-id="33cb3-301">.NET for UWP apps</span></span>](https://msdn.microsoft.com/library/windows/apps/mt185501)
* [<span data-ttu-id="33cb3-302">チュートリアル: 単純な Windows ランタイム コンポーネントの作成および JavaScript による呼び出し</span><span class="sxs-lookup"><span data-stu-id="33cb3-302">Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</span></span>](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)
