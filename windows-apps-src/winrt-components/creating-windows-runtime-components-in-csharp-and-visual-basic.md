---
title: C# および Visual Basic での Windows ランタイム コンポーネントの作成
description: .NET Framework 4.5 以降では、マネージ コードを使って独自の Windows ランタイム型を作成し、Windows ランタイム コンポーネントにパッケージ化することができます。
ms.assetid: A5672966-74DF-40AB-B01E-01E3FCD0AD7A
ms.date: 12/04/2018
ms.topic: article
dev_langs:
- csharp
- vb
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: b4f5a2de5c3fa5564b4e4389cfc0806fd5d2844f
ms.sourcegitcommit: 8921a9cc0dd3e5665345ae8eca7ab7aeb83ccc6f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/10/2018
ms.locfileid: "8878263"
---
# <a name="creating-windows-runtime-components-in-c-and-visual-basic"></a><span data-ttu-id="63ecb-104">C# および Visual Basic での Windows ランタイム コンポーネントの作成</span><span class="sxs-lookup"><span data-stu-id="63ecb-104">Creating Windows Runtime Components in C# and Visual Basic</span></span>
<span data-ttu-id="63ecb-105">.NET Framework 4.5 以降、マネージ コードを使用して、独自の Windows ランタイム型を作成し、Windows ランタイム コンポーネントにパッケージ化します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-105">Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types and package them in a Windows Runtime component.</span></span> <span data-ttu-id="63ecb-106">コンポーネントは、C++、JavaScript、Visual Basic または c# で記述されたユニバーサル Windows プラットフォーム (UWP) アプリで使用できます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-106">You can use your component in Universal Windows Platform (UWP) apps that are written in C++, JavaScript, Visual Basic, or C#.</span></span> <span data-ttu-id="63ecb-107">このトピックでは、コンポーネントを作成するための規則について説明し、Windows ランタイムの .NET Framework のサポートの一部の側面を説明します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-107">This topic outlines the rules for creating a component, and discusses some aspects of .NET Framework support for the Windows Runtime.</span></span> <span data-ttu-id="63ecb-108">このサポートは、通常、.NET Framework のプログラマが意識しなくても利用できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="63ecb-108">In general, that support is designed to be transparent to the .NET Framework programmer.</span></span> <span data-ttu-id="63ecb-109">ただし、JavaScript や C++ で使うコンポーネントを作成する場合は、これらの言語が Windows ランタイムをサポートする方法の違いに注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-109">However, when you create a component to use with JavaScript or C++, you need to be aware of differences in the way those languages support the Windows Runtime.</span></span>

<span data-ttu-id="63ecb-110">Visual Basic または c# で記述されている UWP アプリでのみ使うコンポーネントを作成して、コンポーネントが UWP のコントロールでは、 **Windows ランタイム コンポーネント**プロジェクト テンプレートではなく、**クラス ライブラリ**テンプレートを使用して onsider し、含まれていない場合Microsoft Visual Studio でできます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-110">If you are creating a component for use only in UWP apps that are written in Visual Basic or C#, and the component does not contain UWP controls, then onsider using the **Class Library** template instead of the **Windows Runtime Component** project template in Microsoft Visual Studio.</span></span> <span data-ttu-id="63ecb-111">単純なクラス ライブラリでは、制限は少なくなります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-111">There are fewer restrictions on a simple class library.</span></span>

## <a name="declaring-types-in-windows-runtime-components"></a><span data-ttu-id="63ecb-112">Windows ランタイム コンポーネントでの型の宣言</span><span class="sxs-lookup"><span data-stu-id="63ecb-112">Declaring types in Windows Runtime Components</span></span>

<span data-ttu-id="63ecb-113">内部では、コンポーネントでの Windows ランタイム型では、UWP アプリで許可されている .NET Framework の機能を使用できます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-113">Internally, the Windows Runtime types in your component can use any .NET Framework functionality that's allowed in a UWP app.</span></span> <span data-ttu-id="63ecb-114">詳しくは、 [UWP アプリ用 .NET](https://msdn.microsoft.com/library/windows/apps/mt185501)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-114">For more info, see [.NET for UWP apps](https://msdn.microsoft.com/library/windows/apps/mt185501).</span></span>

<span data-ttu-id="63ecb-115">外部では、型のメンバーは、パラメーターの Windows ランタイム型だけを公開し、値を返すできます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-115">Externally, the members of your types can expose only Windows Runtime types for their parameters and return values.</span></span> <span data-ttu-id="63ecb-116">次の一覧では、Windows ランタイム コンポーネントから公開される .NET Framework 型の制限事項について説明します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-116">The following list describes the limitations on .NET Framework types that are exposed from a Windows Runtime Component.</span></span>

- <span data-ttu-id="63ecb-117">コンポーネント内にあるすべてのパブリック型とメンバーのフィールド、パラメーター、戻り値は、Windows ランタイム型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-117">The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.</span></span> <span data-ttu-id="63ecb-118">この制限には、および Windows ランタイム自体で提供される型を作成した Windows ランタイム型が含まれています。</span><span class="sxs-lookup"><span data-stu-id="63ecb-118">This restriction includes the Windows Runtime types that you author as well as types that are provided by the Windows Runtime itself.</span></span> <span data-ttu-id="63ecb-119">また、さまざまな .NET Framework 型も対象となります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-119">It also includes a number of .NET Framework types.</span></span> <span data-ttu-id="63ecb-120">これらの型の一部は、マネージ コードで Windows ランタイムの自然な使い方を有効にする .NET Framework が提供するサポートの&mdash;、基になる Windows ランタイム型の代わりに、使い慣れた .NET Framework 型を使用するコードが表示されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-120">The inclusion of these types is part of the support the .NET Framework provides to enable the natural use of the Windows Runtime in managed code&mdash;your code appears to use familiar .NET Framework types instead of the underlying Windows Runtime types.</span></span> <span data-ttu-id="63ecb-121">たとえば、.NET Framework のプリミティブ型**Int32**や**Double**、 **DateTimeOffset**や**Uri**などの特定の基本型などを使用して、 **IEnumerable などのジェネリック インターフェイス型をよく使われるいくつか&lt;T&gt; \*\* (Visual Basic では IEnumerable (Of T)) と**IDictionary&lt;TKey, TValue&gt;\*\* します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-121">For example, you can use .NET Framework primitive types such as **Int32** and **Double**, certain fundamental types such as **DateTimeOffset** and **Uri**, and some commonly used generic interface types such as **IEnumerable&lt;T&gt;** (IEnumerable(Of T) in Visual Basic) and **IDictionary&lt;TKey,TValue&gt;**.</span></span> <span data-ttu-id="63ecb-122">これらのジェネリック型の型引数は Windows ランタイム型である必要がありますに注意してください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-122">Note that the type arguments of these generic types must be Windows Runtime types.</span></span> <span data-ttu-id="63ecb-123">これは、セクションでは、 [Windows ランタイム型の引き渡しをマネージ コード](#passing-windows-runtime-types-to-managed-code)と[マネージ Windows ランタイム型の引き渡し](#passing-managed-types-to-the-windows-runtime)には、このトピックの後半で説明します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-123">This is discussed in the sections [Passing Windows Runtime types to managed code](#passing-windows-runtime-types-to-managed-code) and [Passing managed types to the Windows Runtime](#passing-managed-types-to-the-windows-runtime), later in this topic.</span></span>

- <span data-ttu-id="63ecb-124">パブリック クラスとインターフェイスには、メソッド、プロパティ、イベントを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-124">Public classes and interfaces can contain methods, properties, and events.</span></span> <span data-ttu-id="63ecb-125">イベントのデリゲートを宣言するか、使用、 **EventHandler&lt;T&gt;** を委任します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-125">You can declare delegates for your events, or use the **EventHandler&lt;T&gt;** delegate.</span></span> <span data-ttu-id="63ecb-126">パブリック クラスやインターフェイスは使用できません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-126">A public class or interface can't:</span></span>
    - <span data-ttu-id="63ecb-127">ジェネリックにする。</span><span class="sxs-lookup"><span data-stu-id="63ecb-127">Be generic.</span></span>
    - <span data-ttu-id="63ecb-128">Windows ランタイム インターフェイスではないインターフェイスを実装 (ただし、独自の Windows ランタイム インターフェイスを作成してそれらを実装できます)。</span><span class="sxs-lookup"><span data-stu-id="63ecb-128">Implement an interface that is not a Windows Runtime interface (however, you can create your own Windows Runtime interfaces and implement them).</span></span>
    - <span data-ttu-id="63ecb-129">**System.Exception**や**System.EventArgs**など、Windows ランタイムではなく型から派生します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-129">Derive from types that are not in the Windows Runtime, such as **System.Exception** and **System.EventArgs**.</span></span>

- <span data-ttu-id="63ecb-130">すべてのパブリック型にはアセンブリ名に一致するルート名前空間が必要になります。ただし、アセンブリ名の先頭には "Windows" を付けることはできません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-130">All public types must have a root namespace that matches the assembly name, and the assembly name must not begin with "Windows".</span></span>

    > <span data-ttu-id="63ecb-131">**ヒント**をします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-131">**Tip**.</span></span> <span data-ttu-id="63ecb-132">既定では、Visual Studio プロジェクトはアセンブリ名に一致する名前空間名があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-132">By default, Visual Studio projects have namespace names that match the assembly name.</span></span> <span data-ttu-id="63ecb-133">Visual Basic では、この既定の名前空間の Namespace ステートメントはコードに表示されません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-133">In Visual Basic, the Namespace statement for this default namespace is not shown in your code.</span></span>

- <span data-ttu-id="63ecb-134">パブリック構造体はパブリック フィールド以外のメンバーを持つことができません。また、それらのフィールドは値型または文字列であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="63ecb-134">Public structures can't have any members other than public fields, and those fields must be value types or strings.</span></span>
- <span data-ttu-id="63ecb-135">パブリック クラスは **sealed** (Visual Basic では **NotInheritable**) であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="63ecb-135">Public classes must be **sealed** (**NotInheritable** in Visual Basic).</span></span> <span data-ttu-id="63ecb-136">プログラミング モデルには、ポリモーフィズムが必要とする場合はパブリック インターフェイスを作成し、ポリモーフィックにする必要のあるクラスにそのインターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-136">If your programming model requires polymorphism, then you can create a public interface, and implement that interface on the classes that must be polymorphic.</span></span>

## <a name="debugging-your-component"></a><span data-ttu-id="63ecb-137">コンポーネントのデバッグ</span><span class="sxs-lookup"><span data-stu-id="63ecb-137">Debugging your component</span></span>

<span data-ttu-id="63ecb-138">UWP アプリとコンポーネントの両方がマネージ コードでに組み込まれている場合、デバッグできますその両方同時にします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-138">If both your UWP app and your component are built with managed code, then you can debug them both at the same time.</span></span>

<span data-ttu-id="63ecb-139">C++ を使った UWP アプリの一部としてコンポーネントをテストしている場合は、同時にマネージとネイティブ コードをデバッグできます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-139">When you're testing your component as part of a UWP app using C++, you can debug managed and native code at the same time.</span></span> <span data-ttu-id="63ecb-140">既定では、ネイティブ コードのみになります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-140">The default is native code only.</span></span>

## <a name="to-debug-both-native-c-code-and-managed-code"></a><span data-ttu-id="63ecb-141">ネイティブ C++ コードとマネージ コードの両方をデバッグするには</span><span class="sxs-lookup"><span data-stu-id="63ecb-141">To debug both native C++ code and managed code</span></span>
1.  <span data-ttu-id="63ecb-142">Visual C++ プロジェクトのショートカット メニューを開き、**[プロパティ]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-142">Open the shortcut menu for your Visual C++ project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="63ecb-143">プロパティ ページの **[構成プロパティ]** で、**[デバッグ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-143">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="63ecb-144">**[デバッガーの種類]** を選び、ドロップダウン リスト ボックスで、**[ネイティブのみ]** を **[混合 (マネージとネイティブ)]** に変更します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-144">Choose **Debugger Type**, and in the drop-down list box change **Native Only** to **Mixed (Managed and Native)**.</span></span> <span data-ttu-id="63ecb-145">**[OK]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-145">Choose **OK**.</span></span>
4.  <span data-ttu-id="63ecb-146">ネイティブ コードとマネージ コードのブレークポイントを設定します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-146">Set breakpoints in native and managed code.</span></span>

<span data-ttu-id="63ecb-147">JavaScript を使って UWP アプリの一部としてコンポーネントをテストしているとき既定では、ソリューションは JavaScript デバッグ モード。</span><span class="sxs-lookup"><span data-stu-id="63ecb-147">When you're testing your component as part of a UWP app using JavaScript, by default the solution is in JavaScript debugging mode.</span></span> <span data-ttu-id="63ecb-148">Visual Studio では、JavaScript とマネージ コードを同時にデバッグすることはできません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-148">In Visual Studio, you can't debug JavaScript and managed code at the same time.</span></span>

## <a name="to-debug-managed-code-instead-of-javascript"></a><span data-ttu-id="63ecb-149">JavaScript ではなくマネージ コードをデバッグするには</span><span class="sxs-lookup"><span data-stu-id="63ecb-149">To debug managed code instead of JavaScript</span></span>
1.  <span data-ttu-id="63ecb-150">JavaScript プロジェクトのショートカット メニューを開き、**[プロパティ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-150">Open the shortcut menu for your JavaScript project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="63ecb-151">プロパティ ページの **[構成プロパティ]** で、**[デバッグ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-151">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="63ecb-152">**[デバッガーの種類]** を選び、ドロップダウン リスト ボックスで、**[スクリプトのみ]** を **[マネージのみ]** に変更します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-152">Choose **Debugger Type**, and in the drop-down list box change **Script Only** to **Managed Only**.</span></span> <span data-ttu-id="63ecb-153">**[OK]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-153">Choose **OK**.</span></span>
4.  <span data-ttu-id="63ecb-154">マネージ コードのブレークポイントを設定し、通常どおりにデバッグします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-154">Set breakpoints in managed code and debug as usual.</span></span>

## <a name="passing-windows-runtime-types-to-managed-code"></a><span data-ttu-id="63ecb-155">マネージ コードへの Windows ランタイム型の引き渡し</span><span class="sxs-lookup"><span data-stu-id="63ecb-155">Passing Windows Runtime types to managed code</span></span>
<span data-ttu-id="63ecb-156">[Windows ランタイム コンポーネントの宣言型](#declaring-types-in-windows-runtime-components)セクションで既に説明した、特定の .NET Framework 型はパブリック クラスのメンバーのシグネチャに表示されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-156">As mentioned previously in the section [Declaring types in Windows Runtime Components](#declaring-types-in-windows-runtime-components), certain .NET Framework types can appear in the signatures of members of public classes.</span></span> <span data-ttu-id="63ecb-157">これは、マネージ コードで Windows ランタイムを通常どおりに使うことができるようにするために、.NET Framework が提供するサポートの一部です。</span><span class="sxs-lookup"><span data-stu-id="63ecb-157">This is part of the support that the .NET Framework provides to enable the natural use of the Windows Runtime in managed code.</span></span> <span data-ttu-id="63ecb-158">これには、プリミティブ型と一部のクラスやインターフェイスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-158">It includes primitive types and some classes and interfaces.</span></span> <span data-ttu-id="63ecb-159">JavaScript または C++ コードからコンポーネントを使用する場合は、呼び出し元に、.NET Framework 型がどのように表示されるかを知る必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-159">When your component is used from JavaScript, or from C++ code, it's important to know how your .NET Framework types appear to the caller.</span></span> <span data-ttu-id="63ecb-160">JavaScript を使った例については、「[チュートリアル: C# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-160">See [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md) for examples with JavaScript.</span></span> <span data-ttu-id="63ecb-161">このセクションでは、よく使われる型について説明します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-161">This section discusses commonly used types.</span></span>

<span data-ttu-id="63ecb-162">.NET framework では、多くの便利なプロパティやメソッドは、 **TryParse**メソッドなど、 **Int32**構造体などのプリミティブ型があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-162">In the .NET Framework, primitive types such as the **Int32** structure have many useful properties and methods, such as the **TryParse** method.</span></span> <span data-ttu-id="63ecb-163">これに対して、Windows ランタイムのプリミティブ型と構造体は、フィールドしか保持していません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-163">By contrast, primitive types and structures in the Windows Runtime only have fields.</span></span> <span data-ttu-id="63ecb-164">これらの型をマネージ コードに渡すと、.NET Framework 型のように表示され、通常どおりに .NET Framework のプロパティとメソッドを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-164">When you pass these types to managed code, they appear to be .NET Framework types, and you can use the properties and methods of the .NET Framework types as you normally would.</span></span> <span data-ttu-id="63ecb-165">IDE で自動的に行われる置き換えの概要を次に示します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-165">The following list summarizes the substitutions that are made automatically in the IDE:</span></span>

-   <span data-ttu-id="63ecb-166">Windows ランタイムのプリミティブ**Int32**、 **Int64**、 **1 つ**、 **Double**、 **Boolean**、 **String** (Unicode 文字の変更できないコレクション)、**列挙型**、 **UInt32**、 **UInt64**、および**Guid**、System 名前空間で同じ名前の型を使用します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-166">For the Windows Runtime primitives **Int32**, **Int64**, **Single**, **Double**, **Boolean**, **String** (an immutable collection of Unicode characters), **Enum**, **UInt32**, **UInt64**, and **Guid**, use the type of the same name in the System namespace.</span></span>
-   <span data-ttu-id="63ecb-167">**UInt8**、 **System.Byte**を使用します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-167">For **UInt8**, use **System.Byte**.</span></span>
-   <span data-ttu-id="63ecb-168">\*\* **Char16**、に対して system.char キーを押します。\*\*</span><span class="sxs-lookup"><span data-stu-id="63ecb-168">For **Char16**, use **System.Char**.</span></span>
-   <span data-ttu-id="63ecb-169">**IInspectable**インターフェイスでは、 **System.Object**を使用します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-169">For the **IInspectable** interface, use **System.Object**.</span></span>

<span data-ttu-id="63ecb-170">C# または Visual Basic のこれら型に対して言語キーワードを提供する場合、できます言語キーワード代わりに使うことです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-170">If C# or Visual Basic provides a language keyword for any of these types, then you can use the language keyword instead.</span></span>

<span data-ttu-id="63ecb-171">プリミティブ型に加えて、よく使用される基本的な Windows ランタイム型が、同等の .NET Framework 型としてマネージ コードに表示されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-171">In addition to primitive types, some basic, commonly used Windows Runtime types appear in managed code as their .NET Framework equivalents.</span></span> <span data-ttu-id="63ecb-172">たとえば、JavaScript コードで**Windows.Foundation.Uri**クラスを使用し、それを c# または Visual Basic のメソッドに渡すとします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-172">For example, suppose your JavaScript code uses the **Windows.Foundation.Uri** class, and you want to pass it to a C# or Visual Basic method.</span></span> <span data-ttu-id="63ecb-173">マネージ コードでの同等の型は、.NET Framework の**System.Uri**クラスとメソッドのパラメーターを使用する型がします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-173">The equivalent type in managed code is the .NET Framework **System.Uri** class, and that's the type to use for the method parameter.</span></span> <span data-ttu-id="63ecb-174">マネージ コードを記述するとき、Visual Studio の IntelliSense によって Windows ランタイム型が表示されなくなり、同等の .NET Framework 型が示されるため、Windows ランタイム型が .NET Framework 型として表示されていることがわかります </span><span class="sxs-lookup"><span data-stu-id="63ecb-174">You can tell when a Windows Runtime type appears as a .NET Framework type, because IntelliSense in Visual Studio hides the Windows Runtime type when you're writing managed code, and presents the equivalent .NET Framework type.</span></span> <span data-ttu-id="63ecb-175">(通常、2 つの型の名前は同じです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-175">(Usually the two types have the same name.</span></span> <span data-ttu-id="63ecb-176">ただし、 **Windows.Foundation.DateTime**構造体は、 **System.DateTime**ではなく、 **System.DateTimeOffset**としてマネージ コードでが表示されます。)</span><span class="sxs-lookup"><span data-stu-id="63ecb-176">However, note that the **Windows.Foundation.DateTime** structure appears in managed code as **System.DateTimeOffset** and not as **System.DateTime**.)</span></span>

<span data-ttu-id="63ecb-177">よく使われるコレクション型の一部では、Windows ランタイム型によって実装されるインターフェイスと、対応する .NET Framework 型によって実装されるインターフェイスと間で対応付けが行われます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-177">For some commonly used collection types, the mapping is between the interfaces that are implemented by a Windows Runtime type and the interfaces that are implemented by the corresponding .NET Framework type.</span></span> <span data-ttu-id="63ecb-178">上で説明した型と同じように、.NET Framework 型を使ってパラメーターの型を宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-178">As with the types mentioned above, you declare parameter types by using the .NET Framework type.</span></span> <span data-ttu-id="63ecb-179">これにより、型の間にある相違点を意識せずに、.NET Framework コードを通常どおりに記述することができます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-179">This hides some differences between the types and makes writing .NET Framework code more natural.</span></span>

<span data-ttu-id="63ecb-180">次の表は、最も一般的なジェネリック インターフェイスの型、および他の一般的なクラスやインターフェイスに関する対応付けを示しています。</span><span class="sxs-lookup"><span data-stu-id="63ecb-180">The following table lists the most common of these generic interface types, along with other common class and interface mappings.</span></span> <span data-ttu-id="63ecb-181">.NET Framework にマップする Windows ランタイム型の一覧は、 [Windows ランタイム型の .NET Framework での対応付け](net-framework-mappings-of-windows-runtime-types.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-181">For a complete list of Windows Runtime types that the .NET Framework maps, see [.NET Framework mappings of Windows Runtime types](net-framework-mappings-of-windows-runtime-types.md).</span></span>

| <span data-ttu-id="63ecb-182">Windows ランタイム</span><span class="sxs-lookup"><span data-stu-id="63ecb-182">Windows Runtime</span></span>                                  | <span data-ttu-id="63ecb-183">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="63ecb-183">.NET Framework</span></span>                                    |
|-|-|
| <span data-ttu-id="63ecb-184">IIterable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-184">IIterable&lt;T&gt;</span></span>                               | <span data-ttu-id="63ecb-185">IEnumerable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-185">IEnumerable&lt;T&gt;</span></span>                              |
| <span data-ttu-id="63ecb-186">IVector&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-186">IVector&lt;T&gt;</span></span>                                 | <span data-ttu-id="63ecb-187">IList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-187">IList&lt;T&gt;</span></span>                                    |
| <span data-ttu-id="63ecb-188">IVectorView&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-188">IVectorView&lt;T&gt;</span></span>                             | <span data-ttu-id="63ecb-189">IReadOnlyList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-189">IReadOnlyList&lt;T&gt;</span></span>                            |
| <span data-ttu-id="63ecb-190">IMap&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-190">IMap&lt;K, V&gt;</span></span>                                 | <span data-ttu-id="63ecb-191">IDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-191">IDictionary&lt;TKey, TValue&gt;</span></span>                   |
| <span data-ttu-id="63ecb-192">IMapView&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-192">IMapView&lt;K, V&gt;</span></span>                             | <span data-ttu-id="63ecb-193">IReadOnlyDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-193">IReadOnlyDictionary&lt;TKey, TValue&gt;</span></span>           |
| <span data-ttu-id="63ecb-194">IKeyValuePair&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-194">IKeyValuePair&lt;K, V&gt;</span></span>                        | <span data-ttu-id="63ecb-195">KeyValuePair&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="63ecb-195">KeyValuePair&lt;TKey, TValue&gt;</span></span>                  |
| <span data-ttu-id="63ecb-196">IBindableIterable</span><span class="sxs-lookup"><span data-stu-id="63ecb-196">IBindableIterable</span></span>                                | <span data-ttu-id="63ecb-197">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="63ecb-197">IEnumerable</span></span>                                       |
| <span data-ttu-id="63ecb-198">IBindableVector</span><span class="sxs-lookup"><span data-stu-id="63ecb-198">IBindableVector</span></span>                                  | <span data-ttu-id="63ecb-199">IList</span><span class="sxs-lookup"><span data-stu-id="63ecb-199">IList</span></span>                                             |
| <span data-ttu-id="63ecb-200">Windows.UI.Xaml.Data.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="63ecb-200">Windows.UI.Xaml.Data.INotifyPropertyChanged</span></span>      | <span data-ttu-id="63ecb-201">System.ComponentModel.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="63ecb-201">System.ComponentModel.INotifyPropertyChanged</span></span>      |
| <span data-ttu-id="63ecb-202">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="63ecb-202">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span></span> | <span data-ttu-id="63ecb-203">System.ComponentModel.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="63ecb-203">System.ComponentModel.PropertyChangedEventHandler</span></span> |
| <span data-ttu-id="63ecb-204">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="63ecb-204">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span></span>    | <span data-ttu-id="63ecb-205">System.ComponentModel.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="63ecb-205">System.ComponentModel.PropertyChangedEventArgs</span></span>    |

<span data-ttu-id="63ecb-206">型によって複数のインターフェイスが実装される場合、メンバーのパラメーターの型または戻り値の型として実装されるインターフェイスをすべて使うことができます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-206">When a type implements more than one interface, you can use any of the interfaces it implements as a parameter type or return type of a member.</span></span> <span data-ttu-id="63ecb-207">たとえば、渡すや、戻り値、**ディクショナリ&lt;int, string&gt; \*\* (Visual Basic では**Dictionary (Of Integer, String)\*\* ) として**IDictionary&lt;int, string&gt;**、 **IReadOnlyDictionary&lt;int, string&gt; **、または**IEnumerable&lt;的に System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;** します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-207">For example, you can pass or return a **Dictionary&lt;int, string&gt;** (**Dictionary(Of Integer, String)** in Visual Basic) as **IDictionary&lt;int, string&gt;**, **IReadOnlyDictionary&lt;int, string&gt;**, or **IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;**.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="63ecb-208">JavaScript では、マネージ型によって実装されるインターフェイスの一覧で最初に表示されるインターフェイスを使用します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-208">JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</span></span> <span data-ttu-id="63ecb-209">たとえば、返すこと**ディクショナリ&lt;int, string&gt;** として表示、JavaScript コードに**IDictionary&lt;int, string&gt;** 戻り値の型としてどのインターフェイスに関係なくを指定します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-209">For example, if you return **Dictionary&lt;int, string&gt;** to JavaScript code, it appears as **IDictionary&lt;int, string&gt;** no matter which interface you specify as the return type.</span></span> <span data-ttu-id="63ecb-210">これは、後のインターフェイスで表示されるメンバーが最初のインターフェイスに含まれていない場合、そのメンバーは JavaScript に認識されないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-210">This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</span></span>

<span data-ttu-id="63ecb-211">Windows ランタイムで**IMap&lt;K, V&gt;** と\*\*IMapView&lt;K, V&gt; \*\* IKeyValuePair を使用して、補間されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-211">In the Windows Runtime, **IMap&lt;K, V&gt;** and **IMapView&lt;K, V&gt;** are iterated by using IKeyValuePair.</span></span> <span data-ttu-id="63ecb-212">として表示されるときに、マネージ コードに渡す、 **IDictionary&lt;TKey, TValue&gt;** と**IReadOnlyDictionary&lt;TKey, TValue&gt;** 必然的に System.Collections.Generic.KeyValuePair**を使用して、&lt;TKey、TValue&gt;** それらを列挙します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-212">When you pass them to managed code, they appear as **IDictionary&lt;TKey, TValue&gt;** and **IReadOnlyDictionary&lt;TKey, TValue&gt;**, so naturally you use **System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;** to enumerate them.</span></span>

<span data-ttu-id="63ecb-213">インターフェイスがマネージ コード内に表示される方法によって、これらのインターフェイスを実装する型の表示方法が決まります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-213">The way interfaces appear in managed code affects the way types that implement these interfaces appear.</span></span> <span data-ttu-id="63ecb-214">たとえば、 **PropertySet**クラスを実装する**IMap&lt;K, V&gt;**、としてマネージ コードで表示される**IDictionary&lt;TKey, TValue&gt;** します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-214">For example, the **PropertySet** class implements **IMap&lt;K, V&gt;**, which appears in managed code as **IDictionary&lt;TKey, TValue&gt;**.</span></span> <span data-ttu-id="63ecb-215">**PropertySet**は、実装される場合とが表示される**IDictionary&lt;TKey, TValue&gt;** の代わりに**IMap&lt;K, V&gt;** ので、マネージ コードで**Add**メソッド、 **Add**メソッドと同様な動作を持つことが表示されます。.NET Framework ディクショナリです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-215">**PropertySet** appears as if it implemented **IDictionary&lt;TKey, TValue&gt;** instead of **IMap&lt;K, V&gt;**, so in managed code it appears to have an **Add** method, which behaves like the **Add** method on .NET Framework dictionaries.</span></span> <span data-ttu-id="63ecb-216">それがないように見える、 **Insert**メソッドです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-216">It doesn't appear to have an **Insert** method.</span></span> <span data-ttu-id="63ecb-217">この例では、トピックを確認できます[チュートリアル: c# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-217">You can see this example in the topic [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="passing-managed-types-to-the-windows-runtime"></a><span data-ttu-id="63ecb-218">Windows ランタイムへのマネージ型の引き渡し</span><span class="sxs-lookup"><span data-stu-id="63ecb-218">Passing managed types to the Windows Runtime</span></span>

<span data-ttu-id="63ecb-219">前のセクションで説明したように、一部の Windows ランタイム型は、コンポーネントのメンバーのシグニチャ内、または IDE で使う場合は Windows ランタイム メンバーのシグニチャ内で、.NET Framework 型として表示される場合があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-219">As discussed in the previous section, some Windows Runtime types can appear as .NET Framework types in the signatures of your component's members, or in the signatures of Windows Runtime members when you use them in the IDE.</span></span> <span data-ttu-id="63ecb-220">.NET Framework 型をこれらのメンバーに渡すか、またはコンポーネントのメンバーの戻り値として使うと、対応する Windows ランタイム型として Windows ランタイム側のコードに表示されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-220">When you pass .NET Framework types to these members or use them as the return values of your component's members, they appear to the code on the other side as the corresponding Windows Runtime type.</span></span> <span data-ttu-id="63ecb-221">コンポーネントが JavaScript から呼び出されたときの影響に関する例については、[「チュートリアル: C# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し」](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)の「コンポーネントからマネージ型を返す」セクションをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-221">For examples of the effects this can have when your component is called from JavaScript, see the "Returning managed types from your component" section in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="overloaded-methods"></a><span data-ttu-id="63ecb-222">オーバー ロードされたメソッド</span><span class="sxs-lookup"><span data-stu-id="63ecb-222">Overloaded methods</span></span>

<span data-ttu-id="63ecb-223">Windows ランタイムでは、メソッドはオーバーロードできます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-223">In the Windows Runtime, methods can be overloaded.</span></span> <span data-ttu-id="63ecb-224">ただし、同じ数のパラメーターを持つ複数のオーバー ロードを宣言している場合は、それらのオーバー ロードのいずれかのみに[**Windows.Foundation.Metadata.DefaultOverloadAttribute**](/uwp/api/windows.foundation.metadata.defaultoverloadattribute)属性を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-224">However, if you declare multiple overloads with the same number of parameters, you must apply the [**Windows.Foundation.Metadata.DefaultOverloadAttribute**](/uwp/api/windows.foundation.metadata.defaultoverloadattribute) attribute to only one of those overloads.</span></span> <span data-ttu-id="63ecb-225">この属性が適用されるオーバーロードが、JavaScript から呼び出すことができる唯一のオーバーロードになります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-225">That overload is the only one you can call from JavaScript.</span></span> <span data-ttu-id="63ecb-226">たとえば、次のコードでは、**int** (Visual Basic では **Integer**) を受け取るオーバーロードが既定のオーバーロードです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-226">For example, in the following code the overload that takes an **int** (**Integer** in Visual Basic) is the default overload.</span></span>

```csharp
public string OverloadExample(string s)
{
    return s;
}

[Windows.Foundation.Metadata.DefaultOverload()]
public int OverloadExample(int x)
{
    return x;
}
```

```vb
Public Function OverloadExample(ByVal s As String) As String
    Return s
End Function

<Windows.Foundation.Metadata.DefaultOverload> _
Public Function OverloadExample(ByVal x As Integer) As Integer
    Return x
End Function
```

> <span data-ttu-id="63ecb-227">[重要]JavaScript では、任意の値を**OverloadExample**に渡すことができるし、値をパラメーターで必要な型に変換します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-227">[IMPORTANT] JavaScript allows you to pass any value to **OverloadExample**, and coerces the value to the type that is required by the parameter.</span></span> <span data-ttu-id="63ecb-228">**OverloadExample**を"forty-two"、「42」、または 42.3 を呼び出すことができますが、それらのすべての値が既定のオーバー ロードに渡されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-228">You can call **OverloadExample** with "forty-two", "42", or 42.3, but all those values are passed to the default overload.</span></span> <span data-ttu-id="63ecb-229">既定のオーバー ロードを前の例では、0、42、および 42 をそれぞれ返します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-229">The default overload in the previous example returns 0, 42, and 42, respectively.</span></span>

<span data-ttu-id="63ecb-230">コンス トラクターを**DefaultOverloadAttribut**e 属性を適用することはできません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-230">You can't apply the **DefaultOverloadAttribut**e attribute to constructors.</span></span> <span data-ttu-id="63ecb-231">クラスのすべてのコンストラクターは、異なる数のパラメーターを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-231">All the constructors in a class must have different numbers of parameters.</span></span>

## <a name="implementing-istringable"></a><span data-ttu-id="63ecb-232">IStringable の実装</span><span class="sxs-lookup"><span data-stu-id="63ecb-232">Implementing IStringable</span></span>

<span data-ttu-id="63ecb-233">Windows 8.1 以降、Windows ランタイムが 1 つのメソッド、 **IStringable.ToString**、 **Object.ToString**で提供されると同等の基本的な書式設定サポートを提供する**IStringable**インターフェイスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="63ecb-233">Starting with Windows 8.1, the Windows Runtime includes an **IStringable** interface whose single method, **IStringable.ToString**, provides basic formatting support comparable to that provided by **Object.ToString**.</span></span> <span data-ttu-id="63ecb-234">Windows ランタイム コンポーネントでエクスポートしたパブリック マネージ型に**IStringable**を実装する場合は、次の制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-234">If you do choose to implement **IStringable** in a public managed type that is exported in a Windows Runtime component, the following restrictions apply:</span></span>

-   <span data-ttu-id="63ecb-235">C# では、次のコードなどの「クラスが実装する」関係でのみ**IStringable**インターフェイスを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-235">You can define the **IStringable** interface only in a "class implements" relationship, such as the following code in C#:</span></span>

    ```cs
    public class NewClass : IStringable
    ```

    <span data-ttu-id="63ecb-236">Visual Basic では、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-236">Or the following Visual Basic code:</span></span>

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   <span data-ttu-id="63ecb-237">インターフェイスで**IStringable**を実装することはできません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-237">You can't implement **IStringable** on an interface.</span></span>
-   <span data-ttu-id="63ecb-238">パラメーターの型を**istringable として**宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-238">You can't declare a parameter to be of type **IStringable**.</span></span>
-   <span data-ttu-id="63ecb-239">**IStringable**は、メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-239">**IStringable** can't be the return type of a method, property, or field.</span></span>
-   <span data-ttu-id="63ecb-240">など、次のメソッドの定義を使用して、基底クラスから**IStringable**の実装を非表示にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-240">You can't hide your **IStringable** implementation from base classes by using a method definition such as the following:</span></span>

    ```cs
    public class NewClass : IStringable
    {
       public new string ToString()
       {
          return "New ToString in NewClass";
       }
    }
    ```

    <span data-ttu-id="63ecb-241">代わりに、 **IStringable.ToString**の実装は、基底クラスの実装を常にオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-241">Instead, the **IStringable.ToString** implementation must always override the base class implementation.</span></span> <span data-ttu-id="63ecb-242">厳密に型指定されたクラスのインスタンスで呼び出すことでのみ**ToString**の実装を非表示にすることができます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-242">You can hide a **ToString** implementation only by invoking it on a strongly typed class instance.</span></span>

> [!NOTE]
> <span data-ttu-id="63ecb-243">さまざまな条件、 **IStringable**を実装やその**ToString**の実装を隠ぺいするマネージ型をネイティブ コードからの呼び出しで予期しない動作を生成できます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-243">Under a variety of conditions, calls from native code to a managed type that implements **IStringable** or hides its **ToString** implementation can produce unexpected behavior.</span></span>

## <a name="asynchronous-operations"></a><span data-ttu-id="63ecb-244">非同期操作</span><span class="sxs-lookup"><span data-stu-id="63ecb-244">Asynchronous operations</span></span>

<span data-ttu-id="63ecb-245">コンポーネントで非同期メソッドを実装するメソッド名の末尾に"Async"を追加し、処理や非同期操作を表す Windows ランタイム インターフェイスのいずれかを返します**IAsyncAction**、IAsyncActionWithProgress **&lt; 。TProgress&gt;**、 **IAsyncOperation&lt;TResult&gt;**、または**IAsyncOperationWithProgress&lt;TResult, TProgress&gt;** します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-245">To implement an asynchronous method in your component, add "Async" to the end of the method name and return one of the Windows Runtime interfaces that represent asynchronous actions or operations: **IAsyncAction**, **IAsyncActionWithProgress&lt;TProgress&gt;**, **IAsyncOperation&lt;TResult&gt;**, or **IAsyncOperationWithProgress&lt;TResult, TProgress&gt;**.</span></span>

<span data-ttu-id="63ecb-246">.NET Framework タスクを使用することができます ( [**Task**](/dotnet/api/system.threading.tasks.task)クラスとジェネリック[**タスク&lt;TResult&gt;**](/dotnet/api/system.threading.tasks.task-1)クラス)、非同期メソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-246">You can use .NET Framework tasks (the [**Task**](/dotnet/api/system.threading.tasks.task) class and generic [**Task&lt;TResult&gt;**](/dotnet/api/system.threading.tasks.task-1) class) to implement your asynchronous method.</span></span> <span data-ttu-id="63ecb-247">C# または Visual Basic で記述された非同期メソッドから返されるタスクや[**Task.Run**](/dotnet/api/system.threading.tasks.task.run)メソッドから返されたタスクなどの進行中の操作を表すタスクを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-247">You must return a task that represents an ongoing operation, such as a task that is returned from an asynchronous method written in C# or Visual Basic, or a task that is returned from the [**Task.Run**](/dotnet/api/system.threading.tasks.task.run) method.</span></span> <span data-ttu-id="63ecb-248">コンストラクターを使ってタスクを作成する場合、その [Task.Start](/dotnet/api/system.threading.tasks.task.start) メソッドを呼び出してから戻す必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-248">If you use a constructor to create the task, you must call its [Task.Start](/dotnet/api/system.threading.tasks.task.start) method before returning it.</span></span>

<span data-ttu-id="63ecb-249">使用するメソッド`await`(`Await` Visual Basic で) 必要があります、`async`キーワード (`Async` Visual Basic で)。</span><span class="sxs-lookup"><span data-stu-id="63ecb-249">A method that uses `await` (`Await` in Visual Basic) requires the `async` keyword (`Async` in Visual Basic).</span></span> <span data-ttu-id="63ecb-250">Windows ランタイム コンポーネントからこれらのメソッドを公開する場合は、適用、 `async` **Run**メソッドに渡すデリゲートにキーワードです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-250">If you expose such a method from a Windows Runtime component, apply the `async` keyword to the delegate that you pass to the **Run** method.</span></span>

<span data-ttu-id="63ecb-251">取り消しや進行状況の報告をサポートしない非同期アクションと非同期操作では、タスクを適切なインターフェイスにラップするために、[WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) または [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) の拡張メソッドを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-251">For asynchronous actions and operations that do not support cancellation or progress reporting, you can use the [WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) or [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) extension method to wrap the task in the appropriate interface.</span></span> <span data-ttu-id="63ecb-252">たとえば、次のコードが非同期メソッドを実装を使用して、 **Task.Run&lt;TResult&gt;** タスクを開始するメソッドです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-252">For example, the following code implements an asynchronous method by using the **Task.Run&lt;TResult&gt;** method to start a task.</span></span> <span data-ttu-id="63ecb-253">**AsAsyncOperation&lt;TResult&gt;** 拡張メソッドは、Windows ランタイムの非同期操作としてタスクを返します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-253">The **AsAsyncOperation&lt;TResult&gt;** extension method returns the task as a Windows Runtime asynchronous operation.</span></span>

```csharp
public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
{
    return Task.Run<IList<string>>(async () =>
    {
        var data = await DownloadDataAsync(id);
        return ExtractStrings(data);
    }).AsAsyncOperation();
}
```

```vb
Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
     As IAsyncOperation(Of IList(Of String))

    Return Task.Run(Of IList(Of String))(
        Async Function()
            Dim data = Await DownloadDataAsync(id)
            Return ExtractStrings(data)
        End Function).AsAsyncOperation()
End Function
```

<span data-ttu-id="63ecb-254">次の JavaScript コードは、 [**WinJS.Promise**](https://msdn.microsoft.com/library/windows/apps/br211867.aspx)オブジェクトを使用して、どのようにメソッドを呼び出すことができますを示しています。</span><span class="sxs-lookup"><span data-stu-id="63ecb-254">The following JavaScript code shows how the method could be called by using a [**WinJS.Promise**](https://msdn.microsoft.com/library/windows/apps/br211867.aspx) object.</span></span> <span data-ttu-id="63ecb-255">then メソッドに渡される関数は、非同期呼び出しが完了したときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-255">The function that is passed to the then method is executed when the asynchronous call completes.</span></span> <span data-ttu-id="63ecb-256">StringList パラメーターには**DownloadAsStringAsync**メソッドによって返される文字列の一覧が含まれています、関数は、すべての処理が必要です。</span><span class="sxs-lookup"><span data-stu-id="63ecb-256">The stringList parameter contains the list of strings that is returned by the **DownloadAsStringAsync** method, and the function does whatever processing is required.</span></span>

```javascript
function asyncExample(id) {

    var result = SampleComponent.Example.downloadAsStringAsync(id).then(
        function (stringList) {
            // Place code that uses the returned list of strings here.
        });
}
```

<span data-ttu-id="63ecb-257">非同期アクションと取り消しや進行状況の報告をサポートする操作は、 [**AsyncInfo**](/dotnet/api/system.runtime.interopservices.windowsruntime)クラスを使って開始タスクの生成を取り消しや進行状況レポート タスクの取り消しや進行状況の機能をフック適切な Windows ランタイム インターフェイスの機能を報告します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-257">For asynchronous actions and operations that support cancellation or progress reporting, use the [**AsyncInfo**](/dotnet/api/system.runtime.interopservices.windowsruntime) class to generate a started task and to hook up the cancellation and progress reporting features of the task with the cancellation and progress reporting features of the appropriate Windows Runtime interface.</span></span> <span data-ttu-id="63ecb-258">取り消しおよび進行状況の報告の両方をサポートする例については、「[チュートリアル: C# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-258">For an example that supports both cancellation and progress reporting, see [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

<span data-ttu-id="63ecb-259">非同期メソッドが取り消しをサポートしないや進行状況の報告場合でも、 **AsyncInfo**クラスのメソッドを使用することができることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-259">Note that you can use the methods of the **AsyncInfo** class even if your asynchronous method doesn't support cancellation or progress reporting.</span></span> <span data-ttu-id="63ecb-260">Visual Basic のラムダ関数または c# の匿名メソッドを使用する場合は、トークンのパラメーターを指定しないでくださいと[**IProgress&lt;T&gt;**](https://msdn.microsoft.com/library/hh138298.aspx)インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-260">If you use a Visual Basic lambda function or a C# anonymous method, don't supply parameters for the token and [**IProgress&lt;T&gt;**](https://msdn.microsoft.com/library/hh138298.aspx) interface.</span></span> <span data-ttu-id="63ecb-261">C# のラムダ関数を使う場合は、トークンのパラメーターを指定しますが、無視されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-261">If you use a C# lambda function, supply a token parameter but ignore it.</span></span> <span data-ttu-id="63ecb-262">前の例は、使用 AsAsyncOperation&lt;TResult&gt;メソッドでは、次のようなを使用する場合、 [**AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;**](https://msdn.microsoft.com/library/hh779740.aspx)) メソッド代わりにオーバー ロードされます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-262">The previous example, which used the AsAsyncOperation&lt;TResult&gt; method, looks like this when you use the [**AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;&gt;**](https://msdn.microsoft.com/library/hh779740.aspx)) method overload instead.</span></span>

```csharp
public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
{
    return AsyncInfo.Run<IList<string>>(async (token) =>
    {
        var data = await DownloadDataAsync(id);
        return ExtractStrings(data);
    });
}
```

```vb
Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
    As IAsyncOperation(Of IList(Of String))

    Return AsyncInfo.Run(Of IList(Of String))(
        Async Function()
            Dim data = Await DownloadDataAsync(id)
            Return ExtractStrings(data)
        End Function)
End Function
```

<span data-ttu-id="63ecb-263">必要に応じて取り消しや進行状況の報告をサポートする非同期メソッドを作成する場合は、キャンセル トークンのパラメーターを持たないオーバー ロードを追加することを検討してくださいまたは**IProgress&lt;T&gt;** インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="63ecb-263">If you create an asynchronous method that optionally supports cancellation or progress reporting, consider adding overloads that don't have parameters for a cancellation token or the **IProgress&lt;T&gt;** interface.</span></span>

## <a name="throwing-exceptions"></a><span data-ttu-id="63ecb-264">例外のスロー</span><span class="sxs-lookup"><span data-stu-id="63ecb-264">Throwing exceptions</span></span>

<span data-ttu-id="63ecb-265">Windows アプリ用 .NET に含まれている例外の型は、どれでもスローすることができます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-265">You can throw any exception type that is included in the .NET for Windows apps.</span></span> <span data-ttu-id="63ecb-266">Windows ランタイム コンポーネントで独自のパブリック型の例外を宣言することはできませんが、非パブリック型を宣言し、スローすることはできます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-266">You can't declare your own public exception types in a Windows Runtime component, but you can declare and throw non-public types.</span></span>

<span data-ttu-id="63ecb-267">コンポーネントが例外を処理しない場合は、コンポーネントを呼び出したコードで対応する例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-267">If your component doesn't handle the exception, a corresponding exception is raised in the code that called your component.</span></span> <span data-ttu-id="63ecb-268">例外が呼び出し元に表示される方法は、呼び出し元の言語が Windows ランタイムをサポートする方法によって異なります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-268">The way the exception appears to the caller depends on the way the calling language supports the Windows Runtime.</span></span>

-   <span data-ttu-id="63ecb-269">JavaScript では、例外はオブジェクトとして表示され、例外メッセージがスタック トレースで置き換えられています。</span><span class="sxs-lookup"><span data-stu-id="63ecb-269">In JavaScript, the exception appears as an object in which the exception message is replaced by a stack trace.</span></span> <span data-ttu-id="63ecb-270">Visual Studio でアプリをデバッグするとき、デバッガーの例外ダイアログ ボックスに、"WinRT 情報" として元のメッセージ テキストが表示されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-270">When you debug your app in Visual Studio, you can see the original message text displayed in the debugger exception dialog box, identified as "WinRT Information".</span></span> <span data-ttu-id="63ecb-271">JavaScript コードから元のメッセージ テキストにアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-271">You can't access the original message text from JavaScript code.</span></span>

    > <span data-ttu-id="63ecb-272">**ヒント**をします。</span><span class="sxs-lookup"><span data-stu-id="63ecb-272">**Tip**.</span></span><span data-ttu-id="63ecb-273">現時点では、スタック トレースには、マネージ例外の型が含まれていますが、例外の種類を識別するトレースを解析お勧めしません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-273">Currently, the stack trace contains the managed exception type, but we don't recommend parsing the trace to identify the exception type.</span></span> <span data-ttu-id="63ecb-274">このセクションの後半で説明するように、代わりに HRESULT 値を使ってください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-274">Instead, use an HRESULT value as described later in this section.</span></span>

-   <span data-ttu-id="63ecb-275">C++ では、例外はプラットフォーム例外として表示されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-275">In C++, the exception appears as a platform exception.</span></span> <span data-ttu-id="63ecb-276">マネージ例外の HResult プロパティは、特定のプラットフォーム例外の HRESULT にマップできる場合、は、特定の例外が使われます。それ以外の場合、 [**Platform::COMException**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx)例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-276">If the managed exception's HResult property can be mapped to the HRESULT of a specific platform exception, the specific exception is used; otherwise, a [**Platform::COMException**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx) exception is thrown.</span></span> <span data-ttu-id="63ecb-277">マネージ例外のメッセージ テキストは、C++ コードでは利用できません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-277">The message text of the managed exception is not available to C++ code.</span></span> <span data-ttu-id="63ecb-278">特定のプラットフォーム例外がスローされた場合、その例外の型に関する既定のメッセージ テキストが表示されます。それ以外の場合は、メッセージ テキストは表示されません。</span><span class="sxs-lookup"><span data-stu-id="63ecb-278">If a specific platform exception was thrown, the default message text for that exception type appears; otherwise, no message text appears.</span></span> <span data-ttu-id="63ecb-279">「[例外 (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-279">See [Exceptions (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx).</span></span>
-   <span data-ttu-id="63ecb-280">C# または Visual Basic では、例外は通常のマネージ例外です。</span><span class="sxs-lookup"><span data-stu-id="63ecb-280">In C# or Visual Basic, the exception is a normal managed exception.</span></span>

<span data-ttu-id="63ecb-281">コンポーネントから例外をスローする場合、コンポーネントに固有の HResult プロパティ値を持つ非パブリック型の例外をスローすることにより、JavaScript や C++ の呼び出し元で例外を簡単に処理できるようになります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-281">When you throw an exception from your component, you can make it easier for a JavaScript or C++ caller to handle the exception by throwing a non-public exception type whose HResult property value is specific to your component.</span></span> <span data-ttu-id="63ecb-282">HRESULT は、JavaScript の呼び出し元で例外オブジェクトの number プロパティと、C++ の呼び出し元[**:hresult**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx)プロパティで使用できます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-282">The HRESULT is available to a JavaScript caller through the exception object's number property, and to a C++ caller through the [**COMException::HResult**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx) property.</span></span>

> [!NOTE]
> <span data-ttu-id="63ecb-283">HRESULT の負の値を使用します。</span><span class="sxs-lookup"><span data-stu-id="63ecb-283">Use a negative value for your HRESULT.</span></span> <span data-ttu-id="63ecb-284">正の値は成功と解釈されるので、JavaScript や C++ の呼び出し元で例外がスローされなくなります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-284">A positive value is interpreted as success, and no exception is thrown in the JavaScript or C++ caller.</span></span>

## <a name="declaring-and-raising-events"></a><span data-ttu-id="63ecb-285">イベントの宣言と発生</span><span class="sxs-lookup"><span data-stu-id="63ecb-285">Declaring and raising events</span></span>

<span data-ttu-id="63ecb-286">イベントのデータを保持する型を宣言する場合、EventArgs は Windows ランタイム型ではないので、EventArgs の代わりに Object から派生させます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-286">When you declare a type to hold the data for your event, derive from Object instead of from EventArgs, because EventArgs is not a Windows Runtime type.</span></span> <span data-ttu-id="63ecb-287">使用して[**EventHandler&lt;TEventArgs&gt;**](https://msdn.microsoft.com/library/db0etb8x.aspx)としての種類のイベントと、イベント引数の型をジェネリック型引数として使います。</span><span class="sxs-lookup"><span data-stu-id="63ecb-287">Use [**EventHandler&lt;TEventArgs&gt;**](https://msdn.microsoft.com/library/db0etb8x.aspx) as the type of the event, and use your event argument type as the generic type argument.</span></span> <span data-ttu-id="63ecb-288">イベントは .NET Framework アプリケーションの場合と同様に発生させます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-288">Raise the event just as you would in a .NET Framework application.</span></span>

<span data-ttu-id="63ecb-289">Windows ランタイム コンポーネントが JavaScript や C++ で使われる場合、イベントはそれらの言語で想定されている Windows ランタイムのイベント パターンに従います。</span><span class="sxs-lookup"><span data-stu-id="63ecb-289">When your Windows Runtime component is used from JavaScript or C++, the event follows the Windows Runtime event pattern that those languages expect.</span></span> <span data-ttu-id="63ecb-290">C# や Visual Basic でコンポーネントを使う場合、イベントは通常の .NET Framework のイベントとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-290">When you use the component from C# or Visual Basic, the event appears as an ordinary .NET Framework event.</span></span> <span data-ttu-id="63ecb-291">例については、「[チュートリアル: C# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し]()」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-291">An example is provided in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript]().</span></span>

<span data-ttu-id="63ecb-292">カスタム イベント アクセサーを実装する場合 (Visual Basic では **Custom** キーワードでイベントを宣言する場合) は、実装で Windows ランタイムのイベント パターンに従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-292">If you implement custom event accessors (declare an event with the **Custom** keyword, in Visual Basic), you must follow the Windows Runtime event pattern in your implementation.</span></span> <span data-ttu-id="63ecb-293">「[Windows ランタイム コンポーネントのカスタム イベントおよびイベント アクセサー](custom-events-and-event-accessors-in-windows-runtime-components.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-293">See [Custom events and event accessors in Windows Runtime Components](custom-events-and-event-accessors-in-windows-runtime-components.md).</span></span> <span data-ttu-id="63ecb-294">C# や Visual Basic コードでイベントを処理する場合でも、通常の .NET Framework のイベントとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="63ecb-294">Note that when you handle the event from C# or Visual Basic code, it still appears to be an ordinary .NET Framework event.</span></span>

## <a name="next-steps"></a><span data-ttu-id="63ecb-295">次の手順</span><span class="sxs-lookup"><span data-stu-id="63ecb-295">Next steps</span></span>

<span data-ttu-id="63ecb-296">ユーザーが独自に使う Windows ランタイム コンポーネントを作成した後で、そのコンポーネントにカプセル化されている機能が他の開発者の役に立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-296">After you’ve created a Windows Runtime component for your own use, you may find that the functionality it encapsulates is useful to other developers.</span></span> <span data-ttu-id="63ecb-297">他の開発者に配布するためにコンポーネントをパッケージ化する方法は 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="63ecb-297">You have two options for packaging a component for distribution to other developers.</span></span> <span data-ttu-id="63ecb-298">「[マネージ Windows ランタイム コンポーネントの配布](https://msdn.microsoft.com/library/jj614475.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-298">See [Distributing a managed Windows Runtime component](https://msdn.microsoft.com/library/jj614475.aspx).</span></span>

<span data-ttu-id="63ecb-299">Visual Basic と C# の言語の機能、および Windows ランタイムに関する .NET Framework のサポートについて詳しくは、「[Visual Basic および C# 言語リファレンス](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="63ecb-299">For more information about Visual Basic and C# language features, and .NET Framework support for the Windows Runtime, see [Visual Basic and C# language reference](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx).</span></span>

## <a name="related-topics"></a><span data-ttu-id="63ecb-300">関連トピック</span><span class="sxs-lookup"><span data-stu-id="63ecb-300">Related topics</span></span>
* [<span data-ttu-id="63ecb-301">UWP アプリの .NET</span><span class="sxs-lookup"><span data-stu-id="63ecb-301">.NET for UWP apps</span></span>](https://msdn.microsoft.com/library/windows/apps/mt185501)
* [<span data-ttu-id="63ecb-302">チュートリアル: 単純な Windows ランタイム コンポーネントの作成と JavaScript からの呼び出し</span><span class="sxs-lookup"><span data-stu-id="63ecb-302">Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</span></span>](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)
