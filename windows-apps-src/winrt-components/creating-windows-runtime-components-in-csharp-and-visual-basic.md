---
author: msatranjr
title: C# および Visual Basic での Windows ランタイム コンポーネントの作成
description: .NET Framework 4.5 以降では、マネージ コードを使って独自の Windows ランタイム型を作成し、Windows ランタイム コンポーネントにパッケージ化することができます。
ms.assetid: A5672966-74DF-40AB-B01E-01E3FCD0AD7A
ms.author: misatran
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 4e3b9ed2d256fb9ea8d38690a703baf7fbd3e7f0
ms.sourcegitcommit: 3257416aebb5a7b1515e107866806f8bd57845a8
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/17/2018
ms.locfileid: "7170414"
---
# <a name="creating-windows-runtime-components-in-c-and-visual-basic"></a><span data-ttu-id="ebeaa-104">C# および Visual Basic での Windows ランタイム コンポーネントの作成</span><span class="sxs-lookup"><span data-stu-id="ebeaa-104">Creating Windows Runtime Components in C# and Visual Basic</span></span>
<span data-ttu-id="ebeaa-105">.NET Framework 4.5 以降では、マネージ コードを使って独自の Windows ランタイム型を作成し、Windows ランタイム コンポーネントにパッケージ化することができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-105">Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types, packaged in a Windows Runtime component.</span></span> <span data-ttu-id="ebeaa-106">また、C++、JavaScript、Visual Basic、C# を利用することで、ユニバーサル Windows プラットフォーム (UWP) アプリでコンポーネントを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-106">You can use your component in Universal Windows Platform (UWP) apps with C++, JavaScript, Visual Basic, or C#.</span></span> <span data-ttu-id="ebeaa-107">このトピックでは、コンポーネントを作成するための規則について説明し、Windows ランタイムの .NET Framework のサポートの一部の側面を説明します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-107">This topic outlines the rules for creating a component, and discusses some aspects of .NET Framework support for the Windows Runtime.</span></span> <span data-ttu-id="ebeaa-108">このサポートは、通常、.NET Framework のプログラマが意識しなくても利用できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-108">In general, that support is designed to be transparent to the .NET Framework programmer.</span></span> <span data-ttu-id="ebeaa-109">ただし、JavaScript や C++ で使うコンポーネントを作成する場合は、これらの言語が Windows ランタイムをサポートする方法の違いに注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-109">However, when you create a component to use with JavaScript or C++, you need to be aware of differences in the way those languages support the Windows Runtime.</span></span>

<span data-ttu-id="ebeaa-110">Visual Basic または C# を利用して UWP アプリでのみ使うコンポーネントを作成し、そのコンポーネントには UWP コントロールを含めない場合は、**Windows ランタイム コンポーネント** テンプレートではなく、**クラス ライブラリ**  テンプレートを使うことを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-110">If you are creating a component for use only in UWP apps with Visual Basic or C#, and the component does not contain UWP controls, consider using the **Class Library** template instead of the **Windows Runtime Component** template.</span></span> <span data-ttu-id="ebeaa-111">単純なクラス ライブラリでは、制限は少なくなります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-111">There are fewer restrictions on a simple class library.</span></span>

<span data-ttu-id="ebeaa-112">このトピックでは、次のセクションでは、含まれています。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-112">This topic contains the following sections:</span></span>

## <a name="declaring-types-in-windows-runtime-components"></a><span data-ttu-id="ebeaa-113">Windows ランタイム コンポーネントでの型の宣言</span><span class="sxs-lookup"><span data-stu-id="ebeaa-113">Declaring types in Windows Runtime Components</span></span>
<span data-ttu-id="ebeaa-114">内部的には、コンポーネントの Windows ランタイム型は、ユニバーサル Windows アプリで許可されている .NET Framework の機能をすべて使うことができます </span><span class="sxs-lookup"><span data-stu-id="ebeaa-114">Internally, the Windows Runtime types in your component can use any .NET Framework functionality that's allowed in a Universal Windows app.</span></span> <span data-ttu-id="ebeaa-115">(詳しくは、「[UWP アプリの .NET](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx)」の概要をご覧ください。外部的には、型のメンバーはパラメーターと戻り値の Windows ランタイム型だけを公開できます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-115">(See [.NET for UWP apps](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx) overview for more information.) Externally, the members of your types can expose only Windows Runtime types for their parameters and return values.</span></span> <span data-ttu-id="ebeaa-116">Windows ランタイム コンポーネントから公開される .NET Framework 型の制限事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-116">The following list describes the limitations on .NET Framework types that are exposed from Windows Runtime Components.</span></span>

-   <span data-ttu-id="ebeaa-117">コンポーネント内にあるすべてのパブリック型とメンバーのフィールド、パラメーター、戻り値は、Windows ランタイム型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-117">The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.</span></span>

    <span data-ttu-id="ebeaa-118">この制限は、作成した Windows ランタイム型、および Windows ランタイム自体で提供される型を対象としています。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-118">This restriction includes the Windows Runtime types that you create as well as types that are provided by the Windows Runtime itself.</span></span> <span data-ttu-id="ebeaa-119">また、さまざまな .NET Framework 型も対象となります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-119">It also includes a number of .NET Framework types.</span></span> <span data-ttu-id="ebeaa-120">これらの型の追加は、マネージ コードで Windows ランタイムを通常どおりに使うことができるようにするために、.NET Framework が提供するサポートの一部です。コードでは、基になる Windows ランタイム型ではなく、よく利用する .NET Framework 型が使われているように表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-120">The inclusion of these types is part of the support the .NET Framework provides to enable the natural use of the Windows Runtime in managed code: Your code appears to use familiar .NET Framework types instead of the underlying Windows Runtime types.</span></span> <span data-ttu-id="ebeaa-121">たとえば、Int32 や Double などの .NET Framework のプリミティブ型、DateTimeOffset や Uri などの特定の基本型、および IEnumerable&lt;T&gt; (Visual Basic では IEnumerable(Of T)) や IDictionary&lt;TKey,TValue&gt; などの一般的に利用されるジェネリック インターフェイス型を使うことができます </span><span class="sxs-lookup"><span data-stu-id="ebeaa-121">For example, you can use .NET Framework primitive types such as Int32 and Double, certain fundamental types such as DateTimeOffset and Uri, and some commonly used generic interface types such as IEnumerable&lt;T&gt; (IEnumerable(Of T) in Visual Basic) and IDictionary&lt;TKey,TValue&gt;.</span></span> <span data-ttu-id="ebeaa-122">(注: これらのジェネリック型の型引数は Windows ランタイム型である必要があります。)これについては Windows ランタイム型の引き渡しマネージ コードへのセクションで説明して、マネージの引き渡しには、このトピックの後半で、Windows ランタイム型です。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-122">(Note that the type arguments of these generic types must be Windows Runtime types.) This is discussed in the sections Passing Windows Runtime types to managed code and Passing managed types to the Windows Runtime, later in this topic.</span></span>

-   <span data-ttu-id="ebeaa-123">パブリック クラスとインターフェイスには、メソッド、プロパティ、イベントを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-123">Public classes and interfaces can contain methods, properties, and events.</span></span> <span data-ttu-id="ebeaa-124">イベントのデリゲートを宣言したり、EventHandler&lt;T&gt; デリゲートを使ったりすることができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-124">You can declare delegates for your events, or use the EventHandler&lt;T&gt; delegate.</span></span> <span data-ttu-id="ebeaa-125">パブリック クラスやインターフェイスでは、次のことが許可されていません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-125">A public class or interface cannot:</span></span>

    -   <span data-ttu-id="ebeaa-126">ジェネリックにする。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-126">Be generic.</span></span>
    -   <span data-ttu-id="ebeaa-127">Windows ランタイム インターフェイスではないインターフェイスを実装する </span><span class="sxs-lookup"><span data-stu-id="ebeaa-127">Implement an interface that is not a Windows Runtime interface.</span></span> <span data-ttu-id="ebeaa-128">(ただし、独自の Windows ランタイム インターフェイスを作成し、それを実装することはできます)。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-128">(However, you can create your own Windows Runtime interfaces and implement them.)</span></span>
    -   <span data-ttu-id="ebeaa-129">Windows ランタイムにない型 (System.Exception や System.EventArgs など) から派生させる。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-129">Derive from types that are not in the Windows Runtime, such as System.Exception and System.EventArgs.</span></span>
-   <span data-ttu-id="ebeaa-130">すべてのパブリック型にはアセンブリ名に一致するルート名前空間が必要になります。ただし、アセンブリ名の先頭には "Windows" を付けることはできません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-130">All public types must have a root namespace that matches the assembly name, and the assembly name must not begin with "Windows".</span></span>

    > <span data-ttu-id="ebeaa-131">**ヒント:** 既定では、Visual Studio のプロジェクトがあるアセンブリ名に一致する名前空間の名前。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-131">**Tip**By default, Visual Studio projects have namespace names that match the assembly name.</span></span> <span data-ttu-id="ebeaa-132">Visual Basic では、この既定の名前空間の Namespace ステートメントはコードに表示されません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-132">In Visual Basic, the Namespace statement for this default namespace is not shown in your code.</span></span>

-   <span data-ttu-id="ebeaa-133">パブリック構造体はパブリック フィールド以外のメンバーを持つことができません。また、それらのフィールドは値型または文字列であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-133">Public structures can't have any members other than public fields, and those fields must be value types or strings.</span></span>
-   <span data-ttu-id="ebeaa-134">パブリック クラスは **sealed** (Visual Basic では **NotInheritable**) であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-134">Public classes must be **sealed** (**NotInheritable** in Visual Basic).</span></span> <span data-ttu-id="ebeaa-135">プログラミング モデルでポリモーフィズムが必要となる場合は、パブリック インターフェイスを作成し、ポリモーフィックにする必要があるクラスにそのインターフェイスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-135">If your programming model requires polymorphism, you can create a public interface and implement that interface on the classes that must be polymorphic.</span></span>

## <a name="debugging-your-component"></a><span data-ttu-id="ebeaa-136">コンポーネントのデバッグ</span><span class="sxs-lookup"><span data-stu-id="ebeaa-136">Debugging your component</span></span>
<span data-ttu-id="ebeaa-137">ユニバーサル Windows アプリとコンポーネントの両方がマネージ コードで作成されている場合、それらを同時にデバッグできます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-137">If both your Universal Windows app and your component are built with managed code, you can debug them at the same time.</span></span>

<span data-ttu-id="ebeaa-138">C++ を使ってユニバーサル Windows アプリの一部としてコンポーネントをテストしている場合、マネージ コードとネイティブ コードを同時にデバッグできます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-138">When you're testing your component as part of a Universal Windows app using C++, you can debug managed and native code at the same time.</span></span> <span data-ttu-id="ebeaa-139">既定では、ネイティブ コードのみになります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-139">The default is native code only.</span></span>

## **<a name="to-debug-both-native-c-code-and-managed-code"></a><span data-ttu-id="ebeaa-140">ネイティブ C++ コードとマネージ コードの両方をデバッグするには</span><span class="sxs-lookup"><span data-stu-id="ebeaa-140">To debug both native C++ code and managed code</span></span>**
1.  <span data-ttu-id="ebeaa-141">Visual C++ プロジェクトのショートカット メニューを開き、**[プロパティ]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-141">Open the shortcut menu for your Visual C++ project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="ebeaa-142">プロパティ ページの **[構成プロパティ]** で、**[デバッグ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-142">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="ebeaa-143">**[デバッガーの種類]** を選び、ドロップダウン リスト ボックスで、**[ネイティブのみ]** を **[混合 (マネージとネイティブ)]** に変更します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-143">Choose **Debugger Type**, and in the drop-down list box change **Native Only** to **Mixed (Managed and Native)**.</span></span> <span data-ttu-id="ebeaa-144">**[OK]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-144">Choose **OK**.</span></span>
4.  <span data-ttu-id="ebeaa-145">ネイティブ コードとマネージ コードのブレークポイントを設定します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-145">Set breakpoints in native and managed code.</span></span>

<span data-ttu-id="ebeaa-146">JavaScript を使ってユニバーサル Windows アプリの一部としてコンポーネントをテストしている場合、既定では、ソリューションは JavaScript デバッグ モードになります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-146">When you're testing your component as part of a Universal Windows app using JavaScript, by default the solution is in JavaScript debugging mode.</span></span> <span data-ttu-id="ebeaa-147">Visual Studio では、JavaScript とマネージ コードを同時にデバッグすることはできません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-147">In Visual Studio, you can't debug JavaScript and managed code at the same time.</span></span>

## **<a name="to-debug-managed-code-instead-of-javascript"></a><span data-ttu-id="ebeaa-148">JavaScript ではなくマネージ コードをデバッグするには</span><span class="sxs-lookup"><span data-stu-id="ebeaa-148">To debug managed code instead of JavaScript</span></span>**
1.  <span data-ttu-id="ebeaa-149">JavaScript プロジェクトのショートカット メニューを開き、**[プロパティ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-149">Open the shortcut menu for your JavaScript project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="ebeaa-150">プロパティ ページの **[構成プロパティ]** で、**[デバッグ]** を選びます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-150">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="ebeaa-151">**[デバッガーの種類]** を選び、ドロップダウン リスト ボックスで、**[スクリプトのみ]** を **[マネージのみ]** に変更します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-151">Choose **Debugger Type**, and in the drop-down list box change **Script Only** to **Managed Only**.</span></span> <span data-ttu-id="ebeaa-152">**[OK]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-152">Choose **OK**.</span></span>
4.  <span data-ttu-id="ebeaa-153">マネージ コードのブレークポイントを設定し、通常どおりにデバッグします。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-153">Set breakpoints in managed code and debug as usual.</span></span>

## <a name="passing-windows-runtime-types-to-managed-code"></a><span data-ttu-id="ebeaa-154">マネージ コードへの Windows ランタイム型の引き渡し</span><span class="sxs-lookup"><span data-stu-id="ebeaa-154">Passing Windows Runtime types to managed code</span></span>
<span data-ttu-id="ebeaa-155">「Windows ランタイム コンポーネントでの型の宣言」セクションで既に説明したように、特定の .NET Framework 型はパブリック クラスのメンバーのシグネチャに示される場合があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-155">As mentioned previously in the section Declaring types in Windows Runtime Components, certain .NET Framework types can appear in the signatures of members of public classes.</span></span> <span data-ttu-id="ebeaa-156">これは、マネージ コードで Windows ランタイムを通常どおりに使うことができるようにするために、.NET Framework が提供するサポートの一部です。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-156">This is part of the support that the .NET Framework provides to enable the natural use of the Windows Runtime in managed code.</span></span> <span data-ttu-id="ebeaa-157">これには、プリミティブ型と一部のクラスやインターフェイスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-157">It includes primitive types and some classes and interfaces.</span></span> <span data-ttu-id="ebeaa-158">コンポーネントが JavaScript または C++ コードから使われる場合は、.NET Framework 型が呼び出し元に対してどのように表示されるかを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-158">When your component is used from JavaScript or from C++ code, it's important to know how your .NET Framework types appear to the caller.</span></span> <span data-ttu-id="ebeaa-159">JavaScript を使った例については、「[チュートリアル: C# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-159">See [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md) for examples with JavaScript.</span></span> <span data-ttu-id="ebeaa-160">このセクションでは、よく使われる型について説明します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-160">This section discusses commonly used types.</span></span>

<span data-ttu-id="ebeaa-161">.NET Framework では、Int32 構造体などのプリミティブ型は、TryParse メソッドなどの便利なプロパティやメソッドを多数保持しています。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-161">In the .NET Framework, primitive types like the Int32 structure have many useful properties and methods, such as the TryParse method.</span></span> <span data-ttu-id="ebeaa-162">これに対して、Windows ランタイムのプリミティブ型と構造体は、フィールドしか保持していません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-162">By contrast, primitive types and structures in the Windows Runtime only have fields.</span></span> <span data-ttu-id="ebeaa-163">これらの型をマネージ コードに渡すと、.NET Framework 型のように表示され、通常どおりに .NET Framework のプロパティとメソッドを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-163">When you pass these types to managed code, they appear to be .NET Framework types, and you can use the properties and methods of the .NET Framework types as you normally would.</span></span> <span data-ttu-id="ebeaa-164">IDE で自動的に行われる置き換えの概要を次に示します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-164">The following list summarizes the substitutions that are made automatically in the IDE:</span></span>

-   <span data-ttu-id="ebeaa-165">Windows ランタイムのプリミティブ型 Int32、Int64、Single、Double、Boolean、String (Unicode 文字の変更できないコレクション)、Enum、UInt32、UInt64、および Guid に対しては、System 名前空間に含まれる同じ名前の型が使われます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-165">For the Windows Runtime primitives Int32, Int64, Single, Double, Boolean, String (an immutable collection of Unicode characters), Enum, UInt32, UInt64, and Guid, use the type of the same name in the System namespace.</span></span>
-   <span data-ttu-id="ebeaa-166">UInt8 に対しては、System.Byte が使われます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-166">For UInt8, use System.Byte.</span></span>
-   <span data-ttu-id="ebeaa-167">Char16 に対しては、System.Char が使われます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-167">For Char16, use System.Char.</span></span>
-   <span data-ttu-id="ebeaa-168">IInspectable インターフェイスに対しては、System.Object が使われます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-168">For the IInspectable interface, use System.Object.</span></span>

<span data-ttu-id="ebeaa-169">C# や Visual Basic で、これらの型に対して言語キーワードが指定されている場合は、代わりに言語キーワードを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-169">If C# or Visual Basic provides a language keyword for any of these types, you can use the language keyword instead.</span></span>

<span data-ttu-id="ebeaa-170">プリミティブ型に加えて、よく使用される基本的な Windows ランタイム型が、同等の .NET Framework 型としてマネージ コードに表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-170">In addition to primitive types, some basic, commonly used Windows Runtime types appear in managed code as their .NET Framework equivalents.</span></span> <span data-ttu-id="ebeaa-171">たとえば、JavaScript コードで Windows.Foundation.Uri クラスを使っており、それを C# または Visual Basic のメソッドに渡すとします。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-171">For example, suppose your JavaScript code uses the Windows.Foundation.Uri class, and you want to pass it to a C# or Visual Basic method.</span></span> <span data-ttu-id="ebeaa-172">マネージ コードには、対応する型として .NET Framework の System.Uri クラスが示され、この型がメソッド パラメーター用に使われます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-172">The equivalent type in managed code is the .NET Framework System.Uri class, and that's the type to use for the method parameter.</span></span> <span data-ttu-id="ebeaa-173">マネージ コードを記述するとき、Visual Studio の IntelliSense によって Windows ランタイム型が表示されなくなり、同等の .NET Framework 型が示されるため、Windows ランタイム型が .NET Framework 型として表示されていることがわかります </span><span class="sxs-lookup"><span data-stu-id="ebeaa-173">You can tell when a Windows Runtime type appears as a .NET Framework type, because IntelliSense in Visual Studio hides the Windows Runtime type when you're writing managed code, and presents the equivalent .NET Framework type.</span></span> <span data-ttu-id="ebeaa-174">(通常、2 つの型の名前は同じです。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-174">(Usually the two types have the same name.</span></span> <span data-ttu-id="ebeaa-175">ただし、Windows.Foundation.DateTime 構造体は、System.DateTime ではなく、System.DateTimeOffset としてマネージ コードに表示される点に注意してください)。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-175">However, note that the Windows.Foundation.DateTime structure appears in managed code as System.DateTimeOffset and not as System.DateTime.)</span></span>

<span data-ttu-id="ebeaa-176">よく使われるコレクション型の一部では、Windows ランタイム型によって実装されるインターフェイスと、対応する .NET Framework 型によって実装されるインターフェイスと間で対応付けが行われます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-176">For some commonly used collection types, the mapping is between the interfaces that are implemented by a Windows Runtime type and the interfaces that are implemented by the corresponding .NET Framework type.</span></span> <span data-ttu-id="ebeaa-177">上で説明した型と同じように、.NET Framework 型を使ってパラメーターの型を宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-177">As with the types mentioned above, you declare parameter types by using the .NET Framework type.</span></span> <span data-ttu-id="ebeaa-178">これにより、型の間にある相違点を意識せずに、.NET Framework コードを通常どおりに記述することができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-178">This hides some differences between the types and makes writing .NET Framework code more natural.</span></span> <span data-ttu-id="ebeaa-179">次の表は、最も一般的なジェネリック インターフェイスの型、および他の一般的なクラスやインターフェイスに関する対応付けを示しています。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-179">The following table lists the most common of these generic interface types, along with other common class and interface mappings.</span></span> <span data-ttu-id="ebeaa-180">.NET Framework が対応する Windows ランタイム型の詳しい一覧については、「.NET Framework での Windows ランタイム型の対応付け」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-180">For a complete list of Windows Runtime types that the .NET Framework maps, see .NET Framework mappings of Windows Runtime types.</span></span>

| <span data-ttu-id="ebeaa-181">Windows ランタイム</span><span class="sxs-lookup"><span data-stu-id="ebeaa-181">Windows Runtime</span></span>                                  | <span data-ttu-id="ebeaa-182">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="ebeaa-182">.NET Framework</span></span>                                    |
|--------------------------------------------------|---------------------------------------------------|
| <span data-ttu-id="ebeaa-183">IIterable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-183">IIterable&lt;T&gt;</span></span>                               | <span data-ttu-id="ebeaa-184">IEnumerable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-184">IEnumerable&lt;T&gt;</span></span>                              |
| <span data-ttu-id="ebeaa-185">IVector&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-185">IVector&lt;T&gt;</span></span>                                 | <span data-ttu-id="ebeaa-186">IList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-186">IList&lt;T&gt;</span></span>                                    |
| <span data-ttu-id="ebeaa-187">IVectorView&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-187">IVectorView&lt;T&gt;</span></span>                             | <span data-ttu-id="ebeaa-188">IReadOnlyList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-188">IReadOnlyList&lt;T&gt;</span></span>                            |
| <span data-ttu-id="ebeaa-189">IMap&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-189">IMap&lt;K, V&gt;</span></span>                                 | <span data-ttu-id="ebeaa-190">IDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-190">IDictionary&lt;TKey, TValue&gt;</span></span>                   |
| <span data-ttu-id="ebeaa-191">IMapView&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-191">IMapView&lt;K, V&gt;</span></span>                             | <span data-ttu-id="ebeaa-192">IReadOnlyDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-192">IReadOnlyDictionary&lt;TKey, TValue&gt;</span></span>           |
| <span data-ttu-id="ebeaa-193">IKeyValuePair&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-193">IKeyValuePair&lt;K, V&gt;</span></span>                        | <span data-ttu-id="ebeaa-194">KeyValuePair&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="ebeaa-194">KeyValuePair&lt;TKey, TValue&gt;</span></span>                  |
| <span data-ttu-id="ebeaa-195">IBindableIterable</span><span class="sxs-lookup"><span data-stu-id="ebeaa-195">IBindableIterable</span></span>                                | <span data-ttu-id="ebeaa-196">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="ebeaa-196">IEnumerable</span></span>                                       |
| <span data-ttu-id="ebeaa-197">IBindableVector</span><span class="sxs-lookup"><span data-stu-id="ebeaa-197">IBindableVector</span></span>                                  | <span data-ttu-id="ebeaa-198">IList</span><span class="sxs-lookup"><span data-stu-id="ebeaa-198">IList</span></span>                                             |
| <span data-ttu-id="ebeaa-199">Windows.UI.Xaml.Data.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="ebeaa-199">Windows.UI.Xaml.Data.INotifyPropertyChanged</span></span>      | <span data-ttu-id="ebeaa-200">System.ComponentModel.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="ebeaa-200">System.ComponentModel.INotifyPropertyChanged</span></span>      |
| <span data-ttu-id="ebeaa-201">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="ebeaa-201">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span></span> | <span data-ttu-id="ebeaa-202">System.ComponentModel.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="ebeaa-202">System.ComponentModel.PropertyChangedEventHandler</span></span> |
| <span data-ttu-id="ebeaa-203">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="ebeaa-203">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span></span>    | <span data-ttu-id="ebeaa-204">System.ComponentModel.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="ebeaa-204">System.ComponentModel.PropertyChangedEventArgs</span></span>    |

<span data-ttu-id="ebeaa-205">型によって複数のインターフェイスが実装される場合、メンバーのパラメーターの型または戻り値の型として実装されるインターフェイスをすべて使うことができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-205">When a type implements more than one interface, you can use any of the interfaces it implements as a parameter type or return type of a member.</span></span> <span data-ttu-id="ebeaa-206">たとえば、合格またはディクショナリを返す&lt;int, string&gt; (Dictionary (Of Integer, String) Visual basic) IDictionary として&lt;int, string&gt;、IReadOnlyDictionary&lt;int, string&gt;、または IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-206">For example, you can pass or return a Dictionary&lt;int, string&gt; (Dictionary(Of Integer, String) in Visual Basic) as IDictionary&lt;int, string&gt;, IReadOnlyDictionary&lt;int, string&gt;, or IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;.</span></span>

<span data-ttu-id="ebeaa-207">**重要な**JavaScript は、マネージ型が実装されるインターフェイスの一覧で最初に表示されるインターフェイスを使用します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-207">**Important**JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</span></span> <span data-ttu-id="ebeaa-208">たとえば、Dictionary&lt;int, string&gt; を JavaScript コードに返した場合、戻り値の型としてどのインターフェイスを指定しても、IDictionary&lt;int, string&gt; として表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-208">For example, if you return Dictionary&lt;int, string&gt; to JavaScript code, it appears as IDictionary&lt;int, string&gt; no matter which interface you specify as the return type.</span></span> <span data-ttu-id="ebeaa-209">これは、後のインターフェイスで表示されるメンバーが最初のインターフェイスに含まれていない場合、そのメンバーは JavaScript に認識されないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-209">This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</span></span>

<span data-ttu-id="ebeaa-210">Windows ランタイムでは、IMap&lt;K, V&gt; と IMapView&lt;K, V&gt; は IKeyValuePair を使って反復処理されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-210">In the Windows Runtime, IMap&lt;K, V&gt; and IMapView&lt;K, V&gt; are iterated by using IKeyValuePair.</span></span> <span data-ttu-id="ebeaa-211">これらをマネージ コードに渡すと、IDictionary&lt;TKey, TValue&gt; および IReadOnlyDictionary&lt;TKey, TValue&gt; として表示されるため、これらを列挙するには必然的に System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt; を使います。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-211">When you pass them to managed code, they appear as IDictionary&lt;TKey, TValue&gt; and IReadOnlyDictionary&lt;TKey, TValue&gt;, so naturally you use System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt; to enumerate them.</span></span>

<span data-ttu-id="ebeaa-212">インターフェイスがマネージ コード内に表示される方法によって、これらのインターフェイスを実装する型の表示方法が決まります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-212">The way interfaces appear in managed code affects the way types that implement these interfaces appear.</span></span> <span data-ttu-id="ebeaa-213">たとえば、PropertySet クラスは IMap&lt;K, V&gt; を実装しますが、これはマネージ コードでは IDictionary&lt;TKey, TValue&gt; として表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-213">For example, the PropertySet class implements IMap&lt;K, V&gt;, which appears in managed code as IDictionary&lt;TKey, TValue&gt;.</span></span> <span data-ttu-id="ebeaa-214">PropertySet は、IMap&lt;K, V&gt; ではなく IDictionary&lt;TKey, TValue&gt; を実装したように示されるため、マネージ コードでは、PropertySet は .NET Framework ディクショナリの Add メソッドと同様な動作をする Add メソッドを保持しているように表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-214">PropertySet appears as if it implemented IDictionary&lt;TKey, TValue&gt; instead of IMap&lt;K, V&gt;, so in managed code it appears to have an Add method, which behaves like the Add method on .NET Framework dictionaries.</span></span> <span data-ttu-id="ebeaa-215">この場合、Insert メソッドは保持していないように表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-215">It doesn't appear to have an Insert method.</span></span> <span data-ttu-id="ebeaa-216">この例では、トピックを確認できます[チュートリアル: c# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-216">You can see this example in the topic [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="passing-managed-types-to-the-windows-runtime"></a><span data-ttu-id="ebeaa-217">Windows ランタイムへのマネージ型の引き渡し</span><span class="sxs-lookup"><span data-stu-id="ebeaa-217">Passing managed types to the Windows Runtime</span></span>
<span data-ttu-id="ebeaa-218">前のセクションで説明したように、一部の Windows ランタイム型は、コンポーネントのメンバーのシグニチャ内、または IDE で使う場合は Windows ランタイム メンバーのシグニチャ内で、.NET Framework 型として表示される場合があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-218">As discussed in the previous section, some Windows Runtime types can appear as .NET Framework types in the signatures of your component's members, or in the signatures of Windows Runtime members when you use them in the IDE.</span></span> <span data-ttu-id="ebeaa-219">.NET Framework 型をこれらのメンバーに渡すか、またはコンポーネントのメンバーの戻り値として使うと、対応する Windows ランタイム型として Windows ランタイム側のコードに表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-219">When you pass .NET Framework types to these members or use them as the return values of your component's members, they appear to the code on the other side as the corresponding Windows Runtime type.</span></span> <span data-ttu-id="ebeaa-220">コンポーネントが JavaScript から呼び出されたときの影響に関する例については、[「チュートリアル: C# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し」](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)の「コンポーネントからマネージ型を返す」セクションをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-220">For examples of the effects this can have when your component is called from JavaScript, see the "Returning managed types from your component" section in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="overloaded-methods"></a><span data-ttu-id="ebeaa-221">オーバー ロードされたメソッド</span><span class="sxs-lookup"><span data-stu-id="ebeaa-221">Overloaded methods</span></span>
<span data-ttu-id="ebeaa-222">Windows ランタイムでは、メソッドはオーバーロードできます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-222">In the Windows Runtime, methods can be overloaded.</span></span> <span data-ttu-id="ebeaa-223">ただし、同じ数のパラメーターを持つ複数のオーバーロードを宣言した場合、これらのオーバーロードのうち 1 つのみに [Windows.Foundation.Metadata.DefaultOverloadAttribute](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx) 属性を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-223">However, if you declare multiple overloads with the same number of parameters, you must apply the [Windows.Foundation.Metadata.DefaultOverloadAttribute](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx) attribute to only one of those overloads.</span></span> <span data-ttu-id="ebeaa-224">この属性が適用されるオーバーロードが、JavaScript から呼び出すことができる唯一のオーバーロードになります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-224">That overload is the only one you can call from JavaScript.</span></span> <span data-ttu-id="ebeaa-225">たとえば、次のコードでは、**int** (Visual Basic では **Integer**) を受け取るオーバーロードが既定のオーバーロードです。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-225">For example, in the following code the overload that takes an **int** (**Integer** in Visual Basic) is the default overload.</span></span>

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public string OverloadExample(string s)
> {
>     return s;
> }
> [Windows.Foundation.Metadata.DefaultOverload()]
> public int OverloadExample(int x)
> {
>     return x;
> }
> ```
> ```vb
> Public Function OverloadExample(ByVal s As String) As String
>     Return s
> End Function
> <Windows.Foundation.Metadata.DefaultOverload> _
> Public Function OverloadExample(ByVal x As Integer) As Integer
>     Return x
> End Function
> ```

 <span data-ttu-id="ebeaa-226">**注意:** JavaScript と任意の値を OverloadExample に渡す、できますが、値をパラメーターで必要な型に変換します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-226">**Caution**JavaScript allows you to pass any value to OverloadExample, and coerces the value to the type that is required by the parameter.</span></span> <span data-ttu-id="ebeaa-227">OverloadExample を "forty-two"、"42"、または 42.3 を使って呼び出すことができますが、それらの値はすべて既定のオーバーロードに渡されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-227">You can call OverloadExample with "forty-two", "42", or 42.3, but all those values are passed to the default overload.</span></span> <span data-ttu-id="ebeaa-228">前の例の既定のオーバーロードは、0、42、および 42 をそれぞれ返します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-228">The default overload in the previous example returns 0, 42, and 42 respectively.</span></span>

<span data-ttu-id="ebeaa-229">コンストラクターに DefaultOverloadAttribute 属性を適用することはできません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-229">You cannot apply the DefaultOverloadAttribute attribute to constructors.</span></span> <span data-ttu-id="ebeaa-230">クラスのすべてのコンストラクターは、異なる数のパラメーターを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-230">All the constructors in a class must have different numbers of parameters.</span></span>

## <a name="implementing-istringable"></a><span data-ttu-id="ebeaa-231">IStringable の実装</span><span class="sxs-lookup"><span data-stu-id="ebeaa-231">Implementing IStringable</span></span>
<span data-ttu-id="ebeaa-232">Windows 8.1 以降では、Windows ランタイムに IStringable インターフェイスが用意されています。そのメソッドは IStringable.ToString の 1 つだけで、Object.ToString で提供されるサポートに相当する基本的な書式設定のサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-232">Starting with Windows 8.1, the Windows Runtime includes an IStringable interface whose single method, IStringable.ToString, provides basic formatting support comparable to that provided by Object.ToString.</span></span> <span data-ttu-id="ebeaa-233">Windows ランタイム コンポーネントでエクスポートしたパブリック マネージ型に IStringable を実装する場合は、次の制限があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-233">If you do choose to implement IStringable in a public managed type that is exported in a Windows Runtime component, the following restrictions apply:</span></span>

-   <span data-ttu-id="ebeaa-234">IStringable インターフェイスは、次のコードのように、"クラスが実装する" 関係でのみ定義することができます。C# では、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-234">You can define the IStringable interface only in a "class implements" relationship, such as the following code in C#:</span></span>

    ```cs
    public class NewClass : IStringable
    ```

    <span data-ttu-id="ebeaa-235">Visual Basic では、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-235">Or the following Visual Basic code:</span></span>

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   <span data-ttu-id="ebeaa-236">インターフェイスで IStringable を実装することはできません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-236">You cannot implement IStringable on an interface.</span></span>
-   <span data-ttu-id="ebeaa-237">パラメーターの型を IStringable として宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-237">You cannot declare a parameter to be of type IStringable.</span></span>
-   <span data-ttu-id="ebeaa-238">IStringable をメソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-238">IStringable cannot be the return type of a method, property, or field.</span></span>
-   <span data-ttu-id="ebeaa-239">次のようなメソッド定義を使って IStringable の実装を基底クラスから隠すことはできません。 </span><span class="sxs-lookup"><span data-stu-id="ebeaa-239">You cannot hide your IStringable implementation from base classes by using a method definition such as the following:</span></span>

    ```cs
    public class NewClass : IStringable
    {
       public new string ToString()
       {
          return "New ToString in NewClass";
       }
    }
    ```

    <span data-ttu-id="ebeaa-240">代わりに、IStringable.ToString の実装で基底クラスの実装を常にオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-240">Instead, the IStringable.ToString implementation must always override the base class implementation.</span></span> <span data-ttu-id="ebeaa-241">ToString の実装を隠すことができるのは、厳密に型指定されたクラス インスタンスで呼び出す場合だけです。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-241">You can hide a ToString implementation only by invoking it on a strongly typed class instance.</span></span>

<span data-ttu-id="ebeaa-242">IStringable を実装するマネージ型やその ToString の実装を隠すマネージ型をネイティブ コードから呼び出すと、さまざまな状況で予期しない動作を引き起こす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-242">Note that under a variety of conditions, calls from native code to a managed type that implements IStringable or hides its ToString implementation can produce unexpected behavior.</span></span>

## <a name="asynchronous-operations"></a><span data-ttu-id="ebeaa-243">非同期操作</span><span class="sxs-lookup"><span data-stu-id="ebeaa-243">Asynchronous operations</span></span>
<span data-ttu-id="ebeaa-244">コンポーネントで非同期メソッドを実装するには、メソッド名の最後に "Async" を追加し、非同期アクションまたは非同期操作を表す、次の Windows ランタイム インターフェイスのいずれかを返します。IAsyncAction、IAsyncActionWithProgress&lt;TProgress&gt;、IAsyncOperation&lt;TResult&gt;、IAsyncOperationWithProgress&lt;TResult, TProgress&gt;。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-244">To implement an asynchronous method in your component, add "Async" to the end of the method name and return one of the Windows Runtime interfaces that represent asynchronous actions or operations: IAsyncAction, IAsyncActionWithProgress&lt;TProgress&gt;, IAsyncOperation&lt;TResult&gt;, or IAsyncOperationWithProgress&lt;TResult, TProgress&gt;.</span></span>

<span data-ttu-id="ebeaa-245">.NET Framework タスク ([Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) クラスとジェネリック [Task&lt;TResult&gt;](https://msdn.microsoft.com/library/dd321424.aspx) クラス) を使って、非同期メソッドを実装できます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-245">You can use .NET Framework tasks (the [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) class and generic [Task&lt;TResult&gt;](https://msdn.microsoft.com/library/dd321424.aspx) class) to implement your asynchronous method.</span></span> <span data-ttu-id="ebeaa-246">C# または Visual Basic で記述された非同期メソッドから返されるタスクや、[Task.Run](https://msdn.microsoft.com/library/system.threading.tasks.task.run.aspx) メソッドから返されたタスクなど、進行中の操作を表すタスクを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-246">You must return a task that represents an ongoing operation, such as a task that is returned from an asynchronous method written in C# or Visual Basic, or a task that is returned from the [Task.Run](https://msdn.microsoft.com/library/system.threading.tasks.task.run.aspx) method.</span></span> <span data-ttu-id="ebeaa-247">コンストラクターを使ってタスクを作成する場合、その [Task.Start](https://msdn.microsoft.com/library/system.threading.tasks.task.start.aspx) メソッドを呼び出してから戻す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-247">If you use a constructor to create the task, you must call its [Task.Start](https://msdn.microsoft.com/library/system.threading.tasks.task.start.aspx) method before returning it.</span></span>

<span data-ttu-id="ebeaa-248">await (Visual Basic では Await) を使うメソッドでは、**async** キーワード (Visual Basic では **Async**) が必要です。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-248">A method that uses await (Await in Visual Basic) requires the **async** keyword (**Async** in Visual Basic).</span></span> <span data-ttu-id="ebeaa-249">Windows ランタイム コンポーネントからそのようなメソッドを公開する場合、Run メソッドに渡すデリゲートに **async** キーワードを適用します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-249">If you expose such a method from a Windows Runtime component, apply the **async** keyword to the delegate that you pass to the Run method.</span></span>

<span data-ttu-id="ebeaa-250">取り消しや進行状況の報告をサポートしない非同期アクションと非同期操作では、タスクを適切なインターフェイスにラップするために、[WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) または [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) の拡張メソッドを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-250">For asynchronous actions and operations that do not support cancellation or progress reporting, you can use the [WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) or [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) extension method to wrap the task in the appropriate interface.</span></span> <span data-ttu-id="ebeaa-251">たとえば、次のコードでは、タスクを開始するために Task.Run&lt;TResult&gt; メソッドを使って、非同期メソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-251">For example, the following code implements an asynchronous method by using the Task.Run&lt;TResult&gt; method to start a task.</span></span> <span data-ttu-id="ebeaa-252">AsAsyncOperation&lt;TResult&gt; 拡張メソッドは、タスクを Windows ランタイムの非同期操作として返します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-252">The AsAsyncOperation&lt;TResult&gt; extension method returns the task as a Windows Runtime asynchronous operation.</span></span>

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
> {
>     return Task.Run<IList<string>>(async () =>
>     {
>         var data = await DownloadDataAsync(id);
>         return ExtractStrings(data);
>     }).AsAsyncOperation();
> }
> ```
> ```vb
> Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
>      As IAsyncOperation(Of IList(Of String))
>
>     Return Task.Run(Of IList(Of String))(
>         Async Function()
>             Dim data = Await DownloadDataAsync(id)
>             Return ExtractStrings(data)
>         End Function).AsAsyncOperation()
> End Function
> ```

<span data-ttu-id="ebeaa-253">次の JavaScript コードは、[WinJS.Promise](https://msdn.microsoft.com/library/windows/apps/br211867.aspx) オブジェクトを使ってメソッドを呼び出す方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-253">The following JavaScript code shows how the method could be called by using a [WinJS.Promise](https://msdn.microsoft.com/library/windows/apps/br211867.aspx) object.</span></span> <span data-ttu-id="ebeaa-254">then メソッドに渡される関数は、非同期呼び出しが完了したときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-254">The function that is passed to the then method is executed when the asynchronous call completes.</span></span> <span data-ttu-id="ebeaa-255">stringList パラメーターには DownloadAsStringAsync メソッドによって返される文字列のリストが含まれ、関数は必要な処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-255">The stringList parameter contains the list of strings that is returned by the DownloadAsStringAsync method, and the function does whatever processing is required.</span></span>

```javascript
function asyncExample(id) {

    var result = SampleComponent.Example.downloadAsStringAsync(id).then(
        function (stringList) {
            // Place code that uses the returned list of strings here.
        });
}
```

<span data-ttu-id="ebeaa-256">取り消しや進行状況の報告をサポートする非同期アクションと非同期操作では、開始されたタスクを生成して、適切な Windows ランタイム インターフェイスの取り消し機能と進行状況の報告機能を持つタスクの取り消し機能と進行状況の報告機能をフックするために、[AsyncInfo](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx) クラスを使います。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-256">For asynchronous actions and operations that support cancellation or progress reporting, use the [AsyncInfo](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx) class to generate a started task and to hook up the cancellation and progress reporting features of the task with the cancellation and progress reporting features of the appropriate Windows Runtime interface.</span></span> <span data-ttu-id="ebeaa-257">取り消しおよび進行状況の報告の両方をサポートする例については、「[チュートリアル: C# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-257">For an example that supports both cancellation and progress reporting, see [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

<span data-ttu-id="ebeaa-258">非同期メソッドが取り消しや進行状況の報告をサポートしていない場合でも、AsyncInfo クラスのメソッドを使うことはできます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-258">Note that you can use the methods of the AsyncInfo class even if your asynchronous method doesn't support cancellation or progress reporting.</span></span> <span data-ttu-id="ebeaa-259">Visual Basic のラムダ関数または C# の匿名メソッドを使う場合は、トークンと [IProgress&lt;T&gt;](https://msdn.microsoft.com/library/hh138298.aspx) インターフェイスのパラメーターを指定しないでください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-259">If you use a Visual Basic lambda function or a C# anonymous method, don't supply parameters for the token and [IProgress&lt;T&gt;](https://msdn.microsoft.com/library/hh138298.aspx) interface.</span></span> <span data-ttu-id="ebeaa-260">C# のラムダ関数を使う場合は、トークンのパラメーターを指定しますが、無視されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-260">If you use a C# lambda function, supply a token parameter but ignore it.</span></span> <span data-ttu-id="ebeaa-261">前の例は使用 AsAsyncOperation&lt;TResult&gt;メソッドでは、次のような使用すると、 [AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779740.aspx)) メソッド代わりにオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-261">The previous example, which used the AsAsyncOperation&lt;TResult&gt; method, looks like this when you use the [AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;&gt;](https://msdn.microsoft.com/library/hh779740.aspx)) method overload instead:</span></span>

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
> {
>     return AsyncInfo.Run<IList<string>>(async (token) =>
>     {
>         var data = await DownloadDataAsync(id);
>         return ExtractStrings(data);
>     });
> }
> ```
> ```vb
> Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
>     As IAsyncOperation(Of IList(Of String))
>
>     Return AsyncInfo.Run(Of IList(Of String))(
>         Async Function()
>             Dim data = Await DownloadDataAsync(id)
>             Return ExtractStrings(data)
>         End Function)
> End Function
> ```

<span data-ttu-id="ebeaa-262">取り消しや進行状況の報告をオプションでサポートする非同期メソッドを作成する場合は、キャンセル トークンや IProgress&lt;T&gt; インターフェイスのパラメーターを持たないオーバーロードを追加することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-262">If you create an asynchronous method that optionally supports cancellation or progress reporting, consider adding overloads that don't have parameters for a cancellation token or the IProgress&lt;T&gt; interface.</span></span>

## <a name="throwing-exceptions"></a><span data-ttu-id="ebeaa-263">例外のスロー</span><span class="sxs-lookup"><span data-stu-id="ebeaa-263">Throwing exceptions</span></span>
<span data-ttu-id="ebeaa-264">Windows アプリ用 .NET に含まれている例外の型は、どれでもスローすることができます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-264">You can throw any exception type that is included in the .NET for Windows apps.</span></span> <span data-ttu-id="ebeaa-265">Windows ランタイム コンポーネントで独自のパブリック型の例外を宣言することはできませんが、非パブリック型を宣言し、スローすることはできます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-265">You can't declare your own public exception types in a Windows Runtime component, but you can declare and throw non-public types.</span></span>

<span data-ttu-id="ebeaa-266">コンポーネントが例外を処理しない場合は、コンポーネントを呼び出したコードで対応する例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-266">If your component doesn't handle the exception, a corresponding exception is raised in the code that called your component.</span></span> <span data-ttu-id="ebeaa-267">例外が呼び出し元に表示される方法は、呼び出し元の言語が Windows ランタイムをサポートする方法によって異なります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-267">The way the exception appears to the caller depends on the way the calling language supports the Windows Runtime.</span></span>

-   <span data-ttu-id="ebeaa-268">JavaScript では、例外はオブジェクトとして表示され、例外メッセージがスタック トレースで置き換えられています。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-268">In JavaScript, the exception appears as an object in which the exception message is replaced by a stack trace.</span></span> <span data-ttu-id="ebeaa-269">Visual Studio でアプリをデバッグするとき、デバッガーの例外ダイアログ ボックスに、"WinRT 情報" として元のメッセージ テキストが表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-269">When you debug your app in Visual Studio, you can see the original message text displayed in the debugger exception dialog box, identified as "WinRT Information".</span></span> <span data-ttu-id="ebeaa-270">JavaScript コードから元のメッセージ テキストにアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-270">You can't access the original message text from JavaScript code.</span></span>

    > <span data-ttu-id="ebeaa-271">**ヒント:** 現時点では、スタック トレースには、マネージ例外の型が含まれていますが、例外の種類を識別するトレースを解析お勧めしません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-271">**Tip**Currently, the stack trace contains the managed exception type, but we don't recommend parsing the trace to identify the exception type.</span></span> <span data-ttu-id="ebeaa-272">このセクションの後半で説明するように、代わりに HRESULT 値を使ってください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-272">Instead, use an HRESULT value as described later in this section.</span></span>

-   <span data-ttu-id="ebeaa-273">C++ では、例外はプラットフォーム例外として表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-273">In C++, the exception appears as a platform exception.</span></span> <span data-ttu-id="ebeaa-274">マネージ例外の HResult プロパティを特定のプラットフォーム例外の HRESULT にマップできる場合は、そのプラットフォーム例外が使われます。それ以外の場合は、[Platform::COMException](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx) 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-274">If the managed exception's HResult property can be mapped to the HRESULT of a specific platform exception, the specific exception is used; otherwise, a [Platform::COMException](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx) exception is thrown.</span></span> <span data-ttu-id="ebeaa-275">マネージ例外のメッセージ テキストは、C++ コードでは利用できません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-275">The message text of the managed exception is not available to C++ code.</span></span> <span data-ttu-id="ebeaa-276">特定のプラットフォーム例外がスローされた場合、その例外の型に関する既定のメッセージ テキストが表示されます。それ以外の場合は、メッセージ テキストは表示されません。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-276">If a specific platform exception was thrown, the default message text for that exception type appears; otherwise, no message text appears.</span></span> <span data-ttu-id="ebeaa-277">「[例外 (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-277">See [Exceptions (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx).</span></span>
-   <span data-ttu-id="ebeaa-278">C# または Visual Basic では、例外は通常のマネージ例外です。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-278">In C# or Visual Basic, the exception is a normal managed exception.</span></span>

<span data-ttu-id="ebeaa-279">コンポーネントから例外をスローする場合、コンポーネントに固有の HResult プロパティ値を持つ非パブリック型の例外をスローすることにより、JavaScript や C++ の呼び出し元で例外を簡単に処理できるようになります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-279">When you throw an exception from your component, you can make it easier for a JavaScript or C++ caller to handle the exception by throwing a non-public exception type whose HResult property value is specific to your component.</span></span> <span data-ttu-id="ebeaa-280">HRESULT は、JavaScript の呼び出し元では例外オブジェクトの number プロパティから利用でき、C++ の呼び出し元では [COMException::HResult](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx) プロパティから利用できます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-280">The HRESULT is available to a JavaScript caller through the exception object's number property, and to a C++ caller through the [COMException::HResult](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx) property.</span></span>

> <span data-ttu-id="ebeaa-281">**注:**、HRESULT の負の値を使用します。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-281">**Note**Use a negative value for your HRESULT.</span></span> <span data-ttu-id="ebeaa-282">正の値は成功と解釈されるので、JavaScript や C++ の呼び出し元で例外がスローされなくなります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-282">A positive value is interpreted as success, and no exception is thrown in the JavaScript or C++ caller.</span></span>

## <a name="declaring-and-raising-events"></a><span data-ttu-id="ebeaa-283">イベントの宣言と発生</span><span class="sxs-lookup"><span data-stu-id="ebeaa-283">Declaring and raising events</span></span>
<span data-ttu-id="ebeaa-284">イベントのデータを保持する型を宣言する場合、EventArgs は Windows ランタイム型ではないので、EventArgs の代わりに Object から派生させます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-284">When you declare a type to hold the data for your event, derive from Object instead of from EventArgs, because EventArgs is not a Windows Runtime type.</span></span> <span data-ttu-id="ebeaa-285">[EventHandler&lt;TEventArgs&gt;](https://msdn.microsoft.com/library/db0etb8x.aspx) をイベントの型として使い、イベント引数の型をジェネリック型引数として使います。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-285">Use [EventHandler&lt;TEventArgs&gt;](https://msdn.microsoft.com/library/db0etb8x.aspx) as the type of the event, and use your event argument type as the generic type argument.</span></span> <span data-ttu-id="ebeaa-286">イベントは .NET Framework アプリケーションの場合と同様に発生させます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-286">Raise the event just as you would in a .NET Framework application.</span></span>

<span data-ttu-id="ebeaa-287">Windows ランタイム コンポーネントが JavaScript や C++ で使われる場合、イベントはそれらの言語で想定されている Windows ランタイムのイベント パターンに従います。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-287">When your Windows Runtime component is used from JavaScript or C++, the event follows the Windows Runtime event pattern that those languages expect.</span></span> <span data-ttu-id="ebeaa-288">C# や Visual Basic でコンポーネントを使う場合、イベントは通常の .NET Framework のイベントとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-288">When you use the component from C# or Visual Basic, the event appears as an ordinary .NET Framework event.</span></span> <span data-ttu-id="ebeaa-289">例については、「[チュートリアル: C# または Visual Basic での単純なコンポーネントの作成と JavaScript からの呼び出し]()」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-289">An example is provided in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript]().</span></span>

<span data-ttu-id="ebeaa-290">カスタム イベント アクセサーを実装する場合 (Visual Basic では **Custom** キーワードでイベントを宣言する場合) は、実装で Windows ランタイムのイベント パターンに従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-290">If you implement custom event accessors (declare an event with the **Custom** keyword, in Visual Basic), you must follow the Windows Runtime event pattern in your implementation.</span></span> <span data-ttu-id="ebeaa-291">「[Windows ランタイム コンポーネントのカスタム イベントおよびイベント アクセサー](custom-events-and-event-accessors-in-windows-runtime-components.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-291">See [Custom events and event accessors in Windows Runtime Components](custom-events-and-event-accessors-in-windows-runtime-components.md).</span></span> <span data-ttu-id="ebeaa-292">C# や Visual Basic コードでイベントを処理する場合でも、通常の .NET Framework のイベントとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-292">Note that when you handle the event from C# or Visual Basic code, it still appears to be an ordinary .NET Framework event.</span></span>

## <a name="next-steps"></a><span data-ttu-id="ebeaa-293">次の手順</span><span class="sxs-lookup"><span data-stu-id="ebeaa-293">Next steps</span></span>
<span data-ttu-id="ebeaa-294">ユーザーが独自に使う Windows ランタイム コンポーネントを作成した後で、そのコンポーネントにカプセル化されている機能が他の開発者の役に立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-294">After you’ve created a Windows Runtime component for your own use, you may find that the functionality it encapsulates is useful to other developers.</span></span> <span data-ttu-id="ebeaa-295">他の開発者に配布するためにコンポーネントをパッケージ化する方法は 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-295">You have two options for packaging a component for distribution to other developers.</span></span> <span data-ttu-id="ebeaa-296">「[マネージ Windows ランタイム コンポーネントの配布](https://msdn.microsoft.com/library/jj614475.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-296">See [Distributing a managed Windows Runtime component](https://msdn.microsoft.com/library/jj614475.aspx).</span></span>

<span data-ttu-id="ebeaa-297">Visual Basic と C# の言語の機能、および Windows ランタイムに関する .NET Framework のサポートについて詳しくは、「[Visual Basic および C# 言語リファレンス](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ebeaa-297">For more information about Visual Basic and C# language features, and .NET Framework support for the Windows Runtime, see [Visual Basic and C# language reference](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx).</span></span>

## <a name="related-topics"></a><span data-ttu-id="ebeaa-298">関連トピック</span><span class="sxs-lookup"><span data-stu-id="ebeaa-298">Related topics</span></span>
* [<span data-ttu-id="ebeaa-299">UWP アプリの概要の .NET</span><span class="sxs-lookup"><span data-stu-id="ebeaa-299">.NET for UWP apps Overview</span></span>](https://msdn.microsoft.com/library/windows/apps/xaml/br230302.aspx)
* [<span data-ttu-id="ebeaa-300">UWP アプリの .NET</span><span class="sxs-lookup"><span data-stu-id="ebeaa-300">.NET for UWP apps</span></span>](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx)
* [<span data-ttu-id="ebeaa-301">チュートリアル: 単純な Windows ランタイム コンポーネントの作成と JavaScript からの呼び出し</span><span class="sxs-lookup"><span data-stu-id="ebeaa-301">Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</span></span>](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)
