---
title: 安全な Windows アプリの開発について
description: この概要記事は、アプリの設計者と開発者が適切なセキュリティで保護されたユニバーサル Windows プラットフォーム (UWP) アプリの作成を加速するさまざまな windows 10 プラットフォーム機能を理解します。
ms.assetid: 6AFF9D09-77C2-4811-BB1A-BBF4A6FF511E
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp, セキュリティ
ms.localizationpriority: medium
ms.openlocfilehash: 38318e7f97c8eba7d0137a865f5025fb9a77fa55
ms.sourcegitcommit: b5c9c18e70625ab770946b8243f3465ee1013184
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/29/2018
ms.locfileid: "7992274"
---
# <a name="intro-to-secure-windows-app-development"></a><span data-ttu-id="f9ca4-104">安全な Windows アプリの開発について</span><span class="sxs-lookup"><span data-stu-id="f9ca4-104">Intro to secure Windows app development</span></span>




<span data-ttu-id="f9ca4-105">この概要記事は、アプリの設計者と開発者が適切なセキュリティで保護されたユニバーサル Windows プラットフォーム (UWP) アプリの作成を加速するさまざまな windows 10 プラットフォーム機能を理解します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-105">This introductory article helps app architects and developers better understand the various Windows10 platform capabilities that accelerate creating secure Universal Windows Platform (UWP) apps.</span></span> <span data-ttu-id="f9ca4-106">ここでは、認証、移動中データ、および保存データの各段階で利用可能な、Windows のセキュリティ機能に使用方法について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-106">It details how to use the Windows security features available at each of the following stages: authentication, data-in-flight, and data-at-rest.</span></span> <span data-ttu-id="f9ca4-107">各章にあるその他のリソースを確認すれば、各トピックについてさらに詳しい情報を得ることができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-107">You can find more in-depth information on each topic by reviewing the additional resources included in each chapter.</span></span>

## <a name="1-introduction"></a><span data-ttu-id="f9ca4-108">1 はじめに</span><span class="sxs-lookup"><span data-stu-id="f9ca4-108">1 Introduction</span></span>


<span data-ttu-id="f9ca4-109">セキュリティで保護されたアプリの開発は、容易な作業ではありません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-109">Developing a secure app can be a challenge.</span></span> <span data-ttu-id="f9ca4-110">モバイル アプリ、ソーシャル アプリ、クラウド アプリ、および複雑なエンタープライズ アプリが急速に進歩する現在では、アプリがこれまでよりも早く利用可能になり、更新されることをユーザーは期待しています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-110">In today’s fast-paced world of mobile, social, cloud, and complex enterprise apps, customers expect apps to become available and updated faster than ever.</span></span> <span data-ttu-id="f9ca4-111">また、ユーザーはさまざまな種類のデバイスを使用するので、アプリ エクスペリエンスの実現はますます複雑になっています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-111">They also use many types of devices, further adding to the complexity of creating app experiences.</span></span> <span data-ttu-id="f9ca4-112">Windows 10 ユニバーサル Windows プラットフォーム (UWP) 用にビルドする場合、含めることが可能なデバイス リストには、デスクトップ、ノート、タブレット、モバイル デバイスなどの従来のデバイスの他に、モノのインターネット、Xbox One、Microsoft Surface Hub、HoloLens にわたる新しいデバイスがあり、今後も増加します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-112">If you build for the Windows 10 Universal Windows Platform (UWP), that could include the traditional list of desktops, laptops, tablets, and mobile devices; in addition to a growing list of new devices spanning the Internet of Things, Xbox One, Microsoft Surface Hub, and HoloLens.</span></span> <span data-ttu-id="f9ca4-113">開発者は、関連するすべてのプラットフォームまたはデバイスで、アプリが安全に通信し、データを保存できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-113">As the developer, you must ensure your apps communicate and store data securely, across all the platforms or devices involved.</span></span>

<span data-ttu-id="f9ca4-114">Windows 10 のセキュリティ機能を利用する利点を次にいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-114">Here are some of the benefits of utilizing Windows 10 security features.</span></span>

-   <span data-ttu-id="f9ca4-115">セキュリティのコンポーネントやテクノロジ用の一貫性のある API を使用することにより、Windows 10 をサポートするすべてのデバイスで、標準的なセキュリティを実現できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-115">You will have standardized security across all devices that support Windows 10, by using consistent APIs for security components and technologies.</span></span>
-   <span data-ttu-id="f9ca4-116">これらのセキュリティ シナリオに対応するカスタム コードを実装する場合よりも、作成、テスト、保守の対象となるコードの量は少なくなります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-116">You write, test, and maintain less code than you would if you implemented custom code to cover these security scenarios.</span></span>
-   <span data-ttu-id="f9ca4-117">オペレーティング システムを使用して、アプリのリソースと、ローカルまたはリモートのシステム リソースにアプリがアクセスする方法を制御するため、アプリの安定性と安全性が高まります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-117">Your apps become more stable and secure because you use the operating system to control how the app accesses its resources and local or remote system resources.</span></span>

<span data-ttu-id="f9ca4-118">認証時に、特定のサービスへのアクセスを要求するユーザーの ID が検証されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-118">During authentication, the identity of a user requesting access to a particular service is validated.</span></span> <span data-ttu-id="f9ca4-119">Windows Hello は、Windows アプリでより安全な認証メカニズムを作成するのに役立つ Windows 10 のコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-119">Windows Hello is the component in Windows 10 that helps create a more secure authentication mechanism in Windows apps.</span></span> <span data-ttu-id="f9ca4-120">これらコンポーネントを利用すると、暗証番号 (PIN)、またはユーザーの指紋、顔、虹彩などの生体認証を使って、アプリ用の多要素認証を実装できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-120">With it, you can use a Personal Identification Number (PIN) or biometrics such as the user’s fingerprints, face, or iris to implement multi-factor authentication for your apps.</span></span>

<span data-ttu-id="f9ca4-121">移動中データとは、接続とそれを通してやり取りされるメッセージを表します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-121">Data-in-flight refers to the connection and the messages transferred across it.</span></span> <span data-ttu-id="f9ca4-122">これの例は、Web サービスを使用したリモート サーバーからのデータ取得です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-122">An example of this is retrieving data from a remote server using web services.</span></span> <span data-ttu-id="f9ca4-123">Secure Sockets Layer (SSL) と Secure Hypertext Transfer Protocol (HTTPS) を使うことで、接続の安全性が確保されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-123">The use of Secure Sockets Layer (SSL) and Secure Hypertext Transfer Protocol (HTTPS) ensures the security of the connection.</span></span> <span data-ttu-id="f9ca4-124">仲介するものがこれらのメッセージにアクセスするのを防ぎ、または承認されていないアプリが Web サービスと通信するのを防ぐことが、移動中データを保護するうえでの鍵となります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-124">Preventing intermediary parties from accessing these messages, or unauthorized apps from communicating with the web services, is key to securing data in flight.</span></span>

<span data-ttu-id="f9ca4-125">最後に、保存データとは、メモリや記憶域メディアに存在するデータのことです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-125">Lastly, data-at-rest relates to data residing in memory or on storage media.</span></span> <span data-ttu-id="f9ca4-126">Windows 10 では、アプリ間の承認されていないデータ アクセスを防止するアプリ モデルがあり、デバイス上のデータの安全性をさらに高める暗号化 API が提供されています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-126">Windows 10 has an app model that prevents unauthorized data access between apps, and offers encryption APIs to further secure data on the device.</span></span> <span data-ttu-id="f9ca4-127">資格情報保管ボックスと呼ばれる機能を使用すると、デバイスにユーザー資格情報を安全に保存することができ、オペレーティング システムが他のアプリからのアクセスを防止します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-127">A feature called Credential Locker can be used to securely store user credentials on the device, with the operating system preventing other apps from accessing them.</span></span>

## <a name="2-authentication-factors"></a><span data-ttu-id="f9ca4-128">2 認証要素</span><span class="sxs-lookup"><span data-stu-id="f9ca4-128">2 Authentication Factors</span></span>


<span data-ttu-id="f9ca4-129">データを保護するために、データへのアクセスを要求する人は、特定され、要求するデータ リソースへのアクセスが承認される必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-129">To protect data, the person requesting access to it must be identified and authorized to access the data resources they request.</span></span> <span data-ttu-id="f9ca4-130">ユーザーを特定するプロセスは認証と呼ばれ、リソースへのアクセス特権を判別することは承認と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-130">The process of identifying a user is called authentication, and determining access privileges to a resource is called authorization.</span></span> <span data-ttu-id="f9ca4-131">これらは密接な関係のある操作であり、ユーザーには区別できないかもしれません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-131">These are closely related operations, and to the user they might be indistinguishable.</span></span> <span data-ttu-id="f9ca4-132">操作には、比較的単純な操作から複雑な操作まであります。これは、さまざまな要因 (データが 1 台のサーバーに存在するか、多数のシステム間で分散しているかなど) によって決まります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-132">They can be relatively simple or complex operations, depending on many factors: for example, whether the data resides on one server or is distributed across many systems.</span></span> <span data-ttu-id="f9ca4-133">認証サービスおよび承認サービスを提供するサーバーは、ID プロバイダーと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-133">The server providing the authentication and authorization services is referred to as the identity provider.</span></span>

<span data-ttu-id="f9ca4-134">特定のサービスやアプリを使ってユーザー自身を認証するには、ユーザーは、自分が知っている情報、自分が持っているもの、自分の特徴からなる資格情報を使用します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-134">To authenticate themselves with a particular service and/or app, the user employs credentials made up of something they know, something they have, and/or something they are.</span></span> <span data-ttu-id="f9ca4-135">これらはそれぞれ認証要素と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-135">Each of these are called authentication factors.</span></span>

-   <span data-ttu-id="f9ca4-136">**ユーザーが知っている情報**とは、通常パスワードですが、暗証番号 (PIN) や "秘密" の質問と答えのペアの場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-136">**Something the user knows** is usually a password, but it can also be a personal identification number (PIN) or a “secret” question-and-answer pair.</span></span>
-   <span data-ttu-id="f9ca4-137">**ユーザーが持っているもの**とは、ほとんどの場合、ハードウェアのメモリ デバイス (ユーザーに固有の認証データを含んでいる USB スティックなど) です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-137">**Something the user has** is most often a hardware memory device such as a USB stick containing the authentication data unique to the user.</span></span>
-   <span data-ttu-id="f9ca4-138">**ユーザーの特徴**とは、多くの場合、指紋を意味しますが、ユーザーの音声、顔、眼球 (目) の特性、または動作パターンなどの要素も一般的になってきています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-138">**Something the user is** often encompasses their fingerprints, but there are increasingly popular factors like the user’s speech, facial, ocular (eye) characteristics, or patterns of behavior.</span></span> <span data-ttu-id="f9ca4-139">これらの測定値は、データとして保存されると生体認証と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-139">When stored as data, these measurements are called biometrics.</span></span>

<span data-ttu-id="f9ca4-140">ユーザーが作成したパスワードは認証要素ですが、パスワードだけでは不十分な場合があります。これは、パスワードを知っている人物が、パスワードの所有者であるユーザーになりすますことができるためです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-140">A password created by the user is an authentication factor in itself, but it often isn’t sufficient; anyone who knows the password can impersonate the user who owns it.</span></span> <span data-ttu-id="f9ca4-141">スマート カードではより高いレベルのセキュリティを実現できますが、盗難、紛失、置き忘れなどの可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-141">A smart card can provide a higher level of security, but it might be stolen, lost, or misplaced.</span></span> <span data-ttu-id="f9ca4-142">指紋や眼球のスキャンによってユーザーを認証するシステムでは、最高かつ最も便利なレベルのセキュリティを実現できる可能性があります。ただし、高額で特別なハードウェアが必要になります (たとえば、顔認証用の Intel RealSense カメラなど)。このようなハードウェアは、すべてのユーザーが利用できるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-142">A system that can authenticate a user by their fingerprint or by an ocular scan might provide the highest and most convenient level of security, but it requires expensive and specialized hardware (for example, an Intel RealSense camera for facial recognition) that might not be available to all users.</span></span>

<span data-ttu-id="f9ca4-143">システムで使う認証方法を設計することは、データ セキュリティにおいて複雑かつ重要な要素であるといえます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-143">Designing the method of authentication used by a system is a complex and important aspect of data security.</span></span> <span data-ttu-id="f9ca4-144">一般的に、認証で使う要素の数が多いほど、システムのセキュリティは高くなります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-144">In general, the greater number of factors you use in authentication, the more secure the system is.</span></span> <span data-ttu-id="f9ca4-145">同時に、認証は使いやすいものであることが必要です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-145">At the same time, authentication must be usable.</span></span> <span data-ttu-id="f9ca4-146">通常、ユーザーは 1 日に何度もログインするため、このプロセスは迅速に行われる必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-146">A user will usually log in many times a day, so the process must be fast.</span></span> <span data-ttu-id="f9ca4-147">認証の種類を選ぶときは、セキュリティと使いやすさのバランスを取る必要があります。単一要素認証は、セキュリティが最も低いレベルになりますが、最も使いやすい方法です。多要素認証では、認証要素が増えるに従って、セキュリティのレベルは高くなりますが、複雑になっていきます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-147">Your choice of authentication type is a trade-off between security and ease of use; single-factor authentication is the least secure and easiest to use, and multi-factor authentication becomes more secure, but more complex as more factors are added.</span></span>

## <a name="21-single-factor-authentication"></a><span data-ttu-id="f9ca4-148">2.1 単一要素認証</span><span class="sxs-lookup"><span data-stu-id="f9ca4-148">2.1 Single-factor authentication</span></span>


<span data-ttu-id="f9ca4-149">この形式の認証は、1 つのユーザーの資格情報に基づいています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-149">This form of authentication is based on a single user credential.</span></span> <span data-ttu-id="f9ca4-150">通常、これはパスワードですが、暗証番号 (PIN) の場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-150">This is usually a password, but it could also be a personal identification number (PIN).</span></span>

<span data-ttu-id="f9ca4-151">単一要素認証のプロセスを次に示します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-151">Here’s the process of single-factor authentication.</span></span>

-   <span data-ttu-id="f9ca4-152">ユーザーは、ユーザー名とパスワードを ID プロバイダーに提供します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-152">The user provides their username and password to the identity provider.</span></span> <span data-ttu-id="f9ca4-153">ID プロバイダーとは、ユーザーの身元を確認するサーバー プロセスです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-153">The identity provider is the server process that verifies the identity of the user.</span></span>
-   <span data-ttu-id="f9ca4-154">ID プロバイダーでは、ユーザー名とパスワードがシステムに保存されているものと同じであるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-154">The identity provider checks whether the username and password are the same as those stored in the system.</span></span> <span data-ttu-id="f9ca4-155">ほとんどの場合、パスワードは暗号化され、セキュリティを高めて他の人が読み取れないようにします。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-155">In most cases, the password will be encrypted, providing additional security so that others cannot read it.</span></span>
-   <span data-ttu-id="f9ca4-156">ID プロバイダーは、認証が成功したかどうかを示す認証状態を返します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-156">The identity provider returns an authentication status that indicates whether the authentication was successful.</span></span>
-   <span data-ttu-id="f9ca4-157">成功した場合、データ交換が開始されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-157">If successful, data exchange begins.</span></span> <span data-ttu-id="f9ca4-158">失敗した場合、ユーザーは再認証が必要です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-158">If unsuccessful, the user must be re-authenticated.</span></span>

![単一要素認証](images/secure-sfa.png)

<span data-ttu-id="f9ca4-160">今日、この認証方法はさまざまなサービスで最も一般的に使われている方法です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-160">Today, this method of authentication is the most commonly used one across services.</span></span> <span data-ttu-id="f9ca4-161">この認証形式を唯一の認証方法として使った場合、これは最もセキュリティ レベルの低い認証形式になります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-161">It is also the least secure form of authentication when used as the only means of authentication.</span></span> <span data-ttu-id="f9ca4-162">パスワードの複雑さの要件、"秘密の質問"、定期的なパスワードの変更によって、パスワードを使うセキュリティを高めることはできますが、ユーザーの負担が増え、ハッカーに対する効果的な抑止力とはなりません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-162">Password complexity requirements, "secret questions," and regular password changes can make using passwords more secure, but they put more burden on users and they’re not an effective deterrent against hackers.</span></span>

<span data-ttu-id="f9ca4-163">パスワードの課題は、複数の要素を備えるシステムよりも容易に推測されてしまうということです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-163">The challenge with passwords is that it is easier to guess them successfully than systems that have more than one factor.</span></span> <span data-ttu-id="f9ca4-164">小さなオンライン ショップから、ユーザー アカウントとハッシュされたパスワードのデータベースを盗めば、使用されているパスワードを他の Web サイトで使えます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-164">If they steal a database with user accounts and hashed password from a little web shop, they can use the passwords used on other web sites.</span></span> <span data-ttu-id="f9ca4-165">複雑なパスワードは覚えにくいため、ユーザーはアカウントを常に再利用する傾向があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-165">Users tend to reuse accounts all the time, because complex passwords are hard to remember.</span></span> <span data-ttu-id="f9ca4-166">IT 部門では、パスワード管理には、リセット メカニズムを提供、パスワードを頻繁に更新することを要求、そして安全な方法でパスワードを保存するという複雑さも伴います。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-166">For an IT department, managing passwords also brings with it the complexity of having to offer reset mechanisms, requiring frequent updates to passwords, and storing them in a safe manner.</span></span>

<span data-ttu-id="f9ca4-167">欠点はありますが、単一要素認証ではユーザーが資格情報を制御できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-167">For all of its disadvantages, single-factor authentication gives the user control of the credential.</span></span> <span data-ttu-id="f9ca4-168">資格情報の作成や変更はユーザーが行い、認証プロセスで必要となるのはキーボードだけです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-168">They create it and modify it, and only a keyboard is needed for the authentication process.</span></span> <span data-ttu-id="f9ca4-169">これが、多要素認証にはない単一要素認証の主な特徴です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-169">This is the main aspect that distinguishes single-factor from multi-factor authentication.</span></span>

## <a name="211-web-authentication-broker"></a><span data-ttu-id="f9ca4-170">2.1.1 Web 認証ブローカー</span><span class="sxs-lookup"><span data-stu-id="f9ca4-170">2.1.1 Web authentication broker</span></span>


<span data-ttu-id="f9ca4-171">既に説明したように、IT 部門におけるパスワード認証の課題の 1 つは、ユーザー名/パスワードの基盤やリセット メカニズムなどの管理というオーバーヘッドが加わる点です。一般的になってきているオプションは、認証のオープン スタンダードである OAuth による認証を提供するサード パーティの ID プロバイダーを利用することです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-171">As previously discussed, one of the challenges with password authentication for an IT department is the added overhead of managing the base of usernames/passwords, reset mechanisms, etc. An increasingly popular option is to rely on third-party identity providers that offer authentication through OAuth, an open standard for authentication.</span></span>

<span data-ttu-id="f9ca4-172">OAuth を使用すると、IT 部門は、ユーザー名とパスワードのデータベース、パスワードのリセット機能などの維持という複雑さを、Facebook、Twitter、Microsoft などのサード パーティの ID プロバイダーに効果的に "委託" することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-172">Using OAuth, IT departments can effectively "outsource" the complexity of maintaining a database with usernames and passwords, reset password functionality, etc. to a third party identity provider like Facebook, Twitter or Microsoft.</span></span>

<span data-ttu-id="f9ca4-173">ユーザーがこれらのプラットフォームで自身の ID を完全に制御しますが、アプリはプロバイダーにトークンを要求し、ユーザーが認証された後、ユーザーの同意を得て、それを認証されたユーザーの承認に使用することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-173">Users have complete control over their identity on these platforms, but apps can request a token from the provider, after the user is authenticated and with their consent, which can be used to authorize authenticated users.</span></span>

<span data-ttu-id="f9ca4-174">Windows 10 の Web 認証ブローカーは、アプリが認証プロトコルと承認プロトコル (OAuth や OpenID など) を使うための API のセットとインフラストラクチャを提供します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-174">The web authentication broker in Windows 10 provides a set of APIs and infrastructure for apps to use authentication and authorization protocols like OAuth and OpenID.</span></span> <span data-ttu-id="f9ca4-175">アプリでは、[**WebAuthenticationBroker**](https://msdn.microsoft.com/library/windows/apps/br227025) API を使って認証操作を開始できます。その結果として、[**WebAuthenticationResult**](https://msdn.microsoft.com/library/windows/apps/br227038) が返されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-175">Apps can initiate authentication operations through the [**WebAuthenticationBroker**](https://msdn.microsoft.com/library/windows/apps/br227025) API, resulting in the return of a [**WebAuthenticationResult**](https://msdn.microsoft.com/library/windows/apps/br227038).</span></span> <span data-ttu-id="f9ca4-176">通信フローの概要を次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-176">An overview of the communication flow is illustrated in the following figure.</span></span>

![WAB ワークフロー](images/secure-wab.png)

<span data-ttu-id="f9ca4-178">アプリはブローカーとして機能します。アプリでは、[**WebView**](https://msdn.microsoft.com/library/windows/apps/br227702) を利用して ID プロバイダーを使い、認証を開始します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-178">The app acts as the broker, initiating the authentication with the identity provider through a [**WebView**](https://msdn.microsoft.com/library/windows/apps/br227702) in the app.</span></span> <span data-ttu-id="f9ca4-179">ID プロバイダーがユーザーを認証すると、トークンがアプリに返されます。このトークンを使って、ID プロバイダーに対してユーザーに関する情報を要求することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-179">When the identity provider has authenticated the user, it returns a token to the app that can be used to request information about the user from the identity provider.</span></span> <span data-ttu-id="f9ca4-180">セキュリティ対策として、アプリが ID プロバイダーの認証プロセスを仲介する前に、アプリを ID プロバイダーに登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-180">As a security measure, the app must be registered with the identity provider before it can broker the authentication processes with the identity provider.</span></span> <span data-ttu-id="f9ca4-181">この登録手順は、プロバイダーごとに異なります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-181">This registration steps differ for each provider.</span></span>

<span data-ttu-id="f9ca4-182">プロバイダーと通信するための [**WebAuthenticationBroker**](https://msdn.microsoft.com/library/windows/apps/br227025) API の呼び出しに使われる一般的なワークフローを次に示します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-182">Here’s the general workflow for calling the [**WebAuthenticationBroker**](https://msdn.microsoft.com/library/windows/apps/br227025) API to communicate with the provider.</span></span>

-   <span data-ttu-id="f9ca4-183">ID プロバイダーに送信される要求文字列を作成します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-183">Construct the request strings to be sent to the identity provider.</span></span> <span data-ttu-id="f9ca4-184">文字列の数と各文字列に含まれる情報は、Web サービスごとに異なりますが、通常は、URI 文字列が 2 つあり、それぞれに URL が含まれています。1 つは認証要求の送信先となる URL で、もう 1 つは認証の完了後にユーザーがリダイレクトされる URL です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-184">The number of strings, and the information in each string, is different for each web service but it usually includes two URI strings each containing a URL: one to which the authentication request is sent, and one to which the user is redirected after authorization is complete.</span></span>
-   <span data-ttu-id="f9ca4-185">要求文字列を渡して [**WebAuthenticationBroker.AuthenticateAsync**](https://msdn.microsoft.com/library/windows/apps/br212066) を呼び出し、ID プロバイダーからの応答を待ちます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-185">Call [**WebAuthenticationBroker.AuthenticateAsync**](https://msdn.microsoft.com/library/windows/apps/br212066), passing in the request strings, and wait for the response from the identity provider.</span></span>
-   <span data-ttu-id="f9ca4-186">[**WebAuthenticationResult.ResponseStatus**](https://msdn.microsoft.com/library/windows/apps/br227041) を呼び出し、応答を受け取ったときの状態を取得します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-186">Call [**WebAuthenticationResult.ResponseStatus**](https://msdn.microsoft.com/library/windows/apps/br227041) to get the status when the response is received.</span></span>
-   <span data-ttu-id="f9ca4-187">通信が成功したら、ID プロバイダーから返された応答文字列を処理します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-187">If the communication is successful, process the response string returned by the identity provider.</span></span> <span data-ttu-id="f9ca4-188">通信が失敗した場合は、エラーを処理します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-188">If unsuccessful, process the error.</span></span>

<span data-ttu-id="f9ca4-189">通信が成功したら、ID プロバイダーから返された応答文字列を処理します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-189">If the communication is successful, process the response string returned by the identity provider.</span></span> <span data-ttu-id="f9ca4-190">通信が失敗した場合は、エラーを処理します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-190">If unsuccessful, process the error.</span></span>

<span data-ttu-id="f9ca4-191">このプロセスに関するサンプルの C# コードを次に示します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-191">Sample C# code that for this process is below.</span></span> <span data-ttu-id="f9ca4-192">詳しい情報やチュートリアルについては、「[WebAuthenticationBroker](web-authentication-broker.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-192">For information and a detailed walkthrough, see [WebAuthenticationBroker](web-authentication-broker.md).</span></span> <span data-ttu-id="f9ca4-193">完全なコード サンプルについては、「[GitHub の WebAuthenticationBroker サンプル](http://go.microsoft.com/fwlink/p/?LinkId=620622)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-193">For a complete code sample, check out the [WebAuthenticationBroker sample on GitHub](http://go.microsoft.com/fwlink/p/?LinkId=620622).</span></span>

```cs
string startURL = "https://<providerendpoint>?client_id=<clientid>";
string endURL = "http://<AppEndPoint>";

var startURI = new System.Uri(startURL);
var endURI = new System.Uri(endURL);

try
{
    WebAuthenticationResult webAuthenticationResult = 
        await WebAuthenticationBroker.AuthenticateAsync( 
            WebAuthenticationOptions.None, startURI, endURI);

    switch (webAuthenticationResult.ResponseStatus)
    {
        case WebAuthenticationStatus.Success:
            // Successful authentication. 
            break;
        case WebAuthenticationStatus.ErrorHttp:
            // HTTP error. 
            break;
        default:
            // Other error.
        break;
    }
}
catch (Exception ex)
{
    // Authentication failed. Handle parameter, SSL/TLS, and
    // Network Unavailable errors here. 
}
```

## <a name="22-multi-factor-authentication"></a><span data-ttu-id="f9ca4-194">2.2 多要素認証</span><span class="sxs-lookup"><span data-stu-id="f9ca4-194">2.2 Multi-factor authentication</span></span>


<span data-ttu-id="f9ca4-195">多要素認証では、複数の認証要素を使います。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-195">Multi-factor authentication makes use of more than one authentication factor.</span></span> <span data-ttu-id="f9ca4-196">通常、パスワードなどの "知っている情報" は、携帯電話やスマート カードなどの "持っているもの" に結合されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-196">Usually, "something you know," such as a password, is combined with "something you have," which can be a mobile phone or a smart card.</span></span> <span data-ttu-id="f9ca4-197">攻撃者がユーザーのパスワードを検出しても、デバイスやカードを使わないと、アカウントにアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-197">Even if an attacker discovers the user’s password, the account is still inaccessible without the device or card.</span></span> <span data-ttu-id="f9ca4-198">また、攻撃者がデバイスやカードだけを手に入れても、パスワードがなければ、攻撃者はこれらを使うことはできません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-198">And if only the device or card is compromised, it is not useful to the attacker without the password.</span></span> <span data-ttu-id="f9ca4-199">したがって、多要素認証は単一要素認証よりもセキュリティが高くなりますが、複雑にもなります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-199">Multi-factor authentication is therefore more secure, but also more complex, than single-factor authentication.</span></span>

<span data-ttu-id="f9ca4-200">多要素認証を使うサービスでは、多くの場合、サービスに 2 番目の資格情報を提供する手段をユーザーが選択できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-200">Services that use multi-factor authentication will often give the user a choice in how they receive the second credential.</span></span> <span data-ttu-id="f9ca4-201">この種類の認証の例として、SMS を利用して確認コードをユーザーの携帯電話に送信するという一般的に使われるプロセスを挙げることができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-201">An example of this type of authentication is a commonly used process where a verification code is sent to the user’s mobile phone using SMS.</span></span>

-   <span data-ttu-id="f9ca4-202">ユーザーは、ユーザー名とパスワードを ID プロバイダーに提供します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-202">The user provides their username and password to the identity provider.</span></span>
-   <span data-ttu-id="f9ca4-203">ID プロバイダーでは、ユーザー名とパスワードを単一要素認証の場合と同様に確認し、その後で、システムに保存されているユーザーの携帯電話番号を検索します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-203">The identity provider verifies the username and password as in single-factor authorization, and then looks up the user’s mobile phone number stored in the system.</span></span>
-   <span data-ttu-id="f9ca4-204">サーバーは、生成された確認コードを含んでいる SMS メッセージをユーザーの携帯電話に送信します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-204">The server sends an SMS message containing a generated verification code to the user’s mobile phone.</span></span>
-   <span data-ttu-id="f9ca4-205">ユーザーは、ユーザーに提示された形式で確認コードを ID プロバイダーに提供します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-205">The user provides the verification code to the identity provider; through a form presented to the user.</span></span>
-   <span data-ttu-id="f9ca4-206">ID プロバイダーは、両方の資格情報の認証が成功したかどうかを示す認証状態を返します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-206">The identity provider returns an authentication status that indicates whether the authentication of both credentials were successful.</span></span>
-   <span data-ttu-id="f9ca4-207">成功した場合、データ交換が開始されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-207">If successful, data exchange begins.</span></span> <span data-ttu-id="f9ca4-208">失敗した場合、ユーザーは再認証が必要です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-208">Otherwise, the user must be re-authenticated.</span></span>

![2 要素認証](images/secure-tfa.png)

<span data-ttu-id="f9ca4-210">以上の説明でわかるように、このプロセスは、2 番目のユーザーの資格情報がユーザーによって作成または提供されるのではなく、ユーザーに送られるという点が、単一要素認証とは異なります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-210">As you can see, this process also differs from single-factor authentication in that the second user credential is sent to the user instead of being created or provided by the user.</span></span> <span data-ttu-id="f9ca4-211">そのため、ユーザーは、必要な資格情報を完全に制御することはできません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-211">The user is therefore not in complete control of the necessary credentials.</span></span> <span data-ttu-id="f9ca4-212">このことは、スマート カードを 2 番目の資格情報として使う場合にも該当します。2 番目の資格情報の作成とユーザーへの提供は、組織が管理します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-212">This also applies when a smart card is used as the second credential: the organization is in charge of creating and providing it to the user.</span></span>

## <a name="221-azure-active-directory"></a><span data-ttu-id="f9ca4-213">2.2.1 Azure Active Directory</span><span class="sxs-lookup"><span data-stu-id="f9ca4-213">2.2.1 Azure Active Directory</span></span>


<span data-ttu-id="f9ca4-214">Azure Active Directory (Azure AD) は、クラウド ベースの ID およびアクセスの管理サービスであり、単一要素認証や多要素認証の ID プロバイダーとして使うことができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-214">Azure Active Directory (Azure AD) is a cloud-based identity and access management service that can serve as the identity provider in single-factor or multi-factor authentication.</span></span> <span data-ttu-id="f9ca4-215">Azure AD 認証は、確認コードの有無にかかわらず使うことができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-215">Azure AD authentication can be used with or without a verification code.</span></span>

<span data-ttu-id="f9ca4-216">Azure AD では単一要素認証を実装することもできますが、通常、企業では最もセキュリティ レベルの高い多要素認証を必要とします。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-216">While Azure AD can also implement single-factor authentication, enterprises usually require the higher security of multi-factor authentication.</span></span> <span data-ttu-id="f9ca4-217">多要素認証の構成の場合、Azure AD アカウントを使ったユーザー認証では、確認コードを SMS メッセージとして携帯電話に送信したり、Azure Authenticator モバイル アプリに送信したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-217">In a multi-factor authentication configuration, a user authenticating with an Azure AD account has the option of having a verification code sent as an SMS message either to their mobile phone or the Azure Authenticator mobile app.</span></span>

<span data-ttu-id="f9ca4-218">さらに、Azure AD は OAuth プロバイダーとして使用でき、さまざまなプラットフォームのアプリに対する認証および承認メカニズムを標準ユーザーに提供できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-218">Additionally, Azure AD can be used as an OAuth provider, providing the standard user with an authentication and authorization mechanism to apps across various platforms.</span></span> <span data-ttu-id="f9ca4-219">詳しくは、「[Azure Active Directory](https://azure.microsoft.com/services/active-directory/)」および「[Azure の多要素認証](https://azure.microsoft.com/services/multi-factor-authentication/)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-219">To learn more, see [Azure Active Directory](https://azure.microsoft.com/services/active-directory/) and [Multi-Factor Authentication on Azure](https://azure.microsoft.com/services/multi-factor-authentication/).</span></span>

## <a name="24-windows-hello"></a><span data-ttu-id="f9ca4-220">2.4 Windows Hello</span><span class="sxs-lookup"><span data-stu-id="f9ca4-220">2.4 Windows Hello</span></span>


<span data-ttu-id="f9ca4-221">Windows 10 では、便利な多要素認証メカニズムがオペレーティング システムに組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-221">In Windows 10, a convenient multi-factor authentication mechanism is built into the operating system.</span></span> <span data-ttu-id="f9ca4-222">Windows Hello は、Windows 10 に組み込まれた新しい生体認証サインイン システムです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-222">Windows Hello is the new biometric sign-in system built into Windows 10.</span></span> <span data-ttu-id="f9ca4-223">Windows Hello はオペレーティング システムに直接組み込まれているため、顔または指紋を識別して、ユーザーのデバイスのロックを解除できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-223">Because it is built directly into the operating system, Windows Hello allows face or fingerprint identification to unlock users’ devices.</span></span> <span data-ttu-id="f9ca4-224">Windows のセキュリティ保護された資格情報ストアは、デバイス上の生体認証データを保護します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-224">The Windows secure credential store protects biometric data on the device.</span></span>

<span data-ttu-id="f9ca4-225">Windows Hello は、個々のユーザーを認識するための堅牢な方法をデバイスに提供します。これにより、ユーザーと要求されたサービス (またはデータ項目) との間のパスの最初の部分が処理されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-225">Windows Hello provides a robust way for a device to recognize an individual user, which addresses the first part of the path between a user and a requested service or data item.</span></span> <span data-ttu-id="f9ca4-226">デバイスがユーザーを認識しても、要求されたリソースへのアクセス権を与えるかどうかを決める前に、ユーザーをまだ認証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-226">After the device has recognized the user, it still must authenticate the user before determining whether to grant access to a requested resource.</span></span> <span data-ttu-id="f9ca4-227">Windows Hello は、Windows に完全に統合された強固な 2 要素認証 (2FA) も行い、再利用可能なパスワードを、特定のデバイスと生体認証ジェスチャまたは PIN の組み合わせに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-227">Windows Hello also provides strong two-factor authentication (2FA) that is fully integrated into Windows and replaces reusable passwords with the combination of a specific device, and a biometric gesture or PIN.</span></span> <span data-ttu-id="f9ca4-228">PIN は、Microsoft アカウントの登録時にユーザーが指定します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-228">The PIN is specified by the user as part of their Microsoft account enrollment.</span></span>

<span data-ttu-id="f9ca4-229">Windows Hello は、従来の 2FA システムの単なる代替機能ではありません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-229">Windows Hello isn’t just a replacement for traditional 2FA systems, though.</span></span> <span data-ttu-id="f9ca4-230">概念的にはスマート カードと似ています。文字列比較ではなく、暗号化プリミティブを使用して認証が行われます。ユーザーのキー マテリアルは、が改ざんされにくいハードウェア内にセキュリティ保護されています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-230">It’s conceptually similar to smart cards: authentication is performed by using cryptographic primitives instead of string comparisons, and the user’s key material is secure inside tamper-resistant hardware.</span></span> <span data-ttu-id="f9ca4-231">Microsoft Hello では、スマート カード展開に必要なインフラストラクチャ コンポーネントも追加する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-231">Microsoft Hello doesn't require the extra infrastructure components required for smart card deployment, either.</span></span> <span data-ttu-id="f9ca4-232">具体的には、現在、公開キー基盤 (PKI) を所持していない場合は、証明書を管理するための PKI は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-232">In particular, you don’t need a Public Key Infrastructure (PKI) to manage certificates, if you don’t currently have one.</span></span> <span data-ttu-id="f9ca4-233">Windows Hello では、スマート カードの主な利点である、仮想スマート カードの展開の柔軟性と物理スマート カードの堅牢なセキュリティを組み合わせ、それぞれの欠点を排除しています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-233">Windows Hello combines the major advantages of smart cards—deployment flexibility for virtual smart cards and robust security for physical smart cards—without any of their drawbacks.</span></span>

<span data-ttu-id="f9ca4-234">ユーザーがデバイスを使って認証する前に、デバイスを Windows Hello に登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-234">A device must be registered with Windows Hello before users can authenticate with it.</span></span> <span data-ttu-id="f9ca4-235">Windows Hello は非対称 (公開/秘密キー) の暗号化を使用しています。この暗号化では、相手が秘密キーを使って暗号化解除できるデータを、公開キーを使用して暗号化します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-235">Windows Hello uses asymmetric (public/private key) encryption in which one party uses a public key to encrypt the data that the other party can decrypt using a private key.</span></span> <span data-ttu-id="f9ca4-236">Windows Hello では、公開/秘密キーの組のセットを作成し、デバイスのトラステッド プラットフォーム モジュール (TPM) チップに秘密キーを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-236">In the case of Windows Hello, it creates a set of public/private key pairs and writes the private keys to the device’s Trusted Platform Module (TPM) chip.</span></span> <span data-ttu-id="f9ca4-237">デバイスが登録されると、UWP アプリは、システム API を呼び出してユーザーの公開キーを取得することができ、このキーを使ってユーザーをサーバーに登録することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-237">After a device has been registered, UWP apps can call system APIs to retrieve the user’s public key, which can be used to register the user on the server.</span></span>

<span data-ttu-id="f9ca4-238">アプリの登録ワークフローは、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-238">The registration workflow of an app might look like the following:</span></span>

![Windows Hello の登録](images/secure-passport.png)

<span data-ttu-id="f9ca4-240">収集する登録情報には、この単純なシナリオよりも多くの識別情報が含まれる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-240">The registration information you collect may include a lot more identifying information than it does in this simple scenario.</span></span> <span data-ttu-id="f9ca4-241">たとえば、アプリが、バンキング用などのセキュリティで保護されたサービスにアクセスする場合、サインアップ プロセスの一部として ID やその他の項目の証明を要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-241">For example, if your app accesses a secured service such as one for banking, you’d need to request proof of identity and other things as part of the sign-up process.</span></span> <span data-ttu-id="f9ca4-242">すべての条件が満たされると、ユーザーの公開キーがバックエンドに保存され、次回ユーザーがサービスを利用するときの検証でこの公開キーが使われます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-242">Once all the conditions are met, the public key of this user will be stored in the back-end and used to validate the next time the user uses the service.</span></span>

<span data-ttu-id="f9ca4-243">Windows Hello について詳しくは、「[Windows Hello ガイド](https://msdn.microsoft.com/library/mt589441)」および「[Windows Hello 開発者向けガイド](microsoft-passport.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-243">For more information on Windows Hello, see the [Windows Hello guide](https://msdn.microsoft.com/library/mt589441) and the [Windows Hello developer guide](microsoft-passport.md).</span></span>

## <a name="3-data-in-flight-security-methods"></a><span data-ttu-id="f9ca4-244">3 移動中データに関するセキュリティ保護の方法</span><span class="sxs-lookup"><span data-stu-id="f9ca4-244">3 Data-in-flight security methods</span></span>


<span data-ttu-id="f9ca4-245">移動中データに関するセキュリティ保護の方法は、ネットワークに接続されているデバイス間でやり取りされるデータに適用されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-245">Data-in-flight security methods apply to data in transit between devices connected to a network.</span></span> <span data-ttu-id="f9ca4-246">データは、プライベートな社内イントラネットの高度なセキュリティ環境にあるシステムの間で転送される場合と、セキュリティで保護されていない Web 環境にあるクライアントと Web サービスの間で転送される場合があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-246">The data may be transferred between systems on the high-security environment of a private corporate intranet, or between a client and web service in the non-secure environment of the web.</span></span> <span data-ttu-id="f9ca4-247">Windows 10 アプリでは、ネットワーキング API を利用して SSL などの標準をサポートしており、Azure API 管理などのテクノロジとも連携します。これにより、開発者はアプリで適切なレベルのセキュリティを確保することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-247">Windows 10 apps support standards such as SSL through their networking APIs, and work with technologies such as Azure API Management with which developers can ensure the appropriate level of security for their apps.</span></span>

## <a name="31-remote-system-authentication"></a><span data-ttu-id="f9ca4-248">3.1 リモート システムの認証</span><span class="sxs-lookup"><span data-stu-id="f9ca4-248">3.1 Remote system authentication</span></span>


<span data-ttu-id="f9ca4-249">リモート コンピューター システムとの通信が発生する一般的なシナリオは、2 つあります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-249">There are two general scenarios where communication occurs with a remote computer system.</span></span>

-   <span data-ttu-id="f9ca4-250">ローカル サーバーで、直接接続を経由してユーザーを認証します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-250">A local server authenticates a user over a direct connection.</span></span> <span data-ttu-id="f9ca4-251">たとえば、サーバーとクライアントが社内イントラネット上に存在する場合などです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-251">For example, when the server and the client are on a corporate intranet.</span></span>
-   <span data-ttu-id="f9ca4-252">Web サービスとの通信はインターネット経由で行われます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-252">A web service is communicated with over the Internet.</span></span>

<span data-ttu-id="f9ca4-253">Web サービス通信では、データはもはやセキュリティで保護されたネットワークだけに含まれるのではなく、悪意のある攻撃者が検索してデータを傍受する可能性も高くなるので、Web サービス通信のセキュリティ要件は、直接接続のシナリオの場合よりも高くなります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-253">Security requirements for web service communication are higher than those in direct connection scenarios, as data is no longer only a part of a secure network and the likelihood of malicious attackers looking to intercept data is also higher.</span></span> <span data-ttu-id="f9ca4-254">さまざまな種類のデバイスがサービスにアクセスするため、たとえば WCF サービスではなく RESTful サービスとしてデバイスがビルドされる可能性があります。このため、認証およびサービスへの承認からも新しい課題が生まれます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-254">Because various types of devices will access the service, they will likely be built as RESTful services, as opposed to WCF, for instance, which means authentication and authorization to the service also introduces new challenges.</span></span> <span data-ttu-id="f9ca4-255">セキュリティで保護されたリモート システム通信の 2 つの要件について説明します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-255">We’ll discuss two requirements for secure remote system communication.</span></span>

<span data-ttu-id="f9ca4-256">第 1 の要件は、メッセージの機密性です。クライアントと Web サービス間で渡される情報 (ユーザーの ID やその他の個人情報など) は、転送中に第三者が読み取ることができない情報であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-256">The first requirement is message confidentiality: The information passed between the client and the web services (for example, the identity of the user and other personal information) must not be readable by third parties while in transit.</span></span> <span data-ttu-id="f9ca4-257">通常これは、メッセージ送信に使われる接続を暗号化したり、メッセージ自体を暗号化したりすることによって実現されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-257">This is usually accomplished by encrypting the connection over which messages are sent and by encrypting the message itself.</span></span> <span data-ttu-id="f9ca4-258">秘密キー/公開キーの暗号化では、公開キーはだれでも利用でき、公開キーを使って、特定の受信者に送信されるメッセージを暗号化します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-258">In private/public key encryption, the public key is available to anyone, and is used to encrypt messages to be sent to a specific receiver.</span></span> <span data-ttu-id="f9ca4-259">秘密キーは受信者のみが保持しており、秘密キーを使って、メッセージの暗号化を解除します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-259">The private key is only held by the receiver and is used to decrypt the message.</span></span>

<span data-ttu-id="f9ca4-260">第 2 の要件は、メッセージの整合性です。クライアントと Web サービスは、受信したメッセージが送信側によって送られたものであること、およびメッセージが転送中に改変されていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-260">The second requirement is message integrity: The client and the web service must be able to verify that the messages they receive are the ones intended to be sent by the other party, and that the message has not been altered in transit.</span></span> <span data-ttu-id="f9ca4-261">これは、デジタル署名を使ったメッセージへの署名と、証明書の認証の利用によって実現されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-261">This is accomplished by signing messages with digital signatures and using certificate authentication.</span></span>

## <a name="32-ssl-connections"></a><span data-ttu-id="f9ca4-262">3.2 SSL 接続</span><span class="sxs-lookup"><span data-stu-id="f9ca4-262">3.2 SSL connections</span></span>


<span data-ttu-id="f9ca4-263">セキュリティで保護された接続を確立し、維持するために、Web サービスでは、Secure Hypertext Transfer Protocol (HTTPS) によってサポートされている Secure Sockets Layer (SSL) を使うことができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-263">To establish and maintain secure connections to clients, web services can use Secure Sockets Layer (SSL), which is supported by the Secure Hypertext Transfer Protocol (HTTPS).</span></span> <span data-ttu-id="f9ca4-264">SSL では、公開キーの暗号化、およびサーバーの証明書をサポートすることによって、メッセージの機密性と整合性が実現されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-264">SSL provides message confidentiality and integrity by supporting public key encryption as well as server certificates.</span></span> <span data-ttu-id="f9ca4-265">トランスポート層セキュリティ (TLS) は SSL に取って代わるものですが、TLS は非公式に SSL と呼ばれることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-265">SSL is superseded by Transport Layer Security (TLS), but TLS is often casually referred to as SSL.</span></span>

<span data-ttu-id="f9ca4-266">クライアントがサーバーにあるリソースへのアクセスを要求すると、SSL はサーバーとのネゴシエーション プロセスを開始します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-266">When a client requests access to a resource on a server, SSL starts a negotiation process with the server.</span></span> <span data-ttu-id="f9ca4-267">これは、SSL ハンドシェイクと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-267">This is called an SSL handshake.</span></span> <span data-ttu-id="f9ca4-268">暗号化レベル、公開暗号化キーと秘密暗号化キーのセット、およびクライアントとサーバーの証明書に含まれている ID 情報が、SSL 接続が行われている間のすべての通信における基盤として認識されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-268">An encryption level, a set of public and private encryption keys, and the identity information in the client and server certificates are agreed upon as the basis of all communication for the duration of the SSL connection.</span></span> <span data-ttu-id="f9ca4-269">このとき、サーバーは、認証されるクライアントを要求する場合があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-269">The server may also require the client to be authenticated at this time.</span></span> <span data-ttu-id="f9ca4-270">接続が確立されると、接続が閉じられるまで、すべてのメッセージがネゴシエートされた公開キーで暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-270">Once the connection is established, all messages are encrypted with the negotiated public key until the connection closes.</span></span>

## <a name="321-ssl-pinning"></a><span data-ttu-id="f9ca4-271">3.2.1 SSL のピン留め</span><span class="sxs-lookup"><span data-stu-id="f9ca4-271">3.2.1 SSL pinning</span></span>


<span data-ttu-id="f9ca4-272">SSL では、暗号化と証明書を使ってメッセージの機密性を実現できますが、クライアントが通信しているサーバーが正しいサーバーであることを確認するための処理は行いません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-272">While SSL can provide message confidentiality using encryption and certificates, it does nothing to verify that the server with which the client is communicating is the correct one.</span></span> <span data-ttu-id="f9ca4-273">サーバーの動作は、承認されていない第三者によって模倣され、クライアントが転送した重要なデータが傍受される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-273">The server’s behavior can be mimicked by an unauthorized third-party, intercepting the sensitive data that the client transmits.</span></span> <span data-ttu-id="f9ca4-274">これを防ぐためには、SSL のピン留めと呼ばれる手法を使って、サーバー上の証明書がクライアントで想定され、信頼されている証明書であることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-274">To prevent this, a technique called SSL pinning is used to verify that the certificate on the server is the certificate that the client expects and trusts.</span></span>

<span data-ttu-id="f9ca4-275">アプリに SSL のピン留めを実装する方法はいくつかあります。それぞれの方法に長所と短所があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-275">There are a few different ways to implement SSL pinning in apps, each with their own pros and cons.</span></span> <span data-ttu-id="f9ca4-276">最も簡単な方法は、アプリのパッケージ マニフェストで証明書の宣言を利用する方法です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-276">The easiest approach is via the Certificates declaration in the app’s package manifest.</span></span> <span data-ttu-id="f9ca4-277">この宣言によって、アプリ パッケージはデジタル証明書をインストールし、それらの証明書に排他的信頼を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-277">This declaration enables the app package to install digital certificates and specify exclusive trust in them.</span></span> <span data-ttu-id="f9ca4-278">その結果、アプリと、対応する証明書が証明書チェーンにあるサーバーとの間だけで SSL 接続が許可されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-278">This results in SSL connections being allowed only between the app and servers that have the corresponding certificates in their certificate chain.</span></span> <span data-ttu-id="f9ca4-279">このメカニズムにより、信頼できる公共の証明機関に対するサード パーティの依存関係は不要になるので、セキュリティで保護された自己署名証明書の使用も可能になります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-279">This mechanism also enables the secure use of self-signed certificates, as no third party dependency is needed on trusted public certification authorities.</span></span>

![SSL マニフェスト](images/secure-ssl-manifest.png)

<span data-ttu-id="f9ca4-281">検証ロジックをより細かく制御したい場合は、API を利用して、HTTPS 要求に応じてサーバーから返される証明書を検証できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-281">For more control over the validation logic, APIs are available to validate the certificate(s) returned by the server in response to an HTTPS request.</span></span> <span data-ttu-id="f9ca4-282">この方法では、要求の送信と応答の確認が必要になることに注意してください。重要な情報を要求に含めて実際に送信する前に、この方法を検証方法として追加してください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-282">Note that this method requires sending a request and inspecting the response, so be sure to add this as a validation before actually sending sensitive information in a request.</span></span>

<span data-ttu-id="f9ca4-283">次の C# コードは、この SSL のピン留め方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-283">The following C# code illustrates this method of SSL pinning.</span></span> <span data-ttu-id="f9ca4-284">**ValidateSSLRoot** メソッドでは、[**HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) クラスを使って HTTP 要求を実行します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-284">The **ValidateSSLRoot** method uses the [**HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) class to execute an HTTP request.</span></span> <span data-ttu-id="f9ca4-285">クライアントが応答を送信した後で、クライアントは [**RequestMessage.TransportInformation.ServerIntermediateCertificates**](https://msdn.microsoft.com/library/windows/apps/dn279681) コレクションを使って、サーバーから返された証明書を調べます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-285">After the client sends the response, it uses the [**RequestMessage.TransportInformation.ServerIntermediateCertificates**](https://msdn.microsoft.com/library/windows/apps/dn279681) collection to inspect the certificates returned by the server.</span></span> <span data-ttu-id="f9ca4-286">その後で、クライアントは含まれている拇印を使って、証明書チェーン全体を検証することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-286">The client can then validate the entire certificate chain with the thumbprints it has included.</span></span> <span data-ttu-id="f9ca4-287">この方法では、サーバー証明書の有効期限が切れて新しい証明書に置き換わると、証明書の拇印がアプリで更新される必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-287">This method does require the certificate thumbprints to be updated in the app when the server certificate expires and is renewed.</span></span>

```cs
private async Task ValidateSSLRoot()
{
    // Send a get request to Bing
    var httpClient = new HttpClient();
    var bingUri = new Uri("https://www.bing.com");
    HttpResponseMessage response = 
        await httpClient.GetAsync(bingUri);

    // Get the list of certificates that were used to
    // validate the server's identity
    IReadOnlyList<Certificate> serverCertificates = response.RequestMessage.TransportInformation.ServerIntermediateCertificates;
  
    // Perform validation
    if (!ValidateCertificates(serverCertificates))
    {
        // Close connection as chain is not valid
        return;
    }
    // Validation passed, continue with connection to service
}

private bool ValidateCertificates(IReadOnlyList<Certificate> certs)
{
    // In this example, we iterate through the certificates
    // and check that the chain contains
    // one specific certificate we are expecting
    foreach (var cert in certs)
    {
        byte[] thumbprint = cert.GetHashValue();

        // Check if the thumbprint matches whatever you 
        // are expecting
        var expected = new byte[] { 212, 222, 32, 208, 94, 102, 
            252, 83, 254, 26, 80, 136, 44, 120, 219, 40, 82, 202, 
            228, 116 };

        // ThumbprintMatches does the byte[] comparison 
        if (ThumbprintMatches(thumbprint, expected))
        {
            return true;
        }
    }
    return false;
}
```

## <a name="33-publishing-and-securing-access-to-rest-apis"></a><span data-ttu-id="f9ca4-288">3.3 REST API の公開と REST API へのアクセスの保護</span><span class="sxs-lookup"><span data-stu-id="f9ca4-288">3.3 Publishing and securing access to REST APIs</span></span>


<span data-ttu-id="f9ca4-289">Web サービスへのアクセスの承認を確実に行うためには、API の呼び出しが行われるたびに認証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-289">To ensure authorized access to web services, they must require authentication every time an API call is made.</span></span> <span data-ttu-id="f9ca4-290">Web サービスが Web 経由で公開されている場合、パフォーマンスとスケールを制御できるようにすることも考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-290">Being able to control performance and scale is also something to consider when web services are exposed across the web.</span></span> <span data-ttu-id="f9ca4-291">Azure API Management は、API を Web に公開する場合に役立つサービスであり、3 つのレベルで機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-291">Azure API Management is a service that can help expose APIs across the web, while providing features on three levels.</span></span>

<span data-ttu-id="f9ca4-292">API の**発行者/管理者**は、Azure API Management の発行者ポータルを使って、簡単に API を構成できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-292">**Publishers/Administrators** of the API can easily configure the API through the Publisher Portal of Azure API Management.</span></span> <span data-ttu-id="f9ca4-293">ここでは、API のセットを作成でき、API へのアクセスを管理して、だれがどの API へアクセスできるかを制御できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-293">Here, API sets can be created and access to them can be managed to control who has access to which APIs.</span></span>

<span data-ttu-id="f9ca4-294">**開発者**は、これらの API にアクセスする必要がある場合、開発者ポータルを使って要求できます。開発者ポータルは、直ちにアクセスを提供するか、発行者/管理者による承認を要求します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-294">**Developers** wanting access to these APIs can make requests through the Developer Portal, which can either immediately provide access or require approval by the publisher/administrator.</span></span> <span data-ttu-id="f9ca4-295">開発者は、開発者ポータルで API ドキュメントとサンプル コードを参照し、Web サービスで提供されている API を迅速に採用することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-295">Developers can also view the API documentation and sample code in the Developer Portal, to rapidly adopt the APIs offered by the web service.</span></span>

<span data-ttu-id="f9ca4-296">これらの開発者が作成した**アプリ**は、Azure API Management に用意されているプロキシを経由して API にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-296">The **apps** that these developers create then access the API through the proxy offered by Azure API Management.</span></span> <span data-ttu-id="f9ca4-297">プロキシでは、不明瞭レイヤーによって発行者/管理者のサーバーにある API の実際のエンドポイントが隠蔽され、また API 変換などのロジックを追加して、API の呼び出しが別の API にリダイレクトされる場合に、公開されている API が一貫性を保つようにできます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-297">The proxy both provides a layer of obscurity, hiding the actual end-point of the API on the publisher/administrator’s server and can also include additional logic like API translation to ensure the exposed API is kept consistent when a call to one API is redirected to another.</span></span> <span data-ttu-id="f9ca4-298">また、IP フィルタリングを使って、特定の IP ドメインやドメインのセットで発生した API 呼び出しをブロックすることもできます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-298">It can also use IP filtering to block API calls originating from a specific IP domain or set of domains.</span></span> <span data-ttu-id="f9ca4-299">また、Azure App 管理では、各 API 呼び出しの認証と承認のために公開キーのセット (API キーと呼ばれます) を使って、Web サービスのセキュリティ保護を維持します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-299">Azure API Management also keeps its web services secure by using a set of public keys, called API keys, to authenticate and authorize each API call.</span></span> <span data-ttu-id="f9ca4-300">認証が失敗した場合、API へのアクセスや API がサポートする機能へのアクセスがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-300">When authorization fails, access to the API and the functionality it supports is blocked.</span></span>

<span data-ttu-id="f9ca4-301">Azure App 管理では、Web サービスのパフォーマンスを最適化するために、サービスでの API 呼び出しの回数を減らすこともできます (この手続きはスロットルと呼ばれます)。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-301">Azure API Management can also reduce the number of API calls to a service (a procedure called throttling) to optimizes the performance of the web service.</span></span> <span data-ttu-id="f9ca4-302">詳しくは、「[Azure API 管理](https://azure.microsoft.com/services/api-management/)」および「[AzureCon 2015 の Azure API 管理](https://channel9.msdn.com/events/Microsoft-Azure/AzureCon-2015/ACON313)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-302">To learn more, review [Azure API Management](https://azure.microsoft.com/services/api-management/) and [Azure API Management at AzureCon 2015.](https://channel9.msdn.com/events/Microsoft-Azure/AzureCon-2015/ACON313)</span></span>

## <a name="4-data-at-rest-security-methods"></a><span data-ttu-id="f9ca4-303">4 保存データに関するセキュリティ保護の方法</span><span class="sxs-lookup"><span data-stu-id="f9ca4-303">4 Data-at-rest security methods</span></span>


<span data-ttu-id="f9ca4-304">データがデバイスに到着すると、そのデータは "保存データ" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-304">When data arrives on a device, we refer to it as "data-at-rest."</span></span> <span data-ttu-id="f9ca4-305">このデータは、承認されていないユーザーやアプリからのアクセスを防ぐために、セキュリティ保護の方法に従ってデバイスに保存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-305">This data needs to be stored on the device in a secure manner, so that it cannot be accessed by unauthorized users or apps.</span></span> <span data-ttu-id="f9ca4-306">Windows 10 のアプリ モデルでは、アプリで保存されたデータはそのアプリによってのみアクセスできるようにして、必要な場合はデータを共有するための API を提供するように、さまざまな操作を行います。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-306">The app model in Windows 10 does a lot to ensure that the data stored by any app is only accessible to that app, while providing APIs to share the data when necessary.</span></span> <span data-ttu-id="f9ca4-307">また、追加の API を利用して、データを暗号化し、資格情報を安全に保存することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-307">Additional APIs are also available to ensure that data can be encrypted and credentials can be stored safely.</span></span>

## <a name="41-windows-app-model"></a><span data-ttu-id="f9ca4-308">4.1 Windows アプリ モデル</span><span class="sxs-lookup"><span data-stu-id="f9ca4-308">4.1 Windows app model</span></span>


<span data-ttu-id="f9ca4-309">従来、Windows はアプリの定義を備えていませんでした。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-309">Traditionally, Windows has never had a definition of an app.</span></span> <span data-ttu-id="f9ca4-310">一般的には、実行可能ファイル (.exe) がアプリの定義として扱われていましたが、インストール、状態の記憶、実行の長さ、バージョン管理、OS の統合、およびアプリ間通信は、定義には含まれていませんでした。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-310">It was most commonly referred to as an executable (.exe), and this never included installation, storage of state, execution length, versioning, OS integration, or app-to-app communication.</span></span> <span data-ttu-id="f9ca4-311">ユニバーサル Windows プラットフォーム モデルでは、インストール、ランタイム環境、リソース管理、更新プログラム、データ モデル、およびアンインストールを含めるように、アプリ モデルを定義します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-311">The Universal Windows Platform model defines an app model that covers installation, runtime environment, resource management, updates, data model, and uninstallation.</span></span>

<span data-ttu-id="f9ca4-312">Windows 10 アプリは、既定では (追加の特権を要求したり、ユーザーによって付与される) 特権を制限があることを意味します、コンテナー内で実行します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-312">Windows10 apps run in a container, which means that they have limited privileges by default (additional privileges can be requested and granted by the user).</span></span> <span data-ttu-id="f9ca4-313">たとえば、アプリがシステム上のファイルにアクセスする場合、[**Windows.Storage.Pickers**](https://msdn.microsoft.com/library/windows/apps/br207928) 名前空間のファイル ピッカーを使って、ユーザーにファイルを選ばせる必要があります (ファイルに直接アクセスすることはできません)。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-313">For example, if an app wants to access files on the system, a file picker from the [**Windows.Storage.Pickers**](https://msdn.microsoft.com/library/windows/apps/br207928) namespace has to be used to let the user pick a file (no direct access to files is enabled).</span></span> <span data-ttu-id="f9ca4-314">別の例としては、アプリがユーザーの位置情報データにアクセスする場合、位置デバイス機能を有効にして、このアプリがユーザーの位置情報へのアクセスを要求することをダウンロード時にユーザーに確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-314">Another example is if an app wants to access the user’s location data, it needs to enable the location device capability needs to be declared, prompting the user at download time that this app will request access to the user’s location.</span></span> <span data-ttu-id="f9ca4-315">さらに、アプリが初めてユーザーの位置情報にアクセスするとき、追加の同意のプロンプトがユーザーに示され、データへのアクセスの許可を要求します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-315">On top of that, the first time the app wants to access the user’s location, an additional consent prompt is shown to the user, requesting permission to access the data.</span></span>

<span data-ttu-id="f9ca4-316">このアプリ モデルは、アプリが外部と通信できない "刑務所" として機能しますが、外部から通信できない "城" ではないことに注意してください (もちろん管理者特権を持つアプリケーションは中に入れます)。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-316">Note that this app model acts as a "jail" for apps, meaning that they can’t reach out, but it is not a “castle” that cannot be reached from the outside (applications with administrator privileges can of course still reach in).</span></span> <span data-ttu-id="f9ca4-317">どの (Win32) アプリを実行できるかを組織/IT が指定することを可能にする、Windows 10 の Device Guard は、このアクセスをさらに制限するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-317">Device Guard in Windows 10, which enables organizations/IT to specify which (Win32) apps are allowed to execute, can further help limit this access.</span></span>

<span data-ttu-id="f9ca4-318">また、このアプリ モデルはアプリのライフ サイクルを管理します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-318">The app model also manages the app lifecycle.</span></span> <span data-ttu-id="f9ca4-319">これは、既定では、アプリのバックグラウンド実行を制限します。たとえば、アプリがバックグラウンドに移動するとすぐに、プロセスは中断され (コードのアプリ中断処理を行うための少しの時間をアプリに与えた後で)、メモリはフリーズされます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-319">It limits the background execution of apps by default, for example; as soon as an app goes into the background, the process is suspended – after giving the app a brief period to address app suspension in code – and its memory is frozen.</span></span> <span data-ttu-id="f9ca4-320">オペレーティング システムは、アプリが特定のバックグラウンド タスクの実行 (インターネット/Bluetooth 接続、電源の変更などのさまざまなイベントによってトリガーされるスケジュールに従って、また音楽再生、GPS 追跡などの特定のシナリオで) を要求するためのメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-320">The operating system does provide mechanisms for apps to ask for specific background task execution (on a schedule, triggered by various events such as Internet/Bluetooth connectivity, power changes, etc., and in specific scenarios such as music playing or GPS tracking).</span></span>

<span data-ttu-id="f9ca4-321">デバイスのメモリ リソースが不足している場合は、Windows はアプリを終了することによってメモリ領域を解放します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-321">When memory resources on the device are running low, Windows frees memory space by terminating apps.</span></span> <span data-ttu-id="f9ca4-322">このライフ サイクル モデルでは、アプリは中断時に必ずデータを保持します。これは、中断してから終了するまでの間、猶予時間が与えられないためです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-322">This lifecycle model forces apps to persist data whenever they’re suspended, because there is no additional time available between suspension and termination.</span></span>

<span data-ttu-id="f9ca4-323">詳しくは、「[ユニバーサル: Windows 10 のアプリケーションのライフ サイクルについて](https://visualstudiomagazine.com/articles/2015/09/01/its-universal.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-323">For more information, see [It's Universal: Understanding the Lifecycle of a Windows 10 Application](https://visualstudiomagazine.com/articles/2015/09/01/its-universal.aspx).</span></span>

## <a name="42-stored-credential-protection"></a><span data-ttu-id="f9ca4-324">4.2 保存された資格情報の保護</span><span class="sxs-lookup"><span data-stu-id="f9ca4-324">4.2 Stored credential protection</span></span>


<span data-ttu-id="f9ca4-325">多くの場合、認証済みのサービスにアクセスする Windows アプリでは、ユーザーは資格情報をローカル デバイスに保存することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-325">Windows apps that access authenticated services often provide the users the option of storing their credentials on the local device.</span></span> <span data-ttu-id="f9ca4-326">これは、ユーザーによって指定されたユーザー名とパスワードを、アプリが、次回以降の起動時に自動的に使う場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-326">This is a convenience for the users; when they provide their username and password, the app automatically uses them in subsequent launches of the app.</span></span> <span data-ttu-id="f9ca4-327">この機能は、保存されているデータへのアクセス許可を攻撃者が手に入れた場合に、セキュリティ上の問題となる可能性があります。このため、Windows 10 では、Windows アプリはユーザーの資格情報を安全な資格情報保管ボックスに保存することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-327">Because this can be a security issue if an attacker gains access to this stored data, Windows 10 provides the ability for Windows apps to store user credentials in a secure credential locker.</span></span> <span data-ttu-id="f9ca4-328">アプリは、アプリのストレージ コンテナーに資格情報を保存するのではなく、資格情報保管ボックス API を呼び出して、保管ボックスに対して資格情報の保存や取得を実行します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-328">The app calls the Credential Locker API to store and retrieve the credentials from the locker instead of storing them in the app’s storage container.</span></span> <span data-ttu-id="f9ca4-329">資格情報保管ボックスはオペレーティング システムによって管理されますが、アクセスは資格情報を保存したアプリに制限されます。これにより、資格情報の保存に関して、安全に管理されたソリューションが実現されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-329">The credential locker is managed by the operating system, but access is limited to the app that stores them, providing a securely managed solution for credential storage.</span></span>

<span data-ttu-id="f9ca4-330">保存する資格情報をユーザーが指定すると、アプリでは、[**Windows.Security.Credentials**](https://msdn.microsoft.com/library/windows/apps/br227089) 名前空間の [**PasswordVault**](https://msdn.microsoft.com/library/windows/apps/br227081) オブジェクトを使って、資格情報保管ボックスへの参照を取得します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-330">When a user supplies the credentials to be stored, the app gets a reference to the credential locker using the [**PasswordVault**](https://msdn.microsoft.com/library/windows/apps/br227081) object in the [**Windows.Security.Credentials**](https://msdn.microsoft.com/library/windows/apps/br227089) namespace.</span></span> <span data-ttu-id="f9ca4-331">次に、Windows アプリの識別子、およびユーザー名とパスワードが含まれている [**PasswordCredential**](https://msdn.microsoft.com/library/windows/apps/br227061) オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-331">It then creates a [**PasswordCredential**](https://msdn.microsoft.com/library/windows/apps/br227061) object containing an identifier for the Windows app and the username and password.</span></span> <span data-ttu-id="f9ca4-332">これが [**PasswordVault.Add**](https://msdn.microsoft.com/library/windows/apps/hh701231) メソッドに渡され、保管ボックスに資格情報が保存されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-332">This is passed to the [**PasswordVault.Add**](https://msdn.microsoft.com/library/windows/apps/hh701231) method to store the credentials in the locker.</span></span> <span data-ttu-id="f9ca4-333">次の C# コードの例は、これがどのように実行されるかを示しています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-333">The following C# code example shows how this is done.</span></span>

```cs
var vault = new PasswordVault();
vault.Add(new PasswordCredential("My App", username, password));
```

<span data-ttu-id="f9ca4-334">次の C# コードの例では、アプリは [**PasswordVault**](https://msdn.microsoft.com/library/windows/apps/br227081) オブジェクトの [**FindAllByResource**](https://msdn.microsoft.com/library/windows/apps/br227083) メソッドを呼び出して、アプリに対応するすべての資格情報を要求します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-334">In the following C# code example, the app requests all of the credentials corresponding to the app by calling the [**FindAllByResource**](https://msdn.microsoft.com/library/windows/apps/br227083) method of the [**PasswordVault**](https://msdn.microsoft.com/library/windows/apps/br227081) object.</span></span> <span data-ttu-id="f9ca4-335">複数の資格情報が返された場合、ユーザーは、ユーザー名の入力を求められます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-335">If more than one is returned, it prompts the user to enter their username.</span></span> <span data-ttu-id="f9ca4-336">保管ボックスに資格情報がない場合、アプリは、ユーザーに対して資格情報を指定するように要求します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-336">If the credentials are not in the locker, the app prompts the user for them.</span></span> <span data-ttu-id="f9ca4-337">ユーザーは、資格情報を使ってサーバーにログインします。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-337">The user is then logged into the server using the credentials.</span></span>

```cs
private string resourceName = "My App";
private string defaultUserName;

private void Login()
{
    PasswordCredential loginCredential = GetCredentialFromLocker();

    if (loginCredential != null)
    {
        // There is a credential stored in the locker.
        // Populate the Password property of the credential
        // for automatic login.
        loginCredential.RetrievePassword();
    }
    else
    {
        // There is no credential stored in the locker.
        // Display UI to get user credentials.
        loginCredential = GetLoginCredentialUI();
    }
    // Log the user in.
    ServerLogin(loginCredential.UserName, loginCredential.Password);
}

private PasswordCredential GetCredentialFromLocker()
{
    PasswordCredential credential = null;

    var vault = new PasswordVault();
    var credentialList = vault.FindAllByResource(resourceName);

    if (credentialList.Count == 1)
    {
        credential = credentialList[0];
    }
    else if (credentialList.Count > 0)
    {
        // When there are multiple usernames,
        // retrieve the default username. If one doesn't
        // exist, then display UI to have the user select
        // a default username.
        defaultUserName = GetDefaultUserNameUI();

        credential = vault.Retrieve(resourceName, defaultUserName);
    }
    return credential;
}
```

<span data-ttu-id="f9ca4-338">詳しくは、「[資格情報保管ボックス](credential-locker.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-338">For more information, see [Credential locker](credential-locker.md).</span></span>

## <a name="43-stored-data-protection"></a><span data-ttu-id="f9ca4-339">4.3 保存されたデータの保護</span><span class="sxs-lookup"><span data-stu-id="f9ca4-339">4.3 Stored data protection</span></span>


<span data-ttu-id="f9ca4-340">保存されたデータ (一般に "保存データ" と呼ばれます) を扱う場合、これを暗号化することによって、承認されていないユーザーは、保存されたデータにアクセスできなくなります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-340">When you are dealing with stored data, commonly referred to as data-at-rest, encrypting it can prevent unauthorized users from accessing the stored data.</span></span> <span data-ttu-id="f9ca4-341">データを暗号化する一般的なメカニズムには、対称キーを使う方法と非対称キーを使う方法の 2 つがあります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-341">The two common mechanisms to encrypt data are using either symmetric keys or using asymmetric keys.</span></span> <span data-ttu-id="f9ca4-342">ただし、データを暗号化しても、データが送信されて保存されるまでの間に、データの変更を防ぐことができるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-342">However, data encryption can’t ensure that the data is unaltered between the time it was sent and the time it was stored.</span></span> <span data-ttu-id="f9ca4-343">つまり、データの整合性を保証することはできません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-343">In other words, the data integrity cannot be ensured.</span></span> <span data-ttu-id="f9ca4-344">メッセージ認証コード、ハッシュ、デジタル署名を利用することが、この問題を解決するための一般的な手法です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-344">Using message authentication codes, hashes, and digital signing are common techniques to solve this problem.</span></span>

## <a name="431-data-encryption"></a><span data-ttu-id="f9ca4-345">4.3.1 データの暗号化</span><span class="sxs-lookup"><span data-stu-id="f9ca4-345">4.3.1 Data encryption</span></span>


<span data-ttu-id="f9ca4-346">対称暗号化では、送信者と受信者は同じキーを所持し、そのキーを使ってデータの暗号化と暗号化解除を行います。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-346">With symmetric encryption, both the sender and recipient have the same key and use it to both encrypt and decrypt the data.</span></span> <span data-ttu-id="f9ca4-347">この方法で重要となる点は、送信者と受信者の双方が把握しているキーを安全に共有することです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-347">The challenge with this approach is securely sharing the key so both parties are aware of it.</span></span>

<span data-ttu-id="f9ca4-348">このデータ保護の方法の 1 つとして、公開/秘密キー ペアを使う非対称暗号化があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-348">One answer to this is asymmetric encryption, in which a public/private key pair is used.</span></span> <span data-ttu-id="f9ca4-349">公開キーは、メッセージを暗号化するすべてのユーザーによって自由に共有されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-349">The public key is shared freely with anyone who wants to encrypt a message.</span></span> <span data-ttu-id="f9ca4-350">秘密キーは、常に秘密のまま保持され、データの受信者だけがこのキーを使ってデータの暗号化を解除できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-350">The private key is always kept secret so that only you can use it to decrypt the data.</span></span> <span data-ttu-id="f9ca4-351">公開キーを検出できるようにするための一般的な方法は、デジタル証明書 (単に証明書とも呼ばる場合もあります) を使うことです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-351">A common technique to allow for discovery of the public key is by using digital certificates, also simply referred to as certificates.</span></span> <span data-ttu-id="f9ca4-352">証明書には、ユーザーやサーバーに関する情報 (名前、発行者、メール アドレス、国など) に加えて公開キーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-352">The certificate holds information about the public key, in addition to information about the user or server such as the name, issuer, email address and country.</span></span>

<span data-ttu-id="f9ca4-353">Windows アプリの開発者は、[**SymmetricKeyAlgorithmProvider**](https://msdn.microsoft.com/library/windows/apps/br241537) クラスと [**AsymmetricKeyAlgorithmProvider**](https://msdn.microsoft.com/library/windows/apps/br241478) クラスを使って、UWP アプリに対称暗号化と非対称暗号化を実装することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-353">Windows app developers can use the [**SymmetricKeyAlgorithmProvider**](https://msdn.microsoft.com/library/windows/apps/br241537) and [**AsymmetricKeyAlgorithmProvider**](https://msdn.microsoft.com/library/windows/apps/br241478) classes to implement symmetric and asymmetric encryption in their UWP apps.</span></span> <span data-ttu-id="f9ca4-354">また、[**CryptographicEngine**](https://msdn.microsoft.com/library/windows/apps/br241490) クラスを使って、データの暗号化と暗号化解除、コンテンツへの署名、デジタル署名の確認を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-354">Additionally, the [**CryptographicEngine**](https://msdn.microsoft.com/library/windows/apps/br241490) class can be used to encrypt and decrypt data, sign content and verify digital signatures.</span></span> <span data-ttu-id="f9ca4-355">アプリでは、[**Windows.Security.Cryptography.DataProtection**](https://msdn.microsoft.com/library/windows/apps/br241585) 名前空間の [**DataProtectionProvider**](https://msdn.microsoft.com/library/windows/apps/br241559) クラスを使って、保存されているローカル データの暗号化と暗号化解除を実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-355">Apps can also use the [**DataProtectionProvider**](https://msdn.microsoft.com/library/windows/apps/br241559) class in the [**Windows.Security.Cryptography.DataProtection**](https://msdn.microsoft.com/library/windows/apps/br241585) namespace to encrypt and decrypt stored local data.</span></span>

## <a name="432-detecting-message-tampering-macs-hashes-and-signatures"></a><span data-ttu-id="f9ca4-356">4.3.2 メッセージの改ざんの検出 (Mac、ハッシュ、署名)</span><span class="sxs-lookup"><span data-stu-id="f9ca4-356">4.3.2 Detecting message tampering (MACs, hashes, and signatures)</span></span>


<span data-ttu-id="f9ca4-357">MAC は、対称キー (秘密鍵と呼ばれます) やメッセージを MAC 暗号化アルゴリズムへの入力として使った結果生成されるコード (またはタグ) です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-357">A MAC is a code (or tag) that results from using a symmetric key (called the secret key) or a message as input to a MAC encryption algorithm.</span></span> <span data-ttu-id="f9ca4-358">秘密鍵とアルゴリズムは、メッセージを転送する前に、送信者と受信者の間で合意されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-358">The secret key and the algorithm are agreed upon by the sender and receiver before the message transfer.</span></span>

<span data-ttu-id="f9ca4-359">MAC では、次のようにしてメッセージを確認します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-359">MACs verify messages like this.</span></span>

-   <span data-ttu-id="f9ca4-360">送信者は、秘密鍵を MAC アルゴリズムへの入力として使うことで、MAC タグを取得します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-360">The sender derives the MAC tag by using the secret key as input to the MAC algorithm.</span></span>
-   <span data-ttu-id="f9ca4-361">送信者は、MAC タグとメッセージを受信者に送信します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-361">The sender sends the MAC tag and the message to the receiver.</span></span>
-   <span data-ttu-id="f9ca4-362">受信者は、秘密鍵とメッセージを MAC アルゴリズムへの入力として使うことで、MAC タグを取得します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-362">The receiver derives the MAC tag by using the secret key and the message as inputs to the MAC algorithm.</span></span>
-   <span data-ttu-id="f9ca4-363">受信者は、取得した MAC タグと送信者の MAC タグを比較します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-363">The receiver compares their MAC tag with the sender's MAC tag.</span></span> <span data-ttu-id="f9ca4-364">これらが同じである場合、メッセージは改ざんされていないと見なされます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-364">If they are the same then we know that the message has not been tampered with.</span></span>

![MAC による検証](images/secure-macs.png)

<span data-ttu-id="f9ca4-366">Windows アプリでは、[**MacAlgorithmProvider**](https://msdn.microsoft.com/library/windows/apps/br241530) クラスを呼び出して、MAC 暗号化アルゴリズムを実行するためのキーと [**CryptographicEngine**](https://msdn.microsoft.com/library/windows/apps/br241490) クラスを生成することにより、MAC によるメッセージの検証を実装できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-366">Windows apps can implement MAC message verification by calling the [**MacAlgorithmProvider**](https://msdn.microsoft.com/library/windows/apps/br241530) class to generate the key and [**CryptographicEngine**](https://msdn.microsoft.com/library/windows/apps/br241490) class to perform the MAC encryption algorithm.</span></span>

## <a name="433-using-hashes"></a><span data-ttu-id="f9ca4-367">4.3.3 ハッシュの使用</span><span class="sxs-lookup"><span data-stu-id="f9ca4-367">4.3.3 Using hashes</span></span>


<span data-ttu-id="f9ca4-368">ハッシュ関数は、任意の長さのデータ ブロックを受け取り、固定ビット サイズの文字列 (ハッシュ値) を返す暗号アルゴリズムです。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-368">A hash function is a cryptographic algorithm that takes an arbitrarily long block of data and returns a fixed-size bit string called a hash value.</span></span> <span data-ttu-id="f9ca4-369">この処理を実行できるハッシュ関数のファミリはすべて用意されています。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-369">There is an entire family of hash functions that can do this.</span></span>

<span data-ttu-id="f9ca4-370">上記のメッセージ転送シナリオでは、MAC の代わりにハッシュ値を使うことができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-370">A hash value can be used in place of a MAC in the message-transfer scenario above.</span></span> <span data-ttu-id="f9ca4-371">送信者はハッシュ値とメッセージを送信し、受信者は、受信者独自のハッシュ値を送信者のハッシュ値とメッセージから取得して、2 つのハッシュ値を比較します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-371">The sender sends a hash value and a message, and the receiver derives their own hash value from the sender's hash value and message and compares the two hash values.</span></span> <span data-ttu-id="f9ca4-372">Windows 10 で実行されているアプリでは、[**HashAlgorithmProvider**](https://msdn.microsoft.com/library/windows/apps/br241511) クラスを呼び出して、利用可能なハッシュ アルゴリズムを列挙し、それらのアルゴリズムのいずれかを実行できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-372">Apps running on Windows 10 can call the [**HashAlgorithmProvider**](https://msdn.microsoft.com/library/windows/apps/br241511) class to enumerate the hash algorithms that are available and run one of them.</span></span> <span data-ttu-id="f9ca4-373">[**CryptographicHash**](https://msdn.microsoft.com/library/windows/apps/br241498) クラスは、ハッシュ値を表します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-373">The [**CryptographicHash**](https://msdn.microsoft.com/library/windows/apps/br241498) class represents the hash value.</span></span> <span data-ttu-id="f9ca4-374">[**CryptographicHash.GetValueAndReset**](https://msdn.microsoft.com/library/windows/apps/hh701376) メソッドを使うと、メソッドを使用するたびにオブジェクトを作成しなくても、異なるデータを繰り返しハッシュできます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-374">The [**CryptographicHash.GetValueAndReset**](https://msdn.microsoft.com/library/windows/apps/hh701376) method can be used to repeatedly hash different data without having to re-create the object for each use.</span></span> <span data-ttu-id="f9ca4-375">**CryptographicHash** クラスの Append メソッドは、ハッシュ対象のバッファーに新しいデータを追加します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-375">The Append method of the **CryptographicHash** class adds new data to a buffer to be hashed.</span></span> <span data-ttu-id="f9ca4-376">この処理全体を次の C# コードの例に示します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-376">This entire process is shown in the following C# code example.</span></span>

```cs
public void SampleReusableHash()
{
    // Create a string that contains the name of the
    // hashing algorithm to use.
    string strAlgName = HashAlgorithmNames.Sha512;

    // Create a HashAlgorithmProvider object.
    HashAlgorithmProvider objAlgProv = HashAlgorithmProvider.OpenAlgorithm(strAlgName);

    // Create a CryptographicHash object. This object can be reused to continually
    // hash new messages.
    CryptographicHash objHash = objAlgProv.CreateHash();

    // Hash message 1.
    string strMsg1 = "This is message 1";
    IBuffer buffMsg1 = CryptographicBuffer.ConvertStringToBinary(strMsg1, BinaryStringEncoding.Utf16BE);
    objHash.Append(buffMsg1);
    IBuffer buffHash1 = objHash.GetValueAndReset();

    // Hash message 2.
    string strMsg2 = "This is message 2";
    IBuffer buffMsg2 = CryptographicBuffer.ConvertStringToBinary(strMsg2, BinaryStringEncoding.Utf16BE);
    objHash.Append(buffMsg2);
    IBuffer buffHash2 = objHash.GetValueAndReset();

    // Convert the hashes to string values (for display);
    string strHash1 = CryptographicBuffer.EncodeToBase64String(buffHash1);
    string strHash2 = CryptographicBuffer.EncodeToBase64String(buffHash2);
}
```

## <a name="434-digital-signatures"></a><span data-ttu-id="f9ca4-377">4.3.4 デジタル署名</span><span class="sxs-lookup"><span data-stu-id="f9ca4-377">4.3.4 Digital signatures</span></span>


<span data-ttu-id="f9ca4-378">保存されているメッセージがデジタル署名されている場合、そのメッセージに関するデータの整合性は、MAC による認証と同様の方法で検証されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-378">The data integrity of a digitally signed stored message is verified in a similar way to MAC authentication.</span></span> <span data-ttu-id="f9ca4-379">デジタル署名のワークフローがどのように実施されるかを次に示します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-379">Here is the way the digital signature workflow operates.</span></span>

-   <span data-ttu-id="f9ca4-380">送信者は、メッセージをハッシュ アルゴリズムへの入力として使って、ハッシュ値 (ダイジェストとも呼ばれます) を取得します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-380">The sender derives a hash value (also known as a digest) by using the message as the input to a hash algorithm.</span></span>
-   <span data-ttu-id="f9ca4-381">送信者は、秘密キーを使ってダイジェストを暗号化します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-381">The sender encrypts the digest using their private key.</span></span>
-   <span data-ttu-id="f9ca4-382">送信者は、メッセージ、暗号化されたダイジェスト、使われたハッシュ アルゴリズムの名前を送信します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-382">The sender sends the message, the encrypted digest, and the name of the hash algorithm that was used.</span></span>
-   <span data-ttu-id="f9ca4-383">受信者は、公開キーを使って、受信したダイジェスト (暗号化されたダイジェスト) の暗号化を解除します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-383">The receiver uses the public key to decrypt the encrypted digest it received.</span></span> <span data-ttu-id="f9ca4-384">次に、ハッシュ アルゴリズムを使ってメッセージをハッシュし、独自のダイジェストを作成します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-384">It then uses the hash algorithm to hash the message to create a digest of its own.</span></span> <span data-ttu-id="f9ca4-385">最後に、受信者は 2 つのダイジェストを比較します (受信し暗号化を解除したダイジェストと、作成したダイジェスト)。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-385">And finally the receiver compares the two digests (the one it received and decrypted, and the one it made).</span></span> <span data-ttu-id="f9ca4-386">2 つのダイジェストが一致した場合にのみ、受信者は、メッセージが秘密キーの所有者から送信されたものであることを確信できます。これにより、メッセージが実際にその送信者からのものであり、メッセージが転送中に変更されていないことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-386">Only if the two match can the receiver be sure that the message was sent by the possessor of the private key, and therefore they are who they say they are, and that the message was not altered in transit.</span></span>

![デジタル署名](images/secure-digital-signatures.png)

<span data-ttu-id="f9ca4-388">ハッシュ アルゴリズムは非常に高速であるため、サイズの大きいメッセージからでも、ハッシュ値をすばやく取得できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-388">Hashing algorithms are very fast, so hash values can be derived quickly from even large messages.</span></span> <span data-ttu-id="f9ca4-389">生成されたハッシュ値は任意の長さになりますが、メッセージ全体よりも短くなります。このため、公開キーと秘密キーを使ってメッセージ全体ではなくダイジェストのみを暗号化および暗号化解除する方法が最適な方法です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-389">The resulting hash value is an arbitrary length and can be shorter than the full message, so using public and private keys to encrypt and decrypt only the digest rather than the full message is an optimization.</span></span>

<span data-ttu-id="f9ca4-390">詳しくは、「[デジタル署名](https://msdn.microsoft.com/library/windows/desktop/aa381977)」、「[MAC、ハッシュ、および署名](macs-hashes-and-signatures.md)」、および「[暗号化](cryptography.md)」の記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-390">For more information, take a look articles on [Digital signatures](https://msdn.microsoft.com/library/windows/desktop/aa381977), [MACs, hashes, and signatures](macs-hashes-and-signatures.md), and [Cryptography.](cryptography.md)</span></span>

## <a name="5-summary"></a><span data-ttu-id="f9ca4-391">5 まとめ</span><span class="sxs-lookup"><span data-stu-id="f9ca4-391">5 Summary</span></span>


<span data-ttu-id="f9ca4-392">Windows 10 のユニバーサル Windows プラットフォームには、オペレーティング システムの機能を活用してより安全なアプリを作成する方法が数多くあります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-392">The Universal Windows Platform in Windows 10 offers a number of ways to leverage operating system capabilities to create more secure apps.</span></span> <span data-ttu-id="f9ca4-393">単一要素、多要素、または OAuth ID プロバイダーを利用する仲介の認証などさまざまな認証シナリオで、最も一般的な認証問題を軽減する API があります。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-393">In different authentication scenarios, such as single-factor, multi-factor, or brokered authentication with an OAuth identity provider, APIs exist to mitigate the most common challenges with authentication.</span></span> <span data-ttu-id="f9ca4-394">Windows Hello によって、ユーザーを認識する新しい生体認証サインイン システムが提供されます。また、Windows Hello を使うことで、正しい ID を意図的に回避するような操作をアクティブに阻止することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-394">Windows Hello provides a new biometric sign-in system that recognizes the user and actively defeats efforts to circumvent proper identification.</span></span> <span data-ttu-id="f9ca4-395">さらに、キーと証明書に関する複数の層も提供されます。これらの層は、トラステッド プラットフォーム モジュールの外部で公開されたり、使われたりすることは決してありません。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-395">It also delivers multiple layers of keys and certificates that can never be revealed or used outside the trusted platform module.</span></span> <span data-ttu-id="f9ca4-396">また、より詳細なセキュリティ レイヤーを、オプションである構成証明識別キーや証明書の利用時に使うことができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-396">Plus, a further layer of security is available through the optional use of attestation identity keys and certificates.</span></span>

<span data-ttu-id="f9ca4-397">移動中データの安全性を確保するには、SSL 経由で安全にリモート システムと通信し、SSL のピン留めを使用してサーバーの信頼性を検証することができる API が利用できます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-397">To secure data in flight, APIs exist to communicate with remote systems securely over SSL, while providing the possibility to validate the server’s authenticity with SSL pinning.</span></span> <span data-ttu-id="f9ca4-398">安全かつ制御された方法で API を発行することに関しては、Azure API 管理が、API のエンドポイントを不明瞭化する機能が加わったプロキシを使用して、Web 経由での API 公開用の強力な構成オプションを提供することにより支援します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-398">Publishing APIs securely and in a controlled manner is something in which Azure API Management aids by providing powerful configuration options for exposing APIs across the web using a proxy that provides additional obfuscation of the API endpoint.</span></span> <span data-ttu-id="f9ca4-399">これらの API へのアクセスは API キーを使用することによりセキュリティが確保され、パフォーマンスを制御するために API の呼び出しを抑制することが可能です。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-399">Access to these APIs is secured by using API keys and API calls can be throttled to control performance.</span></span>

<span data-ttu-id="f9ca4-400">データがデバイスに到着すると、Windows アプリ モデルは、アプリがインストール、更新される方法、およびデバイスのデータにアクセスする方法をより細かく制御し、アプリが他のアプリのデータに承認されていない方法でアクセスするのを防止します。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-400">When the data arrives on the device, the Windows app model provides more control over how the app is installed, updated and accesses it data, while keeping it from accessing data of other apps in an unauthorized manner.</span></span> <span data-ttu-id="f9ca4-401">資格情報保管ボックスを利用することで、ユーザーの資格情報の保存用に、オペレーティング システムによって管理されるセキュリティで保護された記憶域を使用し、ユニバーサル Windows プラットフォームが提供する暗号化およびハッシュ化する API を使うことによって他のデータをデバイス上で保護することができます。</span><span class="sxs-lookup"><span data-stu-id="f9ca4-401">Credential locker can provide secure storage of user credentials that is managed by the operating system and other data can be protected on the device by using the encryption and hashing APIs offered by the Universal Windows Platform.</span></span>

## <a name="6-resources"></a><span data-ttu-id="f9ca4-402">6 リソース</span><span class="sxs-lookup"><span data-stu-id="f9ca4-402">6 Resources</span></span>


### <a name="61-how-to-articles"></a><span data-ttu-id="f9ca4-403">6.1 ハウツー記事</span><span class="sxs-lookup"><span data-stu-id="f9ca4-403">6.1 How-to articles</span></span>

-   [<span data-ttu-id="f9ca4-404">認証とユーザー ID</span><span class="sxs-lookup"><span data-stu-id="f9ca4-404">Authentication and user identity</span></span>](authentication-and-user-identity.md)
-   [<span data-ttu-id="f9ca4-405">Windows Hello</span><span class="sxs-lookup"><span data-stu-id="f9ca4-405">Windows Hello</span></span>](microsoft-passport.md)
-   [<span data-ttu-id="f9ca4-406">資格情報保管ボックス</span><span class="sxs-lookup"><span data-stu-id="f9ca4-406">Credential locker</span></span>](credential-locker.md)
-   [<span data-ttu-id="f9ca4-407">Web 認証ブローカー</span><span class="sxs-lookup"><span data-stu-id="f9ca4-407">Web authentication broker</span></span>](web-authentication-broker.md)
-   [<span data-ttu-id="f9ca4-408">指紋生体認証</span><span class="sxs-lookup"><span data-stu-id="f9ca4-408">Fingerprint biometrics</span></span>](fingerprint-biometrics.md)
-   [<span data-ttu-id="f9ca4-409">スマート カード</span><span class="sxs-lookup"><span data-stu-id="f9ca4-409">Smart cards</span></span>](smart-cards.md)
-   [<span data-ttu-id="f9ca4-410">共有証明書</span><span class="sxs-lookup"><span data-stu-id="f9ca4-410">Shared certificates</span></span>](share-certificates.md)
-   [<span data-ttu-id="f9ca4-411">暗号化</span><span class="sxs-lookup"><span data-stu-id="f9ca4-411">Cryptography</span></span>](cryptography.md)
-   [<span data-ttu-id="f9ca4-412">証明書</span><span class="sxs-lookup"><span data-stu-id="f9ca4-412">Certificates</span></span>](certificates.md)
-   [<span data-ttu-id="f9ca4-413">暗号化キー</span><span class="sxs-lookup"><span data-stu-id="f9ca4-413">Cryptographic keys</span></span>](cryptographic-keys.md)
-   [<span data-ttu-id="f9ca4-414">データ保護</span><span class="sxs-lookup"><span data-stu-id="f9ca4-414">Data protection</span></span>](data-protection.md)
-   [<span data-ttu-id="f9ca4-415">MAC、ハッシュ、および署名</span><span class="sxs-lookup"><span data-stu-id="f9ca4-415">MACs, hashes, and signatures</span></span>](macs-hashes-and-signatures.md)
-   [<span data-ttu-id="f9ca4-416">暗号化に関する輸出制限の順守</span><span class="sxs-lookup"><span data-stu-id="f9ca4-416">Export restrictions on cryptography</span></span>](export-restrictions-on-cryptography.md)
-   [<span data-ttu-id="f9ca4-417">一般的な暗号化タスク</span><span class="sxs-lookup"><span data-stu-id="f9ca4-417">Common cryptography tasks</span></span>](common-cryptography-tasks.md)

### <a name="62-code-samples"></a><span data-ttu-id="f9ca4-418">6.2 コード サンプル</span><span class="sxs-lookup"><span data-stu-id="f9ca4-418">6.2 Code samples</span></span>

-   [<span data-ttu-id="f9ca4-419">資格情報保管ボックス</span><span class="sxs-lookup"><span data-stu-id="f9ca4-419">Credential locker</span></span>](https://github.com/Microsoft/Windows-universal-samples/blob/master/Samples/PasswordVault)
-   [<span data-ttu-id="f9ca4-420">資格情報ピッカー</span><span class="sxs-lookup"><span data-stu-id="f9ca4-420">Credential picker</span></span>](https://github.com/Microsoft/Windows-universal-samples/blob/master/Samples/CredentialPicker)
-   [<span data-ttu-id="f9ca4-421">Azure ログインによるデバイスのロックダウン</span><span class="sxs-lookup"><span data-stu-id="f9ca4-421">Device lockdown with Azure login</span></span>](https://github.com/Microsoft/Windows-universal-samples/blob/master/Samples/DeviceLockdownAzureLogin)
-   [<span data-ttu-id="f9ca4-422">エンタープライズ データ保護</span><span class="sxs-lookup"><span data-stu-id="f9ca4-422">Enterprise data protection</span></span>](https://github.com/Microsoft/Windows-universal-samples/blob/master/Samples/EnterpriseDataProtection)
-   [<span data-ttu-id="f9ca4-423">KeyCredentialManager</span><span class="sxs-lookup"><span data-stu-id="f9ca4-423">KeyCredentialManager</span></span>](https://github.com/Microsoft/Windows-universal-samples/blob/master/Samples/KeyCredentialManager)
-   [<span data-ttu-id="f9ca4-424">スマート カード</span><span class="sxs-lookup"><span data-stu-id="f9ca4-424">Smart cards</span></span>](https://github.com/Microsoft/Windows-universal-samples/blob/master/Samples/SmartCard)
-   [<span data-ttu-id="f9ca4-425">Web アカウント管理</span><span class="sxs-lookup"><span data-stu-id="f9ca4-425">Web account management</span></span>](https://github.com/Microsoft/Windows-universal-samples/blob/master/Samples/WebAccountManagement)
-   [<span data-ttu-id="f9ca4-426">WebAuthenticationBroker</span><span class="sxs-lookup"><span data-stu-id="f9ca4-426">WebAuthenticationBroker</span></span>](https://github.com/Microsoft/Windows-universal-samples/blob/master/Samples/WebAuthenticationBroker)

### <a name="63-api-reference"></a><span data-ttu-id="f9ca4-427">6.3 API リファレンス</span><span class="sxs-lookup"><span data-stu-id="f9ca4-427">6.3 API reference</span></span>

-   [**<span data-ttu-id="f9ca4-428">Windows.Security.Authentication.OnlineId</span><span class="sxs-lookup"><span data-stu-id="f9ca4-428">Windows.Security.Authentication.OnlineId</span></span>**](https://msdn.microsoft.com/library/windows/apps/hh701371)
-   [**<span data-ttu-id="f9ca4-429">Windows.Security.Authentication.Web</span><span class="sxs-lookup"><span data-stu-id="f9ca4-429">Windows.Security.Authentication.Web</span></span>**](https://msdn.microsoft.com/library/windows/apps/br227044)
-   [**<span data-ttu-id="f9ca4-430">Windows.Security.Authentication.Web.Core</span><span class="sxs-lookup"><span data-stu-id="f9ca4-430">Windows.Security.Authentication.Web.Core</span></span>**](https://msdn.microsoft.com/library/windows/apps/dn921967)
-   [**<span data-ttu-id="f9ca4-431">Windows.Security.Authentication.Web.Provider</span><span class="sxs-lookup"><span data-stu-id="f9ca4-431">Windows.Security.Authentication.Web.Provider</span></span>**](https://msdn.microsoft.com/library/windows/apps/dn921965)
-   [**<span data-ttu-id="f9ca4-432">Windows.Security.Credentials</span><span class="sxs-lookup"><span data-stu-id="f9ca4-432">Windows.Security.Credentials</span></span>**](https://msdn.microsoft.com/library/windows/apps/br227089)
-   [**<span data-ttu-id="f9ca4-433">Windows.Security.Credentials</span><span class="sxs-lookup"><span data-stu-id="f9ca4-433">Windows.Security.Credentials</span></span>**](https://msdn.microsoft.com/library/windows/apps/br227089)
-   [**<span data-ttu-id="f9ca4-434">Windows.Security.Credentials.UI</span><span class="sxs-lookup"><span data-stu-id="f9ca4-434">Windows.Security.Credentials.UI</span></span>**](https://msdn.microsoft.com/library/windows/apps/hh701356)
-   [**<span data-ttu-id="f9ca4-435">Windows.Security.Cryptography</span><span class="sxs-lookup"><span data-stu-id="f9ca4-435">Windows.Security.Cryptography</span></span>**](https://msdn.microsoft.com/library/windows/apps/br241404)
-   [**<span data-ttu-id="f9ca4-436">Windows.Security.Cryptography.Certificates</span><span class="sxs-lookup"><span data-stu-id="f9ca4-436">Windows.Security.Cryptography.Certificates</span></span>**](https://msdn.microsoft.com/library/windows/apps/br241476)
-   [**<span data-ttu-id="f9ca4-437">Windows.Security.Cryptography.Core</span><span class="sxs-lookup"><span data-stu-id="f9ca4-437">Windows.Security.Cryptography.Core</span></span>**](https://msdn.microsoft.com/library/windows/apps/br241547)
-   [**<span data-ttu-id="f9ca4-438">Windows.Security.Cryptography.DataProtection</span><span class="sxs-lookup"><span data-stu-id="f9ca4-438">Windows.Security.Cryptography.DataProtection</span></span>**](https://msdn.microsoft.com/library/windows/apps/br241585)
-   [**<span data-ttu-id="f9ca4-439">Windows.Security.ExchangeActiveSyncProvisioning</span><span class="sxs-lookup"><span data-stu-id="f9ca4-439">Windows.Security.ExchangeActiveSyncProvisioning</span></span>**](https://msdn.microsoft.com/library/windows/apps/hh701506)
-   [**<span data-ttu-id="f9ca4-440">Windows.Security.EnterpriseData</span><span class="sxs-lookup"><span data-stu-id="f9ca4-440">Windows.Security.EnterpriseData</span></span>**](https://msdn.microsoft.com/library/windows/apps/dn279153)
