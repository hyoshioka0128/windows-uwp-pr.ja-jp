---
ms.assetid: 3A477380-EAC5-44E7-8E0F-18346CC0C92F
title: ListView と GridView のデータ仮想化
description: データ仮想化によって ListView と GridView のパフォーマンスと起動時間を向上させます。
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 6d53ab5949972c3f58e2c4db27b76fa720fd4b95
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/29/2019
ms.locfileid: "66359935"
---
# <a name="listview-and-gridview-data-virtualization"></a><span data-ttu-id="414ac-104">ListView と GridView のデータ仮想化</span><span class="sxs-lookup"><span data-stu-id="414ac-104">ListView and GridView data virtualization</span></span>


<span data-ttu-id="414ac-105">**注**  詳細については、「//build/ セッション[が大幅に向上パフォーマンスのユーザー大きな GridView と ListView にデータの量と対話する際に](https://channel9.msdn.com/Events/Build/2013/3-158)します。</span><span class="sxs-lookup"><span data-stu-id="414ac-105">**Note**  For more details, see the //build/ session [Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView](https://channel9.msdn.com/Events/Build/2013/3-158).</span></span>

<span data-ttu-id="414ac-106">データ仮想化によって [**ListView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView) と [**GridView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.GridView) のパフォーマンスと起動時間を向上させます。</span><span class="sxs-lookup"><span data-stu-id="414ac-106">Improve [**ListView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView) and [**GridView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.GridView) performance and startup time through data virtualization.</span></span> <span data-ttu-id="414ac-107">UI の仮想化、要素の削減、項目の段階的な更新については、「[ListView と GridView の UI の最適化](optimize-gridview-and-listview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="414ac-107">For UI virtualization, element reduction, and progressive updating of items, see [ListView and GridView UI optimization](optimize-gridview-and-listview.md).</span></span>

<span data-ttu-id="414ac-108">データ仮想化のメソッドは、大きすぎてメモリに一度に格納できないか、すべてを格納する必要がないデータ セットで必要です。</span><span class="sxs-lookup"><span data-stu-id="414ac-108">A method of data virtualization is needed for a data set that is so large that it cannot or should not all be stored in memory at one time.</span></span> <span data-ttu-id="414ac-109">最初の部分を (ローカル ディスク、ネットワーク、またはクラウドから) メモリに読み込んで、その部分的なデータ セットに UI の仮想化を適用します。</span><span class="sxs-lookup"><span data-stu-id="414ac-109">You load an initial portion into memory (from local disk, network, or cloud) and apply UI virtualization to this partial data set.</span></span> <span data-ttu-id="414ac-110">データは、後から段階的に読み込むことも、マスター データ セット内の任意の位置からオンデマンドで読み込むこともできます (ランダム アクセス)。</span><span class="sxs-lookup"><span data-stu-id="414ac-110">You can later load data incrementally, or from arbitrary points in the master data set (random access), on demand.</span></span> <span data-ttu-id="414ac-111">データ仮想化が適しているかどうかは、多数の要因によって決まります。</span><span class="sxs-lookup"><span data-stu-id="414ac-111">Whether data virtualization is appropriate for you depends on many factors.</span></span>

-   <span data-ttu-id="414ac-112">データ セットのサイズ</span><span class="sxs-lookup"><span data-stu-id="414ac-112">The size of your data set</span></span>
-   <span data-ttu-id="414ac-113">各項目のサイズ</span><span class="sxs-lookup"><span data-stu-id="414ac-113">The size of each item</span></span>
-   <span data-ttu-id="414ac-114">データ セットのソース (ローカル ディスク、ネットワーク、またはクラウド)</span><span class="sxs-lookup"><span data-stu-id="414ac-114">The source of the data set (local disk, network, or cloud)</span></span>
-   <span data-ttu-id="414ac-115">アプリの総合的なメモリ消費量</span><span class="sxs-lookup"><span data-stu-id="414ac-115">The overall memory consumption of your app</span></span>

<span data-ttu-id="414ac-116">**注**  ListView および GridView、ユーザーはパン スクロール迅速に一時的なプレース ホルダーのビジュアルを表示する、既定で、機能が有効になっていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="414ac-116">**Note**  Be aware that a feature is enabled by default for ListView and GridView that displays temporary placeholder visuals while the user is panning/scrolling quickly.</span></span> <span data-ttu-id="414ac-117">これらのプレース ホルダーの視覚効果は、データが読み込まれると項目テンプレートに置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="414ac-117">As data is loaded, these placeholder visuals are replaced with your item template.</span></span> <span data-ttu-id="414ac-118">この機能は、[**ListViewBase.ShowsScrollingPlaceholders**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.showsscrollingplaceholders) を false に設定することによって無効にできますが、その場合は、x:Phase 属性を使って項目テンプレートの要素を段階的にレンダリングすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="414ac-118">You can turn the feature off by setting [**ListViewBase.ShowsScrollingPlaceholders**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.showsscrollingplaceholders) to false, but if you do so then we recommend that you use the x:Phase attribute to progressively render the elements in your item template.</span></span> <span data-ttu-id="414ac-119">詳しくは、「[GridView と ListView の項目を段階的に更新する](optimize-gridview-and-listview.md#update-items-incrementally)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="414ac-119">See [Update ListView and GridView items progressively](optimize-gridview-and-listview.md#update-items-incrementally).</span></span>

<span data-ttu-id="414ac-120">以降では、段階的なデータ仮想化とランダム アクセスのデータ仮想化の手法について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="414ac-120">Here are more details about the incremental and random-access data virtualization techniques.</span></span>

## <a name="incremental-data-virtualization"></a><span data-ttu-id="414ac-121">段階的なデータ仮想化</span><span class="sxs-lookup"><span data-stu-id="414ac-121">Incremental data virtualization</span></span>

<span data-ttu-id="414ac-122">段階的なデータ仮想化では、データを連続的にダウンロードします。</span><span class="sxs-lookup"><span data-stu-id="414ac-122">Incremental data virtualization loads data sequentially.</span></span> <span data-ttu-id="414ac-123">段階的なデータ仮想化を実行する [**ListView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView) を使って、数百万の項目のコレクションを表示できますが、最初は 50 個の項目だけが読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="414ac-123">A [**ListView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView) that uses incremental data virtualization may be used to view a collection of a million items, but only 50 items are loaded initially.</span></span> <span data-ttu-id="414ac-124">ユーザーがパン/スクロールすると、次の 50 個の項目が読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="414ac-124">As the user pans/scrolls, the next 50 are loaded.</span></span> <span data-ttu-id="414ac-125">項目が読み込まれると、スクロール バーのサムはサイズが小さくなります。</span><span class="sxs-lookup"><span data-stu-id="414ac-125">As items are loaded, the scroll bar's thumb decreases in size.</span></span> <span data-ttu-id="414ac-126">この種のデータ仮想化では、次のインターフェイスを実装するデータ ソース クラスを記述します。</span><span class="sxs-lookup"><span data-stu-id="414ac-126">For this type of data virtualization you write a data source class that implements these interfaces.</span></span>

-   [<span data-ttu-id="414ac-127">**IList**</span><span class="sxs-lookup"><span data-stu-id="414ac-127">**IList**</span></span>](https://docs.microsoft.com/dotnet/api/system.collections.ilist?redirectedfrom=MSDN)
-   <span data-ttu-id="414ac-128">[**INotifyCollectionChanged** ](https://docs.microsoft.com/dotnet/api/system.collections.specialized.inotifycollectionchanged?redirectedfrom=MSDN) (C#または VB) または[ **IObservableVector&lt;T&gt;**  ](https://docs.microsoft.com/uwp/api/Windows.Foundation.Collections.IObservableVector_T_) (C++/CX)</span><span class="sxs-lookup"><span data-stu-id="414ac-128">[**INotifyCollectionChanged**](https://docs.microsoft.com/dotnet/api/system.collections.specialized.inotifycollectionchanged?redirectedfrom=MSDN) (C#/VB) or [**IObservableVector&lt;T&gt;**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Collections.IObservableVector_T_) (C++/CX)</span></span>
-   [<span data-ttu-id="414ac-129">**ISupportIncrementalLoading**</span><span class="sxs-lookup"><span data-stu-id="414ac-129">**ISupportIncrementalLoading**</span></span>](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.ISupportIncrementalLoading)

<span data-ttu-id="414ac-130">このようなデータ ソースは、継続的に拡張できるメモリ内リストです。</span><span class="sxs-lookup"><span data-stu-id="414ac-130">A data source like this is an in-memory list that can be continually extended.</span></span> <span data-ttu-id="414ac-131">項目コントロールは、標準的な [**IList**](https://docs.microsoft.com/dotnet/api/system.collections.ilist?redirectedfrom=MSDN) インデクサーとカウント プロパティを使って項目を要求します。</span><span class="sxs-lookup"><span data-stu-id="414ac-131">The items control will ask for items using the standard [**IList**](https://docs.microsoft.com/dotnet/api/system.collections.ilist?redirectedfrom=MSDN) indexer and count properties.</span></span> <span data-ttu-id="414ac-132">カウントは、データセットの実際のサイズではなく、ローカルでの項目の数を表す必要があります。</span><span class="sxs-lookup"><span data-stu-id="414ac-132">The count should represent the number of items locally, not the true size of the dataset.</span></span>

<span data-ttu-id="414ac-133">項目コントロールは、既存のデータの終わりに近づいたときに [**ISupportIncrementalLoading.HasMoreItems**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.data.isupportincrementalloading.hasmoreitems) を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="414ac-133">When the items control gets close to the end of the existing data, it will call [**ISupportIncrementalLoading.HasMoreItems**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.data.isupportincrementalloading.hasmoreitems).</span></span> <span data-ttu-id="414ac-134">**true** が返された場合は、アドバタイズされた読み込む項目数を渡す [**ISupportIncrementalLoading.LoadMoreItemsAsync**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.data.isupportincrementalloading.loadmoreitemsasync) を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="414ac-134">If you return **true**, then it will call [**ISupportIncrementalLoading.LoadMoreItemsAsync**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.data.isupportincrementalloading.loadmoreitemsasync) passing an advised number of items to load.</span></span> <span data-ttu-id="414ac-135">データの読み込み元 (ローカル ディスク、ネットワーク、またはクラウド) に応じて、アドバタイズされた項目数とは異なる数の項目を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="414ac-135">Depending on where you're loading data from (local disk, network, or cloud), you may choose to load a different number of items than that advised.</span></span> <span data-ttu-id="414ac-136">たとえば、サービスは 50 項目のバッチをサポートしているが、項目コントロールは 10 項目のみを要求している場合、50 項目を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="414ac-136">For example, if your service supports batches of 50 items but the items control only asks for 10 then you can load 50.</span></span> <span data-ttu-id="414ac-137">バックエンドからデータを読み込んでリストに追加した後、[**INotifyCollectionChanged**](https://docs.microsoft.com/dotnet/api/system.collections.specialized.inotifycollectionchanged?redirectedfrom=MSDN) または [**IObservableVector&lt;T&gt;** ](https://docs.microsoft.com/uwp/api/Windows.Foundation.Collections.IObservableVector_T_) 経由で変更通知を発行して、項目コントロールが新しい項目を認識できるようにします。</span><span class="sxs-lookup"><span data-stu-id="414ac-137">Load the data from your back end, add it to your list, and raise a change notification via [**INotifyCollectionChanged**](https://docs.microsoft.com/dotnet/api/system.collections.specialized.inotifycollectionchanged?redirectedfrom=MSDN) or [**IObservableVector&lt;T&gt;**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Collections.IObservableVector_T_) so that the items control knows about the new items.</span></span> <span data-ttu-id="414ac-138">さらに、実際に読み込んだ項目の数を返します。</span><span class="sxs-lookup"><span data-stu-id="414ac-138">Also return a count of the items you actually loaded.</span></span> <span data-ttu-id="414ac-139">アドバタイズされた数よりも少ない項目を読み込むか、項目コントロールが途中でさらにパン/スクロールされた場合は、データ ソースをもう一度呼び出して、さらに項目を読み込むサイクルが続けられます。</span><span class="sxs-lookup"><span data-stu-id="414ac-139">If you load fewer items than advised, or the items control has been panned/scrolled even further in the interim, then your data source will be called again for more items and the cycle will continue.</span></span> <span data-ttu-id="414ac-140">ダウンロードの詳細は、 [XAML データ バインディングのサンプル](https://code.msdn.microsoft.com/windowsapps/Data-Binding-7b1d67b5)Windows 8.1 および Windows 10 アプリでそのソース コードを再利用します。</span><span class="sxs-lookup"><span data-stu-id="414ac-140">You can learn more by downloading the [XAML data binding sample](https://code.msdn.microsoft.com/windowsapps/Data-Binding-7b1d67b5) for Windows 8.1 and re-using its source code in your Windows 10 app.</span></span>

## <a name="random-access-data-virtualization"></a><span data-ttu-id="414ac-141">ランダム アクセスのデータ仮想化</span><span class="sxs-lookup"><span data-stu-id="414ac-141">Random access data virtualization</span></span>

<span data-ttu-id="414ac-142">ランダム アクセスのデータ仮想化を使うと、データ セット内の任意の位置からデータを読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="414ac-142">Random access data virtualization allows loading from an arbitrary point in the data set.</span></span> <span data-ttu-id="414ac-143">ランダム アクセスのデータ仮想化を実行する [**ListView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView) を、100 万の項目があるコレクションを表示するために使うと、100,000 番目から 100,050 番目の項目を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="414ac-143">A [**ListView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView) that uses random access data virtualization, used to view a collection of a million items, can load the items 100,000 – 100,050.</span></span> <span data-ttu-id="414ac-144">ユーザーが一覧の先頭に移動すると、コントロールは 1 番目から 50 番目の項目を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="414ac-144">If the user then moves to the beginning of the list, the control loads items 1 – 50.</span></span> <span data-ttu-id="414ac-145">スクロール バーのサムは、常に **ListView** に 100 万の項目が含まれていることを示します。</span><span class="sxs-lookup"><span data-stu-id="414ac-145">At all times, the scroll bar's thumb indicates that the **ListView** contains a million items.</span></span> <span data-ttu-id="414ac-146">スクロール バーのサムの位置は、表示されている項目がコレクションのデータ セット全体で相対的にどこに位置しているかを示します。</span><span class="sxs-lookup"><span data-stu-id="414ac-146">The position of the scroll bar's thumb is relative to where the visible items are located in the collection's entire data set.</span></span> <span data-ttu-id="414ac-147">この種のデータ仮想化は、必要なメモリを大幅に減らし、コレクションの読み込み時間を大きく短縮します。</span><span class="sxs-lookup"><span data-stu-id="414ac-147">This type of data virtualization can significantly reduce the memory requirements and load times for the collection.</span></span> <span data-ttu-id="414ac-148">これを有効にするには、データをオンデマンドで取得し、ローカル キャッシュを管理し、次のインターフェイスを実装するデータ ソース クラスを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="414ac-148">To enable it you need to write a data source class that fetches data on demand and manages a local cache and implements these interfaces.</span></span>

-   [<span data-ttu-id="414ac-149">**IList**</span><span class="sxs-lookup"><span data-stu-id="414ac-149">**IList**</span></span>](https://docs.microsoft.com/dotnet/api/system.collections.ilist?redirectedfrom=MSDN)
-   <span data-ttu-id="414ac-150">[**INotifyCollectionChanged** ](https://docs.microsoft.com/dotnet/api/system.collections.specialized.inotifycollectionchanged?redirectedfrom=MSDN) (C#または VB) または[ **IObservableVector&lt;T&gt;**  ](https://docs.microsoft.com/uwp/api/Windows.Foundation.Collections.IObservableVector_T_) (C++/CX)</span><span class="sxs-lookup"><span data-stu-id="414ac-150">[**INotifyCollectionChanged**](https://docs.microsoft.com/dotnet/api/system.collections.specialized.inotifycollectionchanged?redirectedfrom=MSDN) (C#/VB) or [**IObservableVector&lt;T&gt;**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Collections.IObservableVector_T_) (C++/CX)</span></span>
-   <span data-ttu-id="414ac-151">(必要に応じて) [**IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo)</span><span class="sxs-lookup"><span data-stu-id="414ac-151">(Optionally) [**IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo)</span></span>
-   <span data-ttu-id="414ac-152">(必要に応じて) [**ISelectionInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.ISelectionInfo)</span><span class="sxs-lookup"><span data-stu-id="414ac-152">(Optionally) [**ISelectionInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.ISelectionInfo)</span></span>

<span data-ttu-id="414ac-153">[**IItemsRangeInfo** ](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo)どの項目コントロールの使用は積極的に情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="414ac-153">[**IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo) provides information on which items the control is actively using.</span></span> <span data-ttu-id="414ac-154">項目コントロールはビューが変更されるたびにこのメソッドを呼び出し、その中には 次の 2 つの範囲のセットが含まれます。</span><span class="sxs-lookup"><span data-stu-id="414ac-154">The items control will call this method whenever its view is changing, and will include these two sets of ranges.</span></span>

-   <span data-ttu-id="414ac-155">ビューポート内の項目のセット。</span><span class="sxs-lookup"><span data-stu-id="414ac-155">The set of items that are in the viewport.</span></span>
-   <span data-ttu-id="414ac-156">項目コントロールが使う項目で、ビューポートに表示されない可能性がある、仮想化されていない項目のセット。</span><span class="sxs-lookup"><span data-stu-id="414ac-156">A set of non-virtualized items that the control is using that may not be in the viewport.</span></span>
    -   <span data-ttu-id="414ac-157">タッチ パンをスムーズに行えるようにするために項目コントロールが保持している、ビューポートの周囲の項目のバッファー。</span><span class="sxs-lookup"><span data-stu-id="414ac-157">A buffer of items around the viewport that the items control keeps so that touch panning is smooth.</span></span>
    -   <span data-ttu-id="414ac-158">フォーカスが置かれている項目。</span><span class="sxs-lookup"><span data-stu-id="414ac-158">The focused item.</span></span>
    -   <span data-ttu-id="414ac-159">先頭の項目。</span><span class="sxs-lookup"><span data-stu-id="414ac-159">The first item.</span></span>

<span data-ttu-id="414ac-160">[  **IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo) を実装することで、データ ソースは、どの項目をフェッチしてキャッシュする必要があり、不要になったキャッシュ データをいつ除去するかがわかります。</span><span class="sxs-lookup"><span data-stu-id="414ac-160">By implementing [**IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo) your data source knows what items need to be fetched and cached, and when to prune from the cache data that is no longer needed.</span></span> <span data-ttu-id="414ac-161">**IItemsRangeInfo** は、[**ItemIndexRange**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.ItemIndexRange) オブジェクトを使って、コレクション内のインデックスに基づいてオブジェクトのセットを記述します。</span><span class="sxs-lookup"><span data-stu-id="414ac-161">**IItemsRangeInfo** uses [**ItemIndexRange**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.ItemIndexRange) objects to describe a set of items based on their index in the collection.</span></span> <span data-ttu-id="414ac-162">これは、正しくないか安定していない可能性がある項目ポインターを使わないようにするためです。</span><span class="sxs-lookup"><span data-stu-id="414ac-162">This is so that it doesn't use item pointers, which may not be correct or stable.</span></span> <span data-ttu-id="414ac-163">**IItemsRangeInfo** は、項目コントロールの状態情報に頼っているため、項目コントロールの 1 つのインスタンスでのみ使われるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="414ac-163">**IItemsRangeInfo** is designed to be used by only a single instance of an items control because it relies on state information for that items control.</span></span> <span data-ttu-id="414ac-164">複数の項目コントロールが同じデータにアクセスする必要がある場合は、それぞれに対してデータ ソースの個別のインスタンスが必要です。</span><span class="sxs-lookup"><span data-stu-id="414ac-164">If multiple items controls need access to the same data then you will need a separate instance of the data source for each.</span></span> <span data-ttu-id="414ac-165">それらは共通のキャッシュを共有できますが、キャッシュから消去するためのロジックはもっと複雑です。</span><span class="sxs-lookup"><span data-stu-id="414ac-165">They can share a common cache, but the logic to purge from the cache will be more complicated.</span></span>

<span data-ttu-id="414ac-166">ランダム アクセスのデータ仮想化データ ソースのための基本的な戦略を次に示します。</span><span class="sxs-lookup"><span data-stu-id="414ac-166">Here's the basic strategy for your random access data virtualization data source.</span></span>

-   <span data-ttu-id="414ac-167">項目を要求されたとき</span><span class="sxs-lookup"><span data-stu-id="414ac-167">When asked for an item</span></span>
    -   <span data-ttu-id="414ac-168">メモリ内の項目を利用できる場合はその項目を返します。</span><span class="sxs-lookup"><span data-stu-id="414ac-168">If you have it available in memory, then return it.</span></span>
    -   <span data-ttu-id="414ac-169">利用できない場合は、null またはプレースホルダー項目を返します。</span><span class="sxs-lookup"><span data-stu-id="414ac-169">If you don’t have it, then return either null or a placeholder item.</span></span>
    -   <span data-ttu-id="414ac-170">項目に対する要求 (または [**IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo) からの範囲要求) を使って、どの項目が必要であるかを調べ、バックエンドから項目のデータを非同期的に取得します。</span><span class="sxs-lookup"><span data-stu-id="414ac-170">Use the request for an item (or the range information from [**IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo)) to know which items are needed, and to fetch data for items from your back end asynchronously.</span></span> <span data-ttu-id="414ac-171">データを取得した後、[**INotifyCollectionChanged**](https://docs.microsoft.com/dotnet/api/system.collections.specialized.inotifycollectionchanged?redirectedfrom=MSDN) または [**IObservableVector&lt;T&gt;** ](https://docs.microsoft.com/uwp/api/Windows.Foundation.Collections.IObservableVector_T_) 経由で変更通知を発行して、項目コントロールが新しい項目を認識できるようにします。</span><span class="sxs-lookup"><span data-stu-id="414ac-171">After retrieving the data, raise a change notification via [**INotifyCollectionChanged**](https://docs.microsoft.com/dotnet/api/system.collections.specialized.inotifycollectionchanged?redirectedfrom=MSDN) or [**IObservableVector&lt;T&gt;**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Collections.IObservableVector_T_) so that the items control knows about the new item.</span></span>
-   <span data-ttu-id="414ac-172">(必要に応じて) 項目コントロールのビューポートが変更されるときに、[**IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo) の実装を通してどの項目がデータ ソースから必要であるかを識別します。</span><span class="sxs-lookup"><span data-stu-id="414ac-172">(Optionally) as the items control's viewport changes, identify what items are needed from your data source via your implementation of [**IItemsRangeInfo**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.IItemsRangeInfo).</span></span>

<span data-ttu-id="414ac-173">その他のいつデータ項目を読み込むか、いくつ読み込むか、そしてどの項目をメモリに保持するかは、アプリケーションにまかされます。</span><span class="sxs-lookup"><span data-stu-id="414ac-173">Beyond that, the strategy for when to load data items, how many to load, and which items to keep in memory is up to your application.</span></span> <span data-ttu-id="414ac-174">いくつかの一般的な考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="414ac-174">Some general considerations to keep in mind:</span></span>

-   <span data-ttu-id="414ac-175">データは非同期に要求します。UI スレッドをブロックしないでください。</span><span class="sxs-lookup"><span data-stu-id="414ac-175">Make asynchronous requests for data; don't block the UI thread.</span></span>
-   <span data-ttu-id="414ac-176">項目を取得するバッチのサイズのスイート スポットを探します。</span><span class="sxs-lookup"><span data-stu-id="414ac-176">Find the sweet spot in the size of the batches you fetch items in.</span></span> <span data-ttu-id="414ac-177">ブロックで処理するようにします。</span><span class="sxs-lookup"><span data-stu-id="414ac-177">Prefer chunky to chatty.</span></span> <span data-ttu-id="414ac-178">小さな要求を何度も繰り返すほど小さくなく、取得するまで時間がかかりすぎるほど大きくないサイズにします。</span><span class="sxs-lookup"><span data-stu-id="414ac-178">Not so small that you make too many small requests; not too large that they take too long to retrieve.</span></span>
-   <span data-ttu-id="414ac-179">同時に保留中にする要求の数を検討します。</span><span class="sxs-lookup"><span data-stu-id="414ac-179">Consider how many requests you want to have pending at the same time.</span></span> <span data-ttu-id="414ac-180">簡単なのは一度に 1 つずつ実行することですが、完了までの時間がかかる場合は遅くなりすぎる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="414ac-180">Performing one at a time is easier, but it may be too slow if turnaround time is high.</span></span>
-   <span data-ttu-id="414ac-181">データの要求を取り消すことができるかどうか。</span><span class="sxs-lookup"><span data-stu-id="414ac-181">Can you cancel requests for data?</span></span>
-   <span data-ttu-id="414ac-182">ホストされるサービスを使っている場合は、トランザクションごとにコストが発生するかどうか。</span><span class="sxs-lookup"><span data-stu-id="414ac-182">If using a hosted service, is there a cost per transaction?</span></span>
-   <span data-ttu-id="414ac-183">クエリの結果が変更されるときにサービスによって提供される通知の種類は何か。</span><span class="sxs-lookup"><span data-stu-id="414ac-183">What kind of notifications are provided by the service when the results of a query are changed?</span></span> <span data-ttu-id="414ac-184">項目がンデックス 33 に挿入されたことがわかるか。</span><span class="sxs-lookup"><span data-stu-id="414ac-184">Will you know if an item is inserted at index 33?</span></span> <span data-ttu-id="414ac-185">サービスがキーとオフセットに基づくクエリをサポートする場合は、インデックスだけを使うよりも適している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="414ac-185">If your service supports queries based on a key-plus-offset, that may be better than just using an index.</span></span>
-   <span data-ttu-id="414ac-186">項目のプリフェッチをいかにスマートに実行するか。</span><span class="sxs-lookup"><span data-stu-id="414ac-186">How smart do you want to be in pre-fetching items?</span></span> <span data-ttu-id="414ac-187">必要な項目を予測するためにスクロールの方向と速度を追跡する予定ですか。</span><span class="sxs-lookup"><span data-stu-id="414ac-187">Are you going to try and track the direction and velocity of scrolling to predict which items are needed?</span></span>
-   <span data-ttu-id="414ac-188">キャッシュの消去をどの程度積極的に行うか。</span><span class="sxs-lookup"><span data-stu-id="414ac-188">How aggressive do you want to be in purging the cache?</span></span> <span data-ttu-id="414ac-189">これはメモリとエクスペリエンスのトレードオフです。</span><span class="sxs-lookup"><span data-stu-id="414ac-189">This is a tradeoff of memory versus experience.</span></span>




