---
author: jwmsft
ms.assetid: E1943DCE-833F-48AE-8402-CD48765B24FC
title: 中断/再開の最適化
description: プロセス継続時間システムの使用を合理化することで、中断または終了の後効率的に再開されるユニバーサル Windows プラットフォーム (UWP) アプリを作成します。
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 4cbaa56f9c25c0e4ea1f10c79b4f7d1100748532
ms.sourcegitcommit: 71e8eae5c077a7740e5606298951bb78fc42b22c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/13/2018
ms.locfileid: "6650195"
---
# <a name="optimize-suspendresume"></a><span data-ttu-id="653e3-104">中断/再開の最適化</span><span class="sxs-lookup"><span data-stu-id="653e3-104">Optimize suspend/resume</span></span>


<span data-ttu-id="653e3-105">プロセス継続時間システムの使用を合理化することで、中断または終了の後効率的に再開されるユニバーサル Windows プラットフォーム (UWP) アプリを作成します。</span><span class="sxs-lookup"><span data-stu-id="653e3-105">Create Universal Windows Platform (UWP) apps that streamline their use of the process lifetime system to resume efficiently after suspension or termination.</span></span>

## <a name="launch"></a><span data-ttu-id="653e3-106">起動</span><span class="sxs-lookup"><span data-stu-id="653e3-106">Launch</span></span>

<span data-ttu-id="653e3-107">中断/終了の後、アプリを再アクティブ化するときは、長い時間が経過したかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="653e3-107">When reactivating an app following suspend/terminate, check to see if a long time has elapsed.</span></span> <span data-ttu-id="653e3-108">長時間経過している場合は、ユーザーの古いデータを表示する代わりに、アプリのメイン ランディング ページに戻ることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="653e3-108">If so, consider returning to the main landing page of the app instead of showing the user stale data.</span></span> <span data-ttu-id="653e3-109">これにより、起動時間も短縮されます。</span><span class="sxs-lookup"><span data-stu-id="653e3-109">This will also result in faster startup.</span></span>

<span data-ttu-id="653e3-110">アクティブ化では、常に、イベント引数のパラメーターの PreviousExecutionState を確認します (たとえば、起動済みのアクティブ化では、LaunchActivatedEventArgs.PreviousExecutionState を確認します)。</span><span class="sxs-lookup"><span data-stu-id="653e3-110">During activation, always check the PreviousExecutionState of the event args parameter (for example, for launched activations check LaunchActivatedEventArgs.PreviousExecutionState).</span></span> <span data-ttu-id="653e3-111">この値が ClosedByUser または NotRunning の場合は、以前に保存された状態を復元することで時間をむだにしないでください。</span><span class="sxs-lookup"><span data-stu-id="653e3-111">If the value is ClosedByUser or NotRunning, don’t waste time restoring previously saved state.</span></span> <span data-ttu-id="653e3-112">この場合、適切な処理は新しいエクスペリエンスを提供することであり、結果として起動時間も短縮されます。</span><span class="sxs-lookup"><span data-stu-id="653e3-112">In this case, the right thing is to provide a fresh experience – and it will result in faster startup.</span></span>

<span data-ttu-id="653e3-113">以前に保存した状態を頻繁に復元する代わりに、その状態を追跡して、要求された場合にのみ復元することを検討します。</span><span class="sxs-lookup"><span data-stu-id="653e3-113">Instead of eagerly restoring previously saved state, consider keep track of that state, and only restoring it on demand.</span></span> <span data-ttu-id="653e3-114">たとえば、以前にアプリが一時停止され、3 つのページの状態を保存した後、終了された場合を考えてみます。</span><span class="sxs-lookup"><span data-stu-id="653e3-114">For example, consider a situation where your app was previously suspended, saved state for 3 pages, and was then terminated.</span></span> <span data-ttu-id="653e3-115">再起動時に、ユーザーに対して 3 番目のページを表示する場合は、最初の 2 つのページの状態を頻繁に復元しないでください。</span><span class="sxs-lookup"><span data-stu-id="653e3-115">Upon relaunch, if you decide to return the user to the 3rd page, do not eagerly restore the state for the first 2 pages.</span></span> <span data-ttu-id="653e3-116">代わりに、この状態を保持し、必要であることがわかった場合にのみ使用します。</span><span class="sxs-lookup"><span data-stu-id="653e3-116">Instead, hold on to this state and only use it once you know you need it.</span></span>

## <a name="while-running"></a><span data-ttu-id="653e3-117">実行中</span><span class="sxs-lookup"><span data-stu-id="653e3-117">While running</span></span>

<span data-ttu-id="653e3-118">ベストプラクティスとして、中断イベントを待機し、大量の状態を保持することはしないでください。</span><span class="sxs-lookup"><span data-stu-id="653e3-118">As a best practice, don’t wait for the suspend event and then persist a large amount of state.</span></span> <span data-ttu-id="653e3-119">代わりに、アプリケーションの実行中に少しずつ状態を保持するようにします。</span><span class="sxs-lookup"><span data-stu-id="653e3-119">Instead, your application should incrementally persist smaller amounts of state as it runs.</span></span> <span data-ttu-id="653e3-120">これは、中断時にすべてを一度に保存しようとすると時間が不足する可能性がある、大規模なアプリで特に重要です。</span><span class="sxs-lookup"><span data-stu-id="653e3-120">This is especially important for large apps that are at risk of running out of time during suspend if they try to save everything at once.</span></span>

<span data-ttu-id="653e3-121">ただし、段階的な保存と実行中のアプリのパフォーマンスの最適なバランスを見つける必要があります。</span><span class="sxs-lookup"><span data-stu-id="653e3-121">However, you need to find a good balance between incremental saving and performance of your app while running.</span></span> <span data-ttu-id="653e3-122">適切な妥協点は、変更された (つまり保存する必要がある) データを段階的に追跡し、中断イベントを使って実際にそのデータを保存することです (すべてのデータを保存したり、アプリ全体の状態を調べて保存する対象を決定したりするよりも高速です)。</span><span class="sxs-lookup"><span data-stu-id="653e3-122">A good tradeoff is to incrementally keep track of the data that has changed (and therefore needs to be saved) – and use the suspend event to actually save that data (which is faster than saving all data or examining the entire state of app to decide what to save).</span></span>

<span data-ttu-id="653e3-123">ウィンドウの Activated イベントや VisibilityChanged イベントを使って、状態を保存するタイミングを決定しないでください。</span><span class="sxs-lookup"><span data-stu-id="653e3-123">Don’t use the window Activated or VisibilityChanged events to decide when to save state.</span></span> <span data-ttu-id="653e3-124">ユーザーがアプリを切り替えたときに、ウィンドウは非アクティブ化されますが、システムはアプリを中断するまでしばらくの間 (約 10 秒間) 待機します。</span><span class="sxs-lookup"><span data-stu-id="653e3-124">When the user switches away from your app, the window is deactivated, but the system waits a short amount of time (about 10 seconds) before suspending the app.</span></span> <span data-ttu-id="653e3-125">これにより、ユーザーがすぐに元のアプリに切り替えた場合に、応答性の高いエクスペリエンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="653e3-125">This is to give a more responsive experience in case the user switches back to your app rapidly.</span></span> <span data-ttu-id="653e3-126">中断ロジックを実行する前に、中断イベントを待機します。</span><span class="sxs-lookup"><span data-stu-id="653e3-126">Wait for the suspend event before running suspend logic.</span></span>

## <a name="suspend"></a><span data-ttu-id="653e3-127">中断</span><span class="sxs-lookup"><span data-stu-id="653e3-127">Suspend</span></span>

<span data-ttu-id="653e3-128">中断時に、アプリのメモリ使用量を削減します。</span><span class="sxs-lookup"><span data-stu-id="653e3-128">During suspend, reduce the footprint of your app.</span></span> <span data-ttu-id="653e3-129">中断中のアプリのメモリ使用量が少なくなると、システム全体の応答性が高くなり、(お客様のアプリを含む) 中断されたアプリが終了されることが少なくなります。</span><span class="sxs-lookup"><span data-stu-id="653e3-129">If your app uses less memory while suspended, the overall system will be more responsive and fewer suspended apps (including yours) will be terminated.</span></span> <span data-ttu-id="653e3-130">ただし、メモリ使用量と迅速な再開の必要性のバランスを考慮する必要があります。メモリ使用量を削減しすぎると、メモリに大量のデータを再び読み込むことが必要になり、再開が大幅に遅くなります。</span><span class="sxs-lookup"><span data-stu-id="653e3-130">However, balance this with the need for snappy resumes: don’t reduce footprint so much that resume slows down considerably while your app reloads lots of data into memory.</span></span>

<span data-ttu-id="653e3-131">マネージ アプリの場合、アプリの中断ハンドラーが完了した後、システムはガベージ コレクション パスを実行します。</span><span class="sxs-lookup"><span data-stu-id="653e3-131">For managed apps, the system will run a garbage collection pass after the app’s suspend handlers complete.</span></span> <span data-ttu-id="653e3-132">これを利用して、中断中のアプリのメモリ使用量の削減に役立つオブジェクトへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="653e3-132">Make sure to take advantage of this by releasing references to objects that will help reduce the app’s footprint while suspended.</span></span>

<span data-ttu-id="653e3-133">アプリで 1 秒未満で中断ロジックを完了することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="653e3-133">Ideally, your app will finish with suspend logic in less than 1 second.</span></span> <span data-ttu-id="653e3-134">中断は迅速に完了できるほどよく、他のアプリやシステムの部分の迅速なユーザー エクスペリエンスにつながります。</span><span class="sxs-lookup"><span data-stu-id="653e3-134">The faster you can suspend, the better – that will result in a snappier user experience for other apps and parts of the system.</span></span> <span data-ttu-id="653e3-135">必要な場合は、デスクトップ デバイスで最大 5 秒間、モバイル デバイスでは 10 秒間、中断ロジックの処理に時間をかけることができます。</span><span class="sxs-lookup"><span data-stu-id="653e3-135">If you must, your suspend logic can take up to 5 seconds on desktop devices or 10 seconds on mobile devices.</span></span> <span data-ttu-id="653e3-136">これらの時間を超過した場合、アプリは突然終了します。</span><span class="sxs-lookup"><span data-stu-id="653e3-136">If those times are exceeded, your app will be abruptly terminated.</span></span> <span data-ttu-id="653e3-137">これは望ましい結果ではありません。この場合、ユーザーがアプリに戻るときに、新しいプロセスが開始され、中断中のアプリを再開するときよりも、エクスペリエンスは非常に遅く感じられるためです。</span><span class="sxs-lookup"><span data-stu-id="653e3-137">You don’t want this to happen – because if it does, when the user switches back to your app, a new process will be launched and the experience will feel much slower compared to resuming a suspended app.</span></span>

## <a name="resume"></a><span data-ttu-id="653e3-138">再開</span><span class="sxs-lookup"><span data-stu-id="653e3-138">Resume</span></span>

<span data-ttu-id="653e3-139">ほとんどのアプリでは、再開時に特別な処理を行う必要がないため、通常、このイベントは処理しません。</span><span class="sxs-lookup"><span data-stu-id="653e3-139">Most apps don’t need to do anything special when resumed, so typically you won’t handle this event.</span></span> <span data-ttu-id="653e3-140">一部のアプリでは、再開を利用して、中断時に終了された接続を復元したり、古くなっている可能性があるデータを更新したりします。</span><span class="sxs-lookup"><span data-stu-id="653e3-140">Some apps use resume to restore connections that were closed during suspend, or to refresh data that may be stale.</span></span> <span data-ttu-id="653e3-141">このような作業を頻繁に行う代わりに、必要に応じてこれらのアクティビティを開始するようアプリを設計します。</span><span class="sxs-lookup"><span data-stu-id="653e3-141">Instead of doing this kind of work eagerly, design your app to initiate these activities on demand.</span></span> <span data-ttu-id="653e3-142">これにより、ユーザーが中断中のアプリに戻ったときのエクスペリエンスが迅速になり、ユーザーが実際に必要としている作業のみを行っていることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="653e3-142">This will result in a faster experience when the user switches back to a suspended app, and ensures that you’re only doing work the user really needs.</span></span>

## <a name="avoid-unnecessary-termination"></a><span data-ttu-id="653e3-143">不必要な終了の回避</span><span class="sxs-lookup"><span data-stu-id="653e3-143">Avoid unnecessary termination</span></span>

<span data-ttu-id="653e3-144">UWP のプロセス継続時間システムは、さまざまな理由でアプリを中断または終了することがあります。</span><span class="sxs-lookup"><span data-stu-id="653e3-144">The UWP process lifetime system can suspend or terminate an app for a variety of reasons.</span></span> <span data-ttu-id="653e3-145">このプロセスは、アプリを中断または終了する前の状態にすばやく戻すように設計されています。</span><span class="sxs-lookup"><span data-stu-id="653e3-145">This process is designed to quickly return an app to the state it was in before it was suspended or terminated.</span></span> <span data-ttu-id="653e3-146">うまく機能すると、アプリの実行が停止していたことにユーザーは気付きません。</span><span class="sxs-lookup"><span data-stu-id="653e3-146">When done well, the user won’t be aware that the app ever stopped running.</span></span> <span data-ttu-id="653e3-147">ここでは、UWP アプリで、システムがアプリの有効期間内で切り替えを効率的に行うのに役立つヒントをいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="653e3-147">Here are a few tricks that your UWP app can use to help the system streamline transitions in an app’s lifetime.</span></span>

<span data-ttu-id="653e3-148">ユーザーがアプリをバックグラウンドに移動した場合、またはシステムが低電力状態に切り替わった場合にアプリを中断できます。</span><span class="sxs-lookup"><span data-stu-id="653e3-148">An app can be suspended when the user moves it to the background or when the system enters a low power state.</span></span> <span data-ttu-id="653e3-149">アプリが中断される際、アプリは suspending イベントを発生して、最長で 5 秒間かけてデータを保存します。</span><span class="sxs-lookup"><span data-stu-id="653e3-149">When the app is being suspended, it raises the suspending event and has up to 5 seconds to save its data.</span></span> <span data-ttu-id="653e3-150">アプリの suspending イベント ハンドラーが 5 秒以内に処理を完了できなかった場合、システムはアプリが応答を停止したと判断してアプリを終了します。</span><span class="sxs-lookup"><span data-stu-id="653e3-150">If the app's suspending event handler doesn't complete within 5 seconds, the system assumes the app has stopped responding and terminates it.</span></span> <span data-ttu-id="653e3-151">終了したアプリは、ユーザーがそのアプリに切り替えたときに、すぐにメモリに読み込まれることはなく、長い起動プロセスをもう一度実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="653e3-151">A terminated app has to go through the long startup process again instead of being immediately loaded into memory when a user switches to it.</span></span>

### <a name="serialize-only-when-necessary"></a><span data-ttu-id="653e3-152">必要最小限のシリアル化</span><span class="sxs-lookup"><span data-stu-id="653e3-152">Serialize only when necessary</span></span>

<span data-ttu-id="653e3-153">中断時にすべてのデータをシリアル化するアプリは少なくありません。</span><span class="sxs-lookup"><span data-stu-id="653e3-153">Many apps serialize all their data on suspension.</span></span> <span data-ttu-id="653e3-154">しかし、アプリの設定データのうち、保存する必要のあるデータがごくわずかであれば、シリアル化ではなく、[**LocalSettings**](https://msdn.microsoft.com/library/windows/apps/BR241622) ストアを使うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="653e3-154">If you only need to store a small amount of app settings data, however, you should use the [**LocalSettings**](https://msdn.microsoft.com/library/windows/apps/BR241622) store instead of serializing the data.</span></span> <span data-ttu-id="653e3-155">シリアル化は、もっと大量のデータや、設定以外のデータに使います。</span><span class="sxs-lookup"><span data-stu-id="653e3-155">Use serialization for larger amounts of data and for non-settings data.</span></span>

<span data-ttu-id="653e3-156">データをシリアル化する際、変更されていないデータを再シリアル化することは避けてください。</span><span class="sxs-lookup"><span data-stu-id="653e3-156">When you do serialize your data, you should avoid reserializing if it hasn't changed.</span></span> <span data-ttu-id="653e3-157">データのシリアル化と保存に時間がかかるばかりか、アプリが再びアクティブ化されたときにもデータの読み取りと逆シリアル化に時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="653e3-157">It takes extra time to serialize and save the data, plus extra time to read and deserialize it when the app is activated again.</span></span> <span data-ttu-id="653e3-158">このような処理ではなく、アプリの状態が実際に変更されたかどうかをアプリが判定し、変更された場合にのみ変更データをシリアル化および逆シリアル化する処理をお勧めしています。</span><span class="sxs-lookup"><span data-stu-id="653e3-158">Instead, we recommend that the app determine if its state has actually changed, and if so, serialize and deserialize only the data that changed.</span></span> <span data-ttu-id="653e3-159">この処理を確実に行う良い方法は、データが変更された後にバックグラウンドでこまめにシリアル化することです。</span><span class="sxs-lookup"><span data-stu-id="653e3-159">A good way to ensure that this happens is to periodically serialize data in the background after it changes.</span></span> <span data-ttu-id="653e3-160">この手法を使うと、中断時にシリアル化する必要があるすべてのデータが既に保存されているため、必要な作業がなく、アプリがすぐに中断されます。</span><span class="sxs-lookup"><span data-stu-id="653e3-160">When you use this technique, everything that needs to be serialized at suspension has already been saved so there is no work to do and an app suspends quickly.</span></span>

### <a name="serializing-data-in-c-and-visual-basic"></a><span data-ttu-id="653e3-161">C# と Visual Basic でのデータのシリアル化</span><span class="sxs-lookup"><span data-stu-id="653e3-161">Serializing data in C# and Visual Basic</span></span>

<span data-ttu-id="653e3-162">.NET アプリで使うことができるシリアル化技術には、[**System.Xml.Serialization.XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx) クラス、[**System.Runtime.Serialization.DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) クラス、[**System.Runtime.Serialization.Json.DataContractJsonSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.json.datacontractjsonserializer.aspx) クラスがあります。</span><span class="sxs-lookup"><span data-stu-id="653e3-162">The available choices of serialization technology for .NET apps are the [**System.Xml.Serialization.XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx), [**System.Runtime.Serialization.DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx), and [**System.Runtime.Serialization.Json.DataContractJsonSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.json.datacontractjsonserializer.aspx) classes.</span></span>

<span data-ttu-id="653e3-163">パフォーマンスの観点から、[**XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx) クラスを使うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="653e3-163">From a performance perspective, we recommend using the [**XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx) class.</span></span> <span data-ttu-id="653e3-164">**XmlSerializer** は、シリアル化と逆シリアル化の処理時間が最も短く、メモリ使用量も低く抑えられます。</span><span class="sxs-lookup"><span data-stu-id="653e3-164">The **XmlSerializer** has the lowest serialization and deserialization times, and maintains a low memory footprint.</span></span> <span data-ttu-id="653e3-165">**XmlSerializer** と .NET Framework の間には依存関係が少ないため、他のシリアル化技術と比較して、**XmlSerializer** を使うためにアプリに読み込む必要があるモジュールが少なくて済みます。</span><span class="sxs-lookup"><span data-stu-id="653e3-165">The **XmlSerializer** has few dependencies on the .NET framework; this means that compared with the other serialization technologies, fewer modules need to be loaded into your app to use the **XmlSerializer**.</span></span>

<span data-ttu-id="653e3-166">**XmlSerializer** と比べて、[**DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) は、カスタム クラスを比較的容易にシリアル化できる反面、パフォーマンスへの影響は大きくなります。</span><span class="sxs-lookup"><span data-stu-id="653e3-166">[**DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) makes it easier to serialize custom classes, although it has a larger performance impact than **XmlSerializer**.</span></span> <span data-ttu-id="653e3-167">より高いパフォーマンスが必要な場合は、切り替えを検討してください。</span><span class="sxs-lookup"><span data-stu-id="653e3-167">If you need better performance, consider switching.</span></span> <span data-ttu-id="653e3-168">通常、複数のシリアライザーを読み込むことは避け、できれば **XmlSerializer** を使うようにしてください (他のシリアライザーの機能を必要とする場合を除く)。</span><span class="sxs-lookup"><span data-stu-id="653e3-168">In general, you should not load more than one serializer, and you should prefer **XmlSerializer** unless you need the features of another serializer.</span></span>

### <a name="reduce-memory-footprint"></a><span data-ttu-id="653e3-169">メモリ使用量の削減</span><span class="sxs-lookup"><span data-stu-id="653e3-169">Reduce memory footprint</span></span>

<span data-ttu-id="653e3-170">システムは、ユーザーがアプリをすばやく簡単に切り替えられるよう、中断されたアプリを可能な限り多く保持しようとします。</span><span class="sxs-lookup"><span data-stu-id="653e3-170">The system tries to keep as many suspended apps in memory as possible so that users can quickly and reliably switch between them.</span></span> <span data-ttu-id="653e3-171">中断され、システムのメモリ内に保持されているアプリは、スプラッシュ画面の表示や長時間の読み込み操作なしでユーザーのフォアグラウンドにすぐに戻ることができます。</span><span class="sxs-lookup"><span data-stu-id="653e3-171">When an app is suspended and stays in the system's memory, it can quickly be brought to the foreground for the user to interact with, without having to display a splash screen or perform a lengthy load operation.</span></span> <span data-ttu-id="653e3-172">十分なリソースがなくアプリをメモリに保持できない場合は、アプリが終了されます。</span><span class="sxs-lookup"><span data-stu-id="653e3-172">If there aren't enough resources to keep an app in memory, the app is terminated.</span></span> <span data-ttu-id="653e3-173">そのため、次の 2 つの理由でメモリ管理が重要になります。</span><span class="sxs-lookup"><span data-stu-id="653e3-173">This makes memory management important for two reasons:</span></span>

-   <span data-ttu-id="653e3-174">中断時にできるだけ多くのメモリを解放すると、中断しているときにアプリがリソース不足によって終了する可能性が最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="653e3-174">Freeing as much memory as possible at suspension minimizes the chances that your app is terminated because of lack of resources while it’s suspended.</span></span>
-   <span data-ttu-id="653e3-175">アプリが使うメモリの総量を減らすと、中断している他のアプリが終了する可能性が低くなります。</span><span class="sxs-lookup"><span data-stu-id="653e3-175">Reducing the overall amount of memory your app uses reduces the chances that other apps are terminated while they are suspended.</span></span>

### <a name="release-resources"></a><span data-ttu-id="653e3-176">リソースの解放</span><span class="sxs-lookup"><span data-stu-id="653e3-176">Release resources</span></span>

<span data-ttu-id="653e3-177">ファイルやデバイスなどの特定のオブジェクトは、大量のメモリを占有します。</span><span class="sxs-lookup"><span data-stu-id="653e3-177">Certain objects, such as files and devices, occupy a large amount of memory.</span></span> <span data-ttu-id="653e3-178">中断中は、アプリがこれらのオブジェクトへのハンドルを解放し、必要なときにハンドルを再作成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="653e3-178">We recommend that during suspension, an app release handles to these objects and recreate them when needed.</span></span> <span data-ttu-id="653e3-179">また、これは、アプリが再開したときに使われないキャッシュを削除する良い機会でもあります。</span><span class="sxs-lookup"><span data-stu-id="653e3-179">This is also a good time to purge any caches that won’t be valid when the app is resumed.</span></span> <span data-ttu-id="653e3-180">XAML フレームワークでは、必要に応じて、C# と Visual Basic を使ったアプリに対してガベージ コレクションを追加手順として実行します。</span><span class="sxs-lookup"><span data-stu-id="653e3-180">An additional step the XAML framework runs on your behalf for C# and Visual Basic apps is garbage collection if it is necessary.</span></span> <span data-ttu-id="653e3-181">これによって、アプリ コードで参照されなくなったすべてのオブジェクトが解放されます。</span><span class="sxs-lookup"><span data-stu-id="653e3-181">This ensures any objects no longer referenced in app code are released.</span></span>

## <a name="resume-quickly"></a><span data-ttu-id="653e3-182">迅速な再開</span><span class="sxs-lookup"><span data-stu-id="653e3-182">Resume quickly</span></span>

<span data-ttu-id="653e3-183">中断中のアプリは、ユーザーがフォアグラウンドにアプリを移動した場合、またはシステムが低電力状態から復帰した場合に再開することができます。</span><span class="sxs-lookup"><span data-stu-id="653e3-183">A suspended app can be resumed when the user moves it to the foreground or when the system comes out of a low power state.</span></span> <span data-ttu-id="653e3-184">アプリを中断状態から再開すると、アプリは中断された時点から再開されます。</span><span class="sxs-lookup"><span data-stu-id="653e3-184">When an app is resumed from the suspended state, it continues from where it was when it was suspended.</span></span> <span data-ttu-id="653e3-185">アプリが長時間中断されていた場合でも、アプリのデータはメモリに格納されているため失われることはありません。</span><span class="sxs-lookup"><span data-stu-id="653e3-185">No app data is lost because it was stored in memory, even if the app was suspended for a long period of time.</span></span>

<span data-ttu-id="653e3-186">ほとんどのアプリでは、[**Resuming**](https://msdn.microsoft.com/library/windows/apps/BR205859) イベントを処理する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="653e3-186">Most apps don't need to handle the [**Resuming**](https://msdn.microsoft.com/library/windows/apps/BR205859) event.</span></span> <span data-ttu-id="653e3-187">アプリ再開時の変数とオブジェクトは、アプリが中断された時とまったく同じ状態です。</span><span class="sxs-lookup"><span data-stu-id="653e3-187">When your app is resumed, variables and objects have the exact same state they had when the app was suspended.</span></span> <span data-ttu-id="653e3-188">アプリの中断と再開の間でデータまたはオブジェクトが変更されている可能性があり、それらの更新が必要な場合にのみ **Resuming** イベントを処理してください。この状況としては、コンテンツ (更新フィード データなど) やネットワーク接続が無効になった場合や、デバイス (Web カメラなど) へのアクセスを再取得する必要がある場合が考えられます。</span><span class="sxs-lookup"><span data-stu-id="653e3-188">Handle the **Resuming** event only if you need to update data or objects that might have changed between the time your app was suspended and when it was resumed such as: content (for example, update feed data), network connections that may have gone stale, or if you need to reacquire access to a device (for example, a webcam).</span></span>

## <a name="related-topics"></a><span data-ttu-id="653e3-189">関連トピック</span><span class="sxs-lookup"><span data-stu-id="653e3-189">Related topics</span></span>

* [<span data-ttu-id="653e3-190">アプリの中断と再開のガイドライン</span><span class="sxs-lookup"><span data-stu-id="653e3-190">Guidelines for app suspend and resume</span></span>](https://msdn.microsoft.com/library/windows/apps/Hh465088)
 

 




