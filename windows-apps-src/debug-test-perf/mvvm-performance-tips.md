---
ms.assetid: 159681E4-BF9E-4A57-9FEE-EC7ED0BEFFAD
title: MVVM と言語のパフォーマンスに関するヒント
description: このトピックでは、ソフトウェアの設計パターンとプログラミング言語の選択に関連するいくつかのパフォーマンスの考慮事項について説明します。
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 9027362eccfb8130b181bee26a57f13ce1e1af66
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2019
ms.locfileid: "57621767"
---
# <a name="mvvm-and-language-performance-tips"></a><span data-ttu-id="d8808-104">MVVM と言語のパフォーマンスに関するヒント</span><span class="sxs-lookup"><span data-stu-id="d8808-104">MVVM and language performance tips</span></span>


<span data-ttu-id="d8808-105">このトピックでは、ソフトウェアの設計パターンとプログラミング言語の選択に関連するいくつかのパフォーマンスの考慮事項について説明します。</span><span class="sxs-lookup"><span data-stu-id="d8808-105">This topic discusses some performance considerations related to your choice of software design patterns, and programming language.</span></span>

## <a name="the-model-view-viewmodel-mvvm-pattern"></a><span data-ttu-id="d8808-106">Model-View-ViewModel (MVVM) パターン</span><span class="sxs-lookup"><span data-stu-id="d8808-106">The Model-View-ViewModel (MVVM) pattern</span></span>

<span data-ttu-id="d8808-107">Model-View-ViewModel (MVVM) パターンは、多くの XAML アプリで共通です </span><span class="sxs-lookup"><span data-stu-id="d8808-107">The Model-View-ViewModel (MVVM) pattern is common in a lot of XAML apps.</span></span> <span data-ttu-id="d8808-108">(MVVM は、Fowler の Model-View-Presenter パターンの説明によく似ていますが、これは XAML に合わせて調整されました)。</span><span class="sxs-lookup"><span data-stu-id="d8808-108">(MVVM is very similar to Fowler’s description of the Model-View-Presenter pattern, but it is tailored to XAML).</span></span> <span data-ttu-id="d8808-109">MVVM パターンの問題は、このパターンが原因となり、誤ってアプリのレイヤーおよび割り当てが過剰になる可能性があることです。</span><span class="sxs-lookup"><span data-stu-id="d8808-109">The issue with the MVVM pattern is that it can inadvertently lead to apps that have too many layers and too many allocations.</span></span> <span data-ttu-id="d8808-110">MVVM を使用する利点は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="d8808-110">The motivations for MVVM are these.</span></span>

-   <span data-ttu-id="d8808-111">**問題の分離**。</span><span class="sxs-lookup"><span data-stu-id="d8808-111">**Separation of concerns**.</span></span> <span data-ttu-id="d8808-112">問題を細かく分割することは常に有用であり、MVVM や MVC などのパターンは、アプリ (または 1 つのコントロール) を、実際のビュー、ビューの論理モデル (ビュー モデル)、ビューに依存しないアプリのロジック (モデル) に細かく分割するための方法です。</span><span class="sxs-lookup"><span data-stu-id="d8808-112">It’s always helpful to divide a problem into smaller pieces, and a pattern like MVVM or MVC is a way to divide an app (or even a single control) into smaller pieces: the actual view, a logical model of the view (view-model), and the view-independent app logic (the model).</span></span> <span data-ttu-id="d8808-113">具体的には、設計者は 1 つのツールを使ってビューを所有する、開発者は別のツールを使ってモデルを所有する、デザイン インテグレーターは両方のツールを使ってビュー モデルを所有することが、一般的なワークフローです。</span><span class="sxs-lookup"><span data-stu-id="d8808-113">In particular, it’s a popular workflow to have designers own the view using one tool, developers own the model using another tool, and design integrators own the view-model using both tools.</span></span>
-   <span data-ttu-id="d8808-114">**単体テスト**。</span><span class="sxs-lookup"><span data-stu-id="d8808-114">**Unit testing**.</span></span> <span data-ttu-id="d8808-115">ビューに依存せずに、つまりウィンドウの作成や入力の促進などに依存せずに、ビュー モデル (および結果としてモデル) の単体テストを実行できます。</span><span class="sxs-lookup"><span data-stu-id="d8808-115">You can unit test the view-model (and consequently the model) independent of the view, thereby not relying on creating windows, driving input, and so on.</span></span> <span data-ttu-id="d8808-116">ビューを小さく保つことにより、ウィンドウを作成することなく、アプリの大部分をテストできます。</span><span class="sxs-lookup"><span data-stu-id="d8808-116">By keeping the view small, you can test a large portion of your app without ever having to create a window.</span></span>
-   <span data-ttu-id="d8808-117">**ユーザー エクスペリエンスの変化に対する機敏性**。</span><span class="sxs-lookup"><span data-stu-id="d8808-117">**Agility to user experience changes**.</span></span> <span data-ttu-id="d8808-118">ユーザー エクスペリエンスがエンド ユーザーからのフィードバックに基づいて調整されるため、ビューは最も頻繁に変更され、最新の変更が加えられる傾向があります。</span><span class="sxs-lookup"><span data-stu-id="d8808-118">The view tends to see the most frequent changes, and the most late changes, as the user experience is tweaked based on end-user feedback.</span></span> <span data-ttu-id="d8808-119">ビューを分離しておくことにより、これらの変更に、より迅速に、アプリへの影響を抑えて対応することができます。</span><span class="sxs-lookup"><span data-stu-id="d8808-119">By keeping the view separate, these changes can be accommodated more quickly and with less churn to the app.</span></span>

<span data-ttu-id="d8808-120">MVVM パターンには、複数の具体的な定義と、それを実装するためのサード パーティのフレームワークがあります。</span><span class="sxs-lookup"><span data-stu-id="d8808-120">There are multiple concrete definitions of the MVVM pattern, and 3rd party frameworks that help implement it.</span></span> <span data-ttu-id="d8808-121">ただし、パターンのすべてのバリエーションに厳密に準拠すると、アプリのオーバーヘッドが必要以上に増大します。</span><span class="sxs-lookup"><span data-stu-id="d8808-121">But strict adherence to any variation of the pattern can lead to apps with a lot more overhead than can be justified.</span></span>

-   <span data-ttu-id="d8808-122">XAML データ バインディング ({Binding} マークアップ拡張) は、1 つにはモデル/ビュー パターンを有効にするために設計されました。</span><span class="sxs-lookup"><span data-stu-id="d8808-122">XAML data binding (the {Binding} markup extension) was designed in part to enable model/view patterns.</span></span> <span data-ttu-id="d8808-123">{Binding} により、重大なワーキング セットと CPU オーバーヘッドが生じます。</span><span class="sxs-lookup"><span data-stu-id="d8808-123">But {Binding} brings with it non-trivial working set and CPU overhead.</span></span> <span data-ttu-id="d8808-124">{Binding} を作成すると一連の割り当てが行われるほか、バインディング ターゲットの更新がリフレクションやボックス化の原因となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d8808-124">Creating a {Binding} causes a series of allocations, and updating a binding target can cause reflection and boxing.</span></span> <span data-ttu-id="d8808-125">これらの問題は、ビルド時にバインディングをコンパイルする、{x:Bind} マークアップ拡張によって対処されています。</span><span class="sxs-lookup"><span data-stu-id="d8808-125">These problems are being addressed with the {x:Bind} markup extension, which compiles the bindings at build time.</span></span> <span data-ttu-id="d8808-126">**推奨事項:** {x:Bind} を使用します。</span><span class="sxs-lookup"><span data-stu-id="d8808-126">**Recommendation:** use {x:Bind}.</span></span>
-   <span data-ttu-id="d8808-127">MVVM では、一般的な DelegateCommand または RelayCommand ヘルパーなどの ICommand を使用して、ビュー モデルに Button.Click を接続することが一般的です。</span><span class="sxs-lookup"><span data-stu-id="d8808-127">It’s popular in MVVM to connect Button.Click to the view-model using an ICommand, such as the common DelegateCommand or RelayCommand helpers.</span></span> <span data-ttu-id="d8808-128">ただし、これらのコマンドは、CanExecuteChanged イベント リスナー、ワーキング セットの増加、ページの起動/ナビゲーション時間の増加など、余分な割り当てとなります。</span><span class="sxs-lookup"><span data-stu-id="d8808-128">Those commands are extra allocations, though, including the CanExecuteChanged event listener, adding to the working set, and adding to the startup/navigation time for the page.</span></span> <span data-ttu-id="d8808-129">**推奨事項:** 便利な ICommand インターフェイスを使用する代わりに、分離コードでイベント ハンドラーを配置して、ビュー イベントに添付することを検討してくださいし、それらのイベントが発生したときに、ビュー モデルのコマンドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d8808-129">**Recommendation:** As an alternative to using the convenient ICommand interface, consider putting event handlers in your code-behind and attaching them to the view events and call a command on your view-model when those events are raised.</span></span> <span data-ttu-id="d8808-130">コマンドが利用できない場合、ボタンを無効にするコードを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d8808-130">You'll also need to add extra code to disable the Button when the command is unavailable.</span></span>
-   <span data-ttu-id="d8808-131">MVVM では、UI の使用可能なすべての構成でページを作成し、Visibility プロパティを VM でのプロパティにバインドすることによって、ツリーの一部を折りたたむことが一般的です。</span><span class="sxs-lookup"><span data-stu-id="d8808-131">It’s popular in MVVM to create a Page with all possible configurations of the UI, then collapse parts of the tree by binding the Visibility property to properties in the VM.</span></span> <span data-ttu-id="d8808-132">これにより、起動時間と、場合によってはワーキング セットが不必要に増加します (ツリーの一部は表示されない可能性があるため)。</span><span class="sxs-lookup"><span data-stu-id="d8808-132">This adds unnecessarily to startup time and possibly to working set (because some parts of the tree may never become visible).</span></span> <span data-ttu-id="d8808-133">**推奨事項:** 使用して、 [x: 負荷属性](../xaml-platform/x-load-attribute.md)または[x: DeferLoadStrategy 属性](../xaml-platform/x-deferloadstrategy-attribute.md)スタートアップからツリーの不要な部分を遅延させる機能。</span><span class="sxs-lookup"><span data-stu-id="d8808-133">**Recommendations:** Use the [x:Load attribute](../xaml-platform/x-load-attribute.md) or [x:DeferLoadStrategy attribute](../xaml-platform/x-deferloadstrategy-attribute.md) feature to defer unnecessary portions of the tree out of startup.</span></span> <span data-ttu-id="d8808-134">また、ページのさまざまなモードについて個別のユーザー コントロールを作成し、分離コードを使って必要なコントロールのみを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="d8808-134">Also, create separate user controls for the different modes of the page and use code-behind to keep only the necessary controls loaded.</span></span>

## <a name="ccx-recommendations"></a><span data-ttu-id="d8808-135">C++/CX の推奨事項</span><span class="sxs-lookup"><span data-stu-id="d8808-135">C++/CX recommendations</span></span>

-   <span data-ttu-id="d8808-136">**最新バージョンを使います**。</span><span class="sxs-lookup"><span data-stu-id="d8808-136">**Use the latest version**.</span></span> <span data-ttu-id="d8808-137">C++/CX コンパイラは継続的にパフォーマンスが向上しています。</span><span class="sxs-lookup"><span data-stu-id="d8808-137">There are continual performance improvements made to the C++/CX compiler.</span></span> <span data-ttu-id="d8808-138">アプリが最新のツールセットを使ってビルドされていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="d8808-138">Ensure your app is building using the latest toolset.</span></span>
-   <span data-ttu-id="d8808-139">**RTTI (/GR-) を無効にします**。</span><span class="sxs-lookup"><span data-stu-id="d8808-139">**Disable RTTI (/GR-)**.</span></span> <span data-ttu-id="d8808-140">RTTI はコンパイラで既定でオンになっているため、ビルド環境でオフにしない限り、RTTI を使用している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d8808-140">RTTI is on by default in the compiler so, unless your build environment switches it off, you’re probably using it.</span></span> <span data-ttu-id="d8808-141">RTTI には大きなオーバーヘッドがあるため、コードが RTTI に大きく依存していない限り、オフにしてください。</span><span class="sxs-lookup"><span data-stu-id="d8808-141">RTTI has significant overhead, and unless your code has a deep dependency on it, you should turn it off.</span></span> <span data-ttu-id="d8808-142">XAML フレームワークには、コードで RTTI を使用するという要件はありません。</span><span class="sxs-lookup"><span data-stu-id="d8808-142">The XAML framework has no requirement that your code use RTTI.</span></span>
-   <span data-ttu-id="d8808-143">**ppltasks を使いすぎないようにします**。</span><span class="sxs-lookup"><span data-stu-id="d8808-143">**Avoid heavy use of ppltasks**.</span></span> <span data-ttu-id="d8808-144">ppltasks は、非同期 WinRT API を呼び出すときに非常に便利ですが、重大なコード サイズのオーバーヘッドが生じます。</span><span class="sxs-lookup"><span data-stu-id="d8808-144">Ppltasks are very convenient when calling async WinRT APIs, but they come with significant code size overhead.</span></span> <span data-ttu-id="d8808-145">C++/CX チームは、パフォーマンスを大幅に向上させる言語機能 (await) の開発を進めています。</span><span class="sxs-lookup"><span data-stu-id="d8808-145">The C++/CX team is working on a language feature – await – that will provide much better performance.</span></span> <span data-ttu-id="d8808-146">当面の間、コードのホット パスでの ppltasks の使用を調整してください。</span><span class="sxs-lookup"><span data-stu-id="d8808-146">In the meantime, balance your use of ppltasks in the hot paths of your code.</span></span>
-   <span data-ttu-id="d8808-147">**アプリの "ビジネス ロジック" での C++/CX の使用を避けます**。</span><span class="sxs-lookup"><span data-stu-id="d8808-147">**Avoid use of C++/CX in the “business logic” of your app**.</span></span> <span data-ttu-id="d8808-148">C++/CX は、C++ アプリから WinRT API にアクセスするための便利な方法として設計されています。</span><span class="sxs-lookup"><span data-stu-id="d8808-148">C++/CX is designed to be a convenient way to access WinRT APIs from C++ apps.</span></span> <span data-ttu-id="d8808-149">これは、オーバーヘッドがあるラッパーを利用します。</span><span class="sxs-lookup"><span data-stu-id="d8808-149">It makes use of wrappers that have overhead.</span></span> <span data-ttu-id="d8808-150">クラスのビジネス ロジック/モデル内で C++/CX を使用することを避け、コードと WinRT の間の境界で使用するために予約しておきます。</span><span class="sxs-lookup"><span data-stu-id="d8808-150">You should avoid C++/CX inside the business logic/model of your class, and reserve it for use at the boundaries between your code and WinRT.</span></span>