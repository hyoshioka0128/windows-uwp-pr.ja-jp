---
author: jwmsft
ms.assetid: F912161D-3767-4F35-88C0-E1ECDED692A2
title: ガベージ コレクションのパフォーマンスの向上
description: C# と Visual Basic で記述されたユニバーサル Windows プラットフォーム (UWP) アプリは、.NET ガベージ コレクターによって、自動的にメモリ管理が行われます。 このセクションでは、UWP アプリでの .NET ガーベジ コレクターの動作とパフォーマンスに関するベスト プラクティスについて説明します。
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, UWP
ms.openlocfilehash: 3b7dfb274c5a6d55204a467fc894bac5fd044048
ms.sourcegitcommit: ec18e10f750f3f59fbca2f6a41bf1892072c3692
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/14/2017
ms.locfileid: "894646"
---
# <a name="improve-garbage-collection-performance"></a><span data-ttu-id="72ecc-105">ガベージ コレクションのパフォーマンスの向上</span><span class="sxs-lookup"><span data-stu-id="72ecc-105">Improve garbage collection performance</span></span>

<span data-ttu-id="72ecc-106">\[Windows 10 の UWP アプリ向けに更新。</span><span class="sxs-lookup"><span data-stu-id="72ecc-106">\[ Updated for UWP apps on Windows 10.</span></span> <span data-ttu-id="72ecc-107">Windows 8.x の記事については、[アーカイブ](http://go.microsoft.com/fwlink/p/?linkid=619132)をご覧ください \]</span><span class="sxs-lookup"><span data-stu-id="72ecc-107">For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \]</span></span>

<span data-ttu-id="72ecc-108">C# と Visual Basic で記述されたユニバーサル Windows プラットフォーム (UWP) アプリは、.NET ガベージ コレクターによって、自動的にメモリ管理が行われます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-108">Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</span></span> <span data-ttu-id="72ecc-109">このセクションでは、UWP アプリでの .NET ガーベジ コレクターの動作とパフォーマンスに関するベスト プラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-109">This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</span></span> <span data-ttu-id="72ecc-110">.NET ガーベジ コレクターのしくみと、ガーベジ コレクターのパフォーマンスをデバッグおよび分析するためのツールについて詳しくは、「[ガベージ コレクション](https://msdn.microsoft.com/library/windows/apps/xaml/0xy59wtx.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="72ecc-110">For more info on how the .NET garbage collector works and tools for debugging and analyzing garbage collector performance, see [Garbage collection](https://msdn.microsoft.com/library/windows/apps/xaml/0xy59wtx.aspx).</span></span>

<span data-ttu-id="72ecc-111">**注**  ガベージ コレクターの既定の動作に介入が必要な場合、アプリに関して一般的なメモリの問題があることを強く示唆しています。</span><span class="sxs-lookup"><span data-stu-id="72ecc-111">**Note**  Needing to intervene in the default behavior of the garbage collector is strongly indicative of general memory issues with your app.</span></span> <span data-ttu-id="72ecc-112">詳しくは、「[Memory Usage Tool while debugging in Visual Studio 2015 (Visual Studio でのユーザー モード デバッグの設定)](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="72ecc-112">For more info, see [Memory Usage Tool while debugging in Visual Studio 2015](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx).</span></span> <span data-ttu-id="72ecc-113">このトピックは、C# と Visual Basic にのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-113">This topic applies to C# and Visual Basic only.</span></span>

 

<span data-ttu-id="72ecc-114">ガーベジ コレクターは、ガベージ コレクションで実行する必要がある作業の量とマネージ ヒープのメモリ消費量とのバランスを考慮して、実行するタイミングを決めます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-114">The garbage collector determines when to run by balancing the memory consumption of the managed heap with the amount of work a garbage collection needs to do.</span></span> <span data-ttu-id="72ecc-115">ガーベジ コレクターがこの処理を行う方法の 1 つとして、ヒープをジェネレーション別に分け、ほとんどの場合はヒープの一部のみのコレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-115">One of the ways the garbage collector does this is by dividing the heap into generations and collecting only part of the heap most of the time.</span></span> <span data-ttu-id="72ecc-116">マネージ ヒープには、次の 3 つのジェネレーションがあります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-116">There are three generations in the managed heap:</span></span>

-   <span data-ttu-id="72ecc-117">ジェネレーション 0。</span><span class="sxs-lookup"><span data-stu-id="72ecc-117">Generation 0.</span></span> <span data-ttu-id="72ecc-118">このジェネレーションには、新しく割り当てられた、85 KB 未満のオブジェクトが含まれます。85 KB 以上のオブジェクトは、大きなオブジェクト ヒープに属します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-118">This generation contains newly allocated objects unless they are 85KB or larger, in which case they are part of the large object heap.</span></span> <span data-ttu-id="72ecc-119">大きなオブジェクト ヒープのコレクションは、ジェネレーション 2 のコレクション時に行われます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-119">The large object heap is collected with generation 2 collections.</span></span> <span data-ttu-id="72ecc-120">ジェネレーション 0 のコレクションは最も頻繁に行われ、ローカル変数などの有効期間が短いオブジェクトをクリーンアップします。</span><span class="sxs-lookup"><span data-stu-id="72ecc-120">Generation 0 collections are the most frequently occurring type of collection and clean up short-lived objects such as local variables.</span></span>
-   <span data-ttu-id="72ecc-121">ジェネレーション 1。</span><span class="sxs-lookup"><span data-stu-id="72ecc-121">Generation 1.</span></span> <span data-ttu-id="72ecc-122">このジェネレーションには、ジェネレーション 0 のコレクションの後に残ったオブジェクトが含まれます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-122">This generation contains objects that have survived generation 0 collections.</span></span> <span data-ttu-id="72ecc-123">このジェネレーションは、ジェネレーション 0 とジェネレーション 2 の間のバッファーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-123">It serves as a buffer between generation 0 and generation 2.</span></span> <span data-ttu-id="72ecc-124">ジェネレーション 1 のコレクションは、ジェネレーション 0 のコレクションよりも発生頻度が低く、前のジェネレーション 0 のコレクション時にアクティブだった一時オブジェクトをクリーンアップします。</span><span class="sxs-lookup"><span data-stu-id="72ecc-124">Generation 1 collections occur less frequently than generation 0 collections and clean up temporary objects that were active during previous generation 0 collections.</span></span> <span data-ttu-id="72ecc-125">ジェネレーション 1 のコレクション時には、ジェネレーション 0 のコレクションも実行されます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-125">A generation 1 collection also collects generation 0.</span></span>
-   <span data-ttu-id="72ecc-126">ジェネレーション 2。</span><span class="sxs-lookup"><span data-stu-id="72ecc-126">Generation 2.</span></span> <span data-ttu-id="72ecc-127">このジェネレーションには、ジェネレーション 0 とジェネレーション 1 のコレクションの後に残った、有効期間が長いオブジェクトが含まれます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-127">This generation contains long-lived objects that have survived generation 0 and generation 1 collections.</span></span> <span data-ttu-id="72ecc-128">ジェネレーション 2 のコレクションは最も頻度が低く、85 KB 以上のオブジェクトを含む大きなオブジェクト ヒープなど、マネージ ヒープ全体のコレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-128">Generation 2 collections are the least frequent and collect the entire managed heap, including the large object heap which contains objects that are 85KB or larger.</span></span>

<span data-ttu-id="72ecc-129">ガベージ コレクターのパフォーマンスは、ガベージ コレクションの実行にかかる時間とマネージ ヒープのメモリ消費量という 2 つの側面から測定できます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-129">You can measure the performance of the garbage collector in 2 aspects: the time it takes to do the garbage collection, and the memory consumption of the managed heap.</span></span> <span data-ttu-id="72ecc-130">ヒープ サイズが 100 MB 未満の小規模なアプリの場合は、メモリ消費量の削減に重点を置きます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-130">If you have a small app with a heap size less than 100MB then focus on reducing memory consumption.</span></span> <span data-ttu-id="72ecc-131">アプリのマネージ ヒープが 100 MB を超える場合は、ガベージ コレクションの実行時間の短縮にのみ重点を置きます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-131">If you have an app with a managed heap larger than 100MB then focus on reducing the garbage collection time only.</span></span> <span data-ttu-id="72ecc-132">以下に .NET ガベージ コレクターのパフォーマンスを向上させる方法を紹介します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-132">Here's how you can help the .NET garbage collector achieve better performance.</span></span>

## <a name="reduce-memory-consumption"></a><span data-ttu-id="72ecc-133">メモリ消費量の削減</span><span class="sxs-lookup"><span data-stu-id="72ecc-133">Reduce memory consumption</span></span>

### <a name="release-references"></a><span data-ttu-id="72ecc-134">関連情報</span><span class="sxs-lookup"><span data-stu-id="72ecc-134">Release references</span></span>

<span data-ttu-id="72ecc-135">アプリ内でオブジェクトを参照している場合は、そのオブジェクトと、そのオブジェクトが参照するすべてのオブジェクトのコレクションが行われません。</span><span class="sxs-lookup"><span data-stu-id="72ecc-135">A reference to an object in your app prevents that object, and all of the objects it references, from being collected.</span></span> <span data-ttu-id="72ecc-136">.NET コンパイラは、変数が使われなくなったときにうまく削除を行うため、その変数によって保持されているオブジェクトがコレクションの対象になります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-136">The .NET compiler does a good job of detecting when a variable is no longer in use so objects held onto by that variable will be eligible for collection.</span></span> <span data-ttu-id="72ecc-137">しかし、アプリで使っているライブラリによってオブジェクト グラフの一部が所有されている場合があるため、あるオブジェクトが別のオブジェクトを参照しているかどうかがわからないことがあります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-137">But in some cases it may not be obvious that some objects have a reference to other objects because part of the object graph might be owned by libraries your app uses.</span></span> <span data-ttu-id="72ecc-138">ガベージ コレクションの後に残るオブジェクトを調べるツールと方法については、「[ガベージ コレクションとパフォーマンス](https://msdn.microsoft.com/library/windows/apps/xaml/ee851764.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="72ecc-138">To learn about the tools and techniques to find out which objects survive a garbage collection, see [Garbage collection and performance](https://msdn.microsoft.com/library/windows/apps/xaml/ee851764.aspx).</span></span>

### <a name="induce-a-garbage-collection-if-its-useful"></a><span data-ttu-id="72ecc-139">必要に応じたガベージ コレクションの実行</span><span class="sxs-lookup"><span data-stu-id="72ecc-139">Induce a garbage collection if it’s useful</span></span>

<span data-ttu-id="72ecc-140">アプリのパフォーマンスを測定し、コレクションを実行することでパフォーマンスが向上すると判断した場合にのみ、ガベージ コレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-140">Induce a garbage collection only after you have measured your app's performance and have determined that inducing a collection will improve its performance.</span></span>

<span data-ttu-id="72ecc-141">[**GC.Collect(n)**](https://msdn.microsoft.com/library/windows/apps/xaml/y46kxc5e.aspx) を呼び出すと、ジェネレーション別にガベージ コレクションを実行できます。n には、コレクションを実行するジェネレーション (0、1、または 2) を指定します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-141">You can induce a garbage collection of a generation by calling [**GC.Collect(n)**](https://msdn.microsoft.com/library/windows/apps/xaml/y46kxc5e.aspx), where n is the generation you want to collect (0, 1, or 2).</span></span>

<span data-ttu-id="72ecc-142">**注**  アプリでは、ガベージ コレクションを強制的に実行しないでください。ガーベジ コレクターはコレクションの実行に最も適したタイミングを判断するためにさまざまなヒューリスティックを使うため、コレクションを強制的に実行すると、多くの場合は CPU が不必要に使われます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-142">**Note**  We recommend that you don't force a garbage collection in your app because the garbage collector uses many heuristics to determine the best time to perform a collection, and forcing a collection is in many cases an unnecessary use of the CPU.</span></span> <span data-ttu-id="72ecc-143">ただし、アプリ内のたくさんのオブジェクトが使われなくなることがわかっており、そのメモリをシステムに返す必要がある場合は、ガベージ コレクションを強制的に実行してもかまいません。</span><span class="sxs-lookup"><span data-stu-id="72ecc-143">But if you know that you have a large number of objects in your app that are no longer used and you want to return this memory to the system, then it may be appropriate to force a garbage collection.</span></span> <span data-ttu-id="72ecc-144">たとえば、ゲームの読み込みシーケンスの最後にコレクションを実行すると、ゲームプレイが始まる前にメモリを解放できます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-144">For example, you can induce a collection at the end of a loading sequence in a game to free up memory before gameplay starts.</span></span>
 
<span data-ttu-id="72ecc-145">ガベージ コレクションが誤って何度も実行されないようにするには、[**GCCollectionMode**](https://msdn.microsoft.com/library/windows/apps/xaml/bb495757.aspx) を **Optimized** に設定します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-145">To avoid inadvertently inducing too many garbage collections, you can set the [**GCCollectionMode**](https://msdn.microsoft.com/library/windows/apps/xaml/bb495757.aspx) to **Optimized**.</span></span> <span data-ttu-id="72ecc-146">これにより、コレクションが妥当で生産的であると判断した場合にのみ、ガベージ コレクターがコレクションを開始するようになります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-146">This instructs the garbage collector to start a collection only if it determines that the collection would be productive enough to be justified.</span></span>

## <a name="reduce-garbage-collection-time"></a><span data-ttu-id="72ecc-147">ガベージ コレクションの実行時間の短縮</span><span class="sxs-lookup"><span data-stu-id="72ecc-147">Reduce garbage collection time</span></span>

<span data-ttu-id="72ecc-148">このセクションは、アプリを分析済みで、長いガベージ コレクションの実行時間を確認した場合を対象としています。</span><span class="sxs-lookup"><span data-stu-id="72ecc-148">This section applies if you've analyzed your app and observed large garbage collection times.</span></span> <span data-ttu-id="72ecc-149">ガベージ コレクションに関連した停止時間には、次のような時間があります: 1 回のガベージ コレクションの実行にかかる時間。アプリでのガベージ コレクションの合計実行時間。</span><span class="sxs-lookup"><span data-stu-id="72ecc-149">Garbage collection-related pause times include: the time it takes to run a single garbage collection pass; and the total time your app spends doing garbage collections.</span></span> <span data-ttu-id="72ecc-150">コレクションの実行にかかる時間は、コレクターが分析する必要があるライブ データの量によって決まります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-150">The amount of time it takes to do a collection depends on how much live data the collector has to analyze.</span></span> <span data-ttu-id="72ecc-151">ジェネレーション 0 とジェネレーション 1 はサイズで制限されていますが、ジェネレーション 2 は、アプリ内の有効期間が長いアクティブなオブジェクトが増えると、増え続けます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-151">Generation 0 and generation 1 are bounded in size, but generation 2 continues to grow as more long-lived objects are active in your app.</span></span> <span data-ttu-id="72ecc-152">そのため、ジェネレーション 0 とジェネレーション 1 のコレクションの実行時間には限度がありますが、ジェネレーション 2 のコレクションの実行時間は長くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-152">This means that the collection times for generation 0 and generation 1 are bounded, while generation 2 collections can take longer.</span></span> <span data-ttu-id="72ecc-153">ガベージ コレクションでは、メモリの割り当て要求を満たすためにメモリを解放します。そのため、ガベージ コレクションの実行頻度は、通常、割り当てるメモリの量によって決まります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-153">How often garbage collections run depends mostly on how much memory you allocate, because a garbage collection frees up memory to satisfy allocation requests.</span></span>

<span data-ttu-id="72ecc-154">ガーベジ コレクターは処理を実行するためにアプリを一時停止することがありますが、コレクションを実行している間ずっとアプリを停止するわけではありません。</span><span class="sxs-lookup"><span data-stu-id="72ecc-154">The garbage collector occasionally pauses your app to perform work, but doesn't necessarily pause your app the entire time it is doing a collection.</span></span> <span data-ttu-id="72ecc-155">特にジェネレーション 0 とジェネレーション 1 のコレクションの場合は、通常、アプリが停止したことにユーザーは気が付きません。</span><span class="sxs-lookup"><span data-stu-id="72ecc-155">Pause times are usually not user-perceivable in your app, especially for generation 0 and generation 1 collections.</span></span> <span data-ttu-id="72ecc-156">.NET ガーベジ コレクターの[バックグラウンド ガベージ コレクション](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection)機能を使うと、アプリを実行しているときに、ジェネレーション 2 のコレクションを同時に実行でき、アプリの停止時間が短くなります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-156">The [Background garbage collection](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection) feature of the .NET garbage collector allows Generation 2 collections to be performed concurrently while your app is running and will only pause your app for short periods of time.</span></span> <span data-ttu-id="72ecc-157">ただし、常にジェネレーション 2 のコレクションをバックグラウンド コレクションとして実行できるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="72ecc-157">But it is not always possible to do a Generation 2 collection as a background collection.</span></span> <span data-ttu-id="72ecc-158">その場合は、ヒープがかなり大きい (100 MB を超えている) と、停止したことにユーザーが気付く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-158">In that case, the pause can be user-perceivable if you have a large enough heap (more than 100MB).</span></span>

<span data-ttu-id="72ecc-159">ガベージ コレクションが頻繁に行われると、アプリでの CPU (と電力) 消費量の増加、読み込み時間の増加、またはフレーム レートの低下につながる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-159">Frequent garbage collections can contribute to increased CPU (and therefore power) consumption, longer loading times, or decreased frame rates in your application.</span></span> <span data-ttu-id="72ecc-160">次に、ガベージ コレクションの実行時間を短縮し、マネージ UWP アプリでのコレクションに関連した一時停止を減らすための手法をいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-160">Below are some techniques you can use to reduce garbage collection time and collection-related pauses in your managed UWP app.</span></span>

### <a name="reduce-memory-allocations"></a><span data-ttu-id="72ecc-161">割り当てるメモリの削減</span><span class="sxs-lookup"><span data-stu-id="72ecc-161">Reduce memory allocations</span></span>

<span data-ttu-id="72ecc-162">オブジェクトを割り当てていない場合は、システムでメモリ不足にならない限り、ガーベジ コレクターは実行されません。</span><span class="sxs-lookup"><span data-stu-id="72ecc-162">If you don’t allocate any objects then the garbage collector doesn’t run unless there is a low memory condition in the system.</span></span> <span data-ttu-id="72ecc-163">割り当てるメモリの量を減らすと、ガベージ コレクションの頻度を直接的に減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-163">Reducing the amount of memory you allocate directly translates to less frequent garbage collections.</span></span>

<span data-ttu-id="72ecc-164">アプリのどこかのセクションで一時停止するのが好ましくない場合は、パフォーマンスがあまり重視されないときに前もって必要なオブジェクトを割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-164">If in some sections of your app pauses are completely undesirable, then you can pre-allocate the necessary objects beforehand during a less performance-critical time.</span></span> <span data-ttu-id="72ecc-165">たとえば、ゲームでは、レベルの読み込み画面を表示している間にゲームプレイに必要なすべてのオブジェクトを割り当て、ゲームプレイ中は割り当てを行わないようにします。</span><span class="sxs-lookup"><span data-stu-id="72ecc-165">For example, a game might allocate all of the objects needed for gameplay during the loading screen of a level and not make any allocations during gameplay.</span></span> <span data-ttu-id="72ecc-166">こうすることで、ユーザーがゲームをプレイしているときに一時停止することがなくなり、その結果、フレーム レートの速度と一貫性を向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-166">This avoids pauses while the user is playing the game and can result in a higher and more consistent frame rate.</span></span>

### <a name="reduce-generation-2-collections-by-avoiding-objects-with-a-medium-length-lifetime"></a><span data-ttu-id="72ecc-167">有効期間が中程度のオブジェクトの回避によるジェネレーション 2 のコレクションの削減</span><span class="sxs-lookup"><span data-stu-id="72ecc-167">Reduce generation 2 collections by avoiding objects with a medium-length lifetime</span></span>

<span data-ttu-id="72ecc-168">ジェネレーション別のガベージ コレクションは、アプリ内のオブジェクトの有効期間が実際に短いか長い場合に最も効果を発揮します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-168">Generational garbage collections perform best when you have really short-lived and/or really long-lived objects in your app.</span></span> <span data-ttu-id="72ecc-169">有効期間が短いオブジェクトのコレクションは負荷の少ないジェネレーション 0 とジェネレーション 1 で実行され、有効期間が長いオブジェクトは頻繁にコレクションが実行されないジェネレーション 2 に昇格します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-169">Short lived objects are collected in the cheaper generation 0 and generation 1 collections, and objects that are long-lived get promoted to generation 2, which is collected infrequently.</span></span> <span data-ttu-id="72ecc-170">有効期間が長いオブジェクトとは、アプリの有効期間全体または特定のページやゲーム レベルなどで長期間使われるオブジェクトのことです。</span><span class="sxs-lookup"><span data-stu-id="72ecc-170">Long-lived objects are those that are in use for the entire duration of your app, or during a significant period of your app, such as during a specific page or game level.</span></span>

<span data-ttu-id="72ecc-171">有効期間が一時的であっても長いオブジェクトは、ジェネレーション 2 に昇格します。そのため、そうしたオブジェクトを頻繁に作成すると、負荷の高いジェネレーション 2 のコレクションが多く発生します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-171">If you frequently create objects that have a temporary lifetime but live long enough to be promoted to generation 2, then more of the expensive generation 2 collections happen.</span></span> <span data-ttu-id="72ecc-172">ジェネレーション 2 のコレクションを減らすには、既に存在するオブジェクトをリサイクルするか、オブジェクトをもっと早く解放します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-172">You may be able to reduce generation 2 collections by recycling existing objects or releasing objects more quickly.</span></span>

<span data-ttu-id="72ecc-173">有効期間が中程度のオブジェクトの一般的な例としては、ユーザーがスクロールする一覧に項目を表示するために使われるオブジェクトがあります。</span><span class="sxs-lookup"><span data-stu-id="72ecc-173">A common example of objects with medium-term lifetime is objects that are used for displaying items in a list that a user scrolls through.</span></span> <span data-ttu-id="72ecc-174">一覧の項目がスクロールによって表示されるときにオブジェクトが作成され、一覧の項目がスクロールによって表示されなくなったときにオブジェクトが参照されなくなる場合は、通常、アプリでジェネレーション 2 のコレクションが大量に発生します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-174">If objects are created when items in the list are scrolled into view, and are no longer referenced as items in the list are scrolled out of view, then your app typically has a large number of generation 2 collections.</span></span> <span data-ttu-id="72ecc-175">このような場合は、ユーザーにアクティブに表示されるデータに対して一連のオブジェクトを事前に割り当て、それらを再利用し、一覧の項目が表示されるときに有効期間が短いオブジェクトを使って情報を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-175">In situations like this you can pre-allocate and reuse a set of objects for the data that is actively shown to the user, and use short-lived objects to load info as items in the list come into view.</span></span>

### <a name="reduce-generation-2-collections-by-avoiding-large-sized-objects-with-short-lifetimes"></a><span data-ttu-id="72ecc-176">有効期間が短く、サイズが大きいオブジェクトの回避によるジェネレーション 2 のコレクションの削減</span><span class="sxs-lookup"><span data-stu-id="72ecc-176">Reduce generation 2 collections by avoiding large-sized objects with short lifetimes</span></span>

<span data-ttu-id="72ecc-177">85 KB 以上のオブジェクトは大きなオブジェクト ヒープ (LOH) に割り当てられ、ジェネレーション 2 の一部としてコレクションが実行されます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-177">Any object that is 85KB or larger is allocated on the large object heap (LOH) and gets collected as part of generation 2.</span></span> <span data-ttu-id="72ecc-178">バッファーなどの一時変数が 85 KB を超えている場合は、ジェネレーション 2 のコレクションでクリーンアップされます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-178">If you have temporary variables, such as buffers, that are greater than 85KB, then a generation 2 collection cleans them up.</span></span> <span data-ttu-id="72ecc-179">一時変数を 85 KB 未満に制限すると、アプリでのジェネレーション 2 のコレクションの回数が減少します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-179">Limiting temporary variables to less than 85KB reduces the number of generation 2 collections in your app.</span></span> <span data-ttu-id="72ecc-180">一般的な方法としては、バッファー プールを作成し、プールのオブジェクトを再利用して、サイズが大きい一時的な割り当てを回避します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-180">One common technique is to create a buffer pool and reuse objects from the pool to avoid large temporary allocations.</span></span>

### <a name="avoid-reference-rich-objects"></a><span data-ttu-id="72ecc-181">参照の多いオブジェクトの回避</span><span class="sxs-lookup"><span data-stu-id="72ecc-181">Avoid reference-rich objects</span></span>

<span data-ttu-id="72ecc-182">ガーベジ コレクターは、オブジェクト間の参照の追跡をアプリのルートから開始して、有効なオブジェクトを特定します。</span><span class="sxs-lookup"><span data-stu-id="72ecc-182">The garbage collector determines which objects are live by following references between objects, starting from roots in your app.</span></span> <span data-ttu-id="72ecc-183">詳しくは、「[ガベージ コレクションの実行時の動作](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="72ecc-183">For more info, see [What happens during a garbage collection](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection).</span></span> <span data-ttu-id="72ecc-184">オブジェクトに参照がたくさん含まれていると、ガーベジ コレクターの処理が増えます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-184">If an object contains many references, then there is more work for the garbage collector to do.</span></span> <span data-ttu-id="72ecc-185">一般的な手法としては (特に大きなオブジェクトの場合)、参照の多いオブジェクトを参照のないオブジェクトに変換します (たとえば、参照を保存する代わりに、インデックスを保存します)。</span><span class="sxs-lookup"><span data-stu-id="72ecc-185">A common technique (especially with large objects) is to convert reference rich objects into objects with no references (e.g., instead of storing a reference, store an index).</span></span> <span data-ttu-id="72ecc-186">当然、この手法を使うことができるのは、論理的に可能な場合に限られます。</span><span class="sxs-lookup"><span data-stu-id="72ecc-186">Of course this technique works only when it is logically possible to do so.</span></span>

<span data-ttu-id="72ecc-187">オブジェクト参照をインデックスに置き換えると、アプリに複雑な変更が加わり、混乱を招く可能性があります。また、この手法は、大きなオブジェクトに多数の参照が含まれている場合が最も効果的です。</span><span class="sxs-lookup"><span data-stu-id="72ecc-187">Replacing object references with indexes can be a disruptive and complicated change to your app and is most effective for large objects with a large number of references.</span></span> <span data-ttu-id="72ecc-188">アプリでのガベージ コレクションの実行時間の長さが、参照の多いオブジェクトに関連していることがわかっている場合にのみ行ってください。</span><span class="sxs-lookup"><span data-stu-id="72ecc-188">Do this only if you are noticing large garbage collection times in your app related to reference-heavy objects.</span></span>

 

 




