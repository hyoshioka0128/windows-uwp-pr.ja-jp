---
title: アプリの分析
description: アプリを分析してパフォーマンスの問題を調べます。
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: f1d37446cb5f540cd77928cb8167d8d4319977d1
ms.sourcegitcommit: 49d58bc66c1c9f2a4f81473bcb25af79e2b1088d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2018
ms.locfileid: "8945155"
---
# <a name="app-analysis-overview"></a><span data-ttu-id="0a7b2-104">アプリの分析の概要</span><span class="sxs-lookup"><span data-stu-id="0a7b2-104">App Analysis overview</span></span>

<span data-ttu-id="0a7b2-105">App Analysis は、パフォーマンスの問題を開発者に通知するツールです。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-105">App Analysis  is a tool that provides developers with a heads up notification of performance issues.</span></span> <span data-ttu-id="0a7b2-106">このツールでは、アプリのコードが実行され、一連のパフォーマンス ガイドラインとベスト プラクティスへの準拠が確認されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-106">App Analysis runs your app code against a set of performance guidelines and best practices.</span></span>

<span data-ttu-id="0a7b2-107">App Analysis は、アプリで発生する一般的なパフォーマンスの問題から成る規則セットに基づいて問題を特定します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-107">App Analysis identifies problems from a ruleset of common performance issues that apps run into.</span></span> <span data-ttu-id="0a7b2-108">また必要に応じて、調査の助けとなる Visual Studio のタイムライン ツール、ソース情報、ドキュメントを示します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-108">When appropriate, app analysis will point to Visual Studio's timeline tool, source information, and documentation to give you the means to investigate.</span></span>

<span data-ttu-id="0a7b2-109">App Analysis の規則とは、それに基づいてアプリがチェックされるガイドラインやベスト プラクティスを意味します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-109">Rules in App Analysis refer to a guideline or best practice that your app is being checked against.</span></span>

## <a name="decoded-image-size-larger-than-render-size"></a><span data-ttu-id="0a7b2-110">デコードされた画像サイズがレンダリング後のサイズよりも大きい</span><span class="sxs-lookup"><span data-stu-id="0a7b2-110">Decoded image size larger than render size</span></span>

<span data-ttu-id="0a7b2-111">画像を非常に高い解像度でキャプチャすると、アプリで画像データをデコードする際の CPU 負荷が大きくなり、ディスクから画像を読み込んだときに大容量のメモリが使用されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-111">Images are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk.</span></span> <span data-ttu-id="0a7b2-112">ただし、画像を元のサイズよりも小さいサイズでのみ表示する場合、高解像度の画像をデコードしてメモリに保存するのは無意味です。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-112">But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size.</span></span> <span data-ttu-id="0a7b2-113">この場合、DecodePixelWidth プロパティと DecodePixelHeight プロパティを使って、画面上に描画される正確なサイズのバージョンの画像を作成することができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-113">Instead, create a version of the image at the exact size it will be drawn on-screen using the DecodePixelWidth and DecodePixelHeight properties.</span></span>

### <a name="impact"></a><span data-ttu-id="0a7b2-114">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-114">Impact</span></span>

<span data-ttu-id="0a7b2-115">ネイティブでないサイズでの画像表示は、CPU 時間 (適正なサイズへのデコーディングとダウンロードに時間がかかるため) とメモリの両方に悪影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-115">Displaying images at their non-native sizes can negatively impact both CPU time (due to decoding to the proper size and download time) and memory.</span></span>

### <a name="causes-and-solutions"></a><span data-ttu-id="0a7b2-116">原因と解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-116">Causes and solutions</span></span>

#### <a name="image-is-not-being-set-asynchronously"></a><span data-ttu-id="0a7b2-117">画像が非同期に設定されていない</span><span class="sxs-lookup"><span data-stu-id="0a7b2-117">Image is not being set asynchronously</span></span>

<span data-ttu-id="0a7b2-118">アプリで、SetSourceAsync() ではなく SetSource() が使用されています。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-118">App is using SetSource() instead of SetSourceAsync().</span></span> <span data-ttu-id="0a7b2-119">画像を非同期にデコードするようにストリームを設定する場合は、[**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) ではなく [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) を使います。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-119">You should always avoid using [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) and instead use [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when setting a stream to decode images asynchronously.</span></span> 

#### <a name="image-is-being-called-when-the-imagesource-is-not-in-the-live-tree"></a><span data-ttu-id="0a7b2-120">ImageSource がライブ ツリーに存在しないときに画像を呼び出している</span><span class="sxs-lookup"><span data-stu-id="0a7b2-120">Image is being called when the ImageSource is not in the live tree</span></span>

<span data-ttu-id="0a7b2-121">BitmapImage は、SetSourceAsync または UriSource によってコンテンツを設定した後、ライブ XAML ツリーに接続されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-121">The BitmapImage is connected to the live XAML tree after setting the content with SetSourceAsync or UriSource.</span></span> <span data-ttu-id="0a7b2-122">必ずソースを設定する前に、[**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) をライブ ツリーに接続する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-122">You should always attach a [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) to the live tree before setting the source.</span></span> <span data-ttu-id="0a7b2-123">マークアップで画像要素またはブラシが指定されているときは、常にこのことが当てはまります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-123">Any time an image element or brush is specified in markup, this will automatically be the case.</span></span> <span data-ttu-id="0a7b2-124">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-124">Examples are provided below.</span></span> 

**<span data-ttu-id="0a7b2-125">ライブ ツリーの例</span><span class="sxs-lookup"><span data-stu-id="0a7b2-125">Live tree examples</span></span>**

<span data-ttu-id="0a7b2-126">例 1 (良い例): Uniform Resource Identifier (URI) をマークアップで指定。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-126">Example 1 (good)—Uniform Resource Identifier (URI) specified in markup.</span></span>

```xml
<Image x:Name="myImage" UriSource="Assets/cool-image.png"/>
```

<span data-ttu-id="0a7b2-127">例 2 マークアップ: 分離コードで指定された URI。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-127">Example 2 markup—URI specified in code-behind.</span></span>

```xml
<Image x:Name="myImage"/>
```

<span data-ttu-id="0a7b2-128">例 2 分離コード (良い例): UriSource を設定する前に、ツリーに BitmapImage を接続する。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-128">Example 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.</span></span>

```vb
var bitmapImage = new BitmapImage();
myImage.Source = bitmapImage;
bitmapImage.UriSource = new URI("ms-appx:///Assets/cool-image.png", UriKind.RelativeOrAbsolute);
```

<span data-ttu-id="0a7b2-129">例 2 分離コード (悪い例): ツリーに接続する前に、BitmapImage の UriSource を設定します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-129">Example 2 code-behind (bad)—setting the BitmapImage's UriSource before connecting it to the tree.</span></span>

```vb
var bitmapImage = new BitmapImage();
bitmapImage.UriSource = new URI("ms-appx:///Assets/cool-image.png", UriKind.RelativeOrAbsolute);
myImage.Source = bitmapImage;
```

#### <a name="image-brush-is-non-rectangular"></a><span data-ttu-id="0a7b2-130">イメージ ブラシが四角形でない</span><span class="sxs-lookup"><span data-stu-id="0a7b2-130">Image brush is non-rectangular</span></span> 

<span data-ttu-id="0a7b2-131">画像が四角形以外のブラシに使用されている場合、画像の拡大縮小が行われない、ソフトウェア ラスタライズ パスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-131">When an image is used for a non-rectangular brush, the image will use a software rasterization path, which will not scale images at all.</span></span> <span data-ttu-id="0a7b2-132">また、ソフトウェアとハードウェアの両方のメモリに画像のコピーを保存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-132">Additionally, it must store a copy of the image in both software and hardware memory.</span></span> <span data-ttu-id="0a7b2-133">たとえば、画像が楕円形のブラシとして使われる場合、大きい可能性がある画像全体は内部で 2 回保存されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-133">For example, if an image is used as a brush for an ellipse, the potentially large full image will be stored twice internally.</span></span> <span data-ttu-id="0a7b2-134">四角形以外のブラシを使用する場合は、アプリで画像を事前に拡大縮小し、レンダリング時のおよそのサイズにしておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-134">When using a non-rectangular brush, your app should pre-scale its images to approximately the size they will be rendered at.</span></span>

<span data-ttu-id="0a7b2-135">代わりに、[**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) プロパティと [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) プロパティを使って、明示的にデコード サイズを設定することで、画面上に描画される正確なサイズのバージョンの画像を作成できます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-135">Alternatively, you can set an explicit decode size to create a version of the image at the exact size it will be drawn on-screen using the [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) properties.</span></span>

```xml
<Image>
    <Image.Source>
    <BitmapImage UriSource="ms-appx:///Assets/highresCar.jpg" 
                 DecodePixelWidth="300" DecodePixelHeight="200"/>
    </Image.Source>
</Image>
```

<span data-ttu-id="0a7b2-136">[**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) と [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) の単位は、既定では物理ピクセルです。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-136">The units for [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) are by default physical pixels.</span></span> <span data-ttu-id="0a7b2-137">[**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) プロパティを使って、この動作を変更できます。**DecodePixelType** を **Logical** に設定すると、他の XAML コンテンツと同様に、デコード サイズで自動的に現在の倍率が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-137">The [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) property can be used to change this behavior: setting **DecodePixelType** to **Logical** results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content.</span></span> <span data-ttu-id="0a7b2-138">したがって、一般的には、**DecodePixelType** を **Logical** に設定することをお勧めします。たとえば、**DecodePixelWidth** と **DecodePixelHeight** を、画像が表示される Image コントロールの Height プロパティと Width プロパティと一致させるような場合です。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-138">It would therefore be generally appropriate to set **DecodePixelType** to **Logical** if, for example, you want **DecodePixelWidth** and **DecodePixelHeight** to match the Height and Width properties of the Image control that the image will be displayed in.</span></span> <span data-ttu-id="0a7b2-139">物理ピクセルを使用する既定の動作では、システムの現在の倍率を自分で考慮する必要があります。また、ユーザーが表示設定を変更する場合に備えて、スケール変更通知をリッスンする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-139">With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself, and you should listen for scale change notifications in case the user changes their display preferences.</span></span>

<span data-ttu-id="0a7b2-140">事前に適切なデコード サイズを特定できない場合には、明示的な DecodePixelWidth/DecodePixelHeight が指定されていないときに、適切なサイズでの画像のデコードをベスト エフォート形式で試行する、XAML の適切なサイズの自動デコードを遅延させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-140">In some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding, which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.</span></span>

<span data-ttu-id="0a7b2-141">事前に画像コンテンツのサイズがわかっている場合は、明示的にデコード サイズを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-141">You should set an explicit decode size if you know the size of the image content ahead of time.</span></span> <span data-ttu-id="0a7b2-142">指定したデコード サイズが他の XAML 要素のサイズを基準としている場合は、併せて [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) を **Logical** に設定することも必要です。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-142">You should also in conjunction set [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) to **Logical** if the supplied decode size is relative to other XAML element sizes.</span></span> <span data-ttu-id="0a7b2-143">たとえば、Image.Width と Image.Height を使ってコンテンツのサイズを明示的に設定する場合、DecodePixelType を DecodePixelType.Logical に設定して Image コントロールと同じ論理ピクセル サイズを使用し、明示的に BitmapImage.DecodePixelWidth や BitmapImage.DecodePixelHeight を使って画像のサイズを制御することによって、大量のメモリ消費を抑えることができる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-143">For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control, and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.</span></span>

<span data-ttu-id="0a7b2-144">デコードされたコンテンツのサイズを決定するときに、Image.Stretch を考慮する必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-144">Note that Image.Stretch should be considered when determining the size of the decoded content.</span></span>

#### <a name="images-used-inside-of-bitmapicons-fall-back-to-decoding-to-natural-size"></a><span data-ttu-id="0a7b2-145">BitmapIcons 内で使用されている画像が、自然なサイズのデコードにフォール バックしている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-145">Images used inside of BitmapIcons fall back to decoding to natural size</span></span> 

<span data-ttu-id="0a7b2-146">[**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) プロパティと [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) プロパティを使って、明示的にデコード サイズを設定することで、画面上に描画される正確なサイズのバージョンの画像を作成できます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-146">Set an explicit decode size to create a version of the image at the exact size it will be drawn on-screen by using the [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) properties.</span></span>

#### <a name="images-that-appear-extremely-large-on-screen-fall-back-to-decoding-to-natural-size"></a><span data-ttu-id="0a7b2-147">画面上で極端に大きく表示されるイメージが、自然なサイズのデコードにフォールバックしている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-147">Images that appear extremely large on screen fall back to decoding to natural size</span></span> 

<span data-ttu-id="0a7b2-148">画面上で極端に大きく表示されるイメージは、自然なサイズのデコードにフォールバックします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-148">Images that appear extremely large on screen fall back to decoding to natural size.</span></span> <span data-ttu-id="0a7b2-149">[**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) プロパティと [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) プロパティを使って、明示的にデコード サイズを設定することで、画面上に描画される正確なサイズのバージョンの画像を作成できます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-149">Set an explicit decode size to create a version of the image at the exact size it will be drawn on-screen by using the [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) properties.</span></span>

#### <a name="image-is-hidden"></a><span data-ttu-id="0a7b2-150">画像が非表示になっている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-150">Image is hidden</span></span>

<span data-ttu-id="0a7b2-151">ホスト画像要素、ブラシ、親要素のいずれかで、Opacity が 0 に設定されているか、Visibility が Collapsed に設定されているために、画像が非表示になっています。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-151">The image is hidden via setting Opacity to 0 or Visibility to Collapsed on the host image element or brush or any parent element.</span></span> <span data-ttu-id="0a7b2-152">クリッピングまたは透明度の設定のために画面に表示されない画像は、自然なサイズのデコードにフォールバックする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-152">Images not visible on screen due to clipping or transparency may fall back to decoding to natural size.</span></span> 

#### <a name="image-is-using-ninegrid-property"></a><span data-ttu-id="0a7b2-153">イメージで NineGrid プロパティが使用されている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-153">Image is using NineGrid property</span></span>

<span data-ttu-id="0a7b2-154">画像が [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756) 用に使用されている場合、画像の拡大縮小が行われない、ソフトウェア ラスタライズ パスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-154">When an image is used for a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756), the image will use a software rasterization path, which will not scale images at all.</span></span> <span data-ttu-id="0a7b2-155">また、ソフトウェアとハードウェアの両方のメモリに画像のコピーを保存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-155">Additionally, it must store a copy of the image in both software and hardware memory.</span></span> <span data-ttu-id="0a7b2-156">**NineGrid** を使用する場合は、アプリで画像を事前に拡大縮小し、レンダリング時のおよそのサイズにしておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-156">When using **NineGrid**, your app should pre-scale its images to approximately the size they will be rendered at.</span></span>

<span data-ttu-id="0a7b2-157">NineGrid プロパティを使用しているイメージは、自然なサイズのデコードにフォールバックします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-157">Images that use the NineGrid property fall back to decoding to natural size.</span></span> <span data-ttu-id="0a7b2-158">元のイメージに ninegrid 効果を追加することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-158">Consider adding the ninegrid effect to the original image.</span></span>

#### <a name="decodepixelwidth-or-decodepixelheight-are-set-to-a-size-thats-larger-than-the-image-will-appear-on-screen"></a><span data-ttu-id="0a7b2-159">DecodePixelWidth や DecodePixelHeight が画面上での画像の表示サイズよりも大きく設定されている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-159">DecodePixelWidth or DecodePixelHeight are set to a size that's larger than the image will appear on screen</span></span> 

<span data-ttu-id="0a7b2-160">DecodePixelWidth/Height が画面に表示される画像よりも大きいサイズに明示的に設定されている場合、アプリは不必要に余分なメモリ (1 ピクセルあたり最大 4 バイト) を使用するため、大きい画像では負荷が急速に増大します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-160">If DecodePixelWidth/Height are explicitly set larger than the image that will be displayed on-screen, the app will unnecessarily use extra memory, up to 4 bytes per pixel, which quickly becomes expensive for large images.</span></span> <span data-ttu-id="0a7b2-161">また、画像はバイリニア スケーリングを使って縮小されるため、倍率が大きくなるとぼやけて見える原因となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-161">The image will also be scaled down using bilinear scaling, which could cause it to appear blurry for large scale factors.</span></span>

#### <a name="image-is-decoded-as-part-of-producing-a-drag-and-drop-image"></a><span data-ttu-id="0a7b2-162">画像がドラッグ アンド ドロップ画像を生成する一部としてデコードされている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-162">Image is decoded as part of producing a Drag and Drop image</span></span>

<span data-ttu-id="0a7b2-163">[**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) プロパティと [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) プロパティを使って、明示的にデコード サイズを設定することで、画面上に描画される正確なサイズのバージョンの画像を作成できます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-163">Set an explicit decode size to create a version of the image at the exact size it will be drawn on-screen by using the [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) properties.</span></span>

## <a name="collapsed-elements-at-load-time"></a><span data-ttu-id="0a7b2-164">要素が読み込み時に折りたたまれている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-164">Collapsed elements at load time</span></span>

<span data-ttu-id="0a7b2-165">アプリは、最初 UI 要素を非表示にし、後でそれらを表示するのが一般的なパターンです。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-165">A common pattern in apps is to hide elements in the UI initially and show them at a later time.</span></span> <span data-ttu-id="0a7b2-166">ほとんどの場合、読み込み時に要素を作成するコストを回避するために、x:Load または x:DeferLoadStrategy を使用してこれらの要素の読み込みを延期する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-166">In most cases these elements should be deferred using x:Load or x:DeferLoadStrategy to avoid paying the cost of creating the element at load time.</span></span>

<span data-ttu-id="0a7b2-167">これにはブール値と Visibility 値のコンバーターを使って、後で表示するときまで項目を非表示にする場合が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-167">This includes cases where a boolean to visibility converter is used to hide items until a later time.</span></span>

### <a name="impact"></a><span data-ttu-id="0a7b2-168">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-168">Impact</span></span>

<span data-ttu-id="0a7b2-169">折りたたまれた要素が他の要素と一緒に読み込まれると、読み込み時間が増加します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-169">Collapsed elements are loaded alongside other elements and contribute to an increase in load time.</span></span>

### <a name="cause"></a><span data-ttu-id="0a7b2-170">原因</span><span class="sxs-lookup"><span data-stu-id="0a7b2-170">Cause</span></span>

<span data-ttu-id="0a7b2-171">この規則がトリガーされるのは、読み込み時に要素が折りたたまれているためです。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-171">This rule was triggered because an element was collapsed at load time.</span></span> <span data-ttu-id="0a7b2-172">要素を折りたたんだり、不透明度を 0 に設定したりしても、要素の作成は回避されません。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-172">Collapsing an element, or setting its opacity to 0, does not prevent the element from being created.</span></span> <span data-ttu-id="0a7b2-173">この規則は、既定値が false に設定された、ブール値と Visibility 値のコンバーターを使うアプリによって発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-173">This rule could be caused by an app that uses a Boolean to visibility converter that defaults to false.</span></span>

### <a name="solution"></a><span data-ttu-id="0a7b2-174">解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-174">Solution</span></span>

<span data-ttu-id="0a7b2-175">[x:Load 属性](../xaml-platform/x-load-attribute.md)または [x:DeferLoadStrategy](https://msdn.microsoft.com/library/windows/apps/Mt204785) を使って、UI の要素の読み込みを遅らせて、必要に応じて読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-175">Using [x:Load attribute](../xaml-platform/x-load-attribute.md) or [x:DeferLoadStrategy](https://msdn.microsoft.com/library/windows/apps/Mt204785), you can delay the loading of a piece of UI, and load it when needed.</span></span> <span data-ttu-id="0a7b2-176">最初のフレームで表示しない UI について処理を延期する場合は、この方法をお勧めします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-176">This is good way to delay processing UI that is not visible in the first frame.</span></span> <span data-ttu-id="0a7b2-177">要素は必要に応じてその都度読み込むか、後で実行する一連のロジックの一部として読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-177">You can opt to load the element when needed, or as part of a set of delayed logic.</span></span> <span data-ttu-id="0a7b2-178">読み込みをトリガーするには、読み込む要素に対して findName を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-178">To trigger loading, call findName on the element you wish to load.</span></span> <span data-ttu-id="0a7b2-179">x:Load は x:DeferLoadStrategy の機能を拡張して、要素をアンロードできるようにしたり、読み込み状態を x:Bind によって制御できるようにしたりします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-179">x:Load extends the capabilities of x:DeferLoadStrategy enabling elements to be unloaded, and for the loading state to be controlled via x:Bind.</span></span>

<span data-ttu-id="0a7b2-180">場合によっては、findName を使って UI 要素を表示する方法では問題を解決できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-180">In some cases, using findName to show a piece of UI may not be the answer.</span></span> <span data-ttu-id="0a7b2-181">たとえば、クリックによって多くの UI をきわめて短い遅延時間で表示する場合などです。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-181">This is true if you are expecting to realize a significant piece of UI on the click of a button with very low latency.</span></span> <span data-ttu-id="0a7b2-182">この場合、追加メモリのコストのために高速な UI 待機時間を妥協することもできます。そうするには、x:DeferLoadStrategy を使用し、実現する要素の Visibility を Collapsed に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-182">In this case, you may want to trade off faster UI latency at the cost of additional memory, if so you should use x:DeferLoadStrategy and set Visibility to Collapsed on the element you wish to realize.</span></span> <span data-ttu-id="0a7b2-183">これにより、ページが読み込まれ、UI スレッドが解放された後、必要に応じて findName を呼び出して要素を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-183">After the page has been loaded and the UI thread is free, you can call findName when necessary to load the elements.</span></span> <span data-ttu-id="0a7b2-184">要素は、その要素の Visibility を Visible に設定するまでユーザーには表示されません。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-184">The elements won't be visible to the user until you set the Visibility of the element to Visible.</span></span>

## <a name="listview-is-not-virtualized"></a><span data-ttu-id="0a7b2-185">ListView が仮想化されていない</span><span class="sxs-lookup"><span data-stu-id="0a7b2-185">ListView is not virtualized</span></span>

<span data-ttu-id="0a7b2-186">UI の仮想化は、コレクションのパフォーマンスを向上させることができる最も重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-186">UI virtualization is the most important improvement you can make to improve collection performance.</span></span> <span data-ttu-id="0a7b2-187">これは、項目を表す UI 要素がオンデマンドで作成されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-187">This means that UI elements representing the items are created on demand.</span></span> <span data-ttu-id="0a7b2-188">1,000 項目のコレクションにバインドされている項目コントロールでは、すべての項目の UI を同時に作成しても、同時に全部を表示することはできないため、リソースを無駄に使うことになります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-188">For an items control bound to a 1000-item collection, it would be a waste of resources to create the UI for all the items at the same time because they can't all be displayed at the same time.</span></span> <span data-ttu-id="0a7b2-189">UI の仮想化は、ListView と GridView (およびその他の ItemsControl から派生した標準コントロール) によって実行されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-189">ListView and GridView (and other standard ItemsControl-derived controls) perform UI virtualization for you.</span></span> <span data-ttu-id="0a7b2-190">数ページ先にある項目がスクロールされて表示されそうになると、フレームワークがその項目用の UI を生成してキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-190">When items are close to being scrolled into view (a few pages away), the framework generates the UI for the items and caches them.</span></span> <span data-ttu-id="0a7b2-191">項目がもう一度表示される可能性が低い場合、フレームワークはメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-191">When it's unlikely that the items will be shown again, the framework re-claims the memory.</span></span>

<span data-ttu-id="0a7b2-192">UI の仮想化は、コレクションのパフォーマンスを向上させる重要な複数の要因の 1 つに過ぎません。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-192">UI virtualization is just one of several key factors to improving collection performance.</span></span> <span data-ttu-id="0a7b2-193">コレクションのパフォーマンス向上には、この他に、コレクション項目の複雑さの軽減とデータ仮想化の 2 つの重要な側面があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-193">Reducing the complexity of collection items and data virtualization are two other important aspects to improving collection performance.</span></span> <span data-ttu-id="0a7b2-194">ListView と GridView 内のコレクションのパフォーマンスを向上させる方法について詳しくは、「[ListView と GridView の UI の最適化](https://msdn.microsoft.com/windows/uwp/debug-test-perf/optimize-gridview-and-listview)」と「[ListView と GridView のデータ仮想化](https://msdn.microsoft.com/windows/uwp/debug-test-perf/listview-and-gridview-data-optimization)」に関する記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-194">For more information about improving collection performance within ListViews and GridViews, see the articles on [ListView and GridView UI optimization](https://msdn.microsoft.com/windows/uwp/debug-test-perf/optimize-gridview-and-listview) and [ListView and Gridview data virtualization](https://msdn.microsoft.com/windows/uwp/debug-test-perf/listview-and-gridview-data-optimization).</span></span>

### <a name="impact"></a><span data-ttu-id="0a7b2-195">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-195">Impact</span></span>

<span data-ttu-id="0a7b2-196">仮想化されていない ItemsControl は、必要のない子項目まで読み込むため、読み込み時間とリソース使用量が増大します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-196">A non-virtualized ItemsControl will increase load time and resource usage by loading more of its child items than necessary.</span></span>

### <a name="cause"></a><span data-ttu-id="0a7b2-197">原因</span><span class="sxs-lookup"><span data-stu-id="0a7b2-197">Cause</span></span>

<span data-ttu-id="0a7b2-198">表示される可能性のある要素の作成はフレームワークが行う必要があるため、ビューポートの概念は UI の仮想化にとって非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-198">The concept of a viewport is critical to UI virtualization because the framework must create the elements that are likely to be shown.</span></span> <span data-ttu-id="0a7b2-199">一般的に、ItemsControl のビューポートは論理コントロールの範囲を指します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-199">In general, the viewport of an ItemsControl is the extent of the logical control.</span></span> <span data-ttu-id="0a7b2-200">たとえば、ListView のビューポートは ListView 要素の幅と高さです。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-200">For example, the viewport of a ListView is the width and height of the ListView element.</span></span> <span data-ttu-id="0a7b2-201">一部のパネルでは子要素に制限のない空間を与えることができます。たとえば ScrollViewer や Grid では、行または列のサイズが自動的に調整されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-201">Some panels allow child elements unlimited space, examples being ScrollViewer and a Grid, with auto-sized rows or columns.</span></span> <span data-ttu-id="0a7b2-202">このようなパネルに仮想化された ItemsControl を配置すると、すべての項目を表示できるスペースが用意され、仮想化の意味がなくなります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-202">When a virtualized ItemsControl is placed in a panel like that, it takes enough room to display all of its items, which defeats virtualization.</span></span> 

### <a name="solution"></a><span data-ttu-id="0a7b2-203">解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-203">Solution</span></span>

<span data-ttu-id="0a7b2-204">仮想化を復元するには、使用する ItemsControl に幅と高さを設定します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-204">Restore virtualization by setting a width and height on the ItemsControl you are using.</span></span>

## <a name="ui-thread-blocked-or-idle-during-load"></a><span data-ttu-id="0a7b2-205">UI スレッドがブロックされているか、読み込み中にアイドル状態になっている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-205">UI thread blocked or idle during load</span></span>

<span data-ttu-id="0a7b2-206">UI スレッドのブロックとは、オフスレッドで実行されて UI スレッドをブロックする関数への同期呼び出しを指します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-206">UI thread blocking refers to synchronous calls to functions executing off-thread that block the UI thread.</span></span>  

<span data-ttu-id="0a7b2-207">アプリ起動時のパフォーマンスを向上させるためのすべてのベスト プラクティスについては、「[アプリ起動時のパフォーマンスのベスト プラクティス](https://msdn.microsoft.com/windows/uwp/debug-test-perf/best-practices-for-your-app-s-startup-performance)」と」[UI スレッドの応答性の確保](https://msdn.microsoft.com/windows/uwp/debug-test-perf/keep-the-ui-thread-responsive)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-207">For a full list of best practices to improve your app's startup performance, see [Best practices for your app's startup performance](https://msdn.microsoft.com/windows/uwp/debug-test-perf/best-practices-for-your-app-s-startup-performance) and [Keep the UI thread responsive](https://msdn.microsoft.com/windows/uwp/debug-test-perf/keep-the-ui-thread-responsive).</span></span>

### <a name="impact"></a><span data-ttu-id="0a7b2-208">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-208">Impact</span></span>

<span data-ttu-id="0a7b2-209">読み込み時に UI スレッドがブロックされるかアイドル状態になると、レイアウトやその他の UI 操作が実行できないため、起動に時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-209">A blocked or idle UI thread during load time will prevent layout and other UI operations, increasing startup time.</span></span>

### <a name="cause"></a><span data-ttu-id="0a7b2-210">原因</span><span class="sxs-lookup"><span data-stu-id="0a7b2-210">Cause</span></span>

<span data-ttu-id="0a7b2-211">UI のプラットフォーム コードと UI 用のアプリのコードはすべて、同じ UI スレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-211">Platform code for UI and your app’s code for UI all are executed on the same UI thread.</span></span> <span data-ttu-id="0a7b2-212">このスレッドでは一度に 1 つの命令しか実行できないため、アプリのコードの実行に長い時間がかかるとイベントを処理できず、フレームワークはレイアウトを実行したりユーザー操作を表す新しいイベントを生成したりできません。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-212">Only one instruction can execute on that thread at a time, so if your app code takes too long to process an event, the framework can’t run layout or raise new events representing user interaction.</span></span> <span data-ttu-id="0a7b2-213">アプリの応答性は、作業の処理に UI スレッドを使えるかどうかに関係します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-213">The responsiveness of your app is related to the availability of the UI thread to process work.</span></span>

### <a name="solution"></a><span data-ttu-id="0a7b2-214">解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-214">Solution</span></span>

<span data-ttu-id="0a7b2-215">アプリが部分的に機能していない場合でも、アプリで操作を受け付けることができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-215">Your app can be interactive even though there are parts of the app that aren't fully functional.</span></span> <span data-ttu-id="0a7b2-216">たとえば、アプリが表示するデータの取得に時間がかかっている場合に、データを非同期で取得することによって、そのコードをアプリの起動コードとは別に実行できます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-216">For example, if your app displays data that takes a while to retrieve, you can make that code execute independently of the app's startup code by retrieving the data asynchronously.</span></span> <span data-ttu-id="0a7b2-217">データが利用できる状態であれば、アプリのユーザー インターフェイスにデータを表示することができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-217">When the data is available, populate the app's user interface with the data.</span></span> <span data-ttu-id="0a7b2-218">アプリの高い応答性を維持するため、このプラットフォームの API の大部分に非同期バージョンが用意されています。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-218">To help keep your app responsive, the platform provides asynchronous versions of many of its APIs.</span></span> <span data-ttu-id="0a7b2-219">非同期 API を使うと、アクティブな実行スレッドが長時間ブロックされた状態になるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-219">An asynchronous API ensures that your active execution thread never blocks for a significant amount of time.</span></span> <span data-ttu-id="0a7b2-220">UI スレッドから API を呼び出す場合、提供されている限りは非同期バージョンを使ってください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-220">When you call an API from the UI thread, use the asynchronous version if it's available.</span></span>

## <a name="binding-is-being-used-instead-of-xbind"></a><span data-ttu-id="0a7b2-221">{x:Bind} の代わりに {Binding} が使用されている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-221">{Binding} is being used instead of {x:Bind}</span></span>

<span data-ttu-id="0a7b2-222">この規則はアプリで {binding} ステートメントが使われているときにトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-222">This rule is fired when your app uses a {Binding} statement.</span></span> <span data-ttu-id="0a7b2-223">アプリのパフォーマンスを向上させるには、アプリで {x:Bind} 使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-223">To improve app performance, apps should consider using {x:Bind}.</span></span>

### <a name="impact"></a><span data-ttu-id="0a7b2-224">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-224">Impact</span></span>

<span data-ttu-id="0a7b2-225">{Binding} は、{x:Bind} よりも実行に時間がかかり、多くのメモリ量を消費します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-225">{Binding} runs in more time and more memory than {x:Bind}.</span></span>

### <a name="cause"></a><span data-ttu-id="0a7b2-226">原因</span><span class="sxs-lookup"><span data-stu-id="0a7b2-226">Cause</span></span>

<span data-ttu-id="0a7b2-227">アプリで、{x:Bind} の代わりに {Binding} が使用されています。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-227">App is using {Binding} instead of {x:Bind}.</span></span> <span data-ttu-id="0a7b2-228">{Binding} を使うと、多大なワーキング セットと CPU オーバーヘッドが生じます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-228">{Binding} brings with it non-trivial working set and CPU overhead.</span></span> <span data-ttu-id="0a7b2-229">{Binding} を作成すると一連の割り当てが行われるほか、バインディング ターゲットの更新がリフレクションやボックス化の原因となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-229">Creating a {Binding} causes a series of allocations, and updating a binding target can cause reflection and boxing.</span></span>

### <a name="solution"></a><span data-ttu-id="0a7b2-230">解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-230">Solution</span></span>

<span data-ttu-id="0a7b2-231">{x:Bind} マークアップ拡張を使用してビルド時にバインディングをコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-231">Use the {x:Bind} markup extension, which compiles bindings at build time.</span></span> <span data-ttu-id="0a7b2-232">{x:Bind} バインディング (多くの場合、コンパイル済みバインドと呼ばれます) はパフォーマンスが高く、コンパイル時にバインド式を検証したり、ページの部分クラスとして生成されたコード ファイル内にブレークポイントを設定し、デバッグを行ったりできます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-232">{x:Bind} bindings (often referred-to as compiled bindings) have great performance, provide compile-time validation of your binding expressions, and support debugging by enabling you to set breakpoints in the code files that are generated as the partial class for your page.</span></span> 

<span data-ttu-id="0a7b2-233">x:Bind は、適切でない場合もあることに注意してください (遅延バインディングのシナリオなど)。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-233">Note that x:Bind is not suitable in all cases such as late-bound scenarios.</span></span> <span data-ttu-id="0a7b2-234">{x:Bind} で対応できない場合の完全な一覧については、{x:Bind} のドキュメントをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-234">For a full list of cases not covered by {x:Bind}, see the {x:Bind} documentation.</span></span>

## <a name="xname-is-being-used-instead-of-xkey"></a><span data-ttu-id="0a7b2-235">x:Key の代わりに x:Name が使われている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-235">x:Name is being used instead of x:Key</span></span>

<span data-ttu-id="0a7b2-236">ResourceDictionaries は通常、ある程度グローバル レベルでリソースを格納する場合に使用されます。つまり、アプリの複数の場所で参照する必要があるリソース (スタイル、ブラシ、テンプレートなど) の格納に使われます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-236">ResourceDictionaries are generally used to store your resources at a somewhat global level, that is, resources that your app wants to reference in multiple places; for example, styles, brushes, templates, and so on.</span></span> <span data-ttu-id="0a7b2-237">一般的に、要求されない限り、リソースがインスタンス化されないようにするために ResourceDictionaries を最適化します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-237">In general, we have optimized ResourceDictionaries to not instantiate resources unless they're asked for.</span></span> <span data-ttu-id="0a7b2-238">少し注意を払う必要がある場合がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-238">But there are few places where you need to be a little careful.</span></span>

### <a name="impact"></a><span data-ttu-id="0a7b2-239">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-239">Impact</span></span>

<span data-ttu-id="0a7b2-240">x:Name が設定されたリソースは、ResourceDictionary が作成されるとすぐにインスタンス化されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-240">Any resource with x:Name will be instantiated as soon as the ResourceDictionary is created.</span></span> <span data-ttu-id="0a7b2-241">これは、x: Name がプラットフォームに対し、アプリがこのリソースへのフィールド アクセスを必要としており、プラットフォームは参照を作成するものを何か作成する必要があると指示するからです。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-241">This happens because x:Name tells the platform that your app needs field access to this resource, so the platform needs to create something to create a reference to.</span></span>

### <a name="cause"></a><span data-ttu-id="0a7b2-242">原因</span><span class="sxs-lookup"><span data-stu-id="0a7b2-242">Cause</span></span>

<span data-ttu-id="0a7b2-243">アプリで、リソースに対して x:Name が設定されています。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-243">Your app is setting x:Name on a resource.</span></span>

### <a name="solution"></a><span data-ttu-id="0a7b2-244">解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-244">Solution</span></span>

<span data-ttu-id="0a7b2-245">分離コードのリソースを参照しない場合、x: Name ではなく X:key を使用します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-245">Use x:Key instead of x:Name when you are not referencing resources from code-behind.</span></span>

## <a name="collections-control-is-using-a-non-virtualizing-panel"></a><span data-ttu-id="0a7b2-246">コレクション コントロールが非仮想化パネルを使っている</span><span class="sxs-lookup"><span data-stu-id="0a7b2-246">Collections control is using a non-virtualizing panel</span></span>

<span data-ttu-id="0a7b2-247">カスタム項目パネル テンプレート (ItemsPanel をご覧ください) を用意する場合は、ItemsWrapGrid や ItemsStackPanel などの仮想パネルを必ず使用してください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-247">If you provide a custom items panel template (see ItemsPanel), make sure you use a virtualizing panel such as ItemsWrapGrid or ItemsStackPanel.</span></span> <span data-ttu-id="0a7b2-248">VariableSizedWrapGrid、WrapGrid、または StackPanel を使用した場合、仮想化は得られません。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-248">If you use VariableSizedWrapGrid, WrapGrid, or StackPanel, you will not get virtualization.</span></span> <span data-ttu-id="0a7b2-249">また、ChoosingGroupHeaderContainer、ChoosingItemContainer、ContainerContentChanging の各 ListView イベントは、ItemsWrapGrid または ItemsStackPanel を使用したときにのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-249">Additionally, the following ListView events are raised only when using an ItemsWrapGrid or an ItemsStackPanel: ChoosingGroupHeaderContainer, ChoosingItemContainer, and ContainerContentChanging.</span></span>

<span data-ttu-id="0a7b2-250">UI の仮想化は、コレクションのパフォーマンスを向上させることができる最も重要な機能です。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-250">UI virtualization is the most important improvement you can make to improve collection performance.</span></span> <span data-ttu-id="0a7b2-251">これは、項目を表す UI 要素がオンデマンドで作成されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-251">This means that UI elements representing the items are created on demand.</span></span> <span data-ttu-id="0a7b2-252">1,000 項目のコレクションにバインドされている項目コントロールでは、すべての項目の UI を同時に作成しても、同時に全部を表示することはできないため、リソースを無駄に使うことになります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-252">For an items control bound to a 1000-item collection, it would be a waste of resources to create the UI for all the items at the same time because they can't all be displayed at the same time.</span></span> <span data-ttu-id="0a7b2-253">UI の仮想化は、ListView と GridView (およびその他の ItemsControl から派生した標準コントロール) によって実行されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-253">ListView and GridView (and other standard ItemsControl-derived controls) perform UI virtualization for you.</span></span> <span data-ttu-id="0a7b2-254">数ページ先にある項目がスクロールされて表示されそうになると、フレームワークがその項目用の UI を生成してキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-254">When items are close to being scrolled into view (a few pages away), the framework generates the UI for the items and caches them.</span></span> <span data-ttu-id="0a7b2-255">項目がもう一度表示される可能性が低い場合、フレームワークはメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-255">When it's unlikely that the items will be shown again, the framework re-claims the memory.</span></span>

<span data-ttu-id="0a7b2-256">UI の仮想化は、コレクションのパフォーマンスを向上させる重要な複数の要因の 1 つに過ぎません。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-256">UI virtualization is just one of several key factors to improving collection performance.</span></span> <span data-ttu-id="0a7b2-257">コレクションのパフォーマンス向上には、この他に、コレクション項目の複雑さの軽減とデータ仮想化の 2 つの重要な側面があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-257">Reducing the complexity of collection items and data virtualization are two other important aspects to improving collection performance.</span></span> <span data-ttu-id="0a7b2-258">ListView と GridView 内のコレクションのパフォーマンスを向上させる方法について詳しくは、「[ListView と GridView の UI の最適化](https://msdn.microsoft.com/windows/uwp/debug-test-perf/optimize-gridview-and-listview)」と「[ListView と GridView のデータ仮想化](https://msdn.microsoft.com/windows/uwp/debug-test-perf/listview-and-gridview-data-optimization)」に関する記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-258">For more information about improving collection performance within ListViews and GridViews, see the articles on [ListView and GridView UI optimization](https://msdn.microsoft.com/windows/uwp/debug-test-perf/optimize-gridview-and-listview) and [ListView and Gridview data virtualization](https://msdn.microsoft.com/windows/uwp/debug-test-perf/listview-and-gridview-data-optimization).</span></span>

### <a name="impact"></a><span data-ttu-id="0a7b2-259">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-259">Impact</span></span>

<span data-ttu-id="0a7b2-260">仮想化されていない ItemsControl は、必要のない子項目まで読み込むため、読み込み時間とリソース使用量が増大します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-260">A non-virtualized ItemsControl will increase load time and resource usage by loading more of its child items than necessary.</span></span>

### <a name="cause"></a><span data-ttu-id="0a7b2-261">原因</span><span class="sxs-lookup"><span data-stu-id="0a7b2-261">Cause</span></span>

<span data-ttu-id="0a7b2-262">仮想化をサポートしていないパネルが使われています。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-262">You are using a panel that does not support virtualization.</span></span>

### <a name="solution"></a><span data-ttu-id="0a7b2-263">解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-263">Solution</span></span>

<span data-ttu-id="0a7b2-264">ItemsWrapGrid や ItemsStackPanel などの仮想化パネルを使います。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-264">Use a virtualizing panel such as ItemsWrapGrid or ItemsStackPanel.</span></span>

## <a name="accessibility-uia-elements-with-no-name"></a><span data-ttu-id="0a7b2-265">アクセシビリティ: 名前のない UIA 要素</span><span class="sxs-lookup"><span data-stu-id="0a7b2-265">Accessibility: UIA elements with no name</span></span>

<span data-ttu-id="0a7b2-266">XAML では、AutomationProperties.Name を設定することで名前を指定できます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-266">In XAML, you can provide a name by setting AutomationProperties.Name.</span></span> <span data-ttu-id="0a7b2-267">多くのオートメーション ピアでは、AutomationProperties.Name を設定していない場合、UIA に既定の名前が指定されます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-267">Many automation peers provide a default name to UIA if AutomationProperties.Name is unset.</span></span> 

### <a name="impact"></a><span data-ttu-id="0a7b2-268">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-268">Impact</span></span>

<span data-ttu-id="0a7b2-269">表示された要素に名前がなければ、それが何に関連する要素なのかをユーザーが理解することは困難です。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-269">If a user reaches an element with no name, they often will have no way of knowing what the element relates to.</span></span> 

### <a name="cause"></a><span data-ttu-id="0a7b2-270">原因</span><span class="sxs-lookup"><span data-stu-id="0a7b2-270">Cause</span></span>

<span data-ttu-id="0a7b2-271">要素の UIA 名が null または空です。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-271">Element’s UIA name is null or empty.</span></span> <span data-ttu-id="0a7b2-272">この規則では、AutomationProperties.Name の値ではなく、UIA に指定された名前がチェックされます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-272">This rule checks what UIA sees, not the value of the AutomationProperties.Name.</span></span>

### <a name="solution"></a><span data-ttu-id="0a7b2-273">解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-273">Solution</span></span>

<span data-ttu-id="0a7b2-274">コントロールの XAML 内の AutomationProperties.Name プロパティに、ローカライズされた適切な文字列を設定します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-274">Set the AutomationProperties.Name property in the control's XAML to an appropriate localized string.</span></span>

<span data-ttu-id="0a7b2-275">アプリケーションによっては、名前を指定するのではなく、Raw ツリー以外のすべてのツリーから UIA 要素を削除して修正する方法が適切である場合があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-275">Sometimes the right application fix isn't to provide a name, it's to remove the UIA element from all but the raw trees.</span></span> <span data-ttu-id="0a7b2-276">これには、XAML で AutomationProperties.AccessibilityView = “Raw” と設定します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-276">You can do that in XAML by setting AutomationProperties.AccessibilityView = “Raw”.</span></span>

## <a name="accessibility-uia-elements-with-the-same-controltype-should-not-have-the-same-name"></a><span data-ttu-id="0a7b2-277">アクセシビリティ: 同じ Controltype の UIA 要素は同じ名前を持つことはできない</span><span class="sxs-lookup"><span data-stu-id="0a7b2-277">Accessibility: UIA elements with the same Controltype should not have the same name</span></span>

<span data-ttu-id="0a7b2-278">同じ UIA の親を持つ 2 つの UIA 要素に、同じ Name と ControlType を設定してはなりません。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-278">Two UIA elements with the same UIA parent must not have the same Name and ControlType.</span></span> <span data-ttu-id="0a7b2-279">2 つのコントロールの ControlTypes が異なる場合は、同じ Name を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-279">It's okay to have two controls with the same Name if they have different ControlTypes.</span></span> 

<span data-ttu-id="0a7b2-280">この規則は、異なる親を持つ複数の要素で名前が重複している場合をチェックしません。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-280">This rule doesn't check for duplicate names with different parents.</span></span> <span data-ttu-id="0a7b2-281">しかし、ほとんどの場合、親が違っていてもウィンドウ全体で Name と ControlType が重複しないように指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-281">However, in most cases, you shouldn't duplicate Names and ControlTypes within an entire window, even with different parents.</span></span> <span data-ttu-id="0a7b2-282">ただし同一の項目が含まれている 2 つの一覧を使う場合は、1 つのウィンドウ内で重複する名前を使うことができます。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-282">Cases where duplicate names within a window are acceptable are two lists with identical items.</span></span> <span data-ttu-id="0a7b2-283">この場合、一覧に含まれる各項目には同じ Name と ControlTypes が指定されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-283">In this case, the list items are expected to have identical Names and ControlTypes.</span></span>

### <a name="impact"></a><span data-ttu-id="0a7b2-284">影響</span><span class="sxs-lookup"><span data-stu-id="0a7b2-284">Impact</span></span>

<span data-ttu-id="0a7b2-285">同じ UIA の親を持つ 2 つの要素に、同じ Name と ControlType が設定されている場合、それらの要素を提示されたユーザーが要素の違いを区別できない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-285">If a user reaches an element with the same Name and ControlType as another element with the same UIA parent, the user may not be able to distinguish the difference between the elements.</span></span>

### <a name="cause"></a><span data-ttu-id="0a7b2-286">原因</span><span class="sxs-lookup"><span data-stu-id="0a7b2-286">Cause</span></span>

<span data-ttu-id="0a7b2-287">同じ UIA の親を持つ複数の UIA 要素に、同じ Name と ControlType が指定されています。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-287">UIA elements with the same UIA parent have the same Name and ControlType.</span></span>

### <a name="solution"></a><span data-ttu-id="0a7b2-288">解決策</span><span class="sxs-lookup"><span data-stu-id="0a7b2-288">Solution</span></span>

<span data-ttu-id="0a7b2-289">XAML で AutomationProperties.Name を使用して名前を設定します。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-289">Set a name in XAML using AutomationProperties.Name.</span></span> <span data-ttu-id="0a7b2-290">一覧でこの問題が頻繁に発生する場合は、バインディングを使って AutomationProperties.Name の値をデータ ソースにバインドします。</span><span class="sxs-lookup"><span data-stu-id="0a7b2-290">In lists where this commonly occurs, use binding to bind the value of the AutomationProperties.Name to a data source.</span></span>


