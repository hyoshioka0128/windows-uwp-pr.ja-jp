---
author: jwmsft
ms.assetid: DE5B084C-DAC1-430B-A15B-5B3D5FB698F7
title: アニメーション、メディア、画像の最適化
description: スムーズなアニメーション、高いフレーム レート、およびパフォーマンスの高いメディア キャプチャと再生を備えたユニバーサル Windows プラットフォーム (UWP) アプリを作成します。
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 66704daaca67dae2ba4f5a3882f5885ff333d2ce
ms.sourcegitcommit: 70ab58b88d248de2332096b20dbd6a4643d137a4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/02/2018
ms.locfileid: "5945551"
---
# <a name="optimize-animations-media-and-images"></a><span data-ttu-id="5b115-104">アニメーション、メディア、画像の最適化</span><span class="sxs-lookup"><span data-stu-id="5b115-104">Optimize animations, media, and images</span></span>


<span data-ttu-id="5b115-105">スムーズなアニメーション、高いフレーム レート、およびパフォーマンスの高いメディア キャプチャと再生を備えたユニバーサル Windows プラットフォーム (UWP) アプリを作成します。</span><span class="sxs-lookup"><span data-stu-id="5b115-105">Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.</span></span>

## <a name="make-animations-smooth"></a><span data-ttu-id="5b115-106">アニメーションのスムーズ化</span><span class="sxs-lookup"><span data-stu-id="5b115-106">Make animations smooth</span></span>

<span data-ttu-id="5b115-107">UWP アプリの重要な側面は、スムーズな対話式操作です。</span><span class="sxs-lookup"><span data-stu-id="5b115-107">A key aspect of UWP apps is smooth interactions.</span></span> <span data-ttu-id="5b115-108">これには、"指の動きに忠実な" タッチ操作、スムーズな切り替えやアニメーション、入力のフィードバックを返す小さな動作などがあります。</span><span class="sxs-lookup"><span data-stu-id="5b115-108">This includes touch manipulations that "stick to your finger," smooth transitions and animations, and small motions that provide input feedback.</span></span> <span data-ttu-id="5b115-109">XAML フレームワークには、アプリの視覚要素の合成とアニメーション専用の、合成スレッドと呼ばれるスレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="5b115-109">In the XAML framework there is a thread called the composition thread that is dedicated to the composition and animation of an app’s visual elements.</span></span> <span data-ttu-id="5b115-110">合成スレッドは UI スレッド (フレームワークと開発者コードを実行するスレッド) からは独立しているため、レイアウト パスや拡張計算が複雑でも、一貫したフレーム レートとスムーズなアニメーションをアプリで実現できます。</span><span class="sxs-lookup"><span data-stu-id="5b115-110">Because the composition thread is separate from UI thread (the thread that runs framework and developer code), apps can achieve a consistent frame rate and smooth animations regardless of complicated layout passes or extended calculations.</span></span> <span data-ttu-id="5b115-111">このセクションでは、合成スレッドを使って、アプリのアニメーションをスムーズにする方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="5b115-111">This section shows how to use the composition thread to keep an app’s animations buttery smooth.</span></span> <span data-ttu-id="5b115-112">アニメーションについて詳しくは、「[アニメーションの概要](https://msdn.microsoft.com/library/windows/apps/Mt187350)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5b115-112">For more info about animations, see [Animations overview](https://msdn.microsoft.com/library/windows/apps/Mt187350).</span></span> <span data-ttu-id="5b115-113">計算を集中的に実行している間のアプリの応答性の向上については、「[UI スレッドの応答性の確保](keep-the-ui-thread-responsive.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5b115-113">To learn about increasing an app’s responsiveness while performing intensive computations, see [Keep the UI thread responsive](keep-the-ui-thread-responsive.md).</span></span>

### <a name="use-independent-instead-of-dependent-animations"></a><span data-ttu-id="5b115-114">依存型ではなく、独立型アニメーションを使う</span><span class="sxs-lookup"><span data-stu-id="5b115-114">Use independent instead of dependent animations</span></span>

<span data-ttu-id="5b115-115">アニメーション化されるプロパティに対する変更は、シーン内の残りのオブジェクトに影響を与えないため、独立型アニメーションは作成時の最初から最後まで計算できます。</span><span class="sxs-lookup"><span data-stu-id="5b115-115">Independent animations can be calculated from beginning to end at the time of creation because changes to the property being animated don't affect rest of the objects in a scene.</span></span> <span data-ttu-id="5b115-116">そのため、独立型アニメーションは UI スレッドではなく合成スレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-116">Independent animations can therefore run on the composition thread instead of the UI thread.</span></span> <span data-ttu-id="5b115-117">合成スレッドは一定の間隔で更新されるため、アニメーションをスムーズに実行し続けることができます。</span><span class="sxs-lookup"><span data-stu-id="5b115-117">This guarantees that they remain smooth because the composition thread is updated at a consistent cadence.</span></span>

<span data-ttu-id="5b115-118">次のようなアニメーションはすべて独立性が保証されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-118">All of these types of animations are guaranteed to be independent:</span></span>

-   <span data-ttu-id="5b115-119">キー フレームを使ったオブジェクト アニメーション</span><span class="sxs-lookup"><span data-stu-id="5b115-119">Object animations using key frames</span></span>
-   <span data-ttu-id="5b115-120">再生時間が 0 のアニメーション</span><span class="sxs-lookup"><span data-stu-id="5b115-120">Zero-duration animations</span></span>
-   <span data-ttu-id="5b115-121">[**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/Hh759771) プロパティと [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/Hh759772) プロパティに対するアニメーション</span><span class="sxs-lookup"><span data-stu-id="5b115-121">Animations to the [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/Hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/Hh759772) properties</span></span>
-   <span data-ttu-id="5b115-122">[**UIElement.Opacity**](/uwp/api/Windows.UI.Xaml.UIElement.Opacity) プロパティに対するアニメーション</span><span class="sxs-lookup"><span data-stu-id="5b115-122">Animations to the [**UIElement.Opacity**](/uwp/api/Windows.UI.Xaml.UIElement.Opacity) property</span></span>
-   <span data-ttu-id="5b115-123">[**SolidColorBrush.Color**](/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush.Color) サブプロパティをターゲット設定した場合の、[**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) 型のプロパティに対するアニメーション</span><span class="sxs-lookup"><span data-stu-id="5b115-123">Animations to properties of type [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) when targeting the [**SolidColorBrush.Color**](/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush.Color) subproperty</span></span>
-   <span data-ttu-id="5b115-124">これらの戻り値の型のサブプロパティをターゲット設定した場合の、次の [**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) プロパティに対するアニメーション</span><span class="sxs-lookup"><span data-stu-id="5b115-124">Animations to the following [**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) properties when targeting subproperties of these return value types:</span></span>

    -   [**<span data-ttu-id="5b115-125">RenderTransform</span><span class="sxs-lookup"><span data-stu-id="5b115-125">RenderTransform</span></span>**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.rendertransform)
    -   [**<span data-ttu-id="5b115-126">Transform3D</span><span class="sxs-lookup"><span data-stu-id="5b115-126">Transform3D</span></span>**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d)
    -   [**<span data-ttu-id="5b115-127">Projection</span><span class="sxs-lookup"><span data-stu-id="5b115-127">Projection</span></span>**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.projection)
    -   [**<span data-ttu-id="5b115-128">Clip</span><span class="sxs-lookup"><span data-stu-id="5b115-128">Clip</span></span>**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.clip)

<span data-ttu-id="5b115-129">依存型アニメーションはレイアウトに影響するため、計算に UI スレッドからの追加の入力が必要です。</span><span class="sxs-lookup"><span data-stu-id="5b115-129">Dependent animations affect layout, which therefore cannot be calculated without extra input from the UI thread.</span></span> <span data-ttu-id="5b115-130">依存型アニメーションには、[**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) や [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) などのプロパティへの変更があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-130">Dependent animations include modifications to properties like [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) and [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height).</span></span> <span data-ttu-id="5b115-131">依存型アニメーションは、既定では実行されず、アプリ開発者からのオプトインが必要です。</span><span class="sxs-lookup"><span data-stu-id="5b115-131">By default, dependent animations are not run and require an opt-in from the app developer.</span></span> <span data-ttu-id="5b115-132">有効になると、UI スレッドがブロックされない限りスムーズに実行されますが、フレームワークやアプリの UI スレッドで他の作業が大量に行われると引っかかりが発生します。</span><span class="sxs-lookup"><span data-stu-id="5b115-132">When enabled, they run smoothly if the UI thread remains unblocked, but they begin to stutter if the framework or app is doing a lot of other work on the UI thread.</span></span>

<span data-ttu-id="5b115-133">XAML フレームワーク内のほぼすべてのアニメーションは、既定で独立して実行されますが、この最適化が無効になる操作がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="5b115-133">Almost all animations in the XAML framework are independent by default, but there are some actions that you can take to disable this optimization.</span></span> <span data-ttu-id="5b115-134">特に次のようなシナリオに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5b115-134">Beware of these scenarios particularly:</span></span>

-   <span data-ttu-id="5b115-135">依存型アニメーションを UI スレッドで実行できるように [**EnableDependentAnimation**](https://msdn.microsoft.com/library/windows/apps/BR210356) プロパティを設定する。</span><span class="sxs-lookup"><span data-stu-id="5b115-135">Setting the [**EnableDependentAnimation**](https://msdn.microsoft.com/library/windows/apps/BR210356) property to allow a dependent animation to run on the UI thread.</span></span> <span data-ttu-id="5b115-136">そうしたアニメーションは、独立型バージョンに変換します。</span><span class="sxs-lookup"><span data-stu-id="5b115-136">Convert these animations into an independent version.</span></span> <span data-ttu-id="5b115-137">たとえば、オブジェクトの [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) と [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) ではなく、[**ScaleTransform.ScaleX**](https://msdn.microsoft.com/library/windows/apps/BR242946) と [**ScaleTransform.ScaleY**](https://msdn.microsoft.com/library/windows/apps/BR242948) をアニメーション化します。</span><span class="sxs-lookup"><span data-stu-id="5b115-137">For example animate [**ScaleTransform.ScaleX**](https://msdn.microsoft.com/library/windows/apps/BR242946) and [**ScaleTransform.ScaleY**](https://msdn.microsoft.com/library/windows/apps/BR242948) instead of the [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) and [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) of an object.</span></span> <span data-ttu-id="5b115-138">画像やテキストなどのオブジェクトも拡大/縮小できます。</span><span class="sxs-lookup"><span data-stu-id="5b115-138">Don’t be afraid to scale objects like images and text.</span></span> <span data-ttu-id="5b115-139">[**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940) がアニメーション化されている間のみ、フレームワークによってバイリニア スケーリングが適用されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-139">The framework applies bilinear scaling only while the [**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940) is being animated.</span></span> <span data-ttu-id="5b115-140">画像やテキストは、常にきれいに表示されるように、最終的なサイズでもう一度ラスター化されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-140">The image/text will be rerasterized at the final size to ensure it’s always clear.</span></span>
-   <span data-ttu-id="5b115-141">フレームごとに更新する。これは、実質的には依存型アニメーションです。</span><span class="sxs-lookup"><span data-stu-id="5b115-141">Making per frame updates, which are effectively dependent animations.</span></span> <span data-ttu-id="5b115-142">これの例には、[**CompositonTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) イベントのハンドラーでの変換の適用があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-142">An example of this is applying transformations in the handler of the [**CompositonTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) event.</span></span>
-   <span data-ttu-id="5b115-143">[**CacheMode**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.cachemode) プロパティを **BitmapCache** に設定した要素で独立型と見なされるアニメーションを実行する。</span><span class="sxs-lookup"><span data-stu-id="5b115-143">Running any animation considered independent in an element with the [**CacheMode**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.cachemode) property set to **BitmapCache**.</span></span> <span data-ttu-id="5b115-144">これは、フレームごとにキャッシュをもう一度ラスター化する必要があるため、依存型と見なされます。</span><span class="sxs-lookup"><span data-stu-id="5b115-144">This is considered dependent because the cache must be re-rasterized for each frame.</span></span>

### <a name="dont-animate-a-webview-or-mediaplayerelement"></a><span data-ttu-id="5b115-145">WebView または MediaPlayerElement はアニメーション化しない</span><span class="sxs-lookup"><span data-stu-id="5b115-145">Don't animate a WebView or MediaPlayerElement</span></span>

<span data-ttu-id="5b115-146">[**WebView**](https://msdn.microsoft.com/library/windows/apps/BR227702) コントロール内の Web コンテンツは、XAML フレームワークによって直接レンダリングされることはないため、画面の他の部分と合成する追加の作業が必要になります。</span><span class="sxs-lookup"><span data-stu-id="5b115-146">Web content within a [**WebView**](https://msdn.microsoft.com/library/windows/apps/BR227702) control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene.</span></span> <span data-ttu-id="5b115-147">この追加の作業は画面上でコントロールをアニメーション化する際に行われ、同期の問題 (HTML コンテンツがページ上の XAML コンテンツの他の部分と同期して動かないなど) が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-147">This extra work adds up when animating the control around the screen and can potentially introduce synchronization issues (for example, the HTML content might not move in sync with the rest of the XAML content on the page).</span></span> <span data-ttu-id="5b115-148">**WebView** コントロールをアニメーション化する必要がある場合は、アニメーションを実行している間、そのコントロールを [**WebViewBrush**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webviewbrush.aspx) に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="5b115-148">When you need to animate a **WebView** control, swap it with a [**WebViewBrush**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webviewbrush.aspx) for the duration of the animation.</span></span>

<span data-ttu-id="5b115-149">[**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) のアニメーション化も同様に適切ではない方法です。</span><span class="sxs-lookup"><span data-stu-id="5b115-149">Animating a [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) is a similarly bad idea.</span></span> <span data-ttu-id="5b115-150">パフォーマンスが低下するだけでなく、再生中のビデオ コンテンツに裂け目のようなアーティファクトが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="5b115-150">Beyond the performance detriment, it can cause tearing or other artifacts in the video content being played.</span></span>

> <span data-ttu-id="5b115-151">**注:**  **MediaPlayerElement**に関するこの記事で推奨事項は、 [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/br242926)にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-151">**Note** The recommendations in this article for **MediaPlayerElement** also apply to [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/br242926).</span></span> <span data-ttu-id="5b115-152">**MediaPlayerElement** は Windows 10 バージョン 1607 でのみ利用できます。以前のバージョンの Windows 用のアプリを作成する場合は、**MediaElement** を使う必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-152">**MediaPlayerElement** is only available in Windows 10, version 1607, so if you are creating an app for a previous version of Windows you need to use **MediaElement**.</span></span>

### <a name="use-infinite-animations-sparingly"></a><span data-ttu-id="5b115-153">無限アニメーションは慎重に使う</span><span class="sxs-lookup"><span data-stu-id="5b115-153">Use infinite animations sparingly</span></span>

<span data-ttu-id="5b115-154">大部分のアニメーションは指定された時間内で実行されますが、[**Timeline.Duration**](https://msdn.microsoft.com/library/windows/apps/BR243207) プロパティを Forever に設定すると、アニメーションを無限に実行できます。</span><span class="sxs-lookup"><span data-stu-id="5b115-154">Most animations execute for a specified amount of time, but setting the [**Timeline.Duration**](https://msdn.microsoft.com/library/windows/apps/BR243207) property to Forever allows an animation to run indefinitely.</span></span> <span data-ttu-id="5b115-155">この無限アニメーションを使うのはできるだけ避けてください。これらが CPU リソースを消費し続けることで、CPU が低電力またはアイドル状態に移行できず、非常に短い時間でバッテリーを使い果たす可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="5b115-155">We recommend minimizing the use of infinite animations because they continually consume CPU resources and can prevent the CPU from going into a low power or idle state, causing it to run out of power more quickly.</span></span>

<span data-ttu-id="5b115-156">[**CompositionTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) のハンドラーの追加は、無限アニメーションの実行と同じような効果があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-156">Adding a handler for [**CompositionTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) is similar to running an infinite animation.</span></span> <span data-ttu-id="5b115-157">通常、UI スレッドは実行する作業がある場合にのみアクティブになりますが、このイベントのハンドラーを追加すると、すべてのフレームが強制的に実行されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-157">Normally the UI thread is active only when there is work to do, but adding handler for this event forces it to run every frame.</span></span> <span data-ttu-id="5b115-158">実行する作業がない場合はハンドラーを削除し、再び必要になったときに再登録してください。</span><span class="sxs-lookup"><span data-stu-id="5b115-158">Remove the handler when there is no work to be done and reregister it when it’s needed again.</span></span>

### <a name="use-the-animation-library"></a><span data-ttu-id="5b115-159">アニメーション ライブラリを使う</span><span class="sxs-lookup"><span data-stu-id="5b115-159">Use the animation library</span></span>

<span data-ttu-id="5b115-160">[**Windows.UI.Xaml.Media.Animation**](https://msdn.microsoft.com/library/windows/apps/BR243232) 名前空間には、他の Windows アニメーションとの一貫性を備えた外観を持つ、高パフォーマンスかつスムーズなアニメーションのライブラリが含まれています。</span><span class="sxs-lookup"><span data-stu-id="5b115-160">The [**Windows.UI.Xaml.Media.Animation**](https://msdn.microsoft.com/library/windows/apps/BR243232) namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations.</span></span> <span data-ttu-id="5b115-161">関連クラスは名前に "Theme" が含まれています。関連クラスについては、「[アニメーションの概要](https://msdn.microsoft.com/library/windows/apps/Mt187350)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5b115-161">The relevant classes have "Theme" in their name, and are described in [Animations overview](https://msdn.microsoft.com/library/windows/apps/Mt187350).</span></span> <span data-ttu-id="5b115-162">このライブラリは、アプリの最初の表示や、状態とコンテンツの切り替えにアニメーションを設定するなど、一般的なアニメーション シナリオの多くに対応しています。</span><span class="sxs-lookup"><span data-stu-id="5b115-162">This library supports many common animation scenarios, such as animating the first view of the app and creating state and content transitions.</span></span> <span data-ttu-id="5b115-163">パフォーマンスを高め UWP UI との一貫性を強化するために、できるだけこのアニメーション ライブラリを使うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="5b115-163">We recommend using this animation library whenever possible to increase performance and consistency for UWP UI.</span></span>

> <span data-ttu-id="5b115-164">**注:** アニメーション ライブラリには、すべてのプロパティがアニメーション化することはできません。</span><span class="sxs-lookup"><span data-stu-id="5b115-164">**Note** The animation library can't animate all possible properties.</span></span> <span data-ttu-id="5b115-165">アニメーション ライブラリが適用されない XAML シナリオについては、「[ストーリーボードに設定されたアニメーション](https://msdn.microsoft.com/library/windows/apps/Mt187354)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5b115-165">For XAML scenarios where the animation library doesn't apply, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/Mt187354).</span></span>


### <a name="animate-compositetransform3d-properties-independently"></a><span data-ttu-id="5b115-166">CompositeTransform3D のプロパティを個別にアニメーション化する</span><span class="sxs-lookup"><span data-stu-id="5b115-166">Animate CompositeTransform3D properties independently</span></span>

<span data-ttu-id="5b115-167">[**CompositeTransform3D**](https://msdn.microsoft.com/library/windows/apps/Dn914714) の各プロパティを個別にアニメーション化して、必要なアニメーションのみを適用できます。</span><span class="sxs-lookup"><span data-stu-id="5b115-167">You can animate each property of a [**CompositeTransform3D**](https://msdn.microsoft.com/library/windows/apps/Dn914714) independently, so apply only the animations you need.</span></span> <span data-ttu-id="5b115-168">詳しい説明と例については、「[**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5b115-168">For examples and more info, see [**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d).</span></span> <span data-ttu-id="5b115-169">変換のアニメーション化について詳しくは、「[ストーリーボードに設定されたアニメーション](https://msdn.microsoft.com/library/windows/apps/Mt187354)」および「[キーフレームとイージング関数のアニメーション](https://msdn.microsoft.com/library/windows/apps/Mt187352)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5b115-169">For more info about animating transforms, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/Mt187354) and [Key-frame and easing function animations](https://msdn.microsoft.com/library/windows/apps/Mt187352).</span></span>

## <a name="optimize-media-resources"></a><span data-ttu-id="5b115-170">メディア リソースの最適化</span><span class="sxs-lookup"><span data-stu-id="5b115-170">Optimize media resources</span></span>

<span data-ttu-id="5b115-171">オーディオ、ビデオ、画像は、ほとんどのアプリがユーザーを引き付けるために使うコンテンツです。</span><span class="sxs-lookup"><span data-stu-id="5b115-171">Audio, video, and images are compelling forms of content that the majority of apps use.</span></span> <span data-ttu-id="5b115-172">メディアのキャプチャ レートが向上し、コンテンツが標準解像度から高解像度に移行しているため、そうしたコンテンツを格納、デコード、再生するために必要なリソースの量が増えています。</span><span class="sxs-lookup"><span data-stu-id="5b115-172">As media capture rates increase and content moves from standard definition to high definition the amount of resources need to store, decode, and play back this content increases.</span></span> <span data-ttu-id="5b115-173">XAML フレームワークは UWP のメディア エンジンに追加された最新機能を基に構築されているため、アプリでそれらの機能を無料で利用できます。</span><span class="sxs-lookup"><span data-stu-id="5b115-173">The XAML framework builds on the latest features added to the UWP media engines so apps get these improvements for free.</span></span> <span data-ttu-id="5b115-174">ここでは、UWP アプリでメディアを活用するためのヒントをいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="5b115-174">Here we explain some additional tricks that allow you to get the most out media in your UWP app.</span></span>

### <a name="release-media-streams"></a><span data-ttu-id="5b115-175">メディア ストリームの解放</span><span class="sxs-lookup"><span data-stu-id="5b115-175">Release media streams</span></span>

<span data-ttu-id="5b115-176">メディア ファイルは、アプリが通常使うリソースの中で最も一般的かつ負荷の高いリソースに分類されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-176">Media files are some of the most common and expensive resources apps typically use.</span></span> <span data-ttu-id="5b115-177">メディア ファイル リソースによってアプリのメモリ使用量のサイズが大幅に増大することがあるため、アプリの使用が終わったらすぐにメディアへのハンドルを忘れずに解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-177">Because media file resources can greatly increase the size of your app's memory footprint, you must remember to release the handle to media as soon as the app is finished using it.</span></span>

<span data-ttu-id="5b115-178">たとえば、アプリが [**RandomAccessStream**](/uwp/api/Windows.Storage.Streams.RandomAccessStream) または [**IInputStream**](https://msdn.microsoft.com/library/windows/apps/BR241718) オブジェクトを使っている場合は、アプリの使用が終わったらこのオブジェクトで close メソッドを呼び出して、下位にあるオブジェクトを解放します。</span><span class="sxs-lookup"><span data-stu-id="5b115-178">For example, if your app working with a [**RandomAccessStream**](/uwp/api/Windows.Storage.Streams.RandomAccessStream) or an [**IInputStream**](https://msdn.microsoft.com/library/windows/apps/BR241718) object, be sure to call the close method on the object when your app has finished using it, to release the underlying object.</span></span>

### <a name="display-full-screen-video-playback-when-possible"></a><span data-ttu-id="5b115-179">可能な場合はビデオ再生を全画面表示</span><span class="sxs-lookup"><span data-stu-id="5b115-179">Display full screen video playback when possible</span></span>

<span data-ttu-id="5b115-180">UWP アプリでは、フル ウィンドウのレンダリングを有効または無効にする場合、常に [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) の [**IsFullWindow**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.isfullwindow.aspx) プロパティを使います。</span><span class="sxs-lookup"><span data-stu-id="5b115-180">In UWP apps, always use the [**IsFullWindow**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.isfullwindow.aspx) property on the [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) to enable and disable full window rendering.</span></span> <span data-ttu-id="5b115-181">そうすることで、メディアの再生中にシステム レベルの最適化が使われることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-181">This insures system level optimizations are used during media playback.</span></span>

<span data-ttu-id="5b115-182">XAML フレームワークでは、レンダリングの対象がビデオ コンテンツだけの場合は、ビデオ コンテンツの表示を最適化することができます。その結果、消費電力が低減され、フレーム レートが改善されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-182">The XAML framework can optimize the display of video content when it is the only thing being rendered, resulting in an experience that uses less power and yields higher frame rates.</span></span> <span data-ttu-id="5b115-183">メディアの再生を最適化するには、**MediaPlayerElement** のサイズを画面の幅と高さに設定し、他の XAML 要素を表示しないようにします。</span><span class="sxs-lookup"><span data-stu-id="5b115-183">For most efficient media playback set the size of a **MediaPlayerElement** to be the width and height of the screen and don’t display other XAML elements</span></span>

<span data-ttu-id="5b115-184">画面全体を占める **MediaPlayerElement** の上に XAML 要素 (クローズド キャプションや一時的なトランスポート コントロールなど) をオーバーレイすることには正当な理由があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-184">There are legitimate reasons to overlay XAML elements on a **MediaPlayerElement** that takes up the full width and height of the screen, for example closed captions or momentary transport controls.</span></span> <span data-ttu-id="5b115-185">これらの要素でメディアの再生を最適な状態に戻す必要がない場合は、これらの要素を非表示にしてください (`Visibility="Collapsed"` を設定する)。</span><span class="sxs-lookup"><span data-stu-id="5b115-185">Make sure to hide these elements (set `Visibility="Collapsed"`) when they are not needed to put media playback back into its most efficient state.</span></span>

### <a name="display-deactivation-and-conserving-power"></a><span data-ttu-id="5b115-186">ディスプレイの非アクティブ化と消費電力の節約</span><span class="sxs-lookup"><span data-stu-id="5b115-186">Display deactivation and conserving power</span></span>

<span data-ttu-id="5b115-187">アプリでビデオを再生しているときなど、無操作状態が検出されてもディスプレイの電源が切れないようにするためには、[**DisplayRequest.RequestActive**](https://msdn.microsoft.com/library/windows/apps/BR241818) を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="5b115-187">To prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call [**DisplayRequest.RequestActive**](https://msdn.microsoft.com/library/windows/apps/BR241818).</span></span>

<span data-ttu-id="5b115-188">消費電力とバッテリーの駆動時間を節約するため、不要になったらすぐに [**DisplayRequest.RequestRelease**](https://msdn.microsoft.com/library/windows/apps/BR241819) を呼び出して表示要求を解放してください。</span><span class="sxs-lookup"><span data-stu-id="5b115-188">To conserve power and battery life, you should call [**DisplayRequest.RequestRelease**](https://msdn.microsoft.com/library/windows/apps/BR241819) to release the display request as soon as it is no longer required.</span></span>

<span data-ttu-id="5b115-189">表示要求を解放する必要があるのは、次のような場合です。</span><span class="sxs-lookup"><span data-stu-id="5b115-189">Here are some situations when you should release the display request:</span></span>

-   <span data-ttu-id="5b115-190">ユーザーの操作、バッファリング、限られた帯域幅のための調整などでビデオの再生が一時停止になる。</span><span class="sxs-lookup"><span data-stu-id="5b115-190">Video playback is paused, for example by user action, buffering, or adjustment due to limited bandwidth.</span></span>
-   <span data-ttu-id="5b115-191">再生が停止する。</span><span class="sxs-lookup"><span data-stu-id="5b115-191">Playback stops.</span></span> <span data-ttu-id="5b115-192">たとえば、ビデオの再生が完了したり、プレゼンテーションが終了したりする。</span><span class="sxs-lookup"><span data-stu-id="5b115-192">For example, the video is done playing or the presentation is over.</span></span>
-   <span data-ttu-id="5b115-193">再生エラーが発生した。</span><span class="sxs-lookup"><span data-stu-id="5b115-193">A playback error has occurred.</span></span> <span data-ttu-id="5b115-194">たとえば、ネットワーク接続の問題や破損したファイル。</span><span class="sxs-lookup"><span data-stu-id="5b115-194">For example, network connectivity issues or a corrupted file.</span></span>

### <a name="put-other-elements-to-the-side-of-embedded-video"></a><span data-ttu-id="5b115-195">埋め込みビデオの横に他の要素を配置</span><span class="sxs-lookup"><span data-stu-id="5b115-195">Put other elements to the side of embedded video</span></span>

<span data-ttu-id="5b115-196">アプリには、ページ内でビデオを再生する埋め込みビューが用意されていることがあります。</span><span class="sxs-lookup"><span data-stu-id="5b115-196">Often apps offer an embedded view where video is played within a page.</span></span> <span data-ttu-id="5b115-197">その場合は、[**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) がページのサイズではなく、他に描画される XAML オブジェクトがあるため、全画面表示の最適化が行われません。</span><span class="sxs-lookup"><span data-stu-id="5b115-197">Now you obviously lost the full screen optimization because the [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) is not the size of the page and there are other XAML objects drawn.</span></span> <span data-ttu-id="5b115-198">**MediaPlayerElement** の周りに境界線を描画すると、意図せずにこのモードになることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5b115-198">Beware of unintentionally entering this mode by drawing a border around a **MediaPlayerElement**.</span></span>

<span data-ttu-id="5b115-199">埋め込みモードの場合は、ビデオの上に重ねて XAML 要素を描画しないでください。</span><span class="sxs-lookup"><span data-stu-id="5b115-199">Don’t draw XAML elements on top of video when it’s in embedded mode.</span></span> <span data-ttu-id="5b115-200">描画すると、画面を合成するためにフレームワークが追加作業を行うことになります。</span><span class="sxs-lookup"><span data-stu-id="5b115-200">If you do, the framework is forced to do a little extra work to compose the scene.</span></span> <span data-ttu-id="5b115-201">この場合は、ビデオの上に重ねずに、たとえば、埋め込みメディア要素の下にトランスポート コントロールを配置すると、最適化が行われます。</span><span class="sxs-lookup"><span data-stu-id="5b115-201">Placing transport controls below an embedded media element instead of on top of the video is a good example of optimizing for this situation.</span></span> <span data-ttu-id="5b115-202">次の画像では、赤色のバーが一連のトランスポート コントロール (再生、一時停止、停止など) を示しています。</span><span class="sxs-lookup"><span data-stu-id="5b115-202">In this image, the red bar indicates a set of transport controls (play, pause, stop, etc.).</span></span>

![要素がオーバーレイされている MediaPlayerElement](images/videowithoverlay.png)

<span data-ttu-id="5b115-204">メディアが全画面ではないときは、メディアの上にこれらのコントロールを重ねて配置しないでください。</span><span class="sxs-lookup"><span data-stu-id="5b115-204">Don’t place these controls on top of media that is not full screen.</span></span> <span data-ttu-id="5b115-205">代わりに、メディアがレンダリングされる領域の外にトランスポート コントロールを配置します。</span><span class="sxs-lookup"><span data-stu-id="5b115-205">Instead place the transport controls somewhere outside of the area where the media is being rendered.</span></span> <span data-ttu-id="5b115-206">次の画像では、コントロールがメディアの下に配置されています。</span><span class="sxs-lookup"><span data-stu-id="5b115-206">In the next image, the controls are placed below the media.</span></span>

![要素が隣接している MediaPlayerElement](images/videowithneighbors.png)

### <a name="delay-setting-the-source-for-a-mediaplayerelement"></a><span data-ttu-id="5b115-208">MediaPlayerElement のソースの遅延設定</span><span class="sxs-lookup"><span data-stu-id="5b115-208">Delay setting the source for a MediaPlayerElement</span></span>

<span data-ttu-id="5b115-209">メディア エンジンは負荷の高いオブジェクトです。XAML フレームワークでは、dll の読み込みと大きなオブジェクトの作成を可能な限り遅らせます。</span><span class="sxs-lookup"><span data-stu-id="5b115-209">Media engines are expensive objects and the XAML framework delays loading dlls and creating large objects as long as possible.</span></span> <span data-ttu-id="5b115-210">[**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) では、ソースが [**Source**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.source.aspx) プロパティによって設定されると、この処理が強制的に実行されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-210">The [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) is forced to do this work after its source is set via the [**Source**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.source.aspx) property.</span></span> <span data-ttu-id="5b115-211">ユーザーがメディアを再生する準備が実際に整った時点でソースを設定すると、**MediaPlayerElement** に関連する負担の大部分を可能な限り遅らせることができます。</span><span class="sxs-lookup"><span data-stu-id="5b115-211">Setting this when the user is really ready to play media delays the majority of the cost associated with the **MediaPlayerElement** as long as possible.</span></span>

### <a name="set-mediaplayerelementpostersource"></a><span data-ttu-id="5b115-212">MediaPlayerElement.PosterSource の設定</span><span class="sxs-lookup"><span data-stu-id="5b115-212">Set MediaPlayerElement.PosterSource</span></span>

<span data-ttu-id="5b115-213">[**MediaPlayerElement.PosterSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.postersource.aspx) を設定すると、XAML は一部の GPU リソースを解放できます。解放しないと、それらのリソースは使われたままになります。</span><span class="sxs-lookup"><span data-stu-id="5b115-213">Setting [**MediaPlayerElement.PosterSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.postersource.aspx) enables XAML to release some GPU resources that would have otherwise been used.</span></span> <span data-ttu-id="5b115-214">この API を使うことで、アプリが使うメモリを最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="5b115-214">This API allows an app to use as little memory as possible.</span></span>

### <a name="improve-media-scrubbing"></a><span data-ttu-id="5b115-215">メディアのスクラブの改善</span><span class="sxs-lookup"><span data-stu-id="5b115-215">Improve media scrubbing</span></span>

<span data-ttu-id="5b115-216">メディア プラットフォームの応答性を高めるにあたってスクラブは常に困難を伴うタスクです。</span><span class="sxs-lookup"><span data-stu-id="5b115-216">Scrubbing is always a tough task for media platforms to make really responsive.</span></span> <span data-ttu-id="5b115-217">一般的には、Slider の値を変更することで、これを実現します。</span><span class="sxs-lookup"><span data-stu-id="5b115-217">Generally people accomplish this by changing the value of a Slider.</span></span> <span data-ttu-id="5b115-218">次に、スクラブ操作をできるだけ効率的にするためのヒントをいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="5b115-218">Here are a couple tips on how to make this as efficient as possible:</span></span>

-   <span data-ttu-id="5b115-219">[**Slider**](https://msdn.microsoft.com/library/windows/apps/BR209614) の値を [**MediaPlayerElement.MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.mediaplayer.aspx) の [**Position**](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplaybacksession.position.aspx) を照会するタイマーに基づいて更新します。</span><span class="sxs-lookup"><span data-stu-id="5b115-219">Update the value of [**Slider**](https://msdn.microsoft.com/library/windows/apps/BR209614) based on a timer that queries the [**Position**](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplaybacksession.position.aspx) on the [**MediaPlayerElement.MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.mediaplayer.aspx).</span></span> <span data-ttu-id="5b115-220">タイマーに適切な更新頻度を設定します。</span><span class="sxs-lookup"><span data-stu-id="5b115-220">Make sure to use a reasonable update frequency for your timer.</span></span> <span data-ttu-id="5b115-221">**Position** プロパティは再生中に 250 ミリ秒ごとにのみ更新します。</span><span class="sxs-lookup"><span data-stu-id="5b115-221">The **Position** property only updates every 250 millisecond during playback.</span></span>
-   <span data-ttu-id="5b115-222">Slider のステップ間隔のサイズは、ビデオの長さに合わせて変える必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-222">The size of the step frequency on the Slider must scale with the length of the video.</span></span>
-   <span data-ttu-id="5b115-223">スライダーの [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerpressed.aspx)、[**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointermoved.aspx)、[**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerreleased.aspx) イベントを取得して、ユーザーがスライダーのつまみをドラッグしたときに [**PlaybackRate**](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplaybacksession.playbackrate.aspx) プロパティを 0 に設定します。</span><span class="sxs-lookup"><span data-stu-id="5b115-223">Subscribe to the [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerpressed.aspx), [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointermoved.aspx), [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerreleased.aspx) events on the slider to set the [**PlaybackRate**](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplaybacksession.playbackrate.aspx) property to 0 when the user drags the thumb of the slider.</span></span>
-   <span data-ttu-id="5b115-224">[**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerreleased.aspx) イベント ハンドラーで、スクラブ中のつまみのスナップ動作を最適化するために、メディアの位置をスライダーの位置の値に手動で設定します。</span><span class="sxs-lookup"><span data-stu-id="5b115-224">In the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerreleased.aspx) event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing.</span></span>

### <a name="match-video-resolution-to-device-resolution"></a><span data-ttu-id="5b115-225">ビデオ解像度とデバイス解像度の一致</span><span class="sxs-lookup"><span data-stu-id="5b115-225">Match video resolution to device resolution</span></span>

<span data-ttu-id="5b115-226">ビデオのデコードにはメモリと GPU サイクルを大量に使うため、ビデオ形式には、表示するときのものに近い解像度を選んでください。</span><span class="sxs-lookup"><span data-stu-id="5b115-226">Decoding video takes a lot of memory and GPU cycles, so choose a video format close to the resolution it will be displayed at.</span></span> <span data-ttu-id="5b115-227">小さいサイズにスケールダウンするのに、リソースを使って 1080 のビデオをデコードするのは無駄です。</span><span class="sxs-lookup"><span data-stu-id="5b115-227">There is no point in using the resources to decode 1080 video if it’s going to get scaled down to a much smaller size.</span></span> <span data-ttu-id="5b115-228">多くのアプリでは同じビデオを異なる解像度でエンコードできませんが、可能であれば、表示される解像度に近いエンコードを使うようにしてください。</span><span class="sxs-lookup"><span data-stu-id="5b115-228">Many apps don’t have the same video encoded at different resolutions; but if it is available, use an encoding that is close to the resolution at which it will be displayed.</span></span>

### <a name="choose-recommended-formats"></a><span data-ttu-id="5b115-229">お勧めの形式の選択</span><span class="sxs-lookup"><span data-stu-id="5b115-229">Choose recommended formats</span></span>

<span data-ttu-id="5b115-230">メディア形式の選択は慎重な判断が必要になる場合があり、多くはビジネス上の意思決定が優先されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-230">Media format selection can be a sensitive topic and is often driven by business decisions.</span></span> <span data-ttu-id="5b115-231">UWP のパフォーマンスの点から見ると、H.264 ビデオが最優先のビデオ形式で、推奨されるオーディオ形式は AAC と MP3 になります。</span><span class="sxs-lookup"><span data-stu-id="5b115-231">From a UWP performance perspective, we recommend H.264 video as the primary video format and AAC and MP3 as the preferred audio formats.</span></span> <span data-ttu-id="5b115-232">ローカル ファイルを再生するためのビデオ コンテンツのファイル コンテナーは MP4 がお勧めです。</span><span class="sxs-lookup"><span data-stu-id="5b115-232">For local file playback, MP4 is the preferred file container for video content.</span></span> <span data-ttu-id="5b115-233">最新のグラフィックス ハードウェアのほとんどは H.264 デコードのアクセラレーションに対応しています。</span><span class="sxs-lookup"><span data-stu-id="5b115-233">H.264 decoding is accelerated through most recent graphics hardware.</span></span> <span data-ttu-id="5b115-234">また、VC-1 デコードのハードウェア アクセラレーションは広く利用できるようになっているものの、市場のグラフィックス ハードウェアの多くで、アクセラレーションがフルストリーム レベルのハードウェア オフロード (VLD モード) ではなく、部分的なアクセラレーションのレベル (IDCT レベル) に制限されています。</span><span class="sxs-lookup"><span data-stu-id="5b115-234">Also, although hardware acceleration for VC-1 decoding is broadly available, for a large set of graphics hardware on the market, the acceleration is limited in many cases to a partial acceleration level (or IDCT level), rather than a full-steam level hardware offload (i.e. VLD mode).</span></span>

<span data-ttu-id="5b115-235">ビデオ コンテンツ生成プロセスを完全に制御できる場合は、圧縮の効率性と GOP 構造を最適なバランスで両立する方法を見つける必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-235">If you have full control of the video content generation process, you must figure out how to keep a good balance between compression efficiency and GOP structure.</span></span> <span data-ttu-id="5b115-236">B ピクチャを持つ GOP のサイズを比較的小さくすることで、シークまたはトリック モードのパフォーマンスを向上できます。</span><span class="sxs-lookup"><span data-stu-id="5b115-236">Relatively smaller GOP size with B pictures can increase the performance in seeking or trick modes.</span></span>

<span data-ttu-id="5b115-237">ゲームなどで、待機時間の短い短時間のオーディオ エフェクトを含める場合、WAV ファイルと非圧縮の PCM データを使います。これにより圧縮オーディオ形式で一般的に発生する処理のオーバーヘッドを削減できます。</span><span class="sxs-lookup"><span data-stu-id="5b115-237">When including short, low-latency audio effects, for example in games, use WAV files with uncompressed PCM data to reduce processing overhead that is typical for compressed audio formats.</span></span>


## <a name="optimize-image-resources"></a><span data-ttu-id="5b115-238">画像リソースの最適化</span><span class="sxs-lookup"><span data-stu-id="5b115-238">Optimize image resources</span></span>

### <a name="scale-images-to-the-appropriate-size"></a><span data-ttu-id="5b115-239">画像の適切なサイズへの拡大/縮小</span><span class="sxs-lookup"><span data-stu-id="5b115-239">Scale images to the appropriate size</span></span>

<span data-ttu-id="5b115-240">画像が非常に高い解像度でキャプチャされた場合、アプリで画像データをデコードするときに CPU をより多く使用し、ディスクから画像を読み込んだ後でより多くのメモリを使用することにつながる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-240">Images are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk.</span></span> <span data-ttu-id="5b115-241">ただし、画像を元のサイズよりも小さいサイズでのみ表示する場合、高解像度の画像をデコードしてメモリに保存するのは無意味です。</span><span class="sxs-lookup"><span data-stu-id="5b115-241">But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size.</span></span> <span data-ttu-id="5b115-242">代わりに、[**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) プロパティと [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) プロパティを使って、画面上に描画される正確なサイズの画像のバージョンを作成します。</span><span class="sxs-lookup"><span data-stu-id="5b115-242">Instead, create a version of the image at the exact size it will be drawn on-screen using the [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) properties.</span></span>

<span data-ttu-id="5b115-243">してはいけない例:</span><span class="sxs-lookup"><span data-stu-id="5b115-243">Don't do this:</span></span>

```xaml
<Image Source="ms-appx:///Assets/highresCar.jpg"
       Width="300" Height="200"/>    <!-- BAD CODE DO NOT USE.-->
```

<span data-ttu-id="5b115-244">代わりに、お勧めする例:</span><span class="sxs-lookup"><span data-stu-id="5b115-244">Instead, do this:</span></span>

```xaml
<Image>
    <Image.Source>
    <BitmapImage UriSource="ms-appx:///Assets/highresCar.jpg"
                 DecodePixelWidth="300" DecodePixelHeight="200"/>
    </Image.Source>
</Image>
```

<span data-ttu-id="5b115-245">[**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) と [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) の単位は、既定では物理ピクセルです。</span><span class="sxs-lookup"><span data-stu-id="5b115-245">The units for [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) are by default physical pixels.</span></span> <span data-ttu-id="5b115-246">[**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) プロパティを使って、この動作を変更できます。**DecodePixelType** を **Logical** に設定すると、他の XAML コンテンツと同様に、デコード サイズで自動的に現在の倍率が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-246">The [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) property can be used to change this behavior: setting **DecodePixelType** to **Logical** results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content.</span></span> <span data-ttu-id="5b115-247">したがって、一般的には、**DecodePixelType** を **Logical** に設定することをお勧めします。たとえば、**DecodePixelWidth** と **DecodePixelHeight** を、画像が表示される Image コントロールの Height プロパティと Width プロパティと一致させるような場合です。</span><span class="sxs-lookup"><span data-stu-id="5b115-247">It would therefore be generally appropriate to set **DecodePixelType** to **Logical** if, for instance, you want **DecodePixelWidth** and **DecodePixelHeight** to match the Height and Width properties of the Image control the image will be displayed in.</span></span> <span data-ttu-id="5b115-248">物理ピクセルを使用する既定の動作では、システムの現在の倍率を自分で考慮する必要があります。また、ユーザーが表示設定を変更する場合に備えて、スケール変更通知をリッスンする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-248">With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself; and you should listen for scale change notifications in case the user changes their display preferences.</span></span>

<span data-ttu-id="5b115-249">DecodePixelWidth/Height が明示的に画面に表示される画像よりも大きく設定されている場合、アプリは不必要に余分なメモリ (1 ピクセルあたり最大 4 バイト) を使用するため、大きい画像では急速に負荷が大きくなります。</span><span class="sxs-lookup"><span data-stu-id="5b115-249">If DecodePixelWidth/Height are explicitly set larger than the image will be displayed on-screen then the app will unnecessarily use extra memory—up to 4 bytes per pixel—which quickly becomes expensive for large images.</span></span> <span data-ttu-id="5b115-250">また、画像はバイリニア スケーリングを使って縮小されるため、倍率が大きくなるとぼやけて見える原因となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-250">The image will also be scaled down using bilinear scaling which could cause it to appear blurry for large scale factors.</span></span>

<span data-ttu-id="5b115-251">DecodePixelWidth/DecodePixelHeight が明示的に画面に表示される画像よりも小さく設定されている場合、画像は拡大され、ピクセル化されたように見える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-251">If DecodePixelWidth/DecodePixelHeight are explicitly set smaller than the image will be displayed on screen then it will be scaled up and could appear pixelated.</span></span>

<span data-ttu-id="5b115-252">事前に適切なデコード サイズを特定できない場合には、明示的な DecodePixelWidth/DecodePixelHeight が指定されていないときに、適切なサイズでの画像のデコードをベスト エフォート形式で試行する、XAML の適切なサイズの自動デコードを遅延させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-252">In some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.</span></span>

<span data-ttu-id="5b115-253">事前に画像コンテンツのサイズがわかっている場合は、明示的にデコード サイズを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-253">You should set an explicit decode size if you know the size of the image content ahead of time.</span></span> <span data-ttu-id="5b115-254">指定したデコード サイズが他の XAML 要素のサイズを基準としている場合は、併せて [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) を **Logical** に設定することも必要です。</span><span class="sxs-lookup"><span data-stu-id="5b115-254">You should also in conjunction set [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) to **Logical** if the supplied decode size is relative to other XAML element sizes.</span></span> <span data-ttu-id="5b115-255">たとえば、Image.Width と Image.Height を使ってコンテンツのサイズを明示的に設定する場合、DecodePixelType を DecodePixelType.Logical に設定して Image コントロールと同じ論理ピクセル サイズを使用し、明示的に BitmapImage.DecodePixelWidth や BitmapImage.DecodePixelHeight を使って画像のサイズを制御することによって、大量のメモリ消費を抑えることができる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-255">For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.</span></span>

<span data-ttu-id="5b115-256">デコードされたコンテンツのサイズを決定するときに、Image.Stretch を考慮する必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5b115-256">Note that Image.Stretch should be considered when determining the size of the decoded content.</span></span>

### <a name="right-sized-decoding"></a><span data-ttu-id="5b115-257">適切なサイズのデコード</span><span class="sxs-lookup"><span data-stu-id="5b115-257">Right-sized decoding</span></span>

<span data-ttu-id="5b115-258">明示的なデコード サイズを設定していない場合、XAML では、画像を表示するページの初期レイアウトに従って、画面に表示される正確なサイズで画像をデコードすることにより、メモリの消費を最大限に抑えようとします。</span><span class="sxs-lookup"><span data-stu-id="5b115-258">In the event that you don't set an explicit decode size, XAML will make a best effort attempt to save memory by decoding an image to the exact size it will appear on-screen according to the containing page’s initial layout.</span></span> <span data-ttu-id="5b115-259">可能な限り、この機能を使用するような方法でアプリケーションを作成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="5b115-259">You're advised to write your application in such a way as to make use of this feature when possible.</span></span> <span data-ttu-id="5b115-260">次の条件のいずれかが満たされる場合、この機能は無効になります。</span><span class="sxs-lookup"><span data-stu-id="5b115-260">This feature will be disabled if any of the following conditions are met.</span></span>

-   <span data-ttu-id="5b115-261">[**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) または [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) を使ってコンテンツを設定した後、[**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) がライブ XAML ツリーに接続されている。</span><span class="sxs-lookup"><span data-stu-id="5b115-261">The [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) is connected to the live XAML tree after setting the content with [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) or [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx).</span></span>
-   <span data-ttu-id="5b115-262">画像が [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) などの同期デコードを使用してデコードされる。</span><span class="sxs-lookup"><span data-stu-id="5b115-262">The image is decoded using synchronous decoding such as [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255).</span></span>
-   <span data-ttu-id="5b115-263">ホスト画像要素、ブラシ、親要素のいずれかで、[**Opacity**](/uwp/api/Windows.UI.Xaml.UIElement.Opacity) を 0 に設定するか、[**Visibility**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.visibility) を **Collapsed** に設定することによって、画像が非表示になっている。</span><span class="sxs-lookup"><span data-stu-id="5b115-263">The image is hidden via setting [**Opacity**](/uwp/api/Windows.UI.Xaml.UIElement.Opacity) to 0 or [**Visibility**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.visibility) to **Collapsed** on the host image element or brush or any parent element.</span></span>
-   <span data-ttu-id="5b115-264">画像コントロールまたはブラシで使用する [**Stretch**](https://msdn.microsoft.com/library/windows/apps/BR242968) が **None** になっている。</span><span class="sxs-lookup"><span data-stu-id="5b115-264">The image control or brush uses a [**Stretch**](https://msdn.microsoft.com/library/windows/apps/BR242968) of **None**.</span></span>
-   <span data-ttu-id="5b115-265">画像が [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756) として使用されている。</span><span class="sxs-lookup"><span data-stu-id="5b115-265">The image is used as a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756).</span></span>
-   `CacheMode="BitmapCache"` <span data-ttu-id="5b115-266">が画像要素またはいずれかの親要素で設定されている。</span><span class="sxs-lookup"><span data-stu-id="5b115-266">is set on the image element or on any parent element.</span></span>
-   <span data-ttu-id="5b115-267">イメージ ブラシが四角形以外である (テキストや図形に適用する場合など)。</span><span class="sxs-lookup"><span data-stu-id="5b115-267">The image brush is non-rectangular (such as when applied to a shape or to text).</span></span>

<span data-ttu-id="5b115-268">上記のシナリオでメモリの節約を実現するための方法は、明示的にデコード サイズを設定することだけです。</span><span class="sxs-lookup"><span data-stu-id="5b115-268">In the above scenarios, setting an explicit decode size is the only way to achieve memory savings.</span></span>

<span data-ttu-id="5b115-269">ソースを設定する前に、常に [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) をライブ ツリーにアタッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-269">You should always attach a [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) to the live tree before setting the source.</span></span> <span data-ttu-id="5b115-270">画像要素またはブラシがマークアップで指定されているときは、常にこれが自動的に適用されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-270">Any time an image element or brush is specified in markup, this will automatically be the case.</span></span> <span data-ttu-id="5b115-271">例については、後の「ライブ ツリーの例」という見出しのトピックをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5b115-271">Examples are provided below under the heading "Live tree examples".</span></span> <span data-ttu-id="5b115-272">ストリーム ソースを設定する場合は、常に [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) を使わずに、代わりに [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) を使います。</span><span class="sxs-lookup"><span data-stu-id="5b115-272">You should always avoid using [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) and instead use [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when setting a stream source.</span></span> <span data-ttu-id="5b115-273">[**ImageOpened**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.imageopened.aspx) イベントの発生を待機している間、画像コンテンツを非表示にする (不透明度を 0 にしたり、表示を折りたたむ) ことを回避することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="5b115-273">And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the [**ImageOpened**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.imageopened.aspx) event to be raised.</span></span> <span data-ttu-id="5b115-274">これを行うかどうかは議論の余地があります。これを行った場合、自動的に適切なサイズに調整されたデコードのメリットが得られません。</span><span class="sxs-lookup"><span data-stu-id="5b115-274">Doing this is a judgment call: you won't benefit from automatic right-sized decoding if it's done.</span></span> <span data-ttu-id="5b115-275">アプリで最初に画像コンテンツを非表示にする必要がある場合、可能であれば、明示的にデコード サイズも設定してください。</span><span class="sxs-lookup"><span data-stu-id="5b115-275">If your app must hide image content initially then it should also set the decode size explicitly if possible.</span></span>

**<span data-ttu-id="5b115-276">ライブ ツリーの例</span><span class="sxs-lookup"><span data-stu-id="5b115-276">Live tree examples</span></span>**

<span data-ttu-id="5b115-277">例 1 (良い例): Uniform Resource Identifier (URI) をマークアップで指定。</span><span class="sxs-lookup"><span data-stu-id="5b115-277">Example 1 (good)—Uniform Resource Identifier (URI) specified in markup.</span></span>

```xaml
<Image x:Name="myImage" UriSource="Assets/cool-image.png"/>
```

<span data-ttu-id="5b115-278">例 2 マークアップ: 分離コードで指定された URI。</span><span class="sxs-lookup"><span data-stu-id="5b115-278">Example 2 markup—URI specified in code-behind.</span></span>

```xaml
<Image x:Name="myImage"/>
```

<span data-ttu-id="5b115-279">例 2 分離コード (良い例): UriSource を設定する前に、ツリーに BitmapImage を接続する。</span><span class="sxs-lookup"><span data-stu-id="5b115-279">Example 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.</span></span>

```csharp
var bitmapImage = new BitmapImage();
myImage.Source = bitmapImage;
bitmapImage.UriSource = new URI("ms-appx:///Assets/cool-image.png", UriKind.RelativeOrAbsolute);
```

<span data-ttu-id="5b115-280">例 2 分離コード (悪い例): ツリーに接続する前に、BitmapImage の UriSource を設定します。</span><span class="sxs-lookup"><span data-stu-id="5b115-280">Example 2 code-behind (bad)—setting the BitmapImage's UriSource before connecting it to the tree.</span></span>

```csharp
var bitmapImage = new BitmapImage();
bitmapImage.UriSource = new URI("ms-appx:///Assets/cool-image.png", UriKind.RelativeOrAbsolute);
myImage.Source = bitmapImage;
```

### <a name="caching-optimizations"></a><span data-ttu-id="5b115-281">キャッシュの最適化</span><span class="sxs-lookup"><span data-stu-id="5b115-281">Caching optimizations</span></span>

<span data-ttu-id="5b115-282">キャッシュの最適化は、[**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) を使って、アプリ パッケージまたは Web からコンテンツを読み込む画像について有効です。</span><span class="sxs-lookup"><span data-stu-id="5b115-282">Caching optimizations are in effect for images that use [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) to load content from an app package or from the web.</span></span> <span data-ttu-id="5b115-283">URI は基になるコンテンツを一意に識別するために使用され、XAML フレームワークは内部でコンテンツを複数回ダウンロードまたはデコードしません。</span><span class="sxs-lookup"><span data-stu-id="5b115-283">The URI is used to uniquely identify the underlying content, and internally the XAML framework will not download or decode the content multiple times.</span></span> <span data-ttu-id="5b115-284">代わりに、キャッシュされたソフトウェアまたはハードウェア リソースを使用して、コンテンツが複数回表示されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-284">Instead, it will use the cached software or hardware resources to display the content multiple times.</span></span>

<span data-ttu-id="5b115-285">この最適化の例外は、画像がさまざまな解像度で複数回表示される場合 (これは明示的に指定することも、自動的に適切なサイズに調整されたデコードで指定することもできます) です</span><span class="sxs-lookup"><span data-stu-id="5b115-285">The exception to this optimization is if the image is displayed multiple times at different resolutions (which can be specified explicitly or through automatic right-sized decoding).</span></span> <span data-ttu-id="5b115-286">キャッシュの各エントリには、画像の解像度も格納されます。XAML で必要な解像度に一致するソース URI を持つ画像が見つからない場合は、そのサイズで新しいバージョンがデコードされます。</span><span class="sxs-lookup"><span data-stu-id="5b115-286">Each cache entry also stores the resolution of the image, and if XAML cannot find an image with a source URI that matches the required resolution then it will decode a new version at that size.</span></span> <span data-ttu-id="5b115-287">ただし、エンコードされた画像データをもう一度ダウンロードすることはありません。</span><span class="sxs-lookup"><span data-stu-id="5b115-287">It will not, however, download the encoded image data again.</span></span>

<span data-ttu-id="5b115-288">そのため、アプリ パッケージから画像を読み込む場合は、[**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) の使用を採用する必要があります。また、必要ではない場合に、ファイル ストリームと [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="5b115-288">Consequently, you should embrace using [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) when loading images from an app package, and avoid using a file stream and [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when it's not required.</span></span>

### <a name="images-in-virtualized-panels-listview-for-instance"></a><span data-ttu-id="5b115-289">仮想化されたパネル内の画像 (ListView など)</span><span class="sxs-lookup"><span data-stu-id="5b115-289">Images in virtualized panels (ListView, for instance)</span></span>

<span data-ttu-id="5b115-290">画像がツリーから削除された場合 (アプリによって明示的に削除された場合、最新の仮想化されたパネルにある場合やビューの外部にスクロールされて暗黙的に削除された場合)、XAML では、不要になった画像のハードウェア リソースを解放することによってメモリ使用量を最適化します。</span><span class="sxs-lookup"><span data-stu-id="5b115-290">If an image is removed from the tree—because the app explicitly removed it, or because it’s in a modern virtualized panel and was implicitly removed when scrolled out of view—then XAML will optimize memory usage by releasing the hardware resources for the image since they are no longer required.</span></span> <span data-ttu-id="5b115-291">メモリはすぐに解放されるのではなく、画像要素がツリーに存在しなくなってから 1 秒後に実行されるフレームの更新時にリリースされます。</span><span class="sxs-lookup"><span data-stu-id="5b115-291">The memory is not released immediately, but rather is released during the frame update that occurs after one second of the image element no longer being in the tree.</span></span>

<span data-ttu-id="5b115-292">そのため、最新の仮想化されたパネルを使用して、画像コンテンツの一覧をホストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-292">Consequently, you should strive to use modern virtualized panels to host lists of image content.</span></span>

### <a name="software-rasterized-images"></a><span data-ttu-id="5b115-293">ソフトウェアでラスタライズされた画像</span><span class="sxs-lookup"><span data-stu-id="5b115-293">Software-rasterized images</span></span>

<span data-ttu-id="5b115-294">画像が四角形以外のブラシや [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756) 用に使用されている場合、画像の拡大縮小が行われない、ソフトウェア ラスタライズ パスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-294">When an image is used for a non-rectangular brush or for a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756), the image will use a software rasterization path, which will not scale images at all.</span></span> <span data-ttu-id="5b115-295">さらに、ソフトウェアとハードウェアの両方のメモリに画像のコピーを保存して必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-295">Additionally, it must store a copy of the image in both software and hardware memory.</span></span> <span data-ttu-id="5b115-296">たとえば、画像が楕円形のブラシとして使われる場合、大きい可能性がある画像全体は内部で 2 回保存されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-296">For instance, if an image is used as a brush for an ellipse then the potentially large full image will be stored twice internally.</span></span> <span data-ttu-id="5b115-297">**NineGrid** または四角形以外のブラシを使用する場合は、アプリで画像を事前に拡大縮小し、レンダリング時のおよそのサイズにしておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-297">When using **NineGrid** or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at.</span></span>

### <a name="background-thread-image-loading"></a><span data-ttu-id="5b115-298">バックグラウンド スレッドによる画像の読み込み</span><span class="sxs-lookup"><span data-stu-id="5b115-298">Background thread image-loading</span></span>

<span data-ttu-id="5b115-299">XAML には内部の最適化機能があり、ソフトウェア メモリ内の中間サーフェスを使用せずに、ハードウェア メモリ内のサーフェスに非同期的に画像の内容をデコードすることができます。</span><span class="sxs-lookup"><span data-stu-id="5b115-299">XAML has an internal optimization that allows it to decode the contents of an image asynchronously to a surface in hardware memory without requiring an intermediate surface in software memory.</span></span> <span data-ttu-id="5b115-300">これにより、ピーク メモリ使用量とレンダリングの待機時間が減少します。</span><span class="sxs-lookup"><span data-stu-id="5b115-300">This reduces peak memory usage and rendering latency.</span></span> <span data-ttu-id="5b115-301">次の条件のいずれかが満たされる場合、この機能は無効になります。</span><span class="sxs-lookup"><span data-stu-id="5b115-301">This feature will be disabled if any of the following conditions are met.</span></span>

-   <span data-ttu-id="5b115-302">画像が [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756) として使用されている。</span><span class="sxs-lookup"><span data-stu-id="5b115-302">The image is used as a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756).</span></span>
-   `CacheMode="BitmapCache"` <span data-ttu-id="5b115-303">が画像要素またはいずれかの親要素で設定されている。</span><span class="sxs-lookup"><span data-stu-id="5b115-303">is set on the image element or on any parent element.</span></span>
-   <span data-ttu-id="5b115-304">イメージ ブラシが四角形以外である (テキストや図形に適用する場合など)。</span><span class="sxs-lookup"><span data-stu-id="5b115-304">The image brush is non-rectangular (such as when applied to a shape or to text).</span></span>

### <a name="softwarebitmapsource"></a><span data-ttu-id="5b115-305">SoftwareBitmapSource</span><span class="sxs-lookup"><span data-stu-id="5b115-305">SoftwareBitmapSource</span></span>

<span data-ttu-id="5b115-306">[**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) クラスは、さまざまな WinRT 名前空間 ([**BitmapDecoder**](https://msdn.microsoft.com/library/windows/apps/BR226176) など)、カメラ API、XAML の間で、相互運用可能な非圧縮画像を交換します。</span><span class="sxs-lookup"><span data-stu-id="5b115-306">The [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) class exchanges interoperable uncompressed images between different WinRT namespaces such as [**BitmapDecoder**](https://msdn.microsoft.com/library/windows/apps/BR226176), camera APIs, and XAML.</span></span> <span data-ttu-id="5b115-307">このクラスを使用すると、[**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259) で通常必要となる余分なコピーが不要になり、ピーク メモリ使用量とソースから画面表示までの待機時間が削減されます。</span><span class="sxs-lookup"><span data-stu-id="5b115-307">This class obviates an extra copy that would typically be necessary with [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259), and that helps reduce peak memory and source-to-screen latency.</span></span>

<span data-ttu-id="5b115-308">ソース情報を提供する [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) は、カスタム [**IWICBitmap**](https://msdn.microsoft.com/library/windows/desktop/Ee719675) を使用するように構成して、再読み込み可能なバッキング ストアを提供することもできます。これにより、アプリは必要に応じてメモリを再マップできます。</span><span class="sxs-lookup"><span data-stu-id="5b115-308">The [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) that supplies source information can also be configured to use a custom [**IWICBitmap**](https://msdn.microsoft.com/library/windows/desktop/Ee719675) to provide a reloadable backing store that allows the app to re-map memory as it sees fit.</span></span> <span data-ttu-id="5b115-309">これは、高度な C++ の使用事例です。</span><span class="sxs-lookup"><span data-stu-id="5b115-309">This is an advanced C++ use case.</span></span>

<span data-ttu-id="5b115-310">画像を生成および使用する他の WinRT API と相互運用するには、アプリで [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) と [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) を使う必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-310">Your app should use [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) and [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) to interoperate with other WinRT APIs that produce and consume images.</span></span> <span data-ttu-id="5b115-311">また、アプリで非圧縮画像データを読み込むときには、[**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259) を使用する代わりに、**SoftwareBitmapSource** を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-311">And your app should use **SoftwareBitmapSource** when loading uncompressed image data instead of using [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259).</span></span>

### <a name="use-getthumbnailasync-for-thumbnails"></a><span data-ttu-id="5b115-312">GetThumbnailAsync を使ったサムネイル</span><span class="sxs-lookup"><span data-stu-id="5b115-312">Use GetThumbnailAsync for thumbnails</span></span>

<span data-ttu-id="5b115-313">画像を縮小する使用事例として、サムネイルの作成があります。</span><span class="sxs-lookup"><span data-stu-id="5b115-313">One use case for scaling images is creating thumbnails.</span></span> <span data-ttu-id="5b115-314">[**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) と [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) を使って画像の縮小版を作ることができますが、UWP には、サムネイルを取得するためのもっと効率的な API が用意されています。</span><span class="sxs-lookup"><span data-stu-id="5b115-314">Although you could use [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails.</span></span> <span data-ttu-id="5b115-315">[**GetThumbnailAsync**](https://msdn.microsoft.com/library/windows/apps/BR227210) ファイル システムに既にキャッシュされている画像のサムネイルを提供します。</span><span class="sxs-lookup"><span data-stu-id="5b115-315">[**GetThumbnailAsync**](https://msdn.microsoft.com/library/windows/apps/BR227210) provides the thumbnails for images that have the file system already cached.</span></span> <span data-ttu-id="5b115-316">この方法では、画像を開いたり、デコードしたりする必要がないため、XAML の API よりもパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="5b115-316">This provides even better performance than the XAML APIs because the image doesn’t need to be opened or decoded.</span></span>

> [!div class="tabbedCodeSnippets"]
> ```csharp
> FileOpenPicker picker = new FileOpenPicker();
> picker.FileTypeFilter.Add(".bmp");
> picker.FileTypeFilter.Add(".jpg");
> picker.FileTypeFilter.Add(".jpeg");
> picker.FileTypeFilter.Add(".png");
> picker.SuggestedStartLocation = PickerLocationId.PicturesLibrary;
>
> StorageFile file = await picker.PickSingleFileAsync();
>
> StorageItemThumbnail fileThumbnail = await file.GetThumbnailAsync(ThumbnailMode.SingleItem, 64);
>
> BitmapImage bmp = new BitmapImage();
> bmp.SetSource(fileThumbnail);
>
> Image img = new Image();
> img.Source = bmp;
> ```
> ```vb
> Dim picker As New FileOpenPicker()
> picker.FileTypeFilter.Add(".bmp")
> picker.FileTypeFilter.Add(".jpg")
> picker.FileTypeFilter.Add(".jpeg")
> picker.FileTypeFilter.Add(".png")
> picker.SuggestedStartLocation = PickerLocationId.PicturesLibrary
>
> Dim file As StorageFile = Await picker.PickSingleFileAsync()
>
> Dim fileThumbnail As StorageItemThumbnail = Await file.GetThumbnailAsync(ThumbnailMode.SingleItem, 64)
>
> Dim bmp As New BitmapImage()
> bmp.SetSource(fileThumbnail)
>
> Dim img As New Image()
> img.Source = bmp
> ```

### <a name="decode-images-once"></a><span data-ttu-id="5b115-317">1 回だけの画像のデコード</span><span class="sxs-lookup"><span data-stu-id="5b115-317">Decode images once</span></span>

<span data-ttu-id="5b115-318">画像が複数回デコードされないようにするには、メモリ ストリームを使わずに、URI から [**Image.Source**](https://msdn.microsoft.com/library/windows/apps/BR242760) プロパティを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="5b115-318">To prevent images from being decoded more than once, assign the [**Image.Source**](https://msdn.microsoft.com/library/windows/apps/BR242760) property from an Uri rather than using memory streams.</span></span> <span data-ttu-id="5b115-319">XAML フレームワークでは、複数の場所にある同じ URI をデコードされた 1 つの画像に関連付けることができます。しかし、同じデータを含む複数のメモリ ストリームに対しては同じ処理を行うことができず、メモリ ストリームごとにデコードされた画像を作成します。</span><span class="sxs-lookup"><span data-stu-id="5b115-319">The XAML framework can associate the same Uri in multiple places with one decoded image, but it cannot do the same for multiple memory streams that contain the same data and creates a different decoded image for each memory stream.</span></span>
