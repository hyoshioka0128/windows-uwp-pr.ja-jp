---
author: drewbatgit
ms.assetid: 58af5e9d-37a1-4f42-909c-db7cb02a0d12
description: この記事では、MediaPlayer を使ってユニバーサル Windows アプリでメディアを再生する方法を示します。
title: MediaPlayer を使ったオーディオとビデオの再生
ms.author: drewbat
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 6b83be1dee4e23fa6974e39fbfb0f9ce26529274
ms.sourcegitcommit: d0e836dfc937ebf7dfa9c424620f93f3c8e0a7e8
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/26/2018
ms.locfileid: "5640506"
---
# <a name="play-audio-and-video-with-mediaplayer"></a><span data-ttu-id="2df6c-104">MediaPlayer を使ったオーディオとビデオの再生</span><span class="sxs-lookup"><span data-stu-id="2df6c-104">Play audio and video with MediaPlayer</span></span>

<span data-ttu-id="2df6c-105">この記事では、[**MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer) クラスを使ってユニバーサル Windows アプリでメディアを再生する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-105">This article shows you how to play media in your Universal Windows app using the  [**MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer) class.</span></span> <span data-ttu-id="2df6c-106">Windows 10 バージョン 1607 で、メディア再生 API が大幅に強化されました。これには、バックグラウンド オーディオ向けの簡素化された単一プロセス設計、システム メディア トランスポート コントロール (SMTC) との自動統合、複数のメディア プレーヤーを同期する機能、Windows.UI.Composition サーフェスに対する機能、コンテンツでメディアの中断を作成およびスケジュールするための簡単なインターフェイスなどが含まれます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-106">With Windows 10, version 1607, significant improvements were made to the media playback APIs, including a simplified single-process design for background audio, automatic integration with the System Media Transport Controls (SMTC), the ability to synchronize multiple media players, the ability to a Windows.UI.Composition surface, and an easy interface for creating and scheduling media breaks in your content.</span></span> <span data-ttu-id="2df6c-107">これらの強化機能を活用できるように、メディアを再生するためのベスト プラクティスとして、メディア再生に **MediaElement** の代わりに **MediaPlayer** クラスを使うことが推奨されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-107">To take advantage of these improvements, the recommended best practice for playing media is to use the **MediaPlayer** class instead of **MediaElement** for media playback.</span></span> <span data-ttu-id="2df6c-108">軽量の XAML コントロールである [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement) が導入され、XAML ページのメディア コンテンツをレンダリングできるようになりました。</span><span class="sxs-lookup"><span data-stu-id="2df6c-108">The lightweight XAML control, [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement), has been introduced to allow you render media content in a XAML page.</span></span> <span data-ttu-id="2df6c-109">**MediaElement** によって提供される再生コントロールと状態 API の多くは、新しい [**MediaPlaybackSession**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession) オブジェクトを通じて利用できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="2df6c-109">Many of the playback control and status APIs provided by **MediaElement** are now available through the new [**MediaPlaybackSession**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession) object.</span></span> <span data-ttu-id="2df6c-110">**MediaElement** は下位互換性をサポートするために今後も動作しますが、このクラスには新しい機能は追加されません。</span><span class="sxs-lookup"><span data-stu-id="2df6c-110">**MediaElement** continues to function to support backwards compatibility, but no additional features will be added to this class.</span></span>

<span data-ttu-id="2df6c-111">この記事では、一般的なメディア再生アプリで使う **MediaPlayer** の機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-111">This article will walk you through the **MediaPlayer** features that a typical media playback app will use.</span></span> <span data-ttu-id="2df6c-112">**MediaPlayer** は、すべてのメディア項目のコンテナーとして [**MediaSource**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Core.MediaSource) クラスを使います。</span><span class="sxs-lookup"><span data-stu-id="2df6c-112">Note that **MediaPlayer** uses the [**MediaSource**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Core.MediaSource) class as a container for all media items.</span></span> <span data-ttu-id="2df6c-113">このクラスを使うと、すべて同じインターフェイスを使って、ローカル ファイル、メモリ ストリーム、ネットワーク ソースなど、さまざまなソースからメディアを読み込んで再生できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-113">This class allows you to load and play media from many different sources, including local files, memory streams, and network sources, all using the same interface.</span></span> <span data-ttu-id="2df6c-114">[**MediaPlaybackItem**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackItem) や [**MediaPlaybackList**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackList) など、**MediaSource** と共に使用できる上位レベルのクラスもあります。これらは、プレイリストや、複数のオーディオ、ビデオ、メタデータ トラックでメディア ソースを管理する機能など、より高度な機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-114">There are also higher-level classes that work with **MediaSource**, such as [**MediaPlaybackItem**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackItem) and [**MediaPlaybackList**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackList), that provide more advanced features like playlists and the ability to manage media sources with multiple audio, video, and metadata tracks.</span></span> <span data-ttu-id="2df6c-115">**MediaSource** および関連 API について詳しくは、「[メディア項目、プレイリスト、トラック](media-playback-with-mediasource.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-115">For more information on **MediaSource** and related APIs, see [Media items, playlists, and tracks](media-playback-with-mediasource.md).</span></span>

> [!NOTE] 
> <span data-ttu-id="2df6c-116">Windows 10 N および Windows 10 KN エディションには、再生用の **MediaPlayer** を使用するために必要なメディア機能が含まれません。</span><span class="sxs-lookup"><span data-stu-id="2df6c-116">Windows 10 N and Windows 10 KN editions do not include the media features required to use **MediaPlayer** for playback.</span></span> <span data-ttu-id="2df6c-117">これらの機能は手動でインストールすることができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-117">These features can be installed manually.</span></span> <span data-ttu-id="2df6c-118">詳細については、「[Windows 10 N エディションおよび Windows 10 KN エディション用の Media Feature Pack](https://support.microsoft.com/en-us/help/3010081/media-feature-pack-for-windows-10-n-and-windows-10-kn-editions)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-118">For more information, see [Media feature pack for Windows 10 N and Windows 10 KN editions](https://support.microsoft.com/en-us/help/3010081/media-feature-pack-for-windows-10-n-and-windows-10-kn-editions).</span></span>

## <a name="play-a-media-file-with-mediaplayer"></a><span data-ttu-id="2df6c-119">MediaPlayer でメディア ファイルを再生する</span><span class="sxs-lookup"><span data-stu-id="2df6c-119">Play a media file with MediaPlayer</span></span>  
<span data-ttu-id="2df6c-120">**MediaPlayer** を使った基本的なメディア再生は非常に簡単に実装できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-120">Basic media playback with **MediaPlayer** is very simple to implement.</span></span> <span data-ttu-id="2df6c-121">まず、**MediaPlayer** クラスの新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-121">First, create a new instance of the **MediaPlayer** class.</span></span> <span data-ttu-id="2df6c-122">アプリは、複数の **MediaPlayer** のインスタンスを同時にアクティブにすることができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-122">Your app can have multiple **MediaPlayer** instances active at once.</span></span> <span data-ttu-id="2df6c-123">次に、プレイヤーの [**Source**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.Source) プロパティを、[**MediaSource**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Core.MediaSource)、[**MediaPlaybackItem**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackItem)、[**MediaPlaybackList**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackList) など、[**IMediaPlaybackSource**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.IMediaPlaybackSource) を実装するオブジェクトに設定します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-123">Next, set the [**Source**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.Source) property of the player to an object that implements the [**IMediaPlaybackSource**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.IMediaPlaybackSource), such as a [**MediaSource**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Core.MediaSource), a [**MediaPlaybackItem**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackItem), or a [**MediaPlaybackList**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackList).</span></span> <span data-ttu-id="2df6c-124">この例では、アプリのローカル ストレージにあるファイルから **MediaSource** が作成された後、**MediaPlaybackItem** がソースから作成されて、プレイヤーの **Source** プロパティに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-124">In this example, a **MediaSource** is created from a file in the app's local storage, and then a **MediaPlaybackItem** is created from the source and then assigned to the player's **Source** property.</span></span>

<span data-ttu-id="2df6c-125">**MediaElement** とは異なり、**MediaPlayer** は既定では自動的に再生を開始しません。</span><span class="sxs-lookup"><span data-stu-id="2df6c-125">Unlike **MediaElement**, **MediaPlayer** does not automatically begin playback by default.</span></span> <span data-ttu-id="2df6c-126">再生を開始するには、[**Play**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.Play) を呼び出すか、[**AutoPlay**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.AutoPlay) プロパティを true に設定するか、またはユーザーが組み込みのメディア コントロールを使って再生を開始するのを待ちます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-126">You can start playback by calling [**Play**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.Play), by setting the [**AutoPlay**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.AutoPlay) property to true, or waiting for the user to initiate playback with the built-in media controls.</span></span>

[!code-cs[SimpleFilePlayback](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSimpleFilePlayback)]

<span data-ttu-id="2df6c-127">アプリが **MediaPlayer** を使って実行されたときは、[**Close**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.Close) メソッド (C# で **Dispose** に投影される) を呼び出して、プレーヤーで使われるリソースをクリーンアップしてください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-127">When your app is done using a **MediaPlayer**, you should call the [**Close**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.Close) method (projected to **Dispose** in C#) to clean up the resources used by the player.</span></span>

[!code-cs[CloseMediaPlayer](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetCloseMediaPlayer)]

## <a name="use-mediaplayerelement-to-render-video-in-xaml"></a><span data-ttu-id="2df6c-128">MediaPlayerElement を使って XAML でビデオをレンダリングする</span><span class="sxs-lookup"><span data-stu-id="2df6c-128">Use MediaPlayerElement to render video in XAML</span></span>
<span data-ttu-id="2df6c-129">メディアを XAML で表示せずに **MediaPlayer** で再生することはできますが、多くのメディア再生アプリは XAML ページでメディアをレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="2df6c-129">You can play media in a **MediaPlayer** without displaying it in XAML, but many media playback apps will want to render the media in a XAML page.</span></span> <span data-ttu-id="2df6c-130">これを行うには、軽量な [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement) コントロールを使います。</span><span class="sxs-lookup"><span data-stu-id="2df6c-130">To do this, use the lightweight [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement) control.</span></span> <span data-ttu-id="2df6c-131">**MediaElement** と同様に、**MediaPlayerElement** でも組み込みのトランスポート コントロールを表示するかどうかを指定することができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-131">Like **MediaElement**, **MediaPlayerElement** allows you to specify whether the built-in transport controls should be shown.</span></span>

[!code-xml[MediaPlayerElementXAML](./code/MediaPlayer_RS1/cs/MainPage.xaml#SnippetMediaPlayerElementXAML)]

<span data-ttu-id="2df6c-132">[**SetMediaPlayer**](https://msdn.microsoft.com/library/windows/apps/mt708764) を呼び出して、要素がバインドされている **MediaPlayer** インスタンスを設定することができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-132">You can set the **MediaPlayer** instance that the element is bound to by calling [**SetMediaPlayer**](https://msdn.microsoft.com/library/windows/apps/mt708764).</span></span>

[!code-cs[SetMediaPlayer](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSetMediaPlayer)]

<span data-ttu-id="2df6c-133">**MediaPlayerElement** での再生ソースを設定することもできます。その場合、要素は自動的に [**MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement.MediaPlayer) プロパティを使ってアクセスできる新しい **MediaPlayer** インスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-133">You can also set the playback source on the **MediaPlayerElement** and the element will automatically create a new **MediaPlayer** instance that you can access using the [**MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement.MediaPlayer) property.</span></span>

[!code-cs[GetPlayerFromElement](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetGetPlayerFromElement)]

> [!NOTE] 
> <span data-ttu-id="2df6c-134">[**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager.IsEnabled) を false に設定して、[**MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer) の [**MediaPlaybackCommandManager**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager) を無効にすると、**MediaPlayerElement** で提供される **MediaPlayer** と [**TransportControls**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement.TransportControls) の間のリンクが解除されます。このため組み込みトランスポート コントロールはプレーヤーの再生を自動的に制御しなくなります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-134">If you disable the [**MediaPlaybackCommandManager**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager) of the [**MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer) by setting [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager.IsEnabled) to false, it will break the link between the **MediaPlayer** the [**TransportControls**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement.TransportControls) provided by the **MediaPlayerElement**, so the built-in transport controls will no longer automatically control the playback of the player.</span></span> <span data-ttu-id="2df6c-135">代わりに、独自のコントロールを実装して、**MediaPlayer** を制御する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-135">Instead, you must implement your own controls to control the **MediaPlayer**.</span></span>

## <a name="common-mediaplayer-tasks"></a><span data-ttu-id="2df6c-136">MediaPlayer の一般的なタスク</span><span class="sxs-lookup"><span data-stu-id="2df6c-136">Common MediaPlayer tasks</span></span>
<span data-ttu-id="2df6c-137">このセクションでは、**MediaPlayer** の一部の機能の使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-137">This section shows you how to use some of the features of the **MediaPlayer**.</span></span>

### <a name="set-the-audio-category"></a><span data-ttu-id="2df6c-138">オーディオ カテゴリの設定</span><span class="sxs-lookup"><span data-stu-id="2df6c-138">Set the audio category</span></span>
<span data-ttu-id="2df6c-139">**MediaPlayer** の [**AudioCategory**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.AudioCategory) プロパティを [**MediaPlayerAudioCategory**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayerAudioCategory) 列挙値のいずれかの値に設定して、再生しているメディアの種類をシステムに知らせます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-139">Set the [**AudioCategory**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.AudioCategory) property of a **MediaPlayer** to one of the values of the [**MediaPlayerAudioCategory**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayerAudioCategory) enumeration to let the system know what kind of media you are playing.</span></span> <span data-ttu-id="2df6c-140">ゲームでは、別のアプリケーションがバックグラウンドで音楽を再生する場合にゲームの音楽が自動的にミュートされるように、ゲームの音楽ストリームを **GameMedia** として分類してください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-140">Games should categorize their music streams as **GameMedia** so that game music mutes automatically if another application plays music in the background.</span></span> <span data-ttu-id="2df6c-141">音楽またはビデオ アプリケーションでは、ストリームの優先順位が **GameMedia** ストリームより高くなるように、ストリームを **Media** または **Movie** として分類してください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-141">Music or video applications should categorize their streams as **Media** or **Movie** so they will take priority over **GameMedia** streams.</span></span>

[!code-cs[SetAudioCategory](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSetAudioCategory)]

### <a name="output-to-a-specific-audio-endpoint"></a><span data-ttu-id="2df6c-142">特定のオーディオ エンドポイントへの出力</span><span class="sxs-lookup"><span data-stu-id="2df6c-142">Output to a specific audio endpoint</span></span>
<span data-ttu-id="2df6c-143">既定では、**MediaPlayer** からのオーディオ出力はシステムの既定のオーディオ エンドポイントに送られますが、**MediaPlayer** が出力用に使う特定のオーディオ エンドポイントを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-143">By default, the audio output from a **MediaPlayer** is routed to the default audio endpoint for the system, but you can specify a specific audio endpoint that the **MediaPlayer** should use for output.</span></span> <span data-ttu-id="2df6c-144">下の例では、[**MediaDevice.GetAudioRenderSelector**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Devices.MediaDevice.GetAudioRenderSelector) がデバイスのオーディオ レンダリング カテゴリを一意に識別する文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-144">In the example below, [**MediaDevice.GetAudioRenderSelector**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Devices.MediaDevice.GetAudioRenderSelector) returns a string that uniquely idenfies the audio render category of devices.</span></span> <span data-ttu-id="2df6c-145">次に、[**DeviceInformation**](https://msdn.microsoft.com/library/windows/apps/Windows.Devices.Enumeration.DeviceInformation) メソッドの [**FindAllAsync**](https://msdn.microsoft.com/library/windows/apps/Windows.Devices.Enumeration.DeviceInformation.FindAllAsync) を呼び出して、選択した種類の利用可能なデバイスの一覧を取得します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-145">Next, the [**DeviceInformation**](https://msdn.microsoft.com/library/windows/apps/Windows.Devices.Enumeration.DeviceInformation) method [**FindAllAsync**](https://msdn.microsoft.com/library/windows/apps/Windows.Devices.Enumeration.DeviceInformation.FindAllAsync) is called to get a list of all available devices of the selected type.</span></span> <span data-ttu-id="2df6c-146">プログラムを使ってどのデバイスを使うかを判断することも、返されたデバイスを [**ComboBox**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.ComboBox) に追加してユーザーがデバイスを選択できるようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-146">You may programmatically determine which device you want to use or add the returned devices to a [**ComboBox**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.ComboBox) to allow the user to select a device.</span></span>

[!code-cs[SetAudioEndpointEnumerate](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSetAudioEndpointEnumerate)]

<span data-ttu-id="2df6c-147">デバイス コンボ ボックスの [**SelectionChanged**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.Primitives.Selector.SelectionChanged) イベントで、**MediaPlayer** の [**AudioDevice**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.AudioDevice) プロパティが選択されたデバイスに設定されます。これは、**ComboBoxItem** の [**Tag**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.FrameworkElement.Tag) プロパティに格納されていました。</span><span class="sxs-lookup"><span data-stu-id="2df6c-147">In the [**SelectionChanged**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.Primitives.Selector.SelectionChanged) event for the devices combo box, the [**AudioDevice**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.AudioDevice) property of the **MediaPlayer** is set to the selected device, which was stored in the [**Tag**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.FrameworkElement.Tag) property of the **ComboBoxItem**.</span></span>

[!code-cs[SetAudioEndpontSelectionChanged](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSetAudioEndpontSelectionChanged)]

### <a name="playback-session"></a><span data-ttu-id="2df6c-148">再生セッション</span><span class="sxs-lookup"><span data-stu-id="2df6c-148">Playback session</span></span>
<span data-ttu-id="2df6c-149">この記事の前の方で説明したように、**MediaElement** クラスによって公開される関数の多くは [**MediaPlaybackSession**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession) クラスに移されました。</span><span class="sxs-lookup"><span data-stu-id="2df6c-149">As described previously in this article, many of the functions that are exposed by the **MediaElement** class have been moved to the [**MediaPlaybackSession**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession) class.</span></span> <span data-ttu-id="2df6c-150">これには、現在の再生位置、プレーヤーが一時停止しているか再生中か、現在の再生速度など、プレーヤーの再生状態に関する情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-150">This includes information about the playback state of the player, such as the current playback position, whether the player is paused or playing, and the current playback speed.</span></span> <span data-ttu-id="2df6c-151">**MediaPlaybackSession** は、再生中のコンテンツの現在のバッファリングおよびダウンロードの状態や、現在再生中のビデオ コンテンツの自然なサイズと縦横比などの状態が変わったときに通知するイベントもいくつか提供します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-151">**MediaPlaybackSession** also provides several events to notify you when the state changes, including the current buffering and download status of content being played and the natural size and aspect ratio of the currently playing video content.</span></span>

<span data-ttu-id="2df6c-152">次の例は、コンテンツを 10 秒前にスキップするボタン クリック ハンドラーを実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-152">The following example shows you how to implement a button click handler that skips 10 seconds forward in the content.</span></span> <span data-ttu-id="2df6c-153">まず、プレイヤーの **MediaPlaybackSession** オブジェクトが [**PlaybackSession**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.PlaybackSession) プロパティで取得されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-153">First, the **MediaPlaybackSession** object for the player is retrieved with the [**PlaybackSession**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.PlaybackSession) property.</span></span> <span data-ttu-id="2df6c-154">次に、[**Position**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession.Position) プロパティが現在の再生位置に 10 秒加えた位置に設定されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-154">Next the [**Position**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession.Position) property is set to the current playback position plus 10 seconds.</span></span>

[!code-cs[SkipForwardClick](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSkipForwardClick)]

<span data-ttu-id="2df6c-155">次の例は、セッションの [**PlaybackRate**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession.PlaybackRate) プロパティを設定して通常の再生速度と 2 倍の速度を切り替えるトグル ボタンを示しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-155">The next example illustrates using a toggle button to toggle between normal playback speed and 2X speed by setting the [**PlaybackRate**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession.PlaybackRate) property of the session.</span></span>

[!code-cs[SpeedChecked](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSpeedChecked)]

<span data-ttu-id="2df6c-156">Windows 10 バージョン 1803 以降では、**MediaPlayer** でビデオが表示される回転を 90 度単位で設定できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-156">Starting with Windows 10, version 1803, you can set the rotation with which video is presented in the **MediaPlayer** in increments of 90 degrees.</span></span>

[!code-cs[SetRotation](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSetRotation)]

### <a name="detect-expected-and-unexpected-buffering"></a><span data-ttu-id="2df6c-157">予期されたバッファー処理と予期しないバッファー処理の検出</span><span class="sxs-lookup"><span data-stu-id="2df6c-157">Detect expected and unexpected buffering</span></span>
<span data-ttu-id="2df6c-158">前のセクションで説明した **MediaPlaybackSession** オブジェクトでは、**[BufferingStarted](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.BufferingStarted)** と **[BufferingEnded](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.BufferingEnded)** という 2 つのイベントによって、現在再生中のメディアファイルが開始および停止した時点を検出します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-158">The **MediaPlaybackSession** object described in the previous section provides two events for detecting when the currently playing media file begins and ends buffering, **[BufferingStarted](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.BufferingStarted)** and **[BufferingEnded](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.BufferingEnded)**.</span></span> <span data-ttu-id="2df6c-159">これにより、バッファー処理が行われていることを UI を更新の更新によってユーザーに表示できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-159">This allows you to update your UI to show the user that buffering is occurring.</span></span> <span data-ttu-id="2df6c-160">初期バッファー処理は、メディア ファイルが最初に開かれたとき、またはユーザーが再生リスト内の新しい項目に切り替えたときに発生する予期されるバッファー処理です。</span><span class="sxs-lookup"><span data-stu-id="2df6c-160">Initial buffering is expected when a media file is first opened or when the user switches to a new item in a playlist.</span></span> <span data-ttu-id="2df6c-161">予期しないバッファー処理は、ネットワーク速度が低下したとき、またはコンテンツを提供するコンテンツ管理システムに、技術的な問題が起こった場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-161">Unexpected buffering can occur when the network speed degrades or if the content management system providing the content experiences technical issues.</span></span> <span data-ttu-id="2df6c-162">RS3 以降では、**BufferingStarted** イベントを使用して、バッファー処理イベントが予期されたものか、それとも予期しないイベントであって、再生が中断されるのかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-162">Starting with RS3, you can use the **BufferingStarted** event to determine if the buffering event is expected or if it is unexpected and interrupting playback.</span></span> <span data-ttu-id="2df6c-163">この情報は、アプリまたはメディア配信サービスのテレメトリ データとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-163">You can use this information as telemetry data for your app or media delivery service.</span></span> 

<span data-ttu-id="2df6c-164">バッファー処理の状態通知を受け取るには、**BufferingStarted** イベントと **BufferingEnded** イベントのハンドラーを登録します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-164">Register handlers for the **BufferingStarted** and **BufferingEnded** events to receive buffering state notifications.</span></span>

[!code-cs[RegisterBufferingHandlers](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetRegisterBufferingHandlers)]

<span data-ttu-id="2df6c-165">**BufferingStarted**イベント ハンドラーで、このイベントに渡されたイベント引数を **[MediaPlaybackSessionBufferingStartedEventArgs](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionbufferingstartedeventargs)** オブジェクトにキャストし、**[IsPlaybackInterruption](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionbufferingstartedeventargs.IsPlaybackInterruption)** プロパティを確認します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-165">In the **BufferingStarted** event handler, cast the event args passed into the event to a **[MediaPlaybackSessionBufferingStartedEventArgs](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionbufferingstartedeventargs)** object and check the **[IsPlaybackInterruption](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionbufferingstartedeventargs.IsPlaybackInterruption)** property.</span></span> <span data-ttu-id="2df6c-166">この値が true の場合、イベントをトリガーしたバッファー処理は予期しないものであり、再生が中断されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-166">If this value is true, the buffering that triggered the event is unexpected and interrupting playback.</span></span> <span data-ttu-id="2df6c-167">そうでない場合は、予想された初期バッファー処理です。</span><span class="sxs-lookup"><span data-stu-id="2df6c-167">Otherwise, it is expected initial buffering.</span></span> 

[!code-cs[BufferingHandlers](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetBufferingHandlers)]


### <a name="pinch-and-zoom-video"></a><span data-ttu-id="2df6c-168">ビデオのピンチおよびズーム</span><span class="sxs-lookup"><span data-stu-id="2df6c-168">Pinch and zoom video</span></span>
<span data-ttu-id="2df6c-169">**MediaPlayer** では、ビデオ コンテンツの中にレンダリングするソースの四角形を指定して、効果的にビデオを拡大することができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-169">**MediaPlayer** allows you to specify the source rectangle within video content that should be rendered, effectively allowing you to zoom into video.</span></span> <span data-ttu-id="2df6c-170">指定する四角形は、正規化された四角形 (0,0,1,1) を基準とします。0,0 はフレームの左上、1,1 はフレームの全幅と全高です。</span><span class="sxs-lookup"><span data-stu-id="2df6c-170">The rectangle you specify is relative to a normalized rectangle (0,0,1,1) where 0,0 is the upper left hand of the frame and 1,1 specifies the full width and height of the frame.</span></span> <span data-ttu-id="2df6c-171">たとえば、ビデオを 4 分割した右上の領域がレンダリングされるようにズーム四角形を設定するには、四角形 (.5,0,.5,.5) を指定します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-171">So, for example, to set the zoom rectangle so that the top-right quadrant of the video is rendered, you would specify the rectangle (.5,0,.5,.5).</span></span>  <span data-ttu-id="2df6c-172">ソースの四角形が正規化された四角形 (0,0,1,1) の内部にあるように値を確認することが重要です。</span><span class="sxs-lookup"><span data-stu-id="2df6c-172">It is important that you check your values to make sure that your source rectangle is within the (0,0,1,1) normalized rectangle.</span></span> <span data-ttu-id="2df6c-173">この範囲外の値を設定しようとすると、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-173">Attempting to set a value outside of this range will cause an exception to be thrown.</span></span>

<span data-ttu-id="2df6c-174">マルチタッチ ジェスチャを使ってピンチおよびズームを実装するには、まずどのジェスチャをサポートするかを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-174">To implement pinch and zoom using multi-touch gestures, you must first specify which gestures you want to support.</span></span> <span data-ttu-id="2df6c-175">この例では、拡大縮小と移動のジェスチャが要求されています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-175">In this example, scale and translate gestures are requested.</span></span> <span data-ttu-id="2df6c-176">サブスクライブしているジェスチャのいずれかが発生すると、[**ManipulationDelta**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.UIElement.ManipulationDelta) イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-176">The [**ManipulationDelta**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.UIElement.ManipulationDelta) event is raised when one of the subscribed gestures occurs.</span></span> <span data-ttu-id="2df6c-177">ズームをフレーム全体にリセットするために、[**DoubleTapped**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.UIElement.DoubleTapped) イベントが使用されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-177">The [**DoubleTapped**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.UIElement.DoubleTapped) event will be used to reset the zoom to the full frame.</span></span> 

[!code-cs[RegisterPinchZoomEvents](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetRegisterPinchZoomEvents)]

<span data-ttu-id="2df6c-178">次に、現在のズーム ソースの四角形を格納する **Rect** オブジェクトを宣言します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-178">Next, declare a **Rect** object that will store the current zoom source rectangle.</span></span>

[!code-cs[DeclareSourceRect](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetDeclareSourceRect)]

<span data-ttu-id="2df6c-179">**ManipulationDelta** ハンドラーは、ズーム四角形の拡大縮小または移動を調整します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-179">The **ManipulationDelta** handler adjusts either the scale or the translation of the zoom rectangle.</span></span> <span data-ttu-id="2df6c-180">デルタ スケールの値が 1 でない場合、それはユーザーがピンチ ジェスチャを実行したことを意味します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-180">If the delta scale value is not 1, it means that the user performed a pinch gesture.</span></span> <span data-ttu-id="2df6c-181">値が 1 より大きい場合、コンテンツを拡大するにはソースの四角形を小さくする必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-181">If the value is greater than 1, the source rectangle should be made smaller to zoom into the content.</span></span> <span data-ttu-id="2df6c-182">値が 1 より小さい場合、縮小するにはソースの四角形を大きくする必要があります。 新しいスケール値を設定する前に、結果の四角形がチェックされ、全体が (0,0,1,1) の範囲内にあることが確認されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-182">If the value is less than 1, then the source rectangle should be made bigger to zoom out. Before setting the new scale values, the resulting rectangle is checked to make sure it lies entirely within the (0,0,1,1) limits.</span></span>

<span data-ttu-id="2df6c-183">スケール値が 1 の場合、移動ジェスチャが処理されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-183">If the scale value is 1, then the translation gesture is handled.</span></span> <span data-ttu-id="2df6c-184">四角形は、ジェスチャのピクセル数をコントロールの幅と高さで割った値だけ移動されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-184">The rectangle is simply translated by the number of pixels in gesture divided by the width and height of the control.</span></span> <span data-ttu-id="2df6c-185">ここでも、結果の四角形がチェックされ、(0,0,1,1) の範囲内にあることが確認されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-185">Again, the resulting rectangle is checked to make sure it lies within the (0,0,1,1) bounds.</span></span>

<span data-ttu-id="2df6c-186">最後に、**MediaPlaybackSession** の [**NormalizedSourceRect**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession.NormalizedSourceRect) が新たに調整された四角形に設定され、レンダリングするビデオ フレーム内の領域が指定されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-186">Finally, the [**NormalizedSourceRect**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackSession.NormalizedSourceRect) of the **MediaPlaybackSession** is set to the newly adjusted rectangle, specifying the area within the video frame that should be rendered.</span></span>

[!code-cs[ManipulationDelta](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetManipulationDelta)]

<span data-ttu-id="2df6c-187">[**DoubleTapped**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.UIElement.DoubleTapped) イベント ハンドラーで、ビデオ フレーム全体がレンダリングされるようにソースの四角形が (0,0,1,1) に戻されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-187">In the [**DoubleTapped**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.UIElement.DoubleTapped) event handler, the source rectangle is set back to (0,0,1,1) to cause the entire video frame to be rendered.</span></span>

[!code-cs[DoubleTapped](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetDoubleTapped)]

### <a name="handling-policy-based-playback-degradation"></a><span data-ttu-id="2df6c-188">ポリシーベースの再生品質低下の処理</span><span class="sxs-lookup"><span data-stu-id="2df6c-188">Handling policy-based playback degradation</span></span>

<span data-ttu-id="2df6c-189">状況によっては、システムが、パフォーマンスの問題ではなく、ポリシーに基づいて、メディア項目の再生品質を低下させることがあります。これは解像度の低下 (圧縮) などの形で行われます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-189">In some circumstances the system may degrade the playback of a media item, such as reducing the resolution (constriction), based on a policy rather than a performance issue.</span></span> <span data-ttu-id="2df6c-190">たとえば、符号なしのビデオ ドライバーを使用して再生されている場合、システムによってビデオが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-190">For example, video may be degraded by the system if it is being played using an unsigned video driver.</span></span> <span data-ttu-id="2df6c-191">この場合、[**MediaPlaybackSession.GetOutputDegradationPolicyState**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.getoutputdegradationpolicystate#Windows_Media_Playback_MediaPlaybackSession_GetOutputDegradationPolicyState) を呼び出して、このポリシーベースの低下が発生しているかどうか、また発生理由を判定した上で、ユーザーに通知し、またはテレメトリ目的で理由を記録することができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-191">You can call [**MediaPlaybackSession.GetOutputDegradationPolicyState**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksession.getoutputdegradationpolicystate#Windows_Media_Playback_MediaPlaybackSession_GetOutputDegradationPolicyState) to determine if and why this policy-based degredation is occurring and alert the user or record the reason for telemetry purposes.</span></span>

<span data-ttu-id="2df6c-192">次の例では、プレイヤーが新しいメディア項目を開いたときに発生する **MediaPlayer.MediaOpened** イベントのハンドラーの実装を示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-192">The following example shows an implementation of a handler for the **MediaPlayer.MediaOpened** event that is raised when the player opens a new media item.</span></span> <span data-ttu-id="2df6c-193">ハンドラーに渡された **MediaPlayer** に対して **GetOutputDegradationPolicyState**が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-193">**GetOutputDegradationPolicyState** is called on the **MediaPlayer** passed into the handler.</span></span> <span data-ttu-id="2df6c-194">[**VideoConstrictionReason**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionoutputdegradationpolicystate.videoconstrictionreason#Windows_Media_Playback_MediaPlaybackSessionOutputDegradationPolicyState_VideoConstrictionReason) の値は、ビデオが圧縮されているポリシー上の理由を示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-194">The value of [**VideoConstrictionReason**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksessionoutputdegradationpolicystate.videoconstrictionreason#Windows_Media_Playback_MediaPlaybackSessionOutputDegradationPolicyState_VideoConstrictionReason) indicates the policy reason that the video is constricted.</span></span> <span data-ttu-id="2df6c-195">以下の例では、値が **None** 以外の場合、テレメトリの目的で低下理由をログに記録します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-195">If the value isn't **None**, this example logs the degradation reason for telemetry purposes.</span></span> <span data-ttu-id="2df6c-196">この例ではまた、ビデオが圧縮されていて、いずれにしても高品位で表示されないときに、データ使用量を節減するために、現在再生中の **AdaptiveMediaSource** のビットレートを最低帯域幅に設定する方法が示されています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-196">This example also shows setting the bitrate of the **AdaptiveMediaSource** currently being played to the lowest bandwidth to save data usage, since the video is constricted and won't be displayed at high resolution anyway.</span></span> <span data-ttu-id="2df6c-197">**AdaptiveMediaSource** の使用方法について詳しくは、「[アダプティブ ストリーミング](adaptive-streaming.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-197">For more information on using **AdaptiveMediaSource**, see [Adaptive streaming](adaptive-streaming.md).</span></span>

[!code-cs[PolicyDegradation](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetPolicyDegradation)]
        
## <a name="use-mediaplayersurface-to-render-video-to-a-windowsuicomposition-surface"></a><span data-ttu-id="2df6c-198">MediaPlayerSurface を使って、Windows.UI.Composition サーフェスにビデオをレンダリングする</span><span class="sxs-lookup"><span data-stu-id="2df6c-198">Use MediaPlayerSurface to render video to a Windows.UI.Composition surface</span></span>
<span data-ttu-id="2df6c-199">Windows 10 バージョン 1607 からは、**MediaPlayer** を使って [**ICompositionSurface**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.ICompositionSurface) にビデオをレンダリングできるため、プレイヤーは [**Windows.UI.Composition**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition) 名前空間で API と相互運用することができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-199">Starting with Windows 10, version 1607, you can use **MediaPlayer** to render video to an to render video to an [**ICompositionSurface**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.ICompositionSurface), which allows the player to interoperate with the APIs in the [**Windows.UI.Composition**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition) namespace.</span></span> <span data-ttu-id="2df6c-200">コンポジション フレームワークを使うと、XAML と低レベルの DirectX グラフィックス API の間のビジュアル レイヤーでグラフィックスを操作することができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-200">The composition framework allows you to work with graphics in the visual layer between XAML and the low-level DirectX graphics APIs.</span></span> <span data-ttu-id="2df6c-201">これにより、任意の XAML コントロールにビデオをレンダリングするようなシナリオが可能になります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-201">This enables scenarios like rendering video into any XAML control.</span></span> <span data-ttu-id="2df6c-202">コンポジション API の使い方について詳しくは、「[ビジュアル レイヤー](https://msdn.microsoft.com/windows/uwp/composition/visual-layer)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-202">For more information on using the composition APIs, see [Visual Layer](https://msdn.microsoft.com/windows/uwp/composition/visual-layer).</span></span>

<span data-ttu-id="2df6c-203">次の例に、ビデオ プレーヤーのコンテンツを [**Canvas**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.Canvas) コントロールにレンダリングする方法を示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-203">The following example illustrates how to render video player content onto a [**Canvas**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.Canvas) control.</span></span> <span data-ttu-id="2df6c-204">この例でのメディア プレーヤー固有の呼び出しは、[**SetSurfaceSize**](https://msdn.microsoft.com/library/windows/apps/mt489968) と [**GetSurface**](https://msdn.microsoft.com/library/windows/apps/mt489963) です。</span><span class="sxs-lookup"><span data-stu-id="2df6c-204">The media player-specific calls in this example are [**SetSurfaceSize**](https://msdn.microsoft.com/library/windows/apps/mt489968) and [**GetSurface**](https://msdn.microsoft.com/library/windows/apps/mt489963).</span></span> <span data-ttu-id="2df6c-205">**SetSurfaceSize** は、コンテンツのレンダリングに割り当てるバッファのサイズをシステムに伝えます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-205">**SetSurfaceSize** tells the system the size of the buffer that should be allocated for rendering content.</span></span> <span data-ttu-id="2df6c-206">**GetSurface** は、引数として [**Compositor**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.Compositor) を受け取り、[**MediaPlayerSurface**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayerSurface) クラスのインスタンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-206">**GetSurface** takes a [**Compositor**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.Compositor) as an arguemnt and retreives an instance of the [**MediaPlayerSurface**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayerSurface) class.</span></span> <span data-ttu-id="2df6c-207">このクラスは、サーフェスを作成するために使われる **MediaPlayer** と **Compositor** へのアクセスを提供し、[**CompositionSurface**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayerSurface.CompositionSurface) プロパティを通じてサーフェス自体を公開します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-207">This class provides access to the **MediaPlayer** and **Compositor** used to create the surface and exposes the surface itself through the [**CompositionSurface**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayerSurface.CompositionSurface) property.</span></span>

<span data-ttu-id="2df6c-208">この例の残りのコードでは、ビデオをレンダリングする [**SpriteVisual**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.SpriteVisual) を作成し、そのサイズをビジュアルを表示するキャンバス要素のサイズに設定します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-208">The rest of the code in this example creates a [**SpriteVisual**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.SpriteVisual) to which the video is rendered and sets the size to the size of the canvas element that will display the visual.</span></span> <span data-ttu-id="2df6c-209">次に、[**MediaPlayerSurface**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayerSurface) から [**CompositionBrush**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.CompositionBrush) が作成され、ビジュアルの [**Brush**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.SpriteVisual.Brush) プロパティに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-209">Next a [**CompositionBrush**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.CompositionBrush) is created from the [**MediaPlayerSurface**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayerSurface) and assigned to the [**Brush**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.SpriteVisual.Brush) property of the visual.</span></span> <span data-ttu-id="2df6c-210">そして、[**ContainerVisual**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.ContainerVisual) が作成され、そのビジュアル ツリーの一番上に **SpriteVisual** が挿入されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-210">Next a [**ContainerVisual**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Composition.ContainerVisual) is created and the **SpriteVisual** is inserted at the top of its visual tree.</span></span> <span data-ttu-id="2df6c-211">最後に、[**SetElementChildVisual**](https://msdn.microsoft.com/library/windows/apps/mt608981) を呼び出してコンテナー ビジュアルを **Canvas** に割り当てます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-211">Finally, [**SetElementChildVisual**](https://msdn.microsoft.com/library/windows/apps/mt608981) is called to assign the container visual to the **Canvas**.</span></span>

[!code-cs[Compositor](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetCompositor)]
        
## <a name="use-mediatimelinecontroller-to-synchronize-content-across-multiple-players"></a><span data-ttu-id="2df6c-212">MediaTimelineController を使って複数のプレイヤー全体でコンテンツを同期する</span><span class="sxs-lookup"><span data-stu-id="2df6c-212">Use MediaTimelineController to synchronize content across multiple players.</span></span>
<span data-ttu-id="2df6c-213">この記事で前に説明したように、アプリは複数の **MediaPlayer** オブジェクトを一度にアクティブにすることができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-213">As discussed previously in this article, your app can have several **MediaPlayer** objects active at a time.</span></span> <span data-ttu-id="2df6c-214">既定では、作成する **MediaPlayer** はそれぞれ独立して動作します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-214">By default, each **MediaPlayer** you create operates independently.</span></span> <span data-ttu-id="2df6c-215">コメント トラックからビデオへの同期などの一部のシナリオでは、複数のプレーヤーの状態、再生位置、および再生速度を同期することもできます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-215">For some scenarios, such as synchronizing a commentary track to a video, you may want to synchronize the player state, playback position, and playback speed of multiple players.</span></span> <span data-ttu-id="2df6c-216">Windows 10 バージョン 1607 以降では、[**MediaTimelineController**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.MediaTimelineController) クラスを使ってこの動作を実装できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-216">Starting with Windows 10, version 1607, you can implement this behavior by using the [**MediaTimelineController**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.MediaTimelineController) class.</span></span>

### <a name="implement-playback-controls"></a><span data-ttu-id="2df6c-217">再生コントロールを実装する</span><span class="sxs-lookup"><span data-stu-id="2df6c-217">Implement playback controls</span></span>
<span data-ttu-id="2df6c-218">次の例は、**MediaTimelineController** を使って **MediaPlayer** の 2 つのインスタンスを制御する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-218">The following example shows how to use a **MediaTimelineController** to control two instances of **MediaPlayer**.</span></span> <span data-ttu-id="2df6c-219">まず、**MediaPlayer** の各インスタンスがインスタンス化され、**Source** がメディア ファイルに設定されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-219">First, each instance of the **MediaPlayer** is instantiated and the **Source** is set to a media file.</span></span> <span data-ttu-id="2df6c-220">次に、新しい **MediaTimelineController** が作成されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-220">Next, a new **MediaTimelineController** is created.</span></span> <span data-ttu-id="2df6c-221">**MediaPlayer** ごとに、[**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager.IsEnabled) プロパティを false に設定することで、各プレーヤー関連付けられている [**MediaPlaybackCommandManager**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager) が無効にされます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-221">For each **MediaPlayer**, the [**MediaPlaybackCommandManager**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager) associated with each player is disabled by setting the [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager.IsEnabled) property to false.</span></span> <span data-ttu-id="2df6c-222">次に、[**TimelineController**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.TimelineController) プロパティがタイムライン コント ローラー オブジェクトに設定されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-222">And then the [**TimelineController**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.TimelineController) property is set to the timeline controller object.</span></span>

[!code-cs[DeclareMediaTimelineController](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetDeclareMediaTimelineController)]

[!code-cs[SetTimelineController](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSetTimelineController)]

<span data-ttu-id="2df6c-223">**注意** [**MediaPlaybackCommandManager**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager) は、**MediaPlayer** とシステム メディア トランスポート コントロール (SMTC) の間の自動統合を提供しますが、この自動統合は **MediaTimelineController** で制御されるメディア プレイヤーでは使うことはできません。</span><span class="sxs-lookup"><span data-stu-id="2df6c-223">**Caution** The [**MediaPlaybackCommandManager**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlaybackCommandManager) provides automatic integration between **MediaPlayer** and the System Media Transport Controls (SMTC), but this automatic integration can't be used with media players that are controlled with a **MediaTimelineController**.</span></span> <span data-ttu-id="2df6c-224">そのため、プレーヤーのタイムライン コント ローラーを設定する前に、メディア プレイヤーのコマンド マネージャーを無効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-224">Therefore you must disable the command manager for the media player before setting the player's timeline controller.</span></span> <span data-ttu-id="2df6c-225">こうしないと、例外がスローされ、"オブジェクトの現在の状態により、メディア タイムライン コントローラーのアタッチがブロックされています。" というメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-225">Failure to do so will result in an exception being thrown with the following message: "Attaching Media Timeline Controller is blocked because of the current state of the object."</span></span> <span data-ttu-id="2df6c-226">メディア プレーヤーの SMTC との統合について詳しくは、「[システム メディア トランスポート コントロールとの統合](integrate-with-systemmediatransportcontrols.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-226">For more information on media player integration with the SMTC, see [Integrate with the System Media Transport Controls](integrate-with-systemmediatransportcontrols.md).</span></span> <span data-ttu-id="2df6c-227">**MediaTimelineController** 使っている場合は、SMTC を手動で制御できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-227">If you are using a **MediaTimelineController** you can still control the SMTC manually.</span></span> <span data-ttu-id="2df6c-228">詳しくは、「[システム メディア トランスポート コントロールの手動制御](system-media-transport-controls.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-228">For more information, see [Manual control of the System Media Transport Controls](system-media-transport-controls.md).</span></span>

<span data-ttu-id="2df6c-229">1 つ以上のメディア プレーヤーに **MediaTimelineController** をアタッチしている場合は、コント ローラーによって公開されているメソッドを使って再生状態を制御できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-229">Once you have attached a **MediaTimelineController** to one or more media players, you can control the playback state by using the methods exposed by the controller.</span></span> <span data-ttu-id="2df6c-230">次の例では、[**Start**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.MediaTimelineController.Start) を呼び出して、メディアの開始部で関連付けられたすべてのメディア プレーヤーの再生を開始します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-230">The following example calls [**Start**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.MediaTimelineController.Start) to begin playback of all associated media players at the beginning of the media.</span></span>

[!code-cs[PlayButtonClick](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetPlayButtonClick)]

<span data-ttu-id="2df6c-231">この例は、アタッチされたすべてのメディア プレーヤーの一時停止と再開を示しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-231">This example illustrates pausing and resuming all of the attached media players.</span></span>

[!code-cs[PauseButtonClick](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetPauseButtonClick)]

<span data-ttu-id="2df6c-232">接続されているすべてのメディア プレーヤーを早送りするには、再生速度を 1 より大きい値に設定します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-232">To fast-forward all connected media players, set the playback speed to a value greater that 1.</span></span>

[!code-cs[FastForwardButtonClick](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetFastForwardButtonClick)]

<span data-ttu-id="2df6c-233">次の例は、**スライダー** コントロールを使って、接続されているメディア プレーヤーの 1 つのコンテンツの再生時間を基準としてタイムライン コント ローラーの現在の再生位置を表示する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-233">The next example shows how to use a **Slider** control to show the current playback position of the timeline controller relative to the duration of the content of one of the connected media players.</span></span> <span data-ttu-id="2df6c-234">まず、新しい **MediaSource** が作成され、メディア ソースの [ **OpenOperationCompleted** ](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Core.MediaSource.OpenOperationCompleted) のハンドラーが登録されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-234">First, a new **MediaSource** is created and a handler for the [**OpenOperationCompleted**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Core.MediaSource.OpenOperationCompleted) of the media source is registered.</span></span> 

[!code-cs[CreateSourceWithOpenCompleted](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetCreateSourceWithOpenCompleted)]

<span data-ttu-id="2df6c-235">**OpenOperationCompleted** ハンドラーは、メディア ソースのコンテンツの再生時間を検出する契機になります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-235">The **OpenOperationCompleted** handler is used as an opportunity to discover the duration of the media source content.</span></span> <span data-ttu-id="2df6c-236">再生時間が決定されると、**Slider** コントロールの最大値がメディア項目の合計秒数に設定されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-236">Once the duration is determined, the maximum value of the **Slider** control is set to the total number of seconds of the media item.</span></span> <span data-ttu-id="2df6c-237">[**RunAsync**](https://msdn.microsoft.com/library/windows/apps/hh750317) の呼び出しの中で値を設定して、UI スレッドで実行されていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-237">The value is set inside a call to [**RunAsync**](https://msdn.microsoft.com/library/windows/apps/hh750317) to make sure it is run on the UI thread.</span></span>

[!code-cs[DeclareDuration](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetDeclareDuration)]

[!code-cs[OpenCompleted](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetOpenCompleted)]

<span data-ttu-id="2df6c-238">次に、タイムライン コント ローラーの [**PositionChanged**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.MediaTimelineController.PositionChanged) イベントのハンドラーを登録します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-238">Next, a handler for the timeline controller's  [**PositionChanged**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.MediaTimelineController.PositionChanged) event is registered.</span></span> <span data-ttu-id="2df6c-239">これは 1 秒間に 4 回程度、システムによって定期的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-239">This is called periodically by the system, approximately 4 times per second.</span></span>

[!code-cs[RegisterPositionChanged](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetRegisterPositionChanged)]

<span data-ttu-id="2df6c-240">**PositionChanged** のハンドラーで、タイムライン コント ローラーの現在位置を反映するようにスライダーの値が更新されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-240">In the handler for **PositionChanged**, the slider value is updated to reflect the current position of the timeline controller.</span></span>

[!code-cs[PositionChanged](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetPositionChanged)]

### <a name="offset-the-playback-position-from-the-timeline-position"></a><span data-ttu-id="2df6c-241">タイムラインの位置から再生位置をオフセットする</span><span class="sxs-lookup"><span data-stu-id="2df6c-241">Offset the playback position from the timeline position</span></span>
<span data-ttu-id="2df6c-242">場合によっては、タイムライン コント ローラーに関連付けられている 1 つ以上のメディア プレーヤーの再生位置に、他のプレーヤーからのオフセットを付けたいことがあります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-242">In some cases you may want the playback position of one or more media players associated with a timeline controller to be offset from the other players.</span></span> <span data-ttu-id="2df6c-243">これを行うには、オフセットを付ける **MediaPlayer** オブジェクトの [ **TimelineControllerPositionOffset** ](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.TimelineControllerPositionOffset) プロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-243">You can do this by setting the [**TimelineControllerPositionOffset**](https://msdn.microsoft.com/library/windows/apps/Windows.Media.Playback.MediaPlayer.TimelineControllerPositionOffset) property of the **MediaPlayer** object you want to be offset.</span></span> <span data-ttu-id="2df6c-244">次の例では、2 つのメディア プレーヤーのコンテンツの再生時間を使って、項目の長さを加えるか差し引くように 2 つのスライダー コントロールの最小値と最大値を設定しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-244">The following example uses the durations of the content of two media players to set the minimum and maximum values of two slider control to plus and minus the length of the item.</span></span>  

[!code-cs[OffsetSliders](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetOffsetSliders)]

<span data-ttu-id="2df6c-245">各スライダーの [**ValueChanged**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.Primitives.RangeBase.ValueChanged) イベントで、各プレーヤーの **TimelineControllerPositionOffset** が対応する値に設定されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-245">In the [**ValueChanged**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.Primitives.RangeBase.ValueChanged) event for each slider, the **TimelineControllerPositionOffset** for each player is set to the corresponding value.</span></span>

[!code-cs[TimelineOffset](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetTimelineOffset)]

<span data-ttu-id="2df6c-246">プレーヤーのオフセット値が負の再生位置にマップされる場合は、オフセットがゼロになるまでクリップは一時停止のままになり、その後に再生が開始されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-246">Note that if the offset value of a player maps to a negative playback position, the clip will remain paused until the offset reaches zero and then playback will begin.</span></span> <span data-ttu-id="2df6c-247">同様に、オフセット値がメディア項目の再生時間を超える再生位置にマップされる場合は、1 つのメディア プレーヤーがそのコンテンツの最後に達したときのように最終フレームが表示されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-247">Likewise, if the offset value maps to a playback position greater than the duration of the media item, the final frame will be shown, just as it does when a single media player reached the end of its content.</span></span>

## <a name="play-spherical-video-with-mediaplayer"></a><span data-ttu-id="2df6c-248">MediaPlayer を使った球面ビデオの再生</span><span class="sxs-lookup"><span data-stu-id="2df6c-248">Play spherical video with MediaPlayer</span></span>
<span data-ttu-id="2df6c-249">Windows 10 Version 1703 以降、**MediaPlayer** は、球面ビデオ再生のための正距円筒図法をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-249">Starting with Windows 10, version 1703, **MediaPlayer** supports equirectangular projection for spherical video playback.</span></span> <span data-ttu-id="2df6c-250">球面ビデオ コンテンツは、ビデオ エンコードがサポートされている限り、**MediaPlayer** がビデオを表示するという点において、通常の平面ビデオと同じです。</span><span class="sxs-lookup"><span data-stu-id="2df6c-250">Spherical video content is no different from regular, flat video in that **MediaPlayer** will render the video as long as the video encoding is supported.</span></span> <span data-ttu-id="2df6c-251">ビデオが正距円筒図法を使用することを指定するメタデータ タグを含む球面ビデオの場合、**MediaPlayer** は、指定された視野とビューの向きを使ってビデオを表示できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-251">For spherical video that contains a metadata tag that specifies that the video uses equirectangular projection, **MediaPlayer** can render the video using a specified field-of-view and view orientation.</span></span> <span data-ttu-id="2df6c-252">これにより、ヘッド マウント ディスプレイによる仮想現実ビデオの再生や、ユーザーがマウスまたはキーボード入力で球面ビデオ コンテンツ内でパンできるようにするなどのシナリオが実現されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-252">This enables scenarios such as virtual reality video playback with a head-mounted display or simply allowing the user to pan around within spherical video content using the mouse or keyboard input.</span></span>

<span data-ttu-id="2df6c-253">球面ビデオを再生するには、この記事で既に説明したビデオ コンテンツを再生するための手順を使用します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-253">To play back spherical video, use the steps for playing back video content described previously in this article.</span></span> <span data-ttu-id="2df6c-254">1 つ追加される手順は、[**MediaPlayer.MediaOpened**](https://docs.microsoft.com/uwp/api/Windows.Media.Playback.MediaPlayer#Windows_Media_Playback_MediaPlayer_MediaOpened) イベントのハンドラーを登録することです。</span><span class="sxs-lookup"><span data-stu-id="2df6c-254">The one additional step is to register a handler for the [**MediaPlayer.MediaOpened**])https://docs.microsoft.com/uwp/api/Windows.Media.Playback.MediaPlayer#Windows_Media_Playback_MediaPlayer_MediaOpened) event.</span></span> <span data-ttu-id="2df6c-255">このイベントにより、球面ビデオの再生パラメーターが有効化され、制御できるようになります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-255">This event gives you an opportunity to enable and control the spherical video playback parameters.</span></span>

[!code-cs[OpenSphericalVideo](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetOpenSphericalVideo)]

<span data-ttu-id="2df6c-256">**MediaOpened** ハンドラーで、最初に [**PlaybackSession.SphericalVideoProjection.FrameFormat**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.FrameFormat) プロパティを調べて、新しく開かれたメディア項目のフレーム形式を確認します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-256">In the **MediaOpened** handler, first check the frame format of the newly opened media item by checking the [**PlaybackSession.SphericalVideoProjection.FrameFormat**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.FrameFormat) property.</span></span> <span data-ttu-id="2df6c-257">この値が [**SphericaVideoFrameFormat.Equirectangular**](https://docs.microsoft.com/uwp/api/windows.media.mediaproperties.sphericalvideoframeformat) である場合、システムは自動的にビデオ コンテンツを投影できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-257">If this value is [**SphericaVideoFrameFormat.Equirectangular**](https://docs.microsoft.com/uwp/api/windows.media.mediaproperties.sphericalvideoframeformat), then the system can automatically project the video content.</span></span> <span data-ttu-id="2df6c-258">最初に、[**PlaybackSession.SphericalVideoProjection.IsEnabled**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.IsEnabled) プロパティを **true** に設定します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-258">First, set the [**PlaybackSession.SphericalVideoProjection.IsEnabled**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.IsEnabled) property to **true**.</span></span> <span data-ttu-id="2df6c-259">メディア プレーヤーがビデオ コンテンツを投影する際に使用するビューの向きや視野などのプロパティを調整することもできます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-259">You can also adjust properties such as the view orientation and field of view that the media player will use to project the video content.</span></span> <span data-ttu-id="2df6c-260">この例では、[**HorizontalFieldOfViewInDegrees**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.HorizontalFieldOfViewInDegrees) プロパティを設定することによって、120 度という広い視野の値を設定しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-260">In this example, the field of view is set to a wide value of 120 degrees by setting the [**HorizontalFieldOfViewInDegrees**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybacksphericalvideoprojection.HorizontalFieldOfViewInDegrees) property.</span></span>

<span data-ttu-id="2df6c-261">ビデオ コンテンツが球面でも、正距円筒図法以外の形式である場合は、メディア プレーヤーのフレーム サーバー モードを使用して個々のフレームを受信し、処理することで、独自の投影アルゴリズムを実装できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-261">If the video content is spherical, but is in a format other than equirectangular, you can implement your own projection algorithm using the media player's frame server mode to receive and process individual frames.</span></span>

[!code-cs[SphericalMediaOpened](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSphericalMediaOpened)]

<span data-ttu-id="2df6c-262">次のコード例は、左右の方向キーを使って球面ビデオのビューの向きを調整する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-262">The following example code illustrates how to adjust the spherical video view orientation using the left and right arrow keys.</span></span>

[!code-cs[SphericalOnKeyDown](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSphericalOnKeyDown)]

<span data-ttu-id="2df6c-263">アプリでビデオの再生リストをサポートしている場合、UI で球面ビデオを含む再生項目の識別が必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-263">If your app supports playlists of video, you may want to identify playback items that contain spherical video in your UI.</span></span> <span data-ttu-id="2df6c-264">メディアの再生リストについて詳しくは、「[メディア項目、プレイリスト、トラック](media-playback-with-mediasource.md)」の記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-264">Media playlists are discussed in detail in the article, [Media items, playlists, and tracks](media-playback-with-mediasource.md).</span></span> <span data-ttu-id="2df6c-265">次の例では、新しい再生リストの作成、項目の追加、[**MediaPlaybackItem.VideoTracksChanged**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.VideoTracksChanged) イベント (メディア項目のビデオ トラックを解決するときに発生する) のハンドラーの登録の方法を示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-265">The following example shows creating a new playlist, adding an item, and registering a handler for the [**MediaPlaybackItem.VideoTracksChanged**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplaybackitem.VideoTracksChanged) event, which occurs when the video tracks for a media item are resolved.</span></span>

[!code-cs[SphericalList](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSphericalList)]

<span data-ttu-id="2df6c-266">**VideoTracksChanged**イベント ハンドラーで、[**VideoTrack.GetEncodingProperties**](https://docs.microsoft.com/uwp/api/windows.media.core.videotrack.GetEncodingProperties) を呼び出すことによって、追加されたビデオ トラックのエンコード プロパティを取得します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-266">In the **VideoTracksChanged** event handler, get the encoding properties for any added video tracks by calling [**VideoTrack.GetEncodingProperties**](https://docs.microsoft.com/uwp/api/windows.media.core.videotrack.GetEncodingProperties).</span></span> <span data-ttu-id="2df6c-267">エンコード プロパティの [**SphericalVideoFrameFormat**](https://docs.microsoft.com/uwp/api/windows.media.mediaproperties.videoencodingproperties.SphericalVideoFrameFormat) プロパティが、[**SphericaVideoFrameFormat.None**](https://docs.microsoft.com/uwp/api/windows.media.mediaproperties.sphericalvideoframeformat) 以外の値である場合、ビデオ トラックには球面ビデオが含まれており、選択した場合は適切に UI を更新できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-267">If the [**SphericalVideoFrameFormat**](https://docs.microsoft.com/uwp/api/windows.media.mediaproperties.videoencodingproperties.SphericalVideoFrameFormat) property of the encoding properties is a value other than [**SphericaVideoFrameFormat.None**](https://docs.microsoft.com/uwp/api/windows.media.mediaproperties.sphericalvideoframeformat), then the video track contains spherical video and you can update your UI accordingly if you choose.</span></span>

[!code-cs[SphericalTracksChanged](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSphericalTracksChanged)]

## <a name="use-mediaplayer-in-frame-server-mode"></a><span data-ttu-id="2df6c-268">フレーム サーバー モードでの MediaPlayer の使用</span><span class="sxs-lookup"><span data-stu-id="2df6c-268">Use MediaPlayer in frame server mode</span></span>
<span data-ttu-id="2df6c-269">Windows 10 Version 1703 以降では、フレーム サーバー モードで **MediaPlayer** を使用できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-269">Starting with Windows 10, version 1703, you can use **MediaPlayer** in frame server mode.</span></span> <span data-ttu-id="2df6c-270">このモードでは、**MediaPlayer** は、関連付けられている **MediaPlayerElement** にフレームを自動的には表示しません。</span><span class="sxs-lookup"><span data-stu-id="2df6c-270">In this mode, the **MediaPlayer** does not automatically render frames to an associated **MediaPlayerElement**.</span></span> <span data-ttu-id="2df6c-271">代わりに、アプリが、**MediaPlayer** から [**IDirect3DSurface**](https://docs.microsoft.com/uwp/api/windows.graphics.directx.direct3d11.idirect3dsurface) を実装するオブジェクトに現在のフレームをコピーします。</span><span class="sxs-lookup"><span data-stu-id="2df6c-271">Instead, your app copies the current frame from the **MediaPlayer** to an object that implements [**IDirect3DSurface**](https://docs.microsoft.com/uwp/api/windows.graphics.directx.direct3d11.idirect3dsurface).</span></span> <span data-ttu-id="2df6c-272">この機能により実現される主要なシナリオは、**MediaPlayer** によって提供されるビデオ フレームをピクセル シェーダーを使用して処理することです。</span><span class="sxs-lookup"><span data-stu-id="2df6c-272">The primary scenario this feature enables is using pixel shaders to process video frames provided by the **MediaPlayer**.</span></span> <span data-ttu-id="2df6c-273">処理後、アプリが XAML [**Image**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.image) コントロールでフレームを表示するなどの方法で、各フレームを表示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-273">Your app is responsible for displaying each frame after processing, such as by showing the frame in a XAML [**Image**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.image) control.</span></span>

<span data-ttu-id="2df6c-274">次の例では、新しい **MediaPlayer** が初期化され、ビデオ コンテンツが読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-274">In the following example, a new **MediaPlayer** is initialized and video content is loaded.</span></span> <span data-ttu-id="2df6c-275">次に、[**VideoFrameAvailable**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.VideoFrameAvailable) のハンドラーが登録されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-275">Next, a handler for [**VideoFrameAvailable**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.VideoFrameAvailable) is registered.</span></span> <span data-ttu-id="2df6c-276">**MediaPlayer** オブジェクトの [**IsVideoFrameServerEnabled**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.IsVideoFrameServerEnabled) プロパティを **true** に設定することによって、フレーム サーバー モードが有効になります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-276">Frame server mode is enabled by setting the **MediaPlayer** object's [**IsVideoFrameServerEnabled**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.IsVideoFrameServerEnabled) property to **true**.</span></span> <span data-ttu-id="2df6c-277">最後に、[**Play**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.Play) の呼び出しによってメディアの再生が開始されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-277">Finally, media playback is started with a call to [**Play**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.Play).</span></span>

[!code-cs[FrameServerInit](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetFrameServerInit)]

<span data-ttu-id="2df6c-278">次の例は、[Win2D](https://github.com/Microsoft/Win2D) を使用してビデオの各フレームに単純なぼかし効果を追加し、処理されたフレームを XAML [Image](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.image) コントロールで表示する **VideoFrameAvailable** ハンドラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-278">The next example shows a handler for **VideoFrameAvailable** that uses [Win2D](https://github.com/Microsoft/Win2D) to add a simple blur effect to each frame of a video and then displays the processed frames in a XAML [Image](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.image) control.</span></span>

<span data-ttu-id="2df6c-279">**VideoFrameAvailable** ハンドラーが呼び出されるたびに、[**CopyFrameToVideoSurface**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.copyframetovideosurface) メソッドを使用して、フレームの内容が [**IDirect3DSurface**](https://docs.microsoft.com/uwp/api/windows.graphics.directx.direct3d11.idirect3dsurface) にコピーされます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-279">Whenever the **VideoFrameAvailable** handler is called, the [**CopyFrameToVideoSurface**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.copyframetovideosurface) method is used to copy the contents of the frame to an [**IDirect3DSurface**](https://docs.microsoft.com/uwp/api/windows.graphics.directx.direct3d11.idirect3dsurface).</span></span> <span data-ttu-id="2df6c-280">[**CopyFrameToStereoscopicVideoSurfaces**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.copyframetostereoscopicvideosurfaces) を使用して 3D コンテンツを 2 つのサーフェスにコピーし、左目用と右目用のコンテンツを個別に処理することもできます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-280">You can also use [**CopyFrameToStereoscopicVideoSurfaces**](https://docs.microsoft.com/uwp/api/windows.media.playback.mediaplayer.copyframetostereoscopicvideosurfaces) to copy 3D content into two surfaces, for processing the left eye and right eye content separately.</span></span> <span data-ttu-id="2df6c-281">**IDirect3DSurface** を実装するオブジェクトを取得するため、この例では、[**SoftwareBitmap**](https://docs.microsoft.com/uwp/api/windows.graphics.imaging.softwarebitmap) を作成し、そのオブジェクトを使って、必要なインターフェイスを実装する Win2D **CanvasBitmap** を作成します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-281">To get an object that implements **IDirect3DSurface**  this example creates a [**SoftwareBitmap**](https://docs.microsoft.com/uwp/api/windows.graphics.imaging.softwarebitmap) and then uses that object to create a Win2D **CanvasBitmap**, which implements the necessary interface.</span></span> <span data-ttu-id="2df6c-282">**CanvasImageSource** は **Image** コントロールのソースとして使用できる Win2D オブジェクトであるため、新しいオブジェクトを作成し、コンテンツを表示する **Image** のソースとして設定しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-282">A **CanvasImageSource** is a Win2D object that can be used as the source for an **Image** control, so a new one is created and set as the source for the **Image** in which the content will be displayed.</span></span> <span data-ttu-id="2df6c-283">次に、**CanvasDrawingSession** が作成されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-283">Next, a **CanvasDrawingSession** is created.</span></span> <span data-ttu-id="2df6c-284">これは、Win2D でぼかし効果のレンダリングに使用されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-284">This is used by Win2D to render the blur effect.</span></span>

<span data-ttu-id="2df6c-285">必要なオブジェクトがすべてインスタンス化されると、**CopyFrameToVideoSurface** が呼び出され、**MediaPlayer** から **CanvasBitmap** に現在のフレームがコピーされます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-285">Once all of the necessary objects have been instantiated, **CopyFrameToVideoSurface** is called, which copies the current frame from the **MediaPlayer** into the **CanvasBitmap**.</span></span> <span data-ttu-id="2df6c-286">次に、Win2D **GaussianBlurEffect**が作成され、操作のソースとして **CanvasBitmap** が設定されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-286">Next, a Win2D **GaussianBlurEffect** is created, with the **CanvasBitmap** set as the source of the operation.</span></span> <span data-ttu-id="2df6c-287">最後に、**CanvasDrawingSession.DrawImage** が呼び出され、ぼかし効果が適用されたソース画像が、**Image** コントロールに関連付けられた **CanvasImageSource** に描画され、それが UI に描画されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-287">Finally, **CanvasDrawingSession.DrawImage** is called to draw the source image, with the blur effect applied, into the **CanvasImageSource** that has been associated with **Image** control, causing it to be drawn in the UI.</span></span>

[!code-cs[VideoFrameAvailable](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetVideoFrameAvailable)]

<span data-ttu-id="2df6c-288">Win2D について詳しくは、[Win2D の GitHub リポジトリ](https://github.com/Microsoft/Win2D)をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="2df6c-288">For more information on Win2D, see the [Win2D GitHub repository](https://github.com/Microsoft/Win2D).</span></span> <span data-ttu-id="2df6c-289">上記のサンプル コードを試すには、次の手順でプロジェクトにWin2D NuGet パッケージを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-289">To try out the sample code shown above, you will need to add the Win2D NuGet package to your project with the following instructions.</span></span>

**<span data-ttu-id="2df6c-290">効果のプロジェクトに Win2D NuGet パッケージを追加するには</span><span class="sxs-lookup"><span data-stu-id="2df6c-290">To add the Win2D NuGet package to your effect project</span></span>**

1.  <span data-ttu-id="2df6c-291">**ソリューション エクスプローラー**で、プロジェクトを右クリックし、**[NuGet パッケージの管理]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="2df6c-291">In **Solution Explorer**, right-click your project and select **Manage NuGet Packages**.</span></span>
2.  <span data-ttu-id="2df6c-292">ウィンドウの上部で **[参照]** タブをクリックします。</span><span class="sxs-lookup"><span data-stu-id="2df6c-292">At the top of the window, select the **Browse** tab.</span></span>
3.  <span data-ttu-id="2df6c-293">検索ボックスに **「Win2D」** と入力します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-293">In the search box, enter **Win2D**.</span></span>
4.  <span data-ttu-id="2df6c-294">**[Win2D.uwp]** を選択し、右のウィンドウで **[インストール]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-294">Select **Win2D.uwp**, and then select **Install** in the right pane.</span></span>
5.  <span data-ttu-id="2df6c-295">**[変更の確認]** ダイアログに、インストールするパッケージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-295">The **Review Changes** dialog shows you the package to be installed.</span></span> <span data-ttu-id="2df6c-296">**[OK]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="2df6c-296">Click **OK**.</span></span>
6.  <span data-ttu-id="2df6c-297">パッケージのライセンスに同意します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-297">Accept the package license.</span></span>

## <a name="detect-and-respond-to-audio-level-changes-by-the-system"></a><span data-ttu-id="2df6c-298">システムによるオーディオ レベルの変更を検出して対応する</span><span class="sxs-lookup"><span data-stu-id="2df6c-298">Detect and respond to audio level changes by the system</span></span>
<span data-ttu-id="2df6c-299">Windows 10、バージョン 1803 以降では、現在 **MediaPlayer** で再生されているオーディオ レベルが、システムによって低下した場合やミュートされた場合に、アプリがそれを検出できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-299">Starting with Windows 10, version 1803, your app can detect when the system lowers or mutes the audio level of a currently playing **MediaPlayer**.</span></span> <span data-ttu-id="2df6c-300">たとえば、アラームが鳴っているときに、システムがオーディオ再生レベルを下げることがあります ("ダッキング" と呼ばれます)。</span><span class="sxs-lookup"><span data-stu-id="2df6c-300">For example, the system may lower, or "duck", the audio playback level when an alarm is ringing.</span></span> <span data-ttu-id="2df6c-301">アプリ マニフェストで *backgroundMediaPlayback* 機能が宣言されていない場合、アプリがバックグラウンドに移動すると、システムによってアプリがミュートされます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-301">The system will mute your app when it goes into the background if your app has not declared the *backgroundMediaPlayback* capability in the app manifest.</span></span> <span data-ttu-id="2df6c-302">[**AudioStateMonitor**](https://docs.microsoft.comuwp/api/windows.media.audio.audiostatemonitor) クラスを使用すると、オーディオ ストリームの音量がシステムによって変更されたときに、イベントを受け取るように登録できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-302">The [**AudioStateMonitor**](https://docs.microsoft.comuwp/api/windows.media.audio.audiostatemonitor) class allows you to register to receive an event when the system modifies the volume of an audio stream.</span></span> <span data-ttu-id="2df6c-303">その **MediaPlayer** のオーディオ レベルがシステムによって変更されたときに通知を受け取るには、**MediaPlayer** の **AudioStateMonitor** プロパティにアクセスし、[**SoundLevelChanged**](https://docs.microsoft.com/uwp/api/windows.media.audio.audiostatemonitor.soundlevelchanged) イベントのハンドラーを登録します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-303">Access the **AudioStateMonitor** property of a **MediaPlayer** and register a handler for the [**SoundLevelChanged**](https://docs.microsoft.com/uwp/api/windows.media.audio.audiostatemonitor.soundlevelchanged) event to be notified when the audio level for that **MediaPlayer** is changed by the system.</span></span>

[!code-cs[RegisterAudioStateMonitor](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetRegisterAudioStateMonitor)]

<span data-ttu-id="2df6c-304">**SoundLevelChanged**イベントを処理するときは、再生中のコンテンツの種類に応じてさまざまな方法を取ることができます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-304">When handling the **SoundLevelChanged** event, you may take different actions depending on the type of content being played.</span></span> <span data-ttu-id="2df6c-305">たとえば現在音楽を再生中の場合は、ボリュームがダッキングされている間も、そのまま音楽を再生し続けることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-305">If you are currently playing music, then you may want to let the music continue to play while the volume is ducked.</span></span> <span data-ttu-id="2df6c-306">しかしポッドキャストを再生中の場合は、ユーザーがコンテンツを聞き逃さないように、ダッキングされている間、再生を一時停止するのが普通です。</span><span class="sxs-lookup"><span data-stu-id="2df6c-306">If you are playing a podcast, however, you likely want to pause playback while the audio is ducked so the user doesn't miss any of the content.</span></span>

<span data-ttu-id="2df6c-307">以下の例では、現在再生されているコンテンツがポッドキャストかどうかを追跡する変数を宣言しています。この変数は、**MediaPlayer** のコンテンツを選択するときに、アプリによって適切な値に設定されるものと想定します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-307">This example declares a variable to track whether the currently playing content is a podcast, it is assumed that you set this to the appropriate value when selecting the content for the **MediaPlayer**.</span></span> <span data-ttu-id="2df6c-308">またオーディオ レベルが変更されたためにプログラムによって再生が一時停止された場合に、それを追跡するクラス変数も作成しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-308">We also create a class variable to track when we pause playback programmatically when the audio level changes.</span></span>

[!code-cs[AudioStateVars](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetAudioStateVars)]

<span data-ttu-id="2df6c-309">**SoundLevelChanged** イベント ハンドラーで、**AudioStateMonitor** センダーの [**SoundLevel**](https://docs.microsoft.com/uwp/api/windows.media.audio.audiostatemonitor.soundlevel) プロパティを確認すると、新しいサウンド レベルを判定できます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-309">In the **SoundLevelChanged** event handler, check the [**SoundLevel**](https://docs.microsoft.com/uwp/api/windows.media.audio.audiostatemonitor.soundlevel) property of the **AudioStateMonitor** sender to determine the new sound level.</span></span> <span data-ttu-id="2df6c-310">以下の例では、新しいサウンド レベルがフル音量かどうか、つまりシステムが音量のミュートまたはダッキングを停止したかどうか、またはサウンド レベルは低いままだが、ポッドキャスト以外のコンテンツを再生しているかどうかを確認しています。</span><span class="sxs-lookup"><span data-stu-id="2df6c-310">This example checks to see if the new sound level is full volume, meaning the system has stopped muting or ducking the volume, or if the sound level has been lowered but is playing non-podcast content.</span></span> <span data-ttu-id="2df6c-311">これらのいずれかが true で、コンテンツがプログラムによって一時停止されている場合、再生が再開されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-311">If either of these are true and the content was previously paused programmatically, playback is resumed.</span></span> <span data-ttu-id="2df6c-312">新しいサウンド レベルがミュートされている場合、または現在のコンテンツがポッドキャストでサウンドレベルが低い場合、再生が一時停止され、プログラムによって一時停止が開始されたことを追跡する変数が設定されます。</span><span class="sxs-lookup"><span data-stu-id="2df6c-312">If the new sound level is muted or if the current content is a podcast and the sound level is low, playback is paused, and the variable is set to track that the pause was initiated programatically.</span></span>

[!code-cs[SoundLevelChanged](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetSoundLevelChanged)]

<span data-ttu-id="2df6c-313">オーディオがシステムによってダッキングされている場合でも、再生を一時停止するか続行するかをユーザーが選択することがあります。</span><span class="sxs-lookup"><span data-stu-id="2df6c-313">The user may decide that they want to pause or continue playback, even if the audio is ducked by the system.</span></span> <span data-ttu-id="2df6c-314">以下の例では、再生と一時停止ボタンのイベント ハンドラーを示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-314">This example shows event handlers for a play and a pause button.</span></span> <span data-ttu-id="2df6c-315">一時停止ボタンのクリック ハンドラーでは、再生がプログラムによって既に一時停止されている場合、この変数を更新して、ユーザーがコンテンツを一時停止したことを示します。</span><span class="sxs-lookup"><span data-stu-id="2df6c-315">In the pause button click handler is paused, if playback had already been paused programmatically, then we update the variable to indicate that the user has paused the content.</span></span> <span data-ttu-id="2df6c-316">再生ボタンのクリック ハンドラーでは、再生を再開し、追跡変数をクリアします。</span><span class="sxs-lookup"><span data-stu-id="2df6c-316">In the play button click handler, we resume playback and clear our tracking variable.</span></span>

[!code-cs[ButtonUserClick](./code/MediaPlayer_RS1/cs/MainPage.xaml.cs#SnippetButtonUserClick)]

## <a name="related-topics"></a><span data-ttu-id="2df6c-317">関連トピック</span><span class="sxs-lookup"><span data-stu-id="2df6c-317">Related topics</span></span>
* [<span data-ttu-id="2df6c-318">メディア再生</span><span class="sxs-lookup"><span data-stu-id="2df6c-318">Media playback</span></span>](media-playback.md)
* [<span data-ttu-id="2df6c-319">メディア項目、プレイリスト、トラック</span><span class="sxs-lookup"><span data-stu-id="2df6c-319">Media items, playlists, and tracks</span></span>](media-playback-with-mediasource.md)
* [<span data-ttu-id="2df6c-320">システム メディア トランスポート コントロールとの統合</span><span class="sxs-lookup"><span data-stu-id="2df6c-320">Integrate with the Sytem Media Transport Controls</span></span>](integrate-with-systemmediatransportcontrols.md)
* [<span data-ttu-id="2df6c-321">メディアの中断の作成、スケジュール、管理</span><span class="sxs-lookup"><span data-stu-id="2df6c-321">Create, schedule, and manage media breaks</span></span>](create-schedule-and-manage-media-breaks.md)
* [<span data-ttu-id="2df6c-322">バックグラウンドでのメディアの再生</span><span class="sxs-lookup"><span data-stu-id="2df6c-322">Play media in the background</span></span>](background-audio.md)





 

 




