---
author: stevewhims
description: ネットワーク経由でファイルを確実にコピーするには、バックグラウンド転送 API を使います。
title: バックグラウンド転送
ms.assetid: 1207B089-BC16-4BF0-BBD4-FD99950C764B
ms.author: stwhi
ms.date: 03/23/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: f533ab00cd80838d630a78f6f877f65fc1d617ba
ms.sourcegitcommit: 6618517dc0a4e4100af06e6d27fac133d317e545
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/28/2018
ms.locfileid: "1691491"
---
# <a name="background-transfers"></a><span data-ttu-id="da1f0-104">バックグラウンド転送</span><span class="sxs-lookup"><span data-stu-id="da1f0-104">Background transfers</span></span>
<span data-ttu-id="da1f0-105">ネットワーク経由でファイルを確実にコピーするには、バックグラウンド転送 API を使います。</span><span class="sxs-lookup"><span data-stu-id="da1f0-105">Use the background transfer API to copy files reliably over the network.</span></span> <span data-ttu-id="da1f0-106">バックグラウンド転送 API には、アプリの一時停止中はバックグラウンドで実行され、アプリの終了後も実行が続行される高度なアップロード機能とダウンロード機能があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-106">The background transfer API provides advanced upload and download features that run in the background during app suspension and persist beyond app termination.</span></span> <span data-ttu-id="da1f0-107">この API は、ネットワークの状態を監視し、接続が失われたときに転送の中断と再開を自動的に実行します。転送ではデータ センサーとバッテリー セーバーにも対応し、ダウンロード アクティビティは現在の接続とデバイスのバッテリー状態に基づいて調整されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-107">The API monitors network status and automatically suspends and resumes transfers when connectivity is lost, and transfers are also Data Sense-aware and Battery Sense-aware, meaning that download activity adjusts based on your current connectivity and device battery status.</span></span> <span data-ttu-id="da1f0-108">この API は、アップロード HTTP(S) を使った大きなファイルのアップロードとダウンロードに適しています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-108">The API is ideal for uploading and downloading large files using HTTP(S).</span></span> <span data-ttu-id="da1f0-109">FTP もサポートされますが、その対象はダウンロードのみです。</span><span class="sxs-lookup"><span data-stu-id="da1f0-109">FTP is also supported, but only for downloads.</span></span>

<span data-ttu-id="da1f0-110">バックグラウンド転送はアプリの呼び出しとは別に実行され、主にビデオ、音楽、サイズの大きい画像などのリソースの長期の転送操作を目的としています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-110">Background Transfer runs separately from the calling app and is primarily designed for long-term transfer operations for resources like video, music, and large images.</span></span> <span data-ttu-id="da1f0-111">これらのシナリオでは、アプリが一時停止状態でもダウンロードが続行されるため、バックグラウンド転送の使用が不可欠です。</span><span class="sxs-lookup"><span data-stu-id="da1f0-111">For these scenarios, using Background Transfer is essential because downloads continue to progress even when the app is suspended.</span></span>

<span data-ttu-id="da1f0-112">すぐに完了する可能性がある小さいリソースをダウンロードする場合は、バックグラウンド転送ではなく [**HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) API を使ってください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-112">If you are downloading small resources that are likely to complete quickly, you should use [**HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) APIs instead of Background Transfer.</span></span>

## <a name="using-windowsnetworkingbackgroundtransfer"></a><span data-ttu-id="da1f0-113">Windows.Networking.BackgroundTransfer を使う</span><span class="sxs-lookup"><span data-stu-id="da1f0-113">Using Windows.Networking.BackgroundTransfer</span></span>

### <a name="how-does-the-background-transfer-feature-work"></a><span data-ttu-id="da1f0-114">バックグラウンド転送機能はどのように動作するか</span><span class="sxs-lookup"><span data-stu-id="da1f0-114">How does the Background Transfer feature work?</span></span>
<span data-ttu-id="da1f0-115">アプリがバックグラウンド転送を使って転送を開始するときは、[**BackgroundDownloader**](https://msdn.microsoft.com/library/windows/apps/br207126) または [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) クラス オブジェクトを使って要求が構成され初期化されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-115">When an app uses Background Transfer to initiate a transfer, the request is configured and initialized using [**BackgroundDownloader**](https://msdn.microsoft.com/library/windows/apps/br207126) or [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) class objects.</span></span> <span data-ttu-id="da1f0-116">それぞれの転送操作は、呼び出し元アプリとは別にシステムによって個別に処理されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-116">Each transfer operation is handled individually by the system and separate from the calling app.</span></span> <span data-ttu-id="da1f0-117">進行情報はアプリの UI でユーザーに状況を示す場合に利用することができ、アプリで一時停止、再開、キャンセルしたり、転送中にデータを読み取ったりすることができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-117">Progress information is available if you want to give status to the user in your app's UI, and your app can pause, resume, cancel, or even read from the data while the transfer is occurring.</span></span> <span data-ttu-id="da1f0-118">システムによって転送が処理される方法により、スマートな電力消費が実現し、アプリの中断や終了、突然のネットワーク ステータス変化などのイベントが接続アプリで発生したときに起こる可能性のある問題を回避できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-118">The way transfers are handled by the system promotes smart power usage and prevents problems that can arise when a connected app encounters events such as app suspension, termination, or sudden network status changes.</span></span>

<span data-ttu-id="da1f0-119">さらに、バック グラウンド転送ではシステム イベント ブローカー イベントを使用します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-119">In addition, Background Transfer uses System Event Broker events.</span></span> <span data-ttu-id="da1f0-120">そのため、システムで利用可能なイベントの数によって、ダウンロード数が制限されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-120">As such, the number of downloads is limited by the number of events available on the system.</span></span> <span data-ttu-id="da1f0-121">既定では利用可能なイベントの数は 500 ですが、これらのイベントはすべてのプロセス間で共有されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-121">By default this is 500 events, but those events are shared across all processes.</span></span> <span data-ttu-id="da1f0-122">そのため、1 つのアプリケーションで、一度に 100 個を超えるバックグラウンド転送を作成しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-122">Therefore, a single application should not create more than 100 background transfers at a time.</span></span>

<span data-ttu-id="da1f0-123">アプリケーションでバック グラウンド転送を開始すると、既存のすべての [**DownloadOperation**](/uwp/api/windows.networking.backgroundtransfer.downloadoperation?branch=live) オブジェクトで[**AttachAsync**](/uwp/api/windows.networking.backgroundtransfer.downloadoperation.AttachAsync) を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-123">When an application starts a background transfer, the application must call [**AttachAsync**](/uwp/api/windows.networking.backgroundtransfer.downloadoperation.AttachAsync) on all existing [**DownloadOperation**](/uwp/api/windows.networking.backgroundtransfer.downloadoperation?branch=live) objects.</span></span> <span data-ttu-id="da1f0-124">そうしなければ、これらのイベントのリークが発生する可能性があります。そのため、バック グラウンド転送機能は使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-124">Not doing this may cause a leak of those events, and thus render the Background Transfer feature useless.</span></span>

### <a name="performing-authenticated-file-requests-with-background-transfer"></a><span data-ttu-id="da1f0-125">バックグラウンド転送での認証されたファイル要求の実行</span><span class="sxs-lookup"><span data-stu-id="da1f0-125">Performing authenticated file requests with Background Transfer</span></span>
<span data-ttu-id="da1f0-126">バックグラウンド転送では、基本サーバーとプロキシの資格情報、Cookie をサポートするメソッドが用意されており、それぞれの転送操作で ([**SetRequestHeader**](https://msdn.microsoft.com/library/windows/apps/br207146) を介して) カスタム HTTP ヘッダーを使うこともできます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-126">Background Transfer provides methods that support basic server and proxy credentials, cookies, and the use of custom HTTP headers (via [**SetRequestHeader**](https://msdn.microsoft.com/library/windows/apps/br207146)) for each transfer operation.</span></span>

### <a name="how-does-this-feature-adapt-to-network-status-changes-or-unexpected-shutdowns"></a><span data-ttu-id="da1f0-127">この機能ではネットワーク ステータスの変化や予期しないシャットダウンにどのように対応するか</span><span class="sxs-lookup"><span data-stu-id="da1f0-127">How does this feature adapt to network status changes or unexpected shutdowns?</span></span>
<span data-ttu-id="da1f0-128">バックグラウンド転送機能により、ネットワークの状態が変化したときに各転送操作に対して一貫性のあるエクスペリエンスが保たれます。これは、[接続](https://msdn.microsoft.com/library/windows/apps/hh452990) 機能によって提供される接続とキャリアのデータ プラン ステータスの情報をインテリジェントに利用しています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-128">The Background Transfer feature maintains a consistent experience for each transfer operation when network status changes occur, by intelligently leveraging connectivity and carrier data-plan status information provided by the [Connectivity](https://msdn.microsoft.com/library/windows/apps/hh452990) feature.</span></span> <span data-ttu-id="da1f0-129">さまざまなネットワーク シナリオでの動作を定義するために、アプリは、[**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138) によって定義された値を使って、各転送操作のコスト ポリシーを設定します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-129">To define behavior for different network scenarios, an app sets a cost policy for each operation using values defined by [**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138).</span></span>

<span data-ttu-id="da1f0-130">たとえば、操作に対して定義されたコスト ポリシーで、デバイスが従量制課金接続を使っているときに操作を自動的に一時停止する必要があることを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-130">For example, the cost policy defined for an operation can indicate that the operation should be paused automatically when the device is using a metered network.</span></span> <span data-ttu-id="da1f0-131">"制限のない" ネットワークへの接続が確立されたときには、転送が自動的に再開されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-131">The transfer is then automatically resumed (or restarted) when a connection to an "unrestricted" network has been established.</span></span> <span data-ttu-id="da1f0-132">コストによってネットワークがどのように定義されるかについては、「[**NetworkCostType**](https://msdn.microsoft.com/library/windows/apps/br207292)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-132">For more information on how networks are defined by cost, see [**NetworkCostType**](https://msdn.microsoft.com/library/windows/apps/br207292).</span></span>

<span data-ttu-id="da1f0-133">バックグラウンド転送機能にはネットワーク ステータスの変化に対応する独自のメカニズムがありますが、ネットワーク接続されたアプリには他にも一般的な接続の考慮事項があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-133">While the Background Transfer feature has its own mechanisms for handling network status changes, there are other general connectivity considerations for network-connected apps.</span></span> <span data-ttu-id="da1f0-134">詳しくは、「[利用できるネットワーク接続情報の活用](https://msdn.microsoft.com/library/windows/apps/hh452983)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-134">Read [Leveraging available network connection information](https://msdn.microsoft.com/library/windows/apps/hh452983) for additional info.</span></span>

> <span data-ttu-id="da1f0-135">**注:** モバイル デバイスで実行されるアプリでは、接続の種類、ローミング ステータス、ユーザーのデータ通信プランに基づいて転送されるデータの量を、ユーザーが監視および制限できる機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-135">**Note**  For apps running on mobile devices, there are features that allow the user to monitor and restrict the amount of data that is transferred based on the type of connection, roaming status, and the user's data plan.</span></span> <span data-ttu-id="da1f0-136">このため、[**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138) が転送が継続中であることを示す場合でも、電話でバックグラウンド転送が一時停止される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-136">Because of this, background transfers may be paused on the phone even when the [**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138) indicates that the transfer should proceed.</span></span>

<span data-ttu-id="da1f0-137">次の表に、電話の現在の状態に応じて、[**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138) の各値に対して、電話でバックグラウンド転送が許可されるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-137">The following table indicates when background transfers are allowed on the phone for each [**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138) value, given the current state of the phone.</span></span> <span data-ttu-id="da1f0-138">[**ConnectionCost**](https://msdn.microsoft.com/library/windows/apps/br207244) クラスを使って、電話の現在の状態を判断できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-138">You can use the [**ConnectionCost**](https://msdn.microsoft.com/library/windows/apps/br207244) class to determine the phone's current state.</span></span>

| <span data-ttu-id="da1f0-139">デバイスの状態</span><span class="sxs-lookup"><span data-stu-id="da1f0-139">Device State</span></span>                                                                                                                      | <span data-ttu-id="da1f0-140">UnrestrictedOnly</span><span class="sxs-lookup"><span data-stu-id="da1f0-140">UnrestrictedOnly</span></span> | <span data-ttu-id="da1f0-141">Default (既定)</span><span class="sxs-lookup"><span data-stu-id="da1f0-141">Default</span></span> | <span data-ttu-id="da1f0-142">Always</span><span class="sxs-lookup"><span data-stu-id="da1f0-142">Always</span></span> |
|-----------------------------------------------------------------------------------------------------------------------------------|------------------|---------|--------|
| <span data-ttu-id="da1f0-143">WiFi 接続</span><span class="sxs-lookup"><span data-stu-id="da1f0-143">Connected to WiFi</span></span>                                                                                                                 | <span data-ttu-id="da1f0-144">許可</span><span class="sxs-lookup"><span data-stu-id="da1f0-144">Allow</span></span>            | <span data-ttu-id="da1f0-145">許可</span><span class="sxs-lookup"><span data-stu-id="da1f0-145">Allow</span></span>   | <span data-ttu-id="da1f0-146">許可</span><span class="sxs-lookup"><span data-stu-id="da1f0-146">Allow</span></span>  |
| <span data-ttu-id="da1f0-147">従量制課金接続、ローミング時以外、データ制限未満、制限内にとどまる見込み</span><span class="sxs-lookup"><span data-stu-id="da1f0-147">Metered Connection, not roaming, under data limit, on track to stay under limit</span></span>                                                   | <span data-ttu-id="da1f0-148">拒否</span><span class="sxs-lookup"><span data-stu-id="da1f0-148">Deny</span></span>             | <span data-ttu-id="da1f0-149">許可</span><span class="sxs-lookup"><span data-stu-id="da1f0-149">Allow</span></span>   | <span data-ttu-id="da1f0-150">許可</span><span class="sxs-lookup"><span data-stu-id="da1f0-150">Allow</span></span>  |
| <span data-ttu-id="da1f0-151">従量制課金接続、ローミング時以外、データ制限未満、制限を超過する見込み</span><span class="sxs-lookup"><span data-stu-id="da1f0-151">Metered Connection, not roaming, under data limit, on track to exceed limit</span></span>                                                       | <span data-ttu-id="da1f0-152">拒否</span><span class="sxs-lookup"><span data-stu-id="da1f0-152">Deny</span></span>             | <span data-ttu-id="da1f0-153">拒否</span><span class="sxs-lookup"><span data-stu-id="da1f0-153">Deny</span></span>    | <span data-ttu-id="da1f0-154">許可</span><span class="sxs-lookup"><span data-stu-id="da1f0-154">Allow</span></span>  |
| <span data-ttu-id="da1f0-155">従量制課金接続、ローミング時、データ制限未満</span><span class="sxs-lookup"><span data-stu-id="da1f0-155">Metered Connection, roaming, under data limit</span></span>                                                                                     | <span data-ttu-id="da1f0-156">拒否</span><span class="sxs-lookup"><span data-stu-id="da1f0-156">Deny</span></span>             | <span data-ttu-id="da1f0-157">拒否</span><span class="sxs-lookup"><span data-stu-id="da1f0-157">Deny</span></span>    | <span data-ttu-id="da1f0-158">許可</span><span class="sxs-lookup"><span data-stu-id="da1f0-158">Allow</span></span>  |
| <span data-ttu-id="da1f0-159">従量制課金接続、データ制限超過</span><span class="sxs-lookup"><span data-stu-id="da1f0-159">Metered Connection, over data limit.</span></span> <span data-ttu-id="da1f0-160">この状態は、ユーザーが Data Sense UI で [バックグラウンドでのデータ通信を制限する] を有効にしている場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-160">This state only occurs when the user enables "Restrict background data in the Data Sense UI.</span></span> | <span data-ttu-id="da1f0-161">拒否</span><span class="sxs-lookup"><span data-stu-id="da1f0-161">Deny</span></span>             | <span data-ttu-id="da1f0-162">拒否</span><span class="sxs-lookup"><span data-stu-id="da1f0-162">Deny</span></span>    | <span data-ttu-id="da1f0-163">拒否</span><span class="sxs-lookup"><span data-stu-id="da1f0-163">Deny</span></span>   |

## <a name="uploading-files"></a><span data-ttu-id="da1f0-164">ファイルのアップロード</span><span class="sxs-lookup"><span data-stu-id="da1f0-164">Uploading files</span></span>
<span data-ttu-id="da1f0-165">バックグラウンド転送を使う場合、アップロードは [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) として存在し、操作の再起動や取り消しに使われる多くの制御メソッドを公開します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-165">When using Background Transfer an upload exists as an [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) that exposes a number of control methods that are used to restart or cancel the operation.</span></span> <span data-ttu-id="da1f0-166">アプリのイベント (一時停止、終了など) や接続の変更は、**UploadOperation** を通じてシステムによって自動的に処理されます。アップロードは、アプリの一時停止中も続行し、アプリの終了以降は一時停止して保持されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-166">App events (e.g. suspension or termination) and connectivity changes are handled automatically by the system per **UploadOperation**; uploads will continue during app suspension periods or pause and persist beyond app termination.</span></span> <span data-ttu-id="da1f0-167">また、[**CostPolicy**](https://msdn.microsoft.com/library/windows/apps/hh701018) プロパティを設定することで、従量制課金接続がインターネット接続のために使われている間もアプリがアップロードを開始するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-167">Additionally, setting the [**CostPolicy**](https://msdn.microsoft.com/library/windows/apps/hh701018) property will indicate whether or not your app will start uploads while a metered network is being used for Internet connectivity.</span></span>

<span data-ttu-id="da1f0-168">以下に、基本的なアップロードを作成および初期化する例と、前のアプリ セッションから続いている操作を列挙および再び取り込む例を示します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-168">The following examples will walk you through the creation and initialization of a basic upload and how to enumerate and reintroduce operations persisted from a previous app session.</span></span>

### <a name="uploading-a-single-file"></a><span data-ttu-id="da1f0-169">1 つのファイルのアップロード</span><span class="sxs-lookup"><span data-stu-id="da1f0-169">Uploading a single file</span></span>
<span data-ttu-id="da1f0-170">アップロードの作成は、[**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) から始めます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-170">The creation of an upload begins with [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140).</span></span> <span data-ttu-id="da1f0-171">このクラスは、アプリで [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) を作成する前に、そのアップロードを構成できるようにするメソッドを提供するために使われます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-171">This class is used to provide the methods that enable your app to configure the upload before creating the resultant [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224).</span></span> <span data-ttu-id="da1f0-172">次の例は、必要な [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) オブジェクトと [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) オブジェクトを使ってこれを行う方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-172">The following example shows how to do this with the required [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) and [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) objects.</span></span>

**<span data-ttu-id="da1f0-173">アップロードするファイルと送信先の特定</span><span class="sxs-lookup"><span data-stu-id="da1f0-173">Identify the file and destination for the upload</span></span>**

<span data-ttu-id="da1f0-174">[**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) の作成を始める前に、アップロード先となる場所の URI とアップロードされるファイルを識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-174">Before we can begin with the creation of an [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224), we first need to identify the URI of the location to upload to, and the file that will be uploaded.</span></span> <span data-ttu-id="da1f0-175">次の例では、UI 入力からの文字列を使って *uriString* の値が設定され、[**PickSingleFileAsync**](https://msdn.microsoft.com/library/windows/apps/jj635275) 操作で返される [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) オブジェクトを使って *file* の値が設定されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-175">In the following example, the *uriString* value is populated using a string from UI input, and the *file* value using the [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) object returned by a [**PickSingleFileAsync**](https://msdn.microsoft.com/library/windows/apps/jj635275) operation.</span></span>

[!code-js[uploadFile](./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_B "Identify the file and destination for the upload")]

**<span data-ttu-id="da1f0-176">アップロード操作の作成と初期化</span><span class="sxs-lookup"><span data-stu-id="da1f0-176">Create and initialize the upload operation</span></span>**

<span data-ttu-id="da1f0-177">前の手順では、*uriString* と *file* の値が次に示す例の UploadOp のインスタンスに渡されました。これらの値は、新しいアップロード操作を構成し開始するために使われます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-177">In the previous step the *uriString* and *file* values are passed to an instance of our next example, UploadOp, where they are used to configure and start the new upload operation.</span></span> <span data-ttu-id="da1f0-178">まず、*uriString* が解析されて、要求された [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-178">First, *uriString* is parsed to create the required [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) object.</span></span>

<span data-ttu-id="da1f0-179">そして、与えられた [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) (*file*) のプロパティが [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) で使われて要求ヘッダーが設定され、*SourceFile* プロパティに **StorageFile** オブジェクトが設定されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-179">Next, the properties of the provided [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) (*file*) are used by [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) to populate the request header and set the *SourceFile* property with the **StorageFile** object.</span></span> <span data-ttu-id="da1f0-180">次に、[**SetRequestHeader**](https://msdn.microsoft.com/library/windows/apps/br207146) メソッドが呼び出され、文字列として提供されたファイル名と [**StorageFile.Name**](https://msdn.microsoft.com/library/windows/apps/br227220) プロパティが挿入されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-180">The [**SetRequestHeader**](https://msdn.microsoft.com/library/windows/apps/br207146) method is then called to insert the file name, provided as a string, and the [**StorageFile.Name**](https://msdn.microsoft.com/library/windows/apps/br227220) property.</span></span>

<span data-ttu-id="da1f0-181">最後に、[**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) によって [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) (*upload*) が作成されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-181">Finally, [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) creates the [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) (*upload*).</span></span>

[!code-js[uploadFile](./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_A "Create and initialize the upload operation")]

<span data-ttu-id="da1f0-182">JavaScript の promise を使って定義した非同期メソッドの呼び出しに注意してください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-182">Note the asynchronous method calls defined using JavaScript promises.</span></span> <span data-ttu-id="da1f0-183">最後の例には次の行があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-183">Looking at a line from the last example:</span></span>

```javascript
promise = upload.startAsync().then(complete, error, progress);
```

<span data-ttu-id="da1f0-184">非同期メソッドの後に then ステートメントが続いています。このステートメントでは、非同期メソッドの呼び出しの結果が返されたときに呼び出される、アプリで定義されたメソッドを指定しています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-184">The async method call is followed by a then statement which indicates methods, defined by the app, that are called when a result from the async method call is returned.</span></span> <span data-ttu-id="da1f0-185">このプログラミング パターンについて詳しくは、「[promise を使った JavaScript での非同期プログラミング](http://msdn.microsoft.com/library/windows/apps/hh464930.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-185">For more information on this programming pattern, see [Asynchronous programming in JavaScript using promises](http://msdn.microsoft.com/library/windows/apps/hh464930.aspx).</span></span>

### <a name="uploading-multiple-files"></a><span data-ttu-id="da1f0-186">複数のファイルのアップロード</span><span class="sxs-lookup"><span data-stu-id="da1f0-186">Uploading multiple files</span></span>
**<span data-ttu-id="da1f0-187">アップロードするファイルと送信先の特定</span><span class="sxs-lookup"><span data-stu-id="da1f0-187">Identify the files and destination for the upload</span></span>**

<span data-ttu-id="da1f0-188">単一の [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) で複数のファイルを転送するシナリオでは、処理は通常どおり、最初に必要なアップロード先 URI とローカル ファイルの情報を指定することから始まります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-188">In a scenario involving multiple files transferred with a single [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224), the process begins as it usually does by first providing the required destination URI and local file information.</span></span> <span data-ttu-id="da1f0-189">前のセクションの例と同様に、URI はエンド ユーザーが文字列で指定します。また、[**FileOpenPicker**](https://msdn.microsoft.com/library/windows/apps/br207847) を使って、ユーザー インターフェイスからファイルを指定する機能も提供できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-189">Similar to the example in the previous section, the URI is provided as a string by the end-user and [**FileOpenPicker**](https://msdn.microsoft.com/library/windows/apps/br207847) can be used to provide the ability to indicate files through the user interface as well.</span></span> <span data-ttu-id="da1f0-190">ただし、このシナリオでは、アプリで代わりに [**PickMultipleFilesAsync**](https://msdn.microsoft.com/library/windows/apps/br207851) メソッドを呼び出して、UI から複数のファイルを選ぶことができるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-190">However, in this scenario the app should instead call the [**PickMultipleFilesAsync**](https://msdn.microsoft.com/library/windows/apps/br207851) method to enable the selection of multiple files through the UI.</span></span>

```javascript
function uploadFiles() {
       var filePicker = new Windows.Storage.Pickers.FileOpenPicker();
       filePicker.fileTypeFilter.replaceAll(["*"]);

       filePicker.pickMultipleFilesAsync().then(function (files) {
          if (files === 0) {
             printLog("No file selected");
                return;
          }

          var upload = new UploadOperation();
          var uriString = document.getElementById("serverAddressField").value;
          upload.startMultipart(uriString, files);

          // Persist the upload operation in the global array.
          uploadOperations.push(upload);
       });
    }
```

**<span data-ttu-id="da1f0-191">指定されたパラメーターに基づくオブジェクトの作成</span><span class="sxs-lookup"><span data-stu-id="da1f0-191">Create objects for the provided parameters</span></span>**

<span data-ttu-id="da1f0-192">次の 2 つの例では、前の手順の最後に呼び出された単一のメソッド例 **startMultipart** に含まれているコードを使っています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-192">The next two examples use code contained in a single example method, **startMultipart**, which was called at the end of the last step.</span></span> <span data-ttu-id="da1f0-193">わかりやすくするために、[**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) オブジェクトの配列を作るメソッドのコードは、結果の [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) を作るコードから分割されています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-193">For the purpose of instruction the code in the method that creates an array of [**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) objects has been split from the code that creates the resultant [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224).</span></span>

<span data-ttu-id="da1f0-194">最初に、ユーザーが指定した URI 文字列を [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) として初期化します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-194">First, the URI string provided by the user is initialized as a [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998).</span></span> <span data-ttu-id="da1f0-195">次に、このメソッドに渡された [**IStorageFile**](https://msdn.microsoft.com/library/windows/apps/br227102) オブジェクト (**files**) の配列を反復処理し、配列内の各オブジェクトを使って新しい [**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) オブジェクトを作り、そのオブジェクトを **contentParts** 配列に配置します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-195">Next, the array of [**IStorageFile**](https://msdn.microsoft.com/library/windows/apps/br227102) objects (**files**) passed to this method is iterated through, each object is used to create a new [**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) object which is then placed in the **contentParts** array.</span></span>

```javascript
    upload.startMultipart = function (uriString, files) {
        try {
            var uri = new Windows.Foundation.Uri(uriString);
            var uploader = new Windows.Networking.BackgroundTransfer.BackgroundUploader();

            var contentParts = [];
            files.forEach(function (file, index) {
                var part = new Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart("File" + index, file.name);
                part.setFile(file);
                contentParts.push(part);
            });
```

**<span data-ttu-id="da1f0-196">マルチパート アップロード操作の作成と初期化</span><span class="sxs-lookup"><span data-stu-id="da1f0-196">Create and initialize the multi-part upload operation</span></span>**

<span data-ttu-id="da1f0-197">contentParts 配列には、アップロード用の各 [**IStorageFile**](https://msdn.microsoft.com/library/windows/apps/br227102) を表す [**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) オブジェクトがすべて含まれているため、要求の送信先を示す [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) を使って [**CreateUploadAsync**](https://msdn.microsoft.com/library/windows/apps/hh923973) を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-197">With our contentParts array populated with all of the [**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) objects representing each [**IStorageFile**](https://msdn.microsoft.com/library/windows/apps/br227102) for upload, we are ready to call [**CreateUploadAsync**](https://msdn.microsoft.com/library/windows/apps/hh923973) using the [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) to indicate where the request will be sent.</span></span>

```javascript
        // Create a new upload operation.
            uploader.createUploadAsync(uri, contentParts).then(function (uploadOperation) {

               // Start the upload and persist the promise to be able to cancel the upload.
               upload = uploadOperation;
               promise = uploadOperation.startAsync().then(complete, error, progress);
            });

         } catch (err) {
             displayError(err);
         }
     };
```

### <a name="restarting-interrupted-upload-operations"></a><span data-ttu-id="da1f0-198">中断されたアップロード操作の再開</span><span class="sxs-lookup"><span data-stu-id="da1f0-198">Restarting interrupted upload operations</span></span>
<span data-ttu-id="da1f0-199">[**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) が完了するか取り消されると、関連するシステム リソースがすべて解放されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-199">On completion or cancellation of an [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224), any associated system resources are released.</span></span> <span data-ttu-id="da1f0-200">ただし、これらのイベントのどちらかが発生する前にアプリが終了した場合、アクティブな操作は一時停止され、それぞれに関連付けられているリソースは占有されたままになります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-200">However, if your app is terminated before either of these things can occur, any active operations are paused and the resources associated with each remain occupied.</span></span> <span data-ttu-id="da1f0-201">これらの操作が列挙されずに次のアプリ セッションに再び取り込まれると、それらの操作は完了せず、デバイス リソースを占有したままとなります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-201">If these operations are not enumerated and re-introduced to the next app session, they will not be completed and will continue to occupy device resources.</span></span>

1.  <span data-ttu-id="da1f0-202">持続している操作を列挙する関数を定義する前に、返される [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) オブジェクトを格納する配列を作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-202">Before defining the function that enumerates persisted operations, we need to create an array that will contain the [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) objects that it will return:</span></span>

    [!code-js[uploadFile](./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_C "Restart interrupted upload operation")]

1.  <span data-ttu-id="da1f0-203">次に、持続している操作を列挙してそれらを配列に格納する関数を定義します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-203">Next we define the function that enumerates persisted operations and stores them in our array.</span></span> <span data-ttu-id="da1f0-204">[**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) に対するコールバックを再び割り当てるために呼び出される **load** メソッドは、アプリの終了後も持続する場合、このセクションでこの後定義する UploadOp クラス内にあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-204">Note that the **load** method called to re-assign callbacks to the [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224), should it persist through app termination, is in the UploadOp class we define later in this section.</span></span>

    [!code-js[uploadFile](./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_D "Enumerate persisted operations")]

## <a name="downloading-files"></a><span data-ttu-id="da1f0-205">ファイルのダウンロード</span><span class="sxs-lookup"><span data-stu-id="da1f0-205">Downloading files</span></span>
<span data-ttu-id="da1f0-206">バックグラウンド転送を使う場合、各ダウンロードは [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) として存在し、操作の一時停止、再開、再起動、取り消しに使われる多くの制御メソッドを公開します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-206">When using Background Transfer, each download exists as a [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) that exposes a number of control methods used to pause, resume, restart, and cancel the operation.</span></span> <span data-ttu-id="da1f0-207">アプリのイベント (一時停止、終了など) や接続の変更は、**DownloadOperation** を通じてシステムによって自動的に処理されます。ダウンロードは、アプリの一時停止中も続行し、アプリの終了以降は一時停止して保持されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-207">App events (e.g. suspension or termination) and connectivity changes are handled automatically by the system per **DownloadOperation**; downloads will continue during app suspension periods or pause and persist beyond app termination.</span></span> <span data-ttu-id="da1f0-208">モバイル ネットワーク シナリオの場合、[**CostPolicy**](https://msdn.microsoft.com/library/windows/apps/hh701018) プロパティを設定することで、従量制課金接続がインターネット接続のために使われている間もアプリがダウンロードを開始または続行するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-208">For mobile network scenarios, setting the [**CostPolicy**](https://msdn.microsoft.com/library/windows/apps/hh701018) property will indicate whether or not your app will begin or continue downloads while a metered network is being used for Internet connectivity.</span></span>

<span data-ttu-id="da1f0-209">すぐに完了する可能性がある小さいリソースをダウンロードする場合は、バックグラウンド転送ではなく [**HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) API を使ってください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-209">If you are downloading small resources that are likely to complete quickly, you should use [**HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) APIs instead of Background Transfer.</span></span>

<span data-ttu-id="da1f0-210">アプリごとのリソースの制約により、常にアプリに 200 を超える転送 (DownloadOperations および UploadOperations) を含めてはなりません。</span><span class="sxs-lookup"><span data-stu-id="da1f0-210">Due to per-app resource constraints, an app should not have more than 200 transfers (DownloadOperations + UploadOperations) at any given time.</span></span> <span data-ttu-id="da1f0-211">この制限を超過すると、アプリの転送キューが回復不能な状態になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-211">Exceeding that limit may leave the app’s transfer queue in an unrecoverable state.</span></span>

<span data-ttu-id="da1f0-212">以下に、基本的なダウンロードを作成および初期化する例と、前のアプリ セッションから続いている操作を列挙および再び取り込む例を示します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-212">The following examples will walk you through the creation and initialization of a basic download, and how to enumerate and reintroduce operations persisted from a previous app session.</span></span>

### <a name="configure-and-start-a-background-transfer-file-download"></a><span data-ttu-id="da1f0-213">バックグラウンド転送によるファイルのダウンロードを構成して開始する</span><span class="sxs-lookup"><span data-stu-id="da1f0-213">Configure and start a Background Transfer file download</span></span>
<span data-ttu-id="da1f0-214">URI とファイル名を表す文字列を使って、[**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) オブジェクトと要求されたファイルを格納する [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) とを作成する方法を次の例で示します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-214">The following example demonstrates how strings representing a URI and a file name can be used to create a [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) object and the [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) that will contain the requested file.</span></span> <span data-ttu-id="da1f0-215">この例では、新しいファイルが定義済みの場所に自動的に配置されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-215">In this example, the new file is automatically placed in a pre-defined location.</span></span> <span data-ttu-id="da1f0-216">または、[**FileSavePicker**](https://msdn.microsoft.com/library/windows/apps/br207871) を使ってユーザーがファイルを保存するデバイスの場所を指定できるようになります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-216">Alternatively, [**FileSavePicker**](https://msdn.microsoft.com/library/windows/apps/br207871) can be used allow users to indicate where to save the file on the device.</span></span> <span data-ttu-id="da1f0-217">[**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) に対するコールバックを再び割り当てるために呼び出される **load** メソッドは、アプリの終了以降も持続する場合、このセクションでこの後定義する DownloadOp クラス内にあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-217">Note that the **load** method called to re-assign callbacks to the [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154), should it persist through app termination, is in the DownloadOp class defined later in this section.</span></span>

[!code-js[uploadFile](./code/backgroundtransfer/download_quickstart/js/main.js#Snippetdownload_quickstart_A)]

<span data-ttu-id="da1f0-218">JavaScript の promise を使って定義した非同期メソッドの呼び出しに注意してください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-218">Note the asynchronous method calls defined using JavaScript promises.</span></span> <span data-ttu-id="da1f0-219">前のコード例の 17 行目には次のコードがあります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-219">Looking at line 17 from the previous code example:</span></span>

```javascript
promise = download.startAsync().then(complete, error, progress);
```

<span data-ttu-id="da1f0-220">非同期メソッドの後に then ステートメントが続いています。このステートメントでは、非同期メソッドの呼び出しの結果が返されたときに呼び出される、アプリで定義されたメソッドを指定しています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-220">The async method call is followed by a then statement which indicates methods, defined by the app, that are called when a result from the async method call is returned.</span></span> <span data-ttu-id="da1f0-221">このプログラミング パターンについて詳しくは、「[プロミスを使った JavaScript での非同期プログラミング](http://msdn.microsoft.com/library/windows/apps/hh464930.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-221">For more information on this programming pattern, see [Asynchronous programming in JavaScript using promises](http://msdn.microsoft.com/library/windows/apps/hh464930.aspx).</span></span>

### <a name="adding-additional-operation-control-methods"></a><span data-ttu-id="da1f0-222">その他の操作制御メソッドの追加</span><span class="sxs-lookup"><span data-stu-id="da1f0-222">Adding additional operation control methods</span></span>
<span data-ttu-id="da1f0-223">追加の [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) メソッドを実装することによって、制御のレベルを高めることができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-223">The level of control can be increased by implementing additional [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) methods.</span></span> <span data-ttu-id="da1f0-224">上の例に次のコードを追加すると、ダウンロードをキャンセルすることができるようになります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-224">For example, adding the following code to the example above will introduce the ability to cancel the download.</span></span>

[!code-js[uploadFile](./code/backgroundtransfer/download_quickstart/js/main.js#Snippetdownload_quickstart_B)]

### <a name="enumerating-persisted-operations-at-start-up"></a><span data-ttu-id="da1f0-225">持続している操作の起動時の列挙</span><span class="sxs-lookup"><span data-stu-id="da1f0-225">Enumerating persisted operations at start-up</span></span>
<span data-ttu-id="da1f0-226">[**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) が完了するか取り消されると、関連するシステム リソースがすべて解放されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-226">On completion or cancellation of a [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154), any associated system resources are released.</span></span> <span data-ttu-id="da1f0-227">ただし、これらのイベントのどちらかが発生する前にアプリが終了した場合、ダウンロードは一時停止され、バックグラウンドで保持されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-227">However, if your app is terminated before either of these events occur, downloads will pause and persist in the background.</span></span> <span data-ttu-id="da1f0-228">以下の例は、持続しているダウンロードを新しいアプリ セッションに再び取り込む方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-228">The following examples demonstrate how to re-introduce persisted downloads into a new app session.</span></span>

1.  <span data-ttu-id="da1f0-229">持続している操作を列挙する関数を定義する前に、返される [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) オブジェクトを格納する配列を作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-229">Before defining the function that enumerates persisted operations, we need to create an array that will contain the [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) objects that it will return:</span></span>

    [!code-js[uploadFile](./code/backgroundtransfer/download_quickstart/js/main.js#Snippetdownload_quickstart_D)]

1.  <span data-ttu-id="da1f0-230">次に、持続している操作を列挙してそれらを配列に格納する関数を定義します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-230">Next we define the function that enumerates persisted operations and stores them in our array.</span></span> <span data-ttu-id="da1f0-231">持続している [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) に対するコールバックを再び割り当てるために呼び出される **load** メソッドは、このセクションでこの後定義する DownloadOp の例に含まれていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-231">Note that the **load** method called to re-assign callbacks for a persisted [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) is in the DownloadOp example we define later in this section.</span></span>

    [!code-js[uploadFile](./code/backgroundtransfer/download_quickstart/js/main.js#Snippetdownload_quickstart_E)]

1.  <span data-ttu-id="da1f0-232">これで、返された値の一覧を使って、保留中の操作を再開できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-232">You can now use the populated list to restart pending operations.</span></span>

## <a name="post-processing"></a><span data-ttu-id="da1f0-233">後処理</span><span class="sxs-lookup"><span data-stu-id="da1f0-233">Post-processing</span></span>
<span data-ttu-id="da1f0-234">Windows 10 の新機能は、アプリが実行されていない場合でも、バックグラウンド転送の完了時にアプリケーション コードを実行できる機能です。</span><span class="sxs-lookup"><span data-stu-id="da1f0-234">A new feature in Windows 10 is the ability to run application code at the completion of a background transfer even when the app is not running.</span></span> <span data-ttu-id="da1f0-235">たとえば、アプリが開始されるたびに新しいムービーをスキャンするのではなく、ムービーのダウンロードが完了した後で利用可能な映画の一覧を更新できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-235">For example, your app might want to update a list of available movies after a movie has finished downloading, rather than have your app scan for new movies every time it starts.</span></span> <span data-ttu-id="da1f0-236">または、アプリでファイル転送が失敗した場合に、別のサーバーまたはポートを使ってもう一度転送し直すことができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-236">Or your app might want to handle a failed file transfer by trying again using a different server or port.</span></span> <span data-ttu-id="da1f0-237">後処理は成功した転送と失敗した転送の両方で呼び出されるため、これを使って、カスタム エラー処理と再試行ロジックを実装できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-237">Post-processing is invoked for both successful and failed transfers, so you can use it to implement custom error-handling and retry logic.</span></span>

<span data-ttu-id="da1f0-238">後処理では、既存のバックグラウンド タスク インフラストラクチャを使います。</span><span class="sxs-lookup"><span data-stu-id="da1f0-238">Postprocessing uses the existing background task infrastructure.</span></span> <span data-ttu-id="da1f0-239">転送を開始する前に、バックグラウンド タスクを作成して転送に関連付けます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-239">You create a background task and associate it with your transfers before you start the transfers.</span></span> <span data-ttu-id="da1f0-240">転送はバックグラウンドで実行され、完了時にバックグラウンド タスクが呼び出されて後処理が実行されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-240">The transfers are then executed in the background, and when they are complete, your background task is called to perform post-processing.</span></span>

<span data-ttu-id="da1f0-241">後処理では、[**BackgroundTransferCompletionGroup**](https://msdn.microsoft.com/library/windows/apps/dn804209) という新しいクラスを使います。</span><span class="sxs-lookup"><span data-stu-id="da1f0-241">Post-processing uses a new class, [**BackgroundTransferCompletionGroup**](https://msdn.microsoft.com/library/windows/apps/dn804209).</span></span> <span data-ttu-id="da1f0-242">このクラスは、バックグラウンド タスクをグループ化できるという点で既存の [**BackgroundTransferGroup**](https://msdn.microsoft.com/library/windows/apps/dn279030) に似ていますが、**BackgroundTransferCompletionGroup** には、転送の完了時に実行するバックグラウンド タスクを指定できる機能が追加されています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-242">This class is similar to the existing [**BackgroundTransferGroup**](https://msdn.microsoft.com/library/windows/apps/dn279030) in that it allows you to group background transfers together, but **BackgroundTransferCompletionGroup** adds the ability to designate a background task to be run when the transfer is complete.</span></span>

<span data-ttu-id="da1f0-243">後処理があるバックグラウンド転送は、次のように開始します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-243">You initiate a background transfer with post-processing as follows.</span></span>

1.  <span data-ttu-id="da1f0-244">[**BackgroundTransferCompletionGroup**](https://msdn.microsoft.com/library/windows/apps/dn804209) オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-244">Create a [**BackgroundTransferCompletionGroup**](https://msdn.microsoft.com/library/windows/apps/dn804209) object.</span></span> <span data-ttu-id="da1f0-245">続けて、[**BackgroundTaskBuilder**](https://msdn.microsoft.com/library/windows/apps/br224768) オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-245">Then, create a [**BackgroundTaskBuilder**](https://msdn.microsoft.com/library/windows/apps/br224768) object.</span></span> <span data-ttu-id="da1f0-246">ビルダー オブジェクトの **Trigger** プロパティを完了グループ オブジェクトに設定し、ビルダーの **TaskEntryPoint** プロパティを、転送完了時に実行する必要があるバックグラウンド タスクのエントリ ポイントに設定します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-246">Set the **Trigger** property of the builder object to the completion group object, and the **TaskEntryPoint** property of the builder to the entry point of the background task that should execute on transfer completion.</span></span> <span data-ttu-id="da1f0-247">最後に、[**BackgroundTaskBuilder.Register**](https://msdn.microsoft.com/library/windows/apps/br224772) メソッドを呼び出してバックグラウンド タスクを登録します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-247">Finally, call the [**BackgroundTaskBuilder.Register**](https://msdn.microsoft.com/library/windows/apps/br224772) method to register your background task.</span></span> <span data-ttu-id="da1f0-248">複数の完了グループで 1 つのバックグラウンド タスクのエントリ ポイントを共有できますが、バックグラウンド タスクの登録では 1 つの完了グループのみ指定できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-248">Note that many completion groups can share one background task entry point, but you can have only one completion group per background task registration.</span></span>

```csharp
var completionGroup = new BackgroundTransferCompletionGroup();
BackgroundTaskBuilder builder = new BackgroundTaskBuilder();

builder.Name = "MyDownloadProcessingTask";
builder.SetTrigger(completionGroup.Trigger);
builder.TaskEntryPoint = "Tasks.BackgroundDownloadProcessingTask";

BackgroundTaskRegistration downloadProcessingTask = builder.Register();
```

2.  <span data-ttu-id="da1f0-249">次に、バックグラウンド転送を完了グループに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-249">Next you associate background transfers with the completion group.</span></span> <span data-ttu-id="da1f0-250">すべての転送を作成したら、完了グループを有効にします。</span><span class="sxs-lookup"><span data-stu-id="da1f0-250">Once all transfers are created, enable the completion group.</span></span>

```csharp
BackgroundDownloader downloader = new BackgroundDownloader(completionGroup);
DownloadOperation download = downloader.CreateDownload(uri, file);
Task<DownloadOperation> startTask = download.StartAsync().AsTask();

// App still sees the normal completion path
startTask.ContinueWith(ForegroundCompletionHandler);

// Do not enable the CompletionGroup until after all downloads are created.
downloader.CompletinGroup.Enable();
```

3.  <span data-ttu-id="da1f0-251">バックグラウンド タスク内のコードで、トリガーの詳細情報から操作の一覧を抽出した後、各操作の詳細を検査し、操作ごとに適切な後処理を実行できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-251">The code in the background task extracts the list of operations from the trigger details, and your code can then inspect the details for each operation and perform appropriate post-processing for each operation.</span></span>

```csharp
public class BackgroundDownloadProcessingTask : IBackgroundTask
{
    public async void Run(IBackgroundTaskInstance taskInstance)
    {
    var details = (BackgroundTransferCompletionGroupTriggerDetails)taskInstance.TriggerDetails;
    IReadOnlyList<DownloadOperation> downloads = details.Downloads;

    // Do post-processing on each finished operation in the list of downloads
    }
}
```

<span data-ttu-id="da1f0-252">後処理タスクは、通常のバックグラウンド タスクです。</span><span class="sxs-lookup"><span data-stu-id="da1f0-252">The post-processing task is a regular background task.</span></span> <span data-ttu-id="da1f0-253">それはすべてのバックグラウンド タスクのプールの一部であり、すべてのバックグラウンド タスクと同じリソース管理ポリシーが適用されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-253">It is part of the pool of all background tasks, and it is subject to the same resource management policy as all background tasks.</span></span>

<span data-ttu-id="da1f0-254">後処理はフォアグラウンド完了ハンドラーに代わるものではないことにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-254">Also, note that post-processing does not replace foreground completion handlers.</span></span> <span data-ttu-id="da1f0-255">アプリにフォアグラウンド完了ハンドラーが定義されているときに、ファイル転送の完了時にアプリが実行されている場合は、フォアグラウンド完了ハンドラーとバックグラウンド完了ハンドラーの両方が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-255">If your app defines a foreground completion handler, and your app is running when the file transfer completes, then both your foreground completion handler and your background completion handler will be called.</span></span> <span data-ttu-id="da1f0-256">フォアグラウンド タスクとバックグラウンド タスクが呼び出される順序は保証されません。</span><span class="sxs-lookup"><span data-stu-id="da1f0-256">The order in which foreground and background tasks are called is not guaranteed.</span></span> <span data-ttu-id="da1f0-257">両方を定義する場合は、2 つのタスクが正常に動作し、同時に実行されても相互に干渉しないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-257">If you define both, you should ensure that the two tasks will work properly and not interfere with each other if they are running concurrently.</span></span>

## <a name="request-timeouts"></a><span data-ttu-id="da1f0-258">要求のタイムアウト</span><span class="sxs-lookup"><span data-stu-id="da1f0-258">Request timeouts</span></span>
<span data-ttu-id="da1f0-259">次の 2 つの主要接続タイムアウト シナリオを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-259">There are two primary connection timeout scenarios to take into consideration:</span></span>

-   <span data-ttu-id="da1f0-260">転送のために新しい接続を確立する場合、5 分以内に接続が確立しないと、接続要求は中止されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-260">When establishing a new connection for a transfer, the connection request is aborted if it is not established within five minutes.</span></span>

-   <span data-ttu-id="da1f0-261">接続が確立された後、2 分以内で応答を受け取らなかった HTTP 要求メッセージは中止されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-261">After a connection has been established, an HTTP request message that has not received a response within two minutes is aborted.</span></span>

> <span data-ttu-id="da1f0-262">**注:** どちらのシナリオにおいても、バックグラウンド転送はインターネット接続があることを前提に、最高 3 回まで自動的に要求を再試行します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-262">**Note**  In either scenario, assuming there is Internet connectivity, Background Transfer will retry a request up to three times automatically.</span></span> <span data-ttu-id="da1f0-263">インターネット接続が検出されないと、検出されるまで別の要求は待機します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-263">In the event Internet connectivity is not detected, additional requests will wait until it is.</span></span>

## <a name="debugging-guidance"></a><span data-ttu-id="da1f0-264">デバッグのガイダンス</span><span class="sxs-lookup"><span data-stu-id="da1f0-264">Debugging guidance</span></span>
<span data-ttu-id="da1f0-265">Microsoft Visual Studio でデバッグ セッションを停止することは、アプリを閉じることに相当します。PUT によるアップロードは一時停止され、POST によるアップロードは終了されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-265">Stopping a debugging session in Microsoft Visual Studio is comparable to closing your app; PUT uploads are paused and POST uploads are terminated.</span></span> <span data-ttu-id="da1f0-266">デバッグ時であっても、アプリでは、持続しているアップロードを列挙し、再実行や取り消しを行うことができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-266">Even while debugging, your app should enumerate and then restart or cancel any persisted uploads.</span></span> <span data-ttu-id="da1f0-267">たとえば、そのデバッグ セッションで以前の操作が重要ではない場合、アプリの起動時に、列挙された持続しているアップロード操作をアプリで取り消すことができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-267">For example, you can have your app cancel enumerated persisted upload operations at app startup if there is no interest in previous operations for that debug session.</span></span>

<span data-ttu-id="da1f0-268">デバッグ セッションでアプリの起動時にダウンロードやアップロードを列挙する際、そのデバッグ セッションで以前の操作が重要ではない場合、列挙された操作をアプリで取り消すことができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-268">While enumerating downloads/uploads on app startup during a debug session, you can have your app cancel them if there is no interest in previous operations for that debug session.</span></span> <span data-ttu-id="da1f0-269">アプリ マニフェストの変更など、Visual Studio プロジェクトの更新があり、アプリがアンインストールされ、もう一度展開された場合、[**GetCurrentUploadsAsync**](https://msdn.microsoft.com/library/windows/apps/hh701149) は、前のアプリの展開を使って作成された操作を列挙できないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="da1f0-269">Note that if there are Visual Studio project updates, like changes to the app manifest, and the app is uninstalled and re-deployed, [**GetCurrentUploadsAsync**](https://msdn.microsoft.com/library/windows/apps/hh701149) cannot enumerate operations created using the previous app deployment.</span></span>

<span data-ttu-id="da1f0-270">開発時にバックグラウンド転送を使うと、完了したアクティブな転送操作の内部キャッシュが同期しなくなる状況が発生する可能性があります。このため、新しい転送操作を開始できない場合や、既存の操作や [**BackgroundTransferGroup**](https://msdn.microsoft.com/library/windows/apps/dn279030) オブジェクトを処理できない場合があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-270">When using Background Transfer during development, you may get into a situation where the internal caches of active and completed transfer operations can get out of sync. This may result in the inability to start new transfer operations or interact with existing operations and [**BackgroundTransferGroup**](https://msdn.microsoft.com/library/windows/apps/dn279030) objects.</span></span> <span data-ttu-id="da1f0-271">状況によっては、既存の操作を処理しようとすると、クラッシュの原因となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-271">In some cases, attempting to interact with existing operations may trigger a crash.</span></span> <span data-ttu-id="da1f0-272">これは、[**TransferBehavior**](https://msdn.microsoft.com/library/windows/apps/dn279033) プロパティが **Parallel** に設定されている場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-272">This result can occur if the [**TransferBehavior**](https://msdn.microsoft.com/library/windows/apps/dn279033) property is set to **Parallel**.</span></span> <span data-ttu-id="da1f0-273">この問題は、開発中に特定のシナリオでのみ発生し、アプリのエンド ユーザーには適用されません。</span><span class="sxs-lookup"><span data-stu-id="da1f0-273">This issue occurs only in certain scenarios during development and is not applicable to end users of your app.</span></span>

<span data-ttu-id="da1f0-274">Visual Studio を使う 4 つのシナリオで、この問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-274">Four scenarios using Visual Studio can cause this issue.</span></span>

-   <span data-ttu-id="da1f0-275">既にあるプロジェクトと同じアプリ名を持つ新しいプロジェクトを、別の言語で作成する (C++ から C# など)。</span><span class="sxs-lookup"><span data-stu-id="da1f0-275">You create a new project with the same app name as an existing project, but a different language (from C++ to C#, for example).</span></span>
-   <span data-ttu-id="da1f0-276">既にあるプロジェクトのターゲット アーキテクチャを変更する (x86 から x64 など)。</span><span class="sxs-lookup"><span data-stu-id="da1f0-276">You change the target architecture (from x86 to x64, for example) in an existing project.</span></span>
-   <span data-ttu-id="da1f0-277">既にあるプロジェクトのカルチャを変更する (ニュートラルから en-US など)。</span><span class="sxs-lookup"><span data-stu-id="da1f0-277">You change the culture (from neutral to en-US, for example) in an existing project.</span></span>
-   <span data-ttu-id="da1f0-278">既にあるプロジェクトのパッケージ マニフェストで機能を追加または削除する (**エンタープライズ認証**を追加するなど)。</span><span class="sxs-lookup"><span data-stu-id="da1f0-278">You add or remove a capability in the package manifest (adding **Enterprise Authentication**, for example) in an existing project.</span></span>

<span data-ttu-id="da1f0-279">機能を追加または削除するマニフェストの更新など、通常のアプリのサービスでは、アプリのエンド ユーザーに対する展開でこの問題は発生しません。</span><span class="sxs-lookup"><span data-stu-id="da1f0-279">Regular app servicing, including manifest updates which add or remove capabilities, do not trigger this issue on end user deployments of your app.</span></span>
<span data-ttu-id="da1f0-280">この問題を回避するには、アプリのすべてのバージョンを完全にアンインストールし、新しい言語、アーキテクチャ、カルチャ、または機能をもう一度展開します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-280">To work around this issue, completely uninstall all versions of the app and re-deploy with the new language, architecture, culture, or capability.</span></span> <span data-ttu-id="da1f0-281">この操作は、**スタート**画面で行うか、PowerShell と **Remove-AppxPackage** コマンドレットを使って行うことができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-281">This can be done via the **Start** screen or using PowerShell and the **Remove-AppxPackage** cmdlet.</span></span>

## <a name="exceptions-in-windowsnetworkingbackgroundtransfer"></a><span data-ttu-id="da1f0-282">Windows.Networking.BackgroundTransfer の例外</span><span class="sxs-lookup"><span data-stu-id="da1f0-282">Exceptions in Windows.Networking.BackgroundTransfer</span></span>
<span data-ttu-id="da1f0-283">Uniform Resource Identifier (URI) として無効な文字列が、[**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) オブジェクトのコンストラクターに渡されると、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-283">An exception is thrown when an invalid string for a the Uniform Resource Identifier (URI) is passed to the constructor for the [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) object.</span></span>

<span data-ttu-id="da1f0-284">**.NET:** [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) 型は、C# や VB では [**System.Uri**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.aspx) と表示されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-284">**.NET:** The [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) type appears as [**System.Uri**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.aspx) in C# and VB.</span></span>

<span data-ttu-id="da1f0-285">C# と Visual Basic では、.NET 4.5 の [**System.Uri**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.aspx) クラスと、いずれかの [**System.Uri.TryCreate**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.trycreate.aspx) メソッドを使って、URI が作成される前にアプリのユーザーから受け取った文字列をテストすることによって、このエラーを回避できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-285">In C# and Visual Basic, this error can be avoided by using the [**System.Uri**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.aspx) class in the .NET 4.5 and one of the [**System.Uri.TryCreate**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.trycreate.aspx) methods to test the string received from the app user before the URI is constructed.</span></span>

<span data-ttu-id="da1f0-286">C++ では、URI として渡される文字列を試行して解析するメソッドはありません。</span><span class="sxs-lookup"><span data-stu-id="da1f0-286">In C++, there is no method to try and parse a string to a URI.</span></span> <span data-ttu-id="da1f0-287">アプリがユーザーから [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) の入力を取得する場合、このコンストラクターを try/catch ブロックに配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-287">If an app gets input from the user for the [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998), the constructor should be in a try/catch block.</span></span> <span data-ttu-id="da1f0-288">例外がスローされた場合、アプリは、ユーザーに通知し、新しいホスト名を要求することができます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-288">If an exception is thrown, the app can notify the user and request a new hostname.</span></span>

<span data-ttu-id="da1f0-289">[**Windows.Networking.backgroundTransfer**](https://msdn.microsoft.com/library/windows/apps/br207242) 名前空間には便利なヘルパー メソッドがあり、[**Windows.Networking.Sockets**](https://msdn.microsoft.com/library/windows/apps/br226960) 名前空間の列挙値を使ってエラーを処理します。</span><span class="sxs-lookup"><span data-stu-id="da1f0-289">The [**Windows.Networking.backgroundTransfer**](https://msdn.microsoft.com/library/windows/apps/br207242) namespace has convenient helper methods and uses enumerations in the [**Windows.Networking.Sockets**](https://msdn.microsoft.com/library/windows/apps/br226960) namespace for handling errors.</span></span> <span data-ttu-id="da1f0-290">これは、アプリで特定のネットワーク例外を異なる方法で処理する場合に役立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="da1f0-290">This can be useful for handling specific network exceptions differently in your app.</span></span>

<span data-ttu-id="da1f0-291">[**Windows.Networking.backgroundTransfer**](https://msdn.microsoft.com/library/windows/apps/br207242) 名前空間の非同期メソッドで発生したエラーは、**HRESULT** 値として返されます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-291">An error encountered on an asynchronous method in the [**Windows.Networking.backgroundTransfer**](https://msdn.microsoft.com/library/windows/apps/br207242) namespace is returned as an **HRESULT** value.</span></span> <span data-ttu-id="da1f0-292">[**BackgroundTransferError.GetStatus**](https://msdn.microsoft.com/library/windows/apps/hh701093) メソッドは、バックグラウンド転送操作からのネットワーク エラーを [**WebErrorStatus**](https://msdn.microsoft.com/library/windows/apps/hh747818) 列挙値に変換するために使われます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-292">The [**BackgroundTransferError.GetStatus**](https://msdn.microsoft.com/library/windows/apps/hh701093) method is used to convert a network error from a background transfer operation to a [**WebErrorStatus**](https://msdn.microsoft.com/library/windows/apps/hh747818) enumeration value.</span></span> <span data-ttu-id="da1f0-293">**WebErrorStatus** 列挙値のほとんどは、ネイティブ HTTP または FTP クライアント操作から返されるエラーに対応しています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-293">Most of the **WebErrorStatus** enumeration values correspond to an error returned by the native HTTP or FTP client operation.</span></span> <span data-ttu-id="da1f0-294">アプリは特定の **WebErrorStatus** 列挙値に対するフィルター処理を行い、例外の原因に応じてアプリの動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-294">An app can filter on specific **WebErrorStatus** enumeration values to modify app behavior depending on the cause of the exception.</span></span>

<span data-ttu-id="da1f0-295">パラメーター検証エラーの場合は、例外の **HRESULT** を使って、その例外の原因となったエラーの詳細情報を確認することもできます。</span><span class="sxs-lookup"><span data-stu-id="da1f0-295">For parameter validation errors, an app can also use the **HRESULT** from the exception to learn more detailed information on the error that caused the exception.</span></span> <span data-ttu-id="da1f0-296">使うことができる **HRESULT** 値は、*Winerror.h* ヘッダー ファイルに記載されています。</span><span class="sxs-lookup"><span data-stu-id="da1f0-296">Possible **HRESULT** values are listed in the *Winerror.h* header file.</span></span> <span data-ttu-id="da1f0-297">ほとんどのパラメーター検証エラーの場合、返される **HRESULT** は **E\_INVALIDARG** です。</span><span class="sxs-lookup"><span data-stu-id="da1f0-297">For most parameter validation errors, the **HRESULT** returned is **E\_INVALIDARG**.</span></span>

## <a name="important-apis"></a><span data-ttu-id="da1f0-298">重要な API</span><span class="sxs-lookup"><span data-stu-id="da1f0-298">Important APIs</span></span>
* [**<span data-ttu-id="da1f0-299">Windows.Networking.BackgroundTransfer</span><span class="sxs-lookup"><span data-stu-id="da1f0-299">Windows.Networking.BackgroundTransfer</span></span>**](/uwp/api/windows.networking.backgroundtransfer)
* [**<span data-ttu-id="da1f0-300">Windows.Foundation.Uri</span><span class="sxs-lookup"><span data-stu-id="da1f0-300">Windows.Foundation.Uri</span></span>**](/uwp/api/Windows.Foundation.Uri)
* [**<span data-ttu-id="da1f0-301">Windows.Networking.Sockets</span><span class="sxs-lookup"><span data-stu-id="da1f0-301">Windows.Networking.Sockets</span></span>**](/uwp/api/Windows.Networking.Sockets)
