---
description: 使用する場合、Windows ランタイム アプリでのイベントのプログラミングの概念について説明しますC#、Visual Basic または Visual C コンポーネント拡張 (C +/cli CX)、プログラミング言語、および UI の定義を XAML として。
title: イベントとルーティング イベントの概要
ms.assetid: 34C219E8-3EFB-45BC-8BBD-6FD937698832
ms.date: 07/12/2018
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: a26211c8a0e2f51108553e15f25d286346a90299
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/29/2019
ms.locfileid: "66371173"
---
# <a name="events-and-routed-events-overview"></a><span data-ttu-id="298ca-104">イベントとルーティング イベントの概要</span><span class="sxs-lookup"><span data-stu-id="298ca-104">Events and routed events overview</span></span>

<span data-ttu-id="298ca-105">**重要な API**</span><span class="sxs-lookup"><span data-stu-id="298ca-105">**Important APIs**</span></span>
- [<span data-ttu-id="298ca-106">**UIElement**</span><span class="sxs-lookup"><span data-stu-id="298ca-106">**UIElement**</span></span>](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement)
- [<span data-ttu-id="298ca-107">**RoutedEventArgs**</span><span class="sxs-lookup"><span data-stu-id="298ca-107">**RoutedEventArgs**</span></span>](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.RoutedEventArgs)

<span data-ttu-id="298ca-108">使用する場合、Windows ランタイム アプリでのイベントのプログラミングの概念について説明しますC#、Visual Basic または Visual C コンポーネント拡張 (C +/cli CX)、プログラミング言語、および UI の定義を XAML として。</span><span class="sxs-lookup"><span data-stu-id="298ca-108">We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</span></span> <span data-ttu-id="298ca-109">イベントのハンドラーは、UI 要素の宣言の一部として XAML で割り当てることも、コードで追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-109">You can assign handlers for events as part of the declarations for UI elements in XAML, or you can add the handlers in code.</span></span> <span data-ttu-id="298ca-110">Windows ランタイムは*ルーティング イベント*をサポートしており、特定の入力イベントとデータ イベントを、その発生元オブジェクト以外のオブジェクトで処理できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-110">Windows Runtime supports *routed events*: certain input events and data events can be handled by objects beyond the object that fired the event.</span></span> <span data-ttu-id="298ca-111">ルーティング イベントは、コントロール テンプレートを定義する際や、ページまたはレイアウト コンテナーを使う際に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="298ca-111">Routed events are useful when you define control templates, or use pages or layout containers.</span></span>

## <a name="events-as-a-programming-concept"></a><span data-ttu-id="298ca-112">プログラミングの概念としてのイベント</span><span class="sxs-lookup"><span data-stu-id="298ca-112">Events as a programming concept</span></span>

<span data-ttu-id="298ca-113">一般に、Windows ランタイム アプリのプログラミングを行う際のイベントの概念は、最も一般的なプログラミング言語のイベント モデルと似ています。</span><span class="sxs-lookup"><span data-stu-id="298ca-113">Generally speaking, event concepts when programming a Windows Runtime app are similar to the event model in most popular programming languages.</span></span> <span data-ttu-id="298ca-114">Microsoft .NET または C++ のイベントの操作方法を把握していれば、スムーズに理解できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-114">If you know how to work with Microsoft .NET or C++ events already, you have a head start.</span></span> <span data-ttu-id="298ca-115">ただし、ハンドラーのアタッチのような基本的なタスクを行うために、イベント モデルの概念について詳しく学ぶ必要はありません。</span><span class="sxs-lookup"><span data-stu-id="298ca-115">But you don't need to know that much about event model concepts to perform some basic tasks, such as attaching handlers.</span></span>

<span data-ttu-id="298ca-116">プログラミング言語として C#、Visual Basic、または C++/CX を使用する場合、UI はマークアップ (XAML) で定義されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-116">When you use C#, Visual Basic or C++/CX as your programming language, the UI is defined in markup (XAML).</span></span> <span data-ttu-id="298ca-117">XAML マークアップの構文で、マークアップ要素とランタイム コード エンティティの間でイベントを関連付けるときの原則の一部は、他の Web テクノロジ (ASP.NET、HTML5 など) と似ています。</span><span class="sxs-lookup"><span data-stu-id="298ca-117">In XAML markup syntax, some of the principles of connecting events between markup elements and runtime code entities are similar to other Web technologies, such as ASP.NET, or HTML5.</span></span>

<span data-ttu-id="298ca-118">**注**  XAML 定義の UI のランタイム ロジックを提供するコードと呼ば*コード ビハインド*または分離コード ファイル。</span><span class="sxs-lookup"><span data-stu-id="298ca-118">**Note**  The code that provides the runtime logic for a XAML-defined UI is often referred to as *code-behind* or the code-behind file.</span></span> <span data-ttu-id="298ca-119">Microsoft Visual Studio のソリューション ビューでは、コード ビハインド ファイルが参照先の XAML ページに対して依存する入れ子のファイルとして表示されて、この関係がグラフィカルに示されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-119">In the Microsoft Visual Studio solution views, this relationship is shown graphically, with the code-behind file being a dependent and nested file versus the XAML page it refers to.</span></span>

## <a name="buttonclick-an-introduction-to-events-and-xaml"></a><span data-ttu-id="298ca-120">Button.Click: イベントと XAML の概要</span><span class="sxs-lookup"><span data-stu-id="298ca-120">Button.Click: an introduction to events and XAML</span></span>

<span data-ttu-id="298ca-121">Windows ランタイム アプリの最も一般的なプログラミング タスクの 1 つは、ユーザー入力を UI に取り込むことです。</span><span class="sxs-lookup"><span data-stu-id="298ca-121">One of the most common programming tasks for a Windows Runtime app is to capture user input to the UI.</span></span> <span data-ttu-id="298ca-122">たとえば、UI には、ユーザーが情報を送信、または状態を変更するためにクリックする必要のあるボタンが組み込まれることがあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-122">For example, your UI might have a button that the user must click to submit info or to change state.</span></span>

<span data-ttu-id="298ca-123">Windows ランタイム アプリの UI を定義するには、XAML を生成します。</span><span class="sxs-lookup"><span data-stu-id="298ca-123">You define the UI for your Windows Runtime app by generating XAML.</span></span> <span data-ttu-id="298ca-124">この XAML は、通常は Visual Studio のデザイン サーフェイスからの出力です。</span><span class="sxs-lookup"><span data-stu-id="298ca-124">This XAML is usually the output from a design surface in Visual Studio.</span></span> <span data-ttu-id="298ca-125">また、プレーンテキスト エディターやサードパーティ製の XAML エディターで記述することもできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-125">You can also write the XAML in a plain-text editor or a third-party XAML editor.</span></span> <span data-ttu-id="298ca-126">この XAML を生成するときに、個々の UI 要素のプロパティ値を設定するすべての XAML 属性を定義する際に、その UI 要素にイベント ハンドラーを関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="298ca-126">While generating that XAML, you can wire event handlers for individual UI elements at the same time that you define all the other XAML attributes that establish property values of that UI element.</span></span>

<span data-ttu-id="298ca-127">XAML でイベントを記述する場合は、コード ビハインドで既に定義してあるものも、これから定義するものも含め、ハンドラー メソッドの文字列形式の名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="298ca-127">To wire the events in XAML, you specify the string-form name of the handler method that you've already defined or will define later in your code-behind.</span></span> <span data-ttu-id="298ca-128">たとえば、この XAML は、他のプロパティ ([x:Name 属性](x-name-attribute.md)、[**コンテンツ**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentcontrol.content)) を属性として割り当てたうえで[**ボタン**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) オブジェクトを定義し、`ShowUpdatesButton_Click` というメソッドを参照してボタンの[**クリック**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) イベントのハンドラーを関連付けます。</span><span class="sxs-lookup"><span data-stu-id="298ca-128">For example, this XAML defines a [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) object with other properties ([x:Name attribute](x-name-attribute.md), [**Content**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentcontrol.content)) assigned as attributes, and wires a handler for the button's [**Click**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) event by referencing a method named `ShowUpdatesButton_Click`:</span></span>

```xaml
<Button x:Name="showUpdatesButton"
  Content="{Binding ShowUpdatesText}"
  Click="ShowUpdatesButton_Click"/>
```

<span data-ttu-id="298ca-129">**ヒント:**   *イベントの関連付け*は、プログラミング用語です。</span><span class="sxs-lookup"><span data-stu-id="298ca-129">**Tip**  *Event wiring* is a programming term.</span></span> <span data-ttu-id="298ca-130">これは、イベントが発生して名前付けされたハンドラー メソッドを呼び出すことを示すプロセスやコードのことを指します。</span><span class="sxs-lookup"><span data-stu-id="298ca-130">It refers to the process or code whereby you indicate that occurrences of an event should invoke a named handler method.</span></span> <span data-ttu-id="298ca-131">ほとんどの手続き型コード モデルで、イベントの関連付けはイベントとメソッドの両方の名前を付ける暗黙的または明示的な "AddHandler" コードで、通常ターゲット オブジェクト インスタンスが関係しています。</span><span class="sxs-lookup"><span data-stu-id="298ca-131">In most procedural code models, event wiring is implicit or explicit "AddHandler" code that names both the event and method, and usually involves a target object instance.</span></span> <span data-ttu-id="298ca-132">XAML では、「AddHandler」は暗黙的であり、イベントの関連付けは、すべてオブジェクト要素の属性名としてのイベントの名前付けと、属性値としてのハンドラーの名前付けで構成されています。</span><span class="sxs-lookup"><span data-stu-id="298ca-132">In XAML, the "AddHandler" is implicit, and event wiring consists entirely of naming the event as the attribute name of an object element, and naming the handler as that attribute's value.</span></span>

<span data-ttu-id="298ca-133">実際のハンドラーは、アプリのすべてのコードとコード ビハインドで使っているプログラミング言語で記述します。</span><span class="sxs-lookup"><span data-stu-id="298ca-133">You write the actual handler in the programming language that you're using for all your app's code and code-behind.</span></span> <span data-ttu-id="298ca-134">ここでは、`Click="ShowUpdatesButton_Click"` という属性を使ってコントラクトを作成しています。このコントラクトにより、XAML のマークアップ コンパイルと解析の際に、IDE のビルド アクションの XAML マークアップ コンパイル ステップと、アプリの読み込み時の最終的な XAML の解析で、`ShowUpdatesButton_Click` という名前のメソッドをアプリのコードの中から検出できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-134">With the attribute `Click="ShowUpdatesButton_Click"`, you have created a contract that when the XAML is markup-compiled and parsed, both the XAML markup compile step in your IDE's build action and the eventual XAML parse when the app loads can find a method named `ShowUpdatesButton_Click` as part of the app's code.</span></span> <span data-ttu-id="298ca-135">`ShowUpdatesButton_Click` は、[**Click**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) イベントのすべてのハンドラーに対応したメソッド シグネチャを (デリゲートに基づいて) 実装するメソッドであることが必要です。</span><span class="sxs-lookup"><span data-stu-id="298ca-135">`ShowUpdatesButton_Click` must be a method that implements a compatible method signature (based on a delegate) for any handler of the [**Click**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) event.</span></span> <span data-ttu-id="298ca-136">たとえば、次のコードは `ShowUpdatesButton_Click` ハンドラーを定義します。</span><span class="sxs-lookup"><span data-stu-id="298ca-136">For example, this code defines the `ShowUpdatesButton_Click` handler.</span></span>

```csharp
private void ShowUpdatesButton_Click (object sender, RoutedEventArgs e) 
{
    Button b = sender as Button;
    //more logic to do here...
}
```

```vb
Private Sub ShowUpdatesButton_Click(ByVal sender As Object, ByVal e As RoutedEventArgs)
    Dim b As Button = CType(sender, Button)
    '  more logic to do here...
End Sub
```

```cppwinrt
void winrt::MyNamespace::implementation::BlankPage::ShowUpdatesButton_Click(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::RoutedEventArgs const& e)
{
    auto b{ sender.as<Windows::UI::Xaml::Controls::Button>() };
    // More logic to do here.
}
```

```cpp
void MyNamespace::BlankPage::ShowUpdatesButton_Click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e) 
{
    Button^ b = (Button^) sender;
    //more logic to do here...
}
```

<span data-ttu-id="298ca-137">この例では、`ShowUpdatesButton_Click` メソッドは [**RoutedEventHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.routedeventhandler) デリゲートに基づいています。</span><span class="sxs-lookup"><span data-stu-id="298ca-137">In this example, the `ShowUpdatesButton_Click` method is based on the [**RoutedEventHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.routedeventhandler) delegate.</span></span> <span data-ttu-id="298ca-138">MSDN のリファレンス ページで、[**Click**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) メソッドの構文にこのデリゲートが指定されているため、このデリゲートを使います。</span><span class="sxs-lookup"><span data-stu-id="298ca-138">You'd know that this is the delegate to use because you'll see that delegate named in the syntax for the [**Click**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) method on the MSDN reference page.</span></span>

<span data-ttu-id="298ca-139">**ヒント:**   Visual Studio には、イベント ハンドラーの名前を指定し、XAML を編集すると、ハンドラー メソッドを定義する便利な方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="298ca-139">**Tip**  Visual Studio provides a convenient way to name the event handler and define the handler method while you're editing XAML.</span></span> <span data-ttu-id="298ca-140">XAML テキスト エディターでイベントの属性名を入力する際には、Microsoft IntelliSense リストが表示されるまで少し待ってください。</span><span class="sxs-lookup"><span data-stu-id="298ca-140">When you provide the attribute name of the event in the XAML text editor, wait a moment until a Microsoft IntelliSense list displays.</span></span> <span data-ttu-id="298ca-141">リストの **[&lt;新しいイベント ハンドラー&gt;]** をクリックすると、要素の **x:Name** (または型名) に基づいて、メソッド名、イベント名、数値サフィックスの候補が表示されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-141">If you click **&lt;New Event Handler&gt;** from the list, Microsoft Visual Studio will suggest a method name based on the element's **x:Name** (or type name), the event name, and a numeric suffix.</span></span> <span data-ttu-id="298ca-142">その後、選択したイベント ハンドラー名を右クリックし、 **[イベント ハンドラーへ移動]** をクリックできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-142">You can then right-click the selected event handler name and click **Navigate to Event Handler**.</span></span> <span data-ttu-id="298ca-143">そうすると、新たに挿入されたイベント ハンドラー定義に直接移動します。これは、XAML ページのコード ビハインド ファイルのコード エディター ビューで確認できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-143">This will navigate directly to the newly inserted event handler definition, as seen in the code editor view of your code-behind file for the XAML page.</span></span> <span data-ttu-id="298ca-144">イベント ハンドラーには既に正しいシグネチャが設定されています (*sender* パラメーターや、イベントが使う特定のイベント データ クラスなど)。</span><span class="sxs-lookup"><span data-stu-id="298ca-144">The event handler already has the correct signature, including the *sender* parameter and the event data class that the event uses.</span></span> <span data-ttu-id="298ca-145">また、正しいシグネチャを持つハンドラー メソッドが既にコード ビハインド内に存在する場合は、メソッドの名前が **[&lt;新しいイベント ハンドラー&gt;]** オプションと共にオート コンプリート ドロップダウンに表示されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-145">Also, if a handler method with the correct signature already exists in your code-behind, that method's name appears in the auto-complete drop-down along with the **&lt;New Event Handler&gt;** option.</span></span> <span data-ttu-id="298ca-146">また、IntelliSense のリスト項目をクリックする代わりに、ショートカットとして Tab キーを押すこともできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-146">You can also press the Tab key as a shortcut instead of clicking the IntelliSense list items.</span></span>

## <a name="defining-an-event-handler"></a><span data-ttu-id="298ca-147">イベント ハンドラーの定義</span><span class="sxs-lookup"><span data-stu-id="298ca-147">Defining an event handler</span></span>

<span data-ttu-id="298ca-148">オブジェクトが UI 要素であり、XAML で宣言される場合、イベント ハンドラー コードは、XAML ページのコード ビハインドとなる部分クラスに定義します。</span><span class="sxs-lookup"><span data-stu-id="298ca-148">For objects that are UI elements and declared in XAML, event handler code is defined in the partial class that serves as the code-behind for a XAML page.</span></span> <span data-ttu-id="298ca-149">イベント ハンドラーは、XAML に関連付けられた部分クラスの一部として記述するメソッドです。</span><span class="sxs-lookup"><span data-stu-id="298ca-149">Event handlers are methods that you write as part of the partial class that is associated with your XAML.</span></span> <span data-ttu-id="298ca-150">これらのイベント ハンドラーは、特定のイベントが使用するデリゲートに基づきます。</span><span class="sxs-lookup"><span data-stu-id="298ca-150">These event handlers are based on the delegates that a particular event uses.</span></span> <span data-ttu-id="298ca-151">イベント ハンドラー メソッドは、public と private のどちらでもかまいません。</span><span class="sxs-lookup"><span data-stu-id="298ca-151">Your event handler methods can be public or private.</span></span> <span data-ttu-id="298ca-152">アクセス レベルを private に設定できるのは、XAML によって作成されるハンドラーとインスタンスが最終的にコード生成によって結合されるためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-152">Private access works because the handler and instance created by the XAML are ultimately joined by code generation.</span></span> <span data-ttu-id="298ca-153">通常は、イベント ハンドラー メソッドをクラス内で private にすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="298ca-153">In general, we recommend that you make your event handler methods private in the class.</span></span>

<span data-ttu-id="298ca-154">**注**  C++ 用のイベント ハンドラーは、部分クラスで定義を取得しない、プライベート クラス メンバーとして、ヘッダーで宣言されています。</span><span class="sxs-lookup"><span data-stu-id="298ca-154">**Note**  Event handlers for C++ don't get defined in partial classes, they are declared in the header as a private class member.</span></span> <span data-ttu-id="298ca-155">C++ プロジェクトのビルド アクションでは、XAML の型システムと C++ のコード ビハインド モデルをサポートするコードが生成されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-155">The build actions for a C++ project take care of generating code that supports the XAML type system and code-behind model for C++.</span></span>

### <a name="the-sender-parameter-and-event-data"></a><span data-ttu-id="298ca-156">*sender* パラメーターとイベント データ</span><span class="sxs-lookup"><span data-stu-id="298ca-156">The *sender* parameter and event data</span></span>

<span data-ttu-id="298ca-157">イベント用に記述したハンドラーは、そのハンドラーが呼び出された際に、その都度入力として使える 2 つの値にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-157">The handler you write for the event can access two values that are available as input for each case where your handler is invoked.</span></span> <span data-ttu-id="298ca-158">その最初の値が *sender* です。これは、ハンドラーがアタッチされているオブジェクトへの参照です。</span><span class="sxs-lookup"><span data-stu-id="298ca-158">The first such value is *sender*, which is a reference to the object where the handler is attached.</span></span> <span data-ttu-id="298ca-159">*sender* パラメーターは、**Object** 基本型として型指定されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-159">The *sender* parameter is typed as the base **Object** type.</span></span> <span data-ttu-id="298ca-160">*sender* をより正確な型にキャストするという手法がよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-160">A common technique is to cast *sender* to a more precise type.</span></span> <span data-ttu-id="298ca-161">この手法は、*sender* オブジェクト自体で状態を確認または変更する必要がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="298ca-161">This technique is useful if you expect to check or change state on the *sender* object itself.</span></span> <span data-ttu-id="298ca-162">通常は、それぞれのアプリ設計に基づき、*sender* のキャスト先として安全な型をハンドラーのアタッチ先やその他の設計の情報を基に把握します。</span><span class="sxs-lookup"><span data-stu-id="298ca-162">Based on your own app design, you usually know a type that is safe to cast *sender* to, based on where the handler is attached or other design specifics.</span></span>

<span data-ttu-id="298ca-163">2 つ目の値はイベント データです。これは通常、*e* パラメーターとして構文の定義に表示されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-163">The second value is event data, which generally appears in syntax definitions as the *e* parameter.</span></span> <span data-ttu-id="298ca-164">使用できるイベント データのプロパティを見つけるには、処理対象のイベントに割り当てられているデリゲートの *e* パラメーターを参照した後、Visual Studio の IntelliSense かオブジェクト ブラウザーを使います。</span><span class="sxs-lookup"><span data-stu-id="298ca-164">You can discover which properties for event data are available by looking at the *e* parameter of the delegate that is assigned for the specific event you are handling, and then using IntelliSense or Object Browser in Visual Studio.</span></span> <span data-ttu-id="298ca-165">Windows ランタイム リファレンス ドキュメントを使うこともできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-165">Or you can use the Windows Runtime reference documentation.</span></span>

<span data-ttu-id="298ca-166">イベントによっては、イベントの発生を検知することと同様にイベント データの特定のプロパティ値が重要となります。</span><span class="sxs-lookup"><span data-stu-id="298ca-166">For some events, the event data's specific property values are as important as knowing that the event occurred.</span></span> <span data-ttu-id="298ca-167">これが特に当てはまるのが入力イベントです。</span><span class="sxs-lookup"><span data-stu-id="298ca-167">This is especially true of the input events.</span></span> <span data-ttu-id="298ca-168">ポインター イベントの場合は、イベントが発生したときのポインターの位置が重要です。</span><span class="sxs-lookup"><span data-stu-id="298ca-168">For pointer events, the position of the pointer when the event occurred might be important.</span></span> <span data-ttu-id="298ca-169">キーボード イベントの場合、キーボード上のいずれのキーが押されても [**KeyDown**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keydown) イベントと [**KeyUp**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keyup) イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="298ca-169">For keyboard events, all possible key presses fire a [**KeyDown**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keydown) and [**KeyUp**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keyup) event.</span></span> <span data-ttu-id="298ca-170">ユーザーがどのキーを押したかを判定するには、イベント ハンドラーで使うことができる [**KeyRoutedEventArgs**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Input.KeyRoutedEventArgs) にアクセスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-170">To determine which key a user pressed, you must access the [**KeyRoutedEventArgs**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Input.KeyRoutedEventArgs) that is available to the event handler.</span></span> <span data-ttu-id="298ca-171">入力イベントの処理について詳しくは、「[キーボード操作](https://docs.microsoft.com/windows/uwp/input-and-devices/keyboard-interactions)」と「[ポインター入力の処理](https://docs.microsoft.com/windows/uwp/input-and-devices/handle-pointer-input)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-171">For more info about handling input events, see [Keyboard interactions](https://docs.microsoft.com/windows/uwp/input-and-devices/keyboard-interactions) and [Handle pointer input](https://docs.microsoft.com/windows/uwp/input-and-devices/handle-pointer-input).</span></span> <span data-ttu-id="298ca-172">入力イベントと入力シナリオに対処するには、通常、ポインター イベントのポインター キャプチャや、キーボード イベントの修飾キーとプラットフォーム キー コードなど、このトピックで取り上げていない事柄についても考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-172">Input events and input scenarios often have additional considerations that are not covered in this topic, such as pointer capture for pointer events, and modifier keys and platform key codes for keyboard events.</span></span>

### <a name="event-handlers-that-use-the-async-pattern"></a><span data-ttu-id="298ca-173">**async** パターンを使うイベント ハンドラー</span><span class="sxs-lookup"><span data-stu-id="298ca-173">Event handlers that use the **async** pattern</span></span>

<span data-ttu-id="298ca-174">ときには、イベント ハンドラー内で **async** パターンを使う API を使う必要が生じることもあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-174">In some cases you'll want to use APIs that use an **async** pattern within an event handler.</span></span> <span data-ttu-id="298ca-175">たとえば、ファイル ピッカーを表示して操作するには、[**AppBar**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.AppBar) で [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) を使います。</span><span class="sxs-lookup"><span data-stu-id="298ca-175">For example, you might use a [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) in an [**AppBar**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.AppBar) to display a file picker and interact with it.</span></span> <span data-ttu-id="298ca-176">ただし、ファイル ピッカー API の多くは非同期です。</span><span class="sxs-lookup"><span data-stu-id="298ca-176">However, many of the file picker APIs are asynchronous.</span></span> <span data-ttu-id="298ca-177">それらの API は **async**/awaitable スコープ内で呼び出す必要があります。これはコンパイラの要件になります。</span><span class="sxs-lookup"><span data-stu-id="298ca-177">They have to be called within an **async**/awaitable scope, and the compiler will enforce this.</span></span> <span data-ttu-id="298ca-178">追加するには何ができるように、 **async**イベント ハンドラーにキーワード、ハンドラーが今すぐ**非同期** **void**。</span><span class="sxs-lookup"><span data-stu-id="298ca-178">So what you can do is add the **async** keyword to your event handler such that the handler is now **async** **void**.</span></span> <span data-ttu-id="298ca-179">これで、イベント ハンドラーは **async**/awaitable での呼び出しが可能になります。</span><span class="sxs-lookup"><span data-stu-id="298ca-179">Now your event handler is permitted to make **async**/awaitable calls.</span></span>

<span data-ttu-id="298ca-180">**async** パターンを使ったユーザー操作イベントの処理の例については、「[ファイル アクセスとファイル ピッカー](https://docs.microsoft.com/previous-versions/windows/apps/jj655411(v=win.10))」(「[C# または Visual Basic を使った初めての Windows ランタイム アプリの作成](https://docs.microsoft.com/previous-versions/windows/apps/hh974581(v=win.10))」シリーズの一部) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-180">For an example of user-interaction event handling using the **async** pattern, see [File access and pickers](https://docs.microsoft.com/previous-versions/windows/apps/jj655411(v=win.10)) (part of the[Create your first Windows Runtime app using C# or Visual Basic](https://docs.microsoft.com/previous-versions/windows/apps/hh974581(v=win.10)) series).</span></span> <span data-ttu-id="298ca-181">「C での非同期 API の呼び出し」もご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-181">See also [Call asynchronous APIs in C).</span></span>

## <a name="adding-event-handlers-in-code"></a><span data-ttu-id="298ca-182">コードでのイベント ハンドラーの追加</span><span class="sxs-lookup"><span data-stu-id="298ca-182">Adding event handlers in code</span></span>

<span data-ttu-id="298ca-183">イベント ハンドラーをオブジェクトに割り当てる手段は、XAML 以外にもあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-183">XAML is not the only way to assign an event handler to an object.</span></span> <span data-ttu-id="298ca-184">イベント ハンドラーをコードで特定のオブジェクト (XAML では使用できないオブジェクトも含む) に追加するには、言語固有のイベント ハンドラー追加構文を使用します。</span><span class="sxs-lookup"><span data-stu-id="298ca-184">To add event handlers to any given object in code, including to objects that are not usable in XAML, you can use the language-specific syntax for adding event handlers.</span></span>

<span data-ttu-id="298ca-185">C# の構文では、`+=` 演算子を使用します。</span><span class="sxs-lookup"><span data-stu-id="298ca-185">In C#, the syntax is to use the `+=` operator.</span></span> <span data-ttu-id="298ca-186">演算子の右側でイベント ハンドラー メソッド名を参照することによって、ハンドラーを登録します。</span><span class="sxs-lookup"><span data-stu-id="298ca-186">You register the handler by referencing the event handler method name on the right side of the operator.</span></span>

<span data-ttu-id="298ca-187">ランタイム UI に表示されるオブジェクトにイベント ハンドラーをコードで追加する場合、[**Loaded**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.loaded) や [**OnApplyTemplate**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.onapplytemplate) など、オブジェクトの有効期間イベントまたはコールバックに応じてハンドラーを追加するのが一般的です。これにより、該当するオブジェクトのイベント ハンドラーは、実行時にユーザーが発生させるイベントに対応できるようになります。</span><span class="sxs-lookup"><span data-stu-id="298ca-187">If you use code to add event handlers to objects that appear in the run-time UI, a common practice is to add such handlers in response to an object lifetime event or callback, such as [**Loaded**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.loaded) or [**OnApplyTemplate**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.onapplytemplate), so that the event handlers on the relevant object are ready for user-initiated events at run time.</span></span> <span data-ttu-id="298ca-188">次の例は、ページ構造の XAML の概略と、イベント ハンドラーをオブジェクトに追加するための C# 言語の構文を示しています。</span><span class="sxs-lookup"><span data-stu-id="298ca-188">This example shows a XAML outline of the page structure and then provides the C# language syntax for adding an event handler to an object.</span></span>

```xaml
<Grid x:Name="LayoutRoot" Loaded="LayoutRoot_Loaded">
  <StackPanel>
    <TextBlock Name="textBlock1">Put the pointer over this text</TextBlock>
...
  </StackPanel>
</Grid>
```

```csharp
void LayoutRoot_Loaded(object sender, RoutedEventArgs e)
{
    textBlock1.PointerEntered += textBlock1_PointerEntered;
    textBlock1.PointerExited += textBlock1_PointerExited;
}
```

<span data-ttu-id="298ca-189">**注**  より詳細な構文が存在します。</span><span class="sxs-lookup"><span data-stu-id="298ca-189">**Note**  A more verbose syntax exists.</span></span> <span data-ttu-id="298ca-190">2005 年に、コンパイラで新しいデリゲート インスタンスを推論できるようにするデリゲートの推論という機能が C# に追加されて、上のより単純な形式の構文を使えるようになりました。</span><span class="sxs-lookup"><span data-stu-id="298ca-190">In 2005, C# added a feature called delegate inference, which enables a compiler to infer the new delegate instance and enables the previous, simpler syntax.</span></span> <span data-ttu-id="298ca-191">冗長な構文は、機能的には上の例と同じですが、新しいデリゲート インスタンスを登録する前に明示的に作成します。したがって、デリゲートの推論は使用されません。</span><span class="sxs-lookup"><span data-stu-id="298ca-191">The verbose syntax is functionally identical to the previous example, but explicitly creates a new delegate instance before registering it, thus not taking advantage of delegate inference.</span></span> <span data-ttu-id="298ca-192">この明示的な構文は、あまり一般的ではありませんが、コード例で使わることがあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-192">This explicit syntax is less common, but you might still see it in some code examples.</span></span>

```csharp
void LayoutRoot_Loaded(object sender, RoutedEventArgs e)
{
    textBlock1.PointerEntered += new PointerEventHandler(textBlock1_PointerEntered);
    textBlock1.PointerExited += new MouseEventHandler(textBlock1_PointerExited);
}
```

<span data-ttu-id="298ca-193">Visual Basic 構文の場合は 2 とおりの方法があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-193">There are two possibilities for Visual Basic syntax.</span></span> <span data-ttu-id="298ca-194">1 つは、C# 構文と同じように記述し、ハンドラーを直接インスタンスにアタッチする方法です。</span><span class="sxs-lookup"><span data-stu-id="298ca-194">One is to parallel the C# syntax and attach handlers directly to instances.</span></span> <span data-ttu-id="298ca-195">この場合は、**AddHandler** キーワードに加え、ハンドラー メソッド名を逆参照する **AddressOf** 演算子が必要です。</span><span class="sxs-lookup"><span data-stu-id="298ca-195">This requires the **AddHandler** keyword and also the **AddressOf** operator that dereferences the handler method name.</span></span>

<span data-ttu-id="298ca-196">もう 1 つは、イベント ハンドラーに **Handles** キーワードを指定するという方法です。</span><span class="sxs-lookup"><span data-stu-id="298ca-196">The other option for Visual Basic syntax is to use the **Handles** keyword on event handlers.</span></span> <span data-ttu-id="298ca-197">この方法は、読み込みの時点からオブジェクトの有効期間を通じてオブジェクト上にハンドラーが存在している必要がある場合に適しています。</span><span class="sxs-lookup"><span data-stu-id="298ca-197">This technique is appropriate for cases where handlers are expected to exist on objects at load time and persist throughout the object lifetime.</span></span> <span data-ttu-id="298ca-198">XAML に定義されたオブジェクトで **Handles** を使うには、**Name** / **x:Name** を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-198">Using **Handles** on an object that is defined in XAML requires that you provide a **Name** / **x:Name**.</span></span> <span data-ttu-id="298ca-199">この名前は、**Handles** 構文の *Instance.Event* 部分に必要なインスタンス修飾子となります。</span><span class="sxs-lookup"><span data-stu-id="298ca-199">This name becomes the instance qualifier that is needed for the *Instance.Event* part of the **Handles** syntax.</span></span> <span data-ttu-id="298ca-200">この場合は、他のイベント ハンドラーのアタッチを開始する、オブジェクトの有効期間に基づくイベント ハンドラーは不要です。**Handles** の関連付けは、XAML ページのコンパイル時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-200">In this case you don't need an object lifetime-based event handler to initiate attaching the other event handlers; the **Handles** connections are created when you compile your XAML page.</span></span>

```vb
Private Sub textBlock1_PointerEntered(ByVal sender As Object, ByVal e As PointerRoutedEventArgs) Handles textBlock1.PointerEntered
' ...
End Sub
```

<span data-ttu-id="298ca-201">**注**  昇格の代わりにインスタンス処理手法が一般に Visual Studio およびその XAML デザイン画面、**処理**キーワード。</span><span class="sxs-lookup"><span data-stu-id="298ca-201">**Note**  Visual Studio and its XAML design surface generally promote the instance-handling technique instead of the **Handles** keyword.</span></span> <span data-ttu-id="298ca-202">その理由は、XAML でのイベント ハンドラーの関連付けがデザイナーと開発者が対処する一般的なワークフローに含まれるだけでなく、**Handles** キーワードを使用する手法に XAML でのイベント ハンドラーの関連付けとの互換性がないためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-202">This is because establishing the event handler wiring in XAML is part of typical designer-developer workflow, and the **Handles** keyword technique is incompatible with wiring the event handlers in XAML.</span></span>

<span data-ttu-id="298ca-203">C++/cli CX、使用することも、 **+=** 構文基本的なから違いがありますが、C#フォーム。</span><span class="sxs-lookup"><span data-stu-id="298ca-203">In C++/CX, you also use the **+=** syntax, but there are differences from the basic C# form:</span></span>

- <span data-ttu-id="298ca-204">デリゲートの推論は行われないため、**ref new** でデリゲート インスタンスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-204">No delegate inference exists, so you must use **ref new** for the delegate instance.</span></span>
- <span data-ttu-id="298ca-205">デリゲート コンストラクターにパラメーターが 2 つあり、最初のパラメーターでターゲット オブジェクトを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-205">The delegate constructor has two parameters, and requires the target object as the first parameter.</span></span> <span data-ttu-id="298ca-206">通常は **this** を指定します。</span><span class="sxs-lookup"><span data-stu-id="298ca-206">Typically you specify **this**.</span></span>
- <span data-ttu-id="298ca-207">デリゲート コンストラクターの 2 番目のパラメーターにはメソッドのアドレスを指定する必要があるため、メソッド名の前に **&** 参照演算子を付けます。</span><span class="sxs-lookup"><span data-stu-id="298ca-207">The delegate constructor requires the method address as the second parameter, so the **&** reference operator precedes the method name.</span></span>

```cppwinrt
textBlock1().PointerEntered({this, &MainPage::TextBlock1_PointerEntered });
```

```cpp
textBlock1->PointerEntered += 
ref new PointerEventHandler(this, &BlankPage::textBlock1_PointerEntered);
```

### <a name="removing-event-handlers-in-code"></a><span data-ttu-id="298ca-208">コードでのイベント ハンドラーの削除</span><span class="sxs-lookup"><span data-stu-id="298ca-208">Removing event handlers in code</span></span>

<span data-ttu-id="298ca-209">イベント ハンドラーをコードで追加した場合であっても、通常はコード内のイベント ハンドラーを削除する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="298ca-209">It's not usually necessary to remove event handlers in code, even if you added them in code.</span></span> <span data-ttu-id="298ca-210">ページやコントロールなど、ほとんどの Windows ランタイム オブジェクトには、その有効期間の動作として、メインの [**Window**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Window) とそのビジュアル ツリーから切断されると破棄されるという動作が備わっています。また、デリゲート参照がある場合には、それも破棄されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-210">The object lifetime behavior for most Windows Runtime objects such as pages and controls will destroy the objects when they are disconnected from the main [**Window**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Window) and its visual tree, and any delegate references are destroyed too.</span></span> <span data-ttu-id="298ca-211">これには、.NET であればガベージ コレクション、C++/CX を備えた Windows ランタイムであれば弱参照が、それぞれ既定で使われます。</span><span class="sxs-lookup"><span data-stu-id="298ca-211">.NET does this through garbage collection and Windows Runtime with C++/CX uses weak references by default.</span></span>

<span data-ttu-id="298ca-212">まれに、イベント ハンドラーを明示的に削除する必要が生じることがあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-212">There are some rare cases where you do want to remove event handlers explicitly.</span></span> <span data-ttu-id="298ca-213">次のようなクラスがあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-213">These include:</span></span>

- <span data-ttu-id="298ca-214">静的イベントのためにハンドラーを追加したものの、従来の方法でガベージ コレクションを実行できない。</span><span class="sxs-lookup"><span data-stu-id="298ca-214">Handlers you added for static events, which can't get garbage-collected in a conventional way.</span></span> <span data-ttu-id="298ca-215">Windows ランタイム API の静的イベントの例は、[**CompositionTarget**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.CompositionTarget) クラスと [**Clipboard**](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.DataTransfer.Clipboard) クラスのイベントです。</span><span class="sxs-lookup"><span data-stu-id="298ca-215">Examples of static events in the Windows Runtime API are the events of the [**CompositionTarget**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.CompositionTarget) and [**Clipboard**](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.DataTransfer.Clipboard) classes.</span></span>
- <span data-ttu-id="298ca-216">テスト コードでハンドラーの削除のタイミングを即時にする必要がある、またはコードで実行時にイベントの古いイベント ハンドラーを新しいものに置き換える必要がある。</span><span class="sxs-lookup"><span data-stu-id="298ca-216">Test code where you want the timing of handler removal to be immediate, or code where you what to swap old/new event handlers for an event at run time.</span></span>
- <span data-ttu-id="298ca-217">カスタム **remove** アクセサーを実装する。</span><span class="sxs-lookup"><span data-stu-id="298ca-217">The implementation of a custom **remove** accessor.</span></span>
- <span data-ttu-id="298ca-218">カスタム静的イベント。</span><span class="sxs-lookup"><span data-stu-id="298ca-218">Custom static events.</span></span>
- <span data-ttu-id="298ca-219">ページ ナビゲーションのハンドラー。</span><span class="sxs-lookup"><span data-stu-id="298ca-219">Handlers for page navigations.</span></span>

<span data-ttu-id="298ca-220">[**FrameworkElement.Unloaded** ](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.unloaded)または[ **Page.NavigatedFrom** ](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.page.onnavigatedfrom)状態管理とオブジェクト有効期間中にこのような適切な位置がある可能性のあるイベントのトリガー他のイベント ハンドラーを削除するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-220">[**FrameworkElement.Unloaded**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.unloaded) or [**Page.NavigatedFrom**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.page.onnavigatedfrom) are possible event triggers that have appropriate positions in state management and object lifetime such that you can use them for removing handlers for other events.</span></span>

<span data-ttu-id="298ca-221">名前付きイベント ハンドラーを削除するなど、 **textBlock1\_PointerEntered**ターゲット オブジェクトから**textBlock1**このコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="298ca-221">For example, you can remove an event handler named **textBlock1\_PointerEntered** from the target object **textBlock1** using this code.</span></span>

```csharp
textBlock1.PointerEntered -= textBlock1_PointerEntered;
```

```vb
RemoveHandler textBlock1.PointerEntered, AddressOf textBlock1_PointerEntered
```

<span data-ttu-id="298ca-222">また、XAML 属性によってイベントが追加された場合 (つまり、生成されたコードにハンドラーが追加された場合) にも、ハンドラーを削除できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-222">You can also remove handlers for cases where the event was added through a XAML attribute, which means that the handler was added in generated code.</span></span> <span data-ttu-id="298ca-223">ハンドラーがアタッチされた要素に **Name** 値を指定した場合には、後でコードにオブジェクト参照が設定されるため、こちらの方法の方が簡単です。ただし、オブジェクトに **Name** がない場合は、必要なオブジェクト参照を探すにあたって、オブジェクト ツリーを辿るという方法もあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-223">This is easier to do if you provided a **Name** value for the element where the handler was attached, because that provides an object reference for code later; however, you could also walk the object tree in order to find the necessary object reference in cases where the object has no **Name**.</span></span>

<span data-ttu-id="298ca-224">C++/CX でイベント ハンドラーを削除する場合には、登録トークンが必要です。このトークンは、`+=` イベント ハンドラー登録の戻り値から受け取ります。</span><span class="sxs-lookup"><span data-stu-id="298ca-224">If you need to remove an event handler in C++/CX, you'll need a registration token, which you should've received from the return value of the `+=` event handler registration.</span></span> <span data-ttu-id="298ca-225">メソッド名ではなく、C++/CX の構文で `-=` 登録解除の右側に使われる値がトークンであるためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-225">That's because the value you use for the right side of the `-=` deregistration in the C++/CX syntax is the token, not the method name.</span></span> <span data-ttu-id="298ca-226">C++/CX で生成されたコードではトークンが保存されないため、C++/CX では、XAML 属性として追加されたハンドラーを削除できません。</span><span class="sxs-lookup"><span data-stu-id="298ca-226">For C++/CX, you can't remove handlers that were added as a XAML attribute because the C++/CX generated code doesn't save a token.</span></span>

## <a name="routed-events"></a><span data-ttu-id="298ca-227">ルーティング イベント</span><span class="sxs-lookup"><span data-stu-id="298ca-227">Routed events</span></span>

<span data-ttu-id="298ca-228">Windows ランタイムと C#、Microsoft Visual Basic、または C++/CX では、ほとんどの UI 要素に存在する一連のイベントのルーティング イベントの概念がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="298ca-228">The Windows Runtime with C#, Microsoft Visual Basic or C++/CX supports the concept of a routed event for a set of events that are present on most UI elements.</span></span> <span data-ttu-id="298ca-229">これらのイベントは、入力やユーザー操作のシナリオ用であり、[**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) 基底クラスに実装されています。</span><span class="sxs-lookup"><span data-stu-id="298ca-229">These events are for input and user interaction scenarios, and they are implemented on the [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) base class.</span></span> <span data-ttu-id="298ca-230">ルーティング イベントである入力イベントの一覧を次に示します。</span><span class="sxs-lookup"><span data-stu-id="298ca-230">Here's a list of input events that are routed events:</span></span>

- [<span data-ttu-id="298ca-231">**BringIntoViewRequested**</span><span class="sxs-lookup"><span data-stu-id="298ca-231">**BringIntoViewRequested**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.bringintoviewrequested)
- [<span data-ttu-id="298ca-232">**CharacterReceived**</span><span class="sxs-lookup"><span data-stu-id="298ca-232">**CharacterReceived**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.characterreceived)
- [<span data-ttu-id="298ca-233">**ContextCanceled**</span><span class="sxs-lookup"><span data-stu-id="298ca-233">**ContextCanceled**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.contextcanceled)
- [<span data-ttu-id="298ca-234">**ContextRequested**</span><span class="sxs-lookup"><span data-stu-id="298ca-234">**ContextRequested**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.contextrequested)
- [<span data-ttu-id="298ca-235">**DoubleTapped**</span><span class="sxs-lookup"><span data-stu-id="298ca-235">**DoubleTapped**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.doubletapped)
- [<span data-ttu-id="298ca-236">**DragEnter**</span><span class="sxs-lookup"><span data-stu-id="298ca-236">**DragEnter**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragenter)
- [<span data-ttu-id="298ca-237">**DragLeave**</span><span class="sxs-lookup"><span data-stu-id="298ca-237">**DragLeave**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragleave)
- [<span data-ttu-id="298ca-238">**DragOver**</span><span class="sxs-lookup"><span data-stu-id="298ca-238">**DragOver**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragover)
- [<span data-ttu-id="298ca-239">**DragStarting**</span><span class="sxs-lookup"><span data-stu-id="298ca-239">**DragStarting**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragstarting)
- [<span data-ttu-id="298ca-240">**ドロップ**</span><span class="sxs-lookup"><span data-stu-id="298ca-240">**Drop**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.drop)
- [<span data-ttu-id="298ca-241">**DropCompleted**</span><span class="sxs-lookup"><span data-stu-id="298ca-241">**DropCompleted**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dropcompleted)
- [<span data-ttu-id="298ca-242">**GettingFocus**</span><span class="sxs-lookup"><span data-stu-id="298ca-242">**GettingFocus**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gettingfocus)
- [<span data-ttu-id="298ca-243">**GotFocus**</span><span class="sxs-lookup"><span data-stu-id="298ca-243">**GotFocus**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gotfocus)
- [<span data-ttu-id="298ca-244">**保持します。** </span><span class="sxs-lookup"><span data-stu-id="298ca-244">**Holding**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.holding)
- [<span data-ttu-id="298ca-245">**KeyDown**</span><span class="sxs-lookup"><span data-stu-id="298ca-245">**KeyDown**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keydown)
- [<span data-ttu-id="298ca-246">**KeyUp**</span><span class="sxs-lookup"><span data-stu-id="298ca-246">**KeyUp**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keyup)
- [<span data-ttu-id="298ca-247">**LosingFocus**</span><span class="sxs-lookup"><span data-stu-id="298ca-247">**LosingFocus**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.losingfocus)
- [<span data-ttu-id="298ca-248">**LostFocus**</span><span class="sxs-lookup"><span data-stu-id="298ca-248">**LostFocus**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.lostfocus)
- [<span data-ttu-id="298ca-249">**ManipulationCompleted**</span><span class="sxs-lookup"><span data-stu-id="298ca-249">**ManipulationCompleted**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationcompleted)
- [<span data-ttu-id="298ca-250">**ManipulationDelta**</span><span class="sxs-lookup"><span data-stu-id="298ca-250">**ManipulationDelta**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationdelta)
- [<span data-ttu-id="298ca-251">**ManipulationInertiaStarting**</span><span class="sxs-lookup"><span data-stu-id="298ca-251">**ManipulationInertiaStarting**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationinertiastarting)
- [<span data-ttu-id="298ca-252">**ManipulationStarted**</span><span class="sxs-lookup"><span data-stu-id="298ca-252">**ManipulationStarted**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationstarted)
- [<span data-ttu-id="298ca-253">**ManipulationStarting**</span><span class="sxs-lookup"><span data-stu-id="298ca-253">**ManipulationStarting**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationstarting)
- [<span data-ttu-id="298ca-254">**NoFocusCandidateFound**</span><span class="sxs-lookup"><span data-stu-id="298ca-254">**NoFocusCandidateFound**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.nofocuscandidatefoundeventargs)
- [<span data-ttu-id="298ca-255">**PointerCanceled**</span><span class="sxs-lookup"><span data-stu-id="298ca-255">**PointerCanceled**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointercanceled)
- [<span data-ttu-id="298ca-256">**PointerCaptureLost**</span><span class="sxs-lookup"><span data-stu-id="298ca-256">**PointerCaptureLost**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointercapturelost)
- [<span data-ttu-id="298ca-257">**PointerEntered**</span><span class="sxs-lookup"><span data-stu-id="298ca-257">**PointerEntered**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerentered)
- [<span data-ttu-id="298ca-258">**PointerExited**</span><span class="sxs-lookup"><span data-stu-id="298ca-258">**PointerExited**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerexited)
- [<span data-ttu-id="298ca-259">**PointerMoved**</span><span class="sxs-lookup"><span data-stu-id="298ca-259">**PointerMoved**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointermoved)
- [<span data-ttu-id="298ca-260">**PointerPressed**</span><span class="sxs-lookup"><span data-stu-id="298ca-260">**PointerPressed**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerpressed)
- [<span data-ttu-id="298ca-261">**PointerReleased**</span><span class="sxs-lookup"><span data-stu-id="298ca-261">**PointerReleased**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerreleased)
- [<span data-ttu-id="298ca-262">**PointerWheelChanged**</span><span class="sxs-lookup"><span data-stu-id="298ca-262">**PointerWheelChanged**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerwheelchanged)
- [<span data-ttu-id="298ca-263">**PreviewKeyDown**</span><span class="sxs-lookup"><span data-stu-id="298ca-263">**PreviewKeyDown**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.previewkeydown.md)
- [<span data-ttu-id="298ca-264">**PreviewKeyUp**</span><span class="sxs-lookup"><span data-stu-id="298ca-264">**PreviewKeyUp**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.previewkeyup.md)
- [<span data-ttu-id="298ca-265">**PointerWheelChanged**</span><span class="sxs-lookup"><span data-stu-id="298ca-265">**PointerWheelChanged**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerwheelchanged)
- [<span data-ttu-id="298ca-266">**RightTapped**</span><span class="sxs-lookup"><span data-stu-id="298ca-266">**RightTapped**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.righttapped)
- [<span data-ttu-id="298ca-267">**タップ**</span><span class="sxs-lookup"><span data-stu-id="298ca-267">**Tapped**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.tapped)

<span data-ttu-id="298ca-268">ルーティング イベントとは、オブジェクト ツリーの子オブジェクトから渡され (*ルーティング*され)、一連の親オブジェクトまでルーティングされる可能性のあるイベントのことです。</span><span class="sxs-lookup"><span data-stu-id="298ca-268">A routed event is an event that is potentially passed on (*routed*) from a child object to each of its successive parent objects in an object tree.</span></span> <span data-ttu-id="298ca-269">UI の XAML 構造はこのツリーに類似した構造となり、このツリーのルートは XAML におけるルート要素に相当します。</span><span class="sxs-lookup"><span data-stu-id="298ca-269">The XAML structure of your UI approximates this tree, with the root of that tree being the root element in XAML.</span></span> <span data-ttu-id="298ca-270">実際のオブジェクト ツリーは、プロパティ要素タグなどの XAML 言語機能が含まれていないので、XAML 要素のネスト構造とはやや異なります。</span><span class="sxs-lookup"><span data-stu-id="298ca-270">The true object tree might vary somewhat from the XAML element nesting, because the object tree doesn't include XAML language features such as property element tags.</span></span> <span data-ttu-id="298ca-271">ルーティング イベントは、イベント発生元の XAML オブジェクト子要素からその親オブジェクト要素へと*バブル* ルーティングされるイベントと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="298ca-271">You can conceive of the routed event as *bubbling* from any XAML object element child element that fires the event, toward the parent object element that contains it.</span></span> <span data-ttu-id="298ca-272">イベントとそのイベント データはイベント ルートをたどって複数のオブジェクトで処理される場合があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-272">The event and its event data can be handled on multiple objects along the event route.</span></span> <span data-ttu-id="298ca-273">どの要素にもハンドラーがない場合は、ルート要素に達するまでイベント ルートをたどっていくことになります。</span><span class="sxs-lookup"><span data-stu-id="298ca-273">If no element has handlers, the route potentially keeps going until the root element is reached.</span></span>

<span data-ttu-id="298ca-274">ダイナミック HTML (DHTML) や HTML5 などの Web テクノロジについて知識がある場合は、既に*バブル* イベントの概念をご存じかもしれません。</span><span class="sxs-lookup"><span data-stu-id="298ca-274">If you know Web technologies such as Dynamic HTML (DHTML) or HTML5, you might already be familiar with the *bubbling* event concept.</span></span>

<span data-ttu-id="298ca-275">ルーティング イベントがイベント ルートをたどってバブル ルーティングされるとき、アタッチされたすべてのイベント ハンドラーはイベント データのインスタンスを共有し、同じインスタンスにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="298ca-275">When a routed event bubbles through its event route, any attached event handlers all access a shared instance of event data.</span></span> <span data-ttu-id="298ca-276">したがって、ハンドラーによる書き込みが可能なイベント データがある場合は、イベント データが変更されると変更後のイベント データが次のハンドラーに渡されるため、そのイベントの元のイベント データを表さなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-276">Therefore, if any of the event data is writeable by a handler, any changes made to event data will be passed on to the next handler, and may no longer represent the original event data from the event.</span></span> <span data-ttu-id="298ca-277">ルーティング イベントの動作を持つイベントは、リファレンス ドキュメントにルーティング動作に関する注釈が含まれています。</span><span class="sxs-lookup"><span data-stu-id="298ca-277">When an event has a routed event behavior, the reference documentation will include remarks or other notations about the routed behavior.</span></span>

### <a name="the-originalsource-property-of-routedeventargs"></a><span data-ttu-id="298ca-278">**RoutedEventArgs** の **OriginalSource** プロパティ</span><span class="sxs-lookup"><span data-stu-id="298ca-278">The **OriginalSource** property of **RoutedEventArgs**</span></span>

<span data-ttu-id="298ca-279">イベントがバブル ルーティングによって移動すると、*sender* はイベントが発生したオブジェクトと同じものではなくなります。</span><span class="sxs-lookup"><span data-stu-id="298ca-279">When an event bubbles up an event route, *sender* is no longer the same object as the event-raising object.</span></span> <span data-ttu-id="298ca-280">*sender* は、呼び出されたハンドラーがアタッチされているオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="298ca-280">Instead, *sender* is the object where the handler that is being invoked is attached.</span></span>

<span data-ttu-id="298ca-281">場合によっては、注目されるのは *sender* ではなく、ポインター イベントが発生したときにどの子オブジェクトにポインターが置かれているかや、ユーザーがキーボードのキーを押したときに上位の UI のどのオブジェクトにフォーカスがあったかなどの情報です。</span><span class="sxs-lookup"><span data-stu-id="298ca-281">In some cases, *sender* is not interesting, and you are instead interested in info such as which of the possible child objects the pointer is over when a pointer event fired, or which object in a larger UI held focus when a user pressed a keyboard key.</span></span> <span data-ttu-id="298ca-282">そのような場合には、[**OriginalSource**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.routedeventargs.originalsource) プロパティの値を利用できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-282">For these cases, you can use the value of the [**OriginalSource**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.routedeventargs.originalsource) property.</span></span> <span data-ttu-id="298ca-283">**OriginalSource** は、ルートのすべての位置で、ハンドラーがアタッチされているオブジェクトではなく、イベントを発生させた元のオブジェクトを報告します。</span><span class="sxs-lookup"><span data-stu-id="298ca-283">At all points on the route, **OriginalSource** reports the original object that fired the event, instead of the object where the handler is attached.</span></span> <span data-ttu-id="298ca-284">ただし、[**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) の入力イベントでは、そのイベント発生元のオブジェクトはページ レベルの UI 定義 XAML ですぐに見つかるオブジェクトではありません。</span><span class="sxs-lookup"><span data-stu-id="298ca-284">However, for [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) input events, that original object is often an object that is not immediately visible in the page-level UI definition XAML.</span></span> <span data-ttu-id="298ca-285">コントロールのテンプレート パーツである場合もよくあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-285">Instead, that original source object might be a templated part of a control.</span></span> <span data-ttu-id="298ca-286">たとえば、ユーザーが [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) の端にポインターをホバーした場合、ほとんどのポインター イベントでは、**OriginalSource** は **Button** そのものではなく、[**Template**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.template) の [**Border**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) テンプレート パーツになります。</span><span class="sxs-lookup"><span data-stu-id="298ca-286">For example, if the user hovers the pointer over the very edge of a [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button), for most pointer events the **OriginalSource** is a [**Border**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) template part in the [**Template**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.template), not the **Button** itself.</span></span>

<span data-ttu-id="298ca-287">**ヒント:**   バブル入力イベントは、template 宣言されたコントロールを作成する場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="298ca-287">**Tip**  Input event bubbling is especially useful if you are creating a templated control.</span></span> <span data-ttu-id="298ca-288">テンプレート化されたすべてのコントロールでは、ユーザーによって新しいテンプレートが適用される可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-288">Any control that has a template can have a new template applied by its consumer.</span></span> <span data-ttu-id="298ca-289">作業テンプレートを再作成しようとしているユーザーによって、既定のテンプレートで宣言されているイベント処理が誤って削除される可能性もあるためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-289">The consumer that's trying to recreate a working template might unintentionally eliminate some event handling declared in the default template.</span></span> <span data-ttu-id="298ca-290">そのような場合でも、クラス定義内でオーバーライドした [**OnApplyTemplate**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.onapplytemplate) の一部としてハンドラーをアタッチすることで、コントロール レベルのイベント処理を提供できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-290">You can still provide control-level event handling by attaching handlers as part of the [**OnApplyTemplate**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.onapplytemplate) override in the class definition.</span></span> <span data-ttu-id="298ca-291">これにより、インスタンス化時にコントロールのルートまでバブル ルーティングされる入力イベントをキャッチできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-291">Then you can catch the input events that bubble up to the control's root on instantiation.</span></span>

### <a name="the-handled-property"></a><span data-ttu-id="298ca-292">**Handled** プロパティ</span><span class="sxs-lookup"><span data-stu-id="298ca-292">The **Handled** property</span></span>

<span data-ttu-id="298ca-293">特定のルーティング イベントのイベント データ クラスには、**Handled** というプロパティが含まれているものがあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-293">Several event data classes for specific routed events contain a property named **Handled**.</span></span> <span data-ttu-id="298ca-294">その例として、[**PointerRoutedEventArgs.Handled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.pointerroutedeventargs.handled)、[**KeyRoutedEventArgs.Handled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs.handled)、[**DragEventArgs.Handled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.handled) があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-294">For examples, see [**PointerRoutedEventArgs.Handled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.pointerroutedeventargs.handled), [**KeyRoutedEventArgs.Handled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs.handled), [**DragEventArgs.Handled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.handled).</span></span> <span data-ttu-id="298ca-295">これらのどのクラスでも、**Handled** は設定可能なブール型プロパティとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-295">In all cases **Handled** is a settable Boolean property.</span></span>

<span data-ttu-id="298ca-296">**Handled** プロパティを **true** に設定すると、イベント システムの動作に影響します。</span><span class="sxs-lookup"><span data-stu-id="298ca-296">Setting the **Handled** property to **true** influences the event system behavior.</span></span> <span data-ttu-id="298ca-297">**Handled** が **true** に設定されると、その時点でほとんどのイベント ハンドラーへのイベントのルーティングは停止し、それ以降イベントはルート上にあるアタッチされている他のハンドラーによってキャッチされなくなります。</span><span class="sxs-lookup"><span data-stu-id="298ca-297">When **Handled** is **true**, the routing stops for most event handlers; the event doesn't continue along the route to notify other attached handlers of that particular event case.</span></span> <span data-ttu-id="298ca-298">"Handled" になったときイベントのコンテキストでどのような結果になるか、またアプリがどのように応答するかは、アプリの設計しだいです。</span><span class="sxs-lookup"><span data-stu-id="298ca-298">What "handled" means in the context of the event and how your app responds to it is up to you.</span></span> <span data-ttu-id="298ca-299">基本的に **Handled** は、イベントの発生時にそのイベントをどのコンテナーにもバブル ルーティングする必要がないことをアプリのコードで指定できるシンプルなプロトコルです。そのときに何を実行する必要があるかはアプリのロジックで扱います。</span><span class="sxs-lookup"><span data-stu-id="298ca-299">Basically, **Handled** is a simple protocol that enables app code to state that an occurrence of an event doesn't need to bubble to any containers, your app logic has taken care of what needs done.</span></span> <span data-ttu-id="298ca-300">ただし逆に注意すべきなのは、組み込みシステムやコントロールの動作用にバブル ルーティングが必要になることが多いイベントは処理しないということです。たとえば、選択コントロールの一部または項目内での低レベルのイベントを処理することで悪影響が出る場合があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-300">Conversely though, you do have to be careful that you aren't handling events that probably should bubble so that built-in system or control behaviors can act. For example, handling low-level events within the parts or items of a selection control can be detrimental.</span></span> <span data-ttu-id="298ca-301">選択コントロールは入力イベントを検索して選択の変更を調べる場合があるためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-301">The selection control might be looking for input events to know that the selection should change.</span></span>

<span data-ttu-id="298ca-302">一部のルーティング イベントではこの方法でルーティングを停止できません。それらのイベントに **Handled** プロパティがないためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-302">Not all of the routed events can cancel a route in this way, and you can tell that because they won't have a **Handled** property.</span></span> <span data-ttu-id="298ca-303">たとえば、[**GotFocus**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gotfocus) と [**LostFocus**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.lostfocus) はバブル ルーティングされますが、対応するイベント データ クラスにルーティングを停止する **Handled** プロパティがないため、常にルートまでバブル ルーティングされます。</span><span class="sxs-lookup"><span data-stu-id="298ca-303">For example, [**GotFocus**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gotfocus) and [**LostFocus**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.lostfocus) do bubble, but they always bubble all the way to the root, and their event data classes don't have a **Handled** property that can influence that behavior.</span></span>

##  <a name="input-event-handlers-in-controls"></a><span data-ttu-id="298ca-304">コントロールの入力イベント ハンドラー</span><span class="sxs-lookup"><span data-stu-id="298ca-304">Input event handlers in controls</span></span>

<span data-ttu-id="298ca-305">特定の Windows ランタイム コントロールでは、入力イベントに **Handled** の概念が内部的に使用されていることがあります。</span><span class="sxs-lookup"><span data-stu-id="298ca-305">Specific Windows Runtime controls sometimes use the **Handled** concept for input events internally.</span></span> <span data-ttu-id="298ca-306">このような場合、ユーザー コードからはそれを操作できないので、入力イベントが発生することはないようにも見えます。</span><span class="sxs-lookup"><span data-stu-id="298ca-306">This can make it seem like an input event never occurs, because your user code can't handle it.</span></span> <span data-ttu-id="298ca-307">たとえば、[**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) クラスには、一般的な入力イベント [**PointerPressed**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerpressed) を意図的に処理するロジックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="298ca-307">For example, the [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) class includes logic that deliberately handles the general input event [**PointerPressed**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerpressed).</span></span> <span data-ttu-id="298ca-308">これは、PointerPressed 入力やその他の入力モード (たとえば、フォーカスがあるときにボタンを起動できる、Enter キーなどのキーの処理) によって開始される [**Click**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) イベントを、ボタンが発生させるためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-308">It does so because buttons fire a [**Click**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) event that is initiated by pointer-pressed input, as well as by other input modes such as handling keys like the Enter key that can invoke the button when it's focused.</span></span> <span data-ttu-id="298ca-309">**Button** クラスの設計上、未加工入力イベントは概念的に処理され、ユーザー コードなどのクラス コンシューマーは、コントロール関連の **Click** イベントとやり取りできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-309">For purposes of the class design of **Button**, the raw input event is conceptually handled, and class consumers such as your user code can instead interact with the control-relevant **Click** event.</span></span> <span data-ttu-id="298ca-310">Windows ランタイム API リファレンスでは、特定のコントロール クラスのリファレンス トピックに、そのクラスが実装しているイベント処理動作の説明が含まれています。</span><span class="sxs-lookup"><span data-stu-id="298ca-310">Topics for specific control classes in the Windows Runtime API reference often note the event handling behavior that the class implements.</span></span> <span data-ttu-id="298ca-311">場合によっては、\**On\*\*\*Event* メソッドをオーバーライドすることで、動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-311">In some cases, you can change the behavior by overriding \**On\*\*\*Event* methods.</span></span> <span data-ttu-id="298ca-312">たとえば、[**TextBox**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBox) 派生クラスがキー入力に対してどう反応するかは、[**Control.OnKeyDown**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.onkeydown) をオーバーライドすることで変更できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-312">For example, you can change how your [**TextBox**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBox) derived class reacts to key input by overriding [**Control.OnKeyDown**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.onkeydown).</span></span>

##  <a name="registering-handlers-for-already-handled-routed-events"></a><span data-ttu-id="298ca-313">処理済みのルーティング イベントに対するハンドラー登録</span><span class="sxs-lookup"><span data-stu-id="298ca-313">Registering handlers for already-handled routed events</span></span>

<span data-ttu-id="298ca-314">既に説明したように、**Handled** を **true** に設定すると、ほとんどのハンドラーは呼び出されなくなります。</span><span class="sxs-lookup"><span data-stu-id="298ca-314">Earlier we said that setting **Handled** to **true** prevents most handlers from being called.</span></span> <span data-ttu-id="298ca-315">ただし、[**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) メソッドを活用すると、ルート内の他のハンドラーが共有イベント データで **Handled** を **true** に設定していても、ルートに対して必ず呼び出されるハンドラーをアタッチできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-315">But the [**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) method provides a technique where you can attach a handler that is always invoked for the route, even if some other handler earlier in the route has set **Handled** to **true** in the shared event data.</span></span> <span data-ttu-id="298ca-316">この手法が役立つのは、使っているコントロールが内部の合成ロジックまたはコントロール固有のロジックでイベントを処理済みにするが、</span><span class="sxs-lookup"><span data-stu-id="298ca-316">This technique is useful if a control you are using has handled the event in its internal compositing or for control-specific logic.</span></span> <span data-ttu-id="298ca-317">コントロールのインスタンスまたはアプリの UI からそのイベントに応答する必要がある場合です。</span><span class="sxs-lookup"><span data-stu-id="298ca-317">but you still want to respond to it from a control instance, or your app UI.</span></span> <span data-ttu-id="298ca-318">ただし、この手法は **Handled** の用途と矛盾し、コントロールの本来の対話操作を中断させる可能性があるため、使う際は注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="298ca-318">But use this technique with caution, because it can contradict the purpose of **Handled** and possibly break a control's intended interactions.</span></span>

<span data-ttu-id="298ca-319">[  **AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) によるイベント処理を使えるのは、対応するルーティング イベント識別子を持つルーティング イベントだけです。これは、**AddHandler** メソッドの入力として、その識別子が必要なためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-319">Only the routed events that have a corresponding routed event identifier can use the [**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) event handling technique, because the identifier is a required input of the **AddHandler** method.</span></span> <span data-ttu-id="298ca-320">ルーティング イベント識別子を使用可能にするイベントの一覧については、[**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) のリファレンス ドキュメントをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-320">See the reference documentation for [**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) for a list of events that have routed event identifiers available.</span></span> <span data-ttu-id="298ca-321">ほとんどの部分は、ここまでに示したルーティング イベントの一覧と同じです。</span><span class="sxs-lookup"><span data-stu-id="298ca-321">For the most part this is the same list of routed events we showed you earlier.</span></span> <span data-ttu-id="298ca-322">例外の一覧で最後の 2 つです。[**GotFocus** ](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gotfocus)と[ **LostFocus** ](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.lostfocus)ルーティング イベント識別子、いないを使用することはできません**AddHandler**にとって。</span><span class="sxs-lookup"><span data-stu-id="298ca-322">The exception is that the last two in the list: [**GotFocus**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gotfocus) and [**LostFocus**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.lostfocus) don't have a routed event identifier, so you can't use **AddHandler** for those.</span></span>

## <a name="routed-events-outside-the-visual-tree"></a><span data-ttu-id="298ca-323">ビジュアル ツリー外のルーティング イベント</span><span class="sxs-lookup"><span data-stu-id="298ca-323">Routed events outside the visual tree</span></span>

<span data-ttu-id="298ca-324">一部のオブジェクトは、プライマリ ビジュアル ツリー (概念的にはメイン ビジュアル上のオーバーレイのようなもの) と関係しています。</span><span class="sxs-lookup"><span data-stu-id="298ca-324">Certain objects participate in a relationship with the primary visual tree that is conceptually like having an overlay over the main visuals.</span></span> <span data-ttu-id="298ca-325">このようなオブジェクトは、すべてのツリー要素と表示ルートを関連付ける通常の親子関係には含まれません。</span><span class="sxs-lookup"><span data-stu-id="298ca-325">These objects are not part of the usual parent-child relationships that connect all tree elements to the visual root.</span></span> <span data-ttu-id="298ca-326">たとえば、表示される [**Popup**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.Popup) や [**ToolTip**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ToolTip) などがこれに該当します。</span><span class="sxs-lookup"><span data-stu-id="298ca-326">This is the case for any displayed [**Popup**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.Popup) or [**ToolTip**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ToolTip).</span></span> <span data-ttu-id="298ca-327">**Popup** または **ToolTip** からのルーティング イベントを処理する場合は、**Popup** 要素または **ToolTip** 要素そのものではなく、**Popup** または **ToolTip** 内の特定の UI 要素にハンドラーを配置してください。</span><span class="sxs-lookup"><span data-stu-id="298ca-327">If you want to handle routed events from a **Popup** or **ToolTip**, place the handlers on specific UI elements that are within the **Popup** or **ToolTip** and not the **Popup** or **ToolTip** elements themselves.</span></span> <span data-ttu-id="298ca-328">**Popup** または **ToolTip** のコンテンツに対して実行される合成の内部のルーティングには依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-328">Don't rely on routing inside any compositing that is performed for **Popup** or **ToolTip** content.</span></span> <span data-ttu-id="298ca-329">ルーティング イベントのイベント ルーティングは、メイン ビジュアル ツリーに沿った形でしか機能しないためです。</span><span class="sxs-lookup"><span data-stu-id="298ca-329">This is because event routing for routed events works only along the main visual tree.</span></span> <span data-ttu-id="298ca-330">**Popup** も **ToolTip** も、従属する UI 要素の親とは見なされず、(たとえば、**Popup** の既定の背景を入力イベントのキャプチャ領域として使用しようとしても) ルーティング イベントを受け取ることはできません。</span><span class="sxs-lookup"><span data-stu-id="298ca-330">A **Popup** or **ToolTip** is not considered a parent of subsidiary UI elements and never receives the routed event, even if it is trying to use something like the **Popup** default background as the capture area for input events.</span></span>

## <a name="hit-testing-and-input-events"></a><span data-ttu-id="298ca-331">ヒット テストと入力イベント</span><span class="sxs-lookup"><span data-stu-id="298ca-331">Hit testing and input events</span></span>

<span data-ttu-id="298ca-332">ある要素が、UI でマウス入力、タッチ入力、スタイラス入力の対象として表示されるかどうかと場所を確認することを、*ヒット テスト*と呼びます。</span><span class="sxs-lookup"><span data-stu-id="298ca-332">Determining whether and where in UI an element is visible to mouse, touch, and stylus input is called *hit testing*.</span></span> <span data-ttu-id="298ca-333">タッチ操作や、タッチ操作の結果に発生する対話/操作イベントについては、ヒット テストで要素が表示されない場合、イベント ソースとして使用したり、操作に関連付けられたイベントを起動することはできません。</span><span class="sxs-lookup"><span data-stu-id="298ca-333">For touch actions and also for interaction-specific or manipulation events that are consequences of a touch action, an element must be hit-test visible in order to be the event source and fire the event that is associated with the action.</span></span> <span data-ttu-id="298ca-334">それ以外の場合、操作はその要素を通過し、その入力を操作する基になる要素またはビジュアル ツリー内の親要素へと渡されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-334">Otherwise, the action passes through the element to any underlying elements or parent elements in the visual tree that could interact with that input.</span></span> <span data-ttu-id="298ca-335">ヒット テストに影響を与える要因はいくつかありますが、指定された要素の [**IsHitTestVisible**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.ishittestvisible) プロパティを確認すると、その要素が入力イベントを発生できるかどうかを判別できます。</span><span class="sxs-lookup"><span data-stu-id="298ca-335">There are several factors that affect hit testing, but you can determine whether a given element can fire input events by checking its [**IsHitTestVisible**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.ishittestvisible) property.</span></span> <span data-ttu-id="298ca-336">このプロパティは、要素が次の条件を満たす場合にのみ、**true** を返します。</span><span class="sxs-lookup"><span data-stu-id="298ca-336">This property returns **true** only if the element meets these criteria:</span></span>

- <span data-ttu-id="298ca-337">要素の [**Visibility**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.visibility) プロパティの値が [**Visible**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Visibility) である。</span><span class="sxs-lookup"><span data-stu-id="298ca-337">The element's [**Visibility**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.visibility) property value is [**Visible**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Visibility).</span></span>
- <span data-ttu-id="298ca-338">要素の **Background** または **Fill** プロパティの値が **null** ではない。</span><span class="sxs-lookup"><span data-stu-id="298ca-338">The element's **Background** or **Fill** property value is not **null**.</span></span> <span data-ttu-id="298ca-339">A **null** [**ブラシ**](/uwp/api/Windows.UI.Xaml.Media.Brush)透過性で結果を値し、ヒット テストの非表示します。</span><span class="sxs-lookup"><span data-stu-id="298ca-339">A **null** [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) value results in transparency and hit test invisibility.</span></span> <span data-ttu-id="298ca-340">(要素を透明にしつつ、ヒット テストも可能にするには、**null** ではなく [**Transparent**](https://docs.microsoft.com/uwp/api/windows.ui.colors.transparent) を使います)。</span><span class="sxs-lookup"><span data-stu-id="298ca-340">(To make an element transparent but also hit testable, use a [**Transparent**](https://docs.microsoft.com/uwp/api/windows.ui.colors.transparent) brush instead of **null**.)</span></span>

<span data-ttu-id="298ca-341">**注**  **Background** と **Fill** は [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) では定義されません。[**Control**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Control) や [**Shape**](/uwp/api/Windows.UI.Xaml.Shapes.Shape) などの別の派生クラスによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-341">**Note**  **Background** and **Fill** aren't defined by [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement), and are instead defined by different derived classes such as [**Control**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Control) and [**Shape**](/uwp/api/Windows.UI.Xaml.Shapes.Shape).</span></span> <span data-ttu-id="298ca-342">ただし、フォアグラウンドやバックグラウンド プロパティに使用するブラシの影響は、それらのプロパティをどのサブクラスが実装するかに関係なく、ヒット テストや入力イベントに対して同様です。</span><span class="sxs-lookup"><span data-stu-id="298ca-342">But the implications of brushes you use for foreground and background properties are the same for hit testing and input events, no matter which subclass implements the properties.</span></span>

- <span data-ttu-id="298ca-343">要素がコントロールの場合、[**IsEnabled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.isenabled) プロパティの値は **true** である必要がある。</span><span class="sxs-lookup"><span data-stu-id="298ca-343">If the element is a control, its [**IsEnabled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.isenabled) property value must be **true**.</span></span>
- <span data-ttu-id="298ca-344">要素はレイアウトで実際のサイズを持ったものである必要がある。</span><span class="sxs-lookup"><span data-stu-id="298ca-344">The element must have actual dimensions in layout.</span></span> <span data-ttu-id="298ca-345">[  **ActualHeight**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.actualheight) と [**ActualWidth**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.actualwidth) のいずれかが 0 である要素は、入力イベントを発生させません。</span><span class="sxs-lookup"><span data-stu-id="298ca-345">An element where either [**ActualHeight**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.actualheight) and [**ActualWidth**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.actualwidth) are 0 won't fire input events.</span></span>

<span data-ttu-id="298ca-346">一部のコントロールでは、ヒット テストに特別な規則があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-346">Some controls have special rules for hit testing.</span></span> <span data-ttu-id="298ca-347">たとえば、[**TextBlock**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBlock) には **Background** プロパティがありませんが、そのサイズの領域全体の中ではヒット テストできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-347">For example, [**TextBlock**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBlock) has no **Background** property, but is still hit testable within the entire region of its dimensions.</span></span> <span data-ttu-id="298ca-348">[**イメージ**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Image)と[ **MediaElement** ](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement)コントロールが、メディアでアルファ チャネルなどの透過的なコンテンツに関係なく、四角形が定義されているディメンションでテスト可能なヒット表示されているソース ファイルです。</span><span class="sxs-lookup"><span data-stu-id="298ca-348">[**Image**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Image) and [**MediaElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) controls are hit testable over their defined rectangle dimensions, regardless of transparent content such as alpha channel in the media source file being displayed.</span></span> <span data-ttu-id="298ca-349">[**WebView** ](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.WebView)コントロールがある特別なヒットがホスト型の HTML および火災スクリプト イベントで、入力を処理できるため、動作をテストします。</span><span class="sxs-lookup"><span data-stu-id="298ca-349">[**WebView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.WebView) controls have special hit testing behavior because the input can be handled by the hosted HTML and fire script events.</span></span>

<span data-ttu-id="298ca-350">ほとんどの [**Panel**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Panel) クラスと [**Border**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) は、自身のバックグラウンド内ではヒット テストできませんが、含んでいる要素からルーティングされたユーザー入力イベントを処理することはできます。</span><span class="sxs-lookup"><span data-stu-id="298ca-350">Most [**Panel**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Panel) classes and [**Border**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) are not hit-testable in their own background, but can still handle the user input events that are routed from the elements that they contain.</span></span>

<span data-ttu-id="298ca-351">要素がヒット テストできるかどうかにかかわらず、どの要素がユーザー入力イベントと同じ位置にあるかどうかを判別することができます。</span><span class="sxs-lookup"><span data-stu-id="298ca-351">You can determine which elements are located at the same position as a user input event, regardless of whether the elements are hit-testable.</span></span> <span data-ttu-id="298ca-352">そのためには、[**FindElementsInHostCoordinates**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.visualtreehelper.findelementsinhostcoordinates) メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="298ca-352">To do this, call the [**FindElementsInHostCoordinates**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.visualtreehelper.findelementsinhostcoordinates) method.</span></span> <span data-ttu-id="298ca-353">このメソッドは名前のとおり、指定されたホスト要素からの相対的な位置にある要素を見つけます。</span><span class="sxs-lookup"><span data-stu-id="298ca-353">As the name implies, this method finds the elements at a location relative to a specified host element.</span></span> <span data-ttu-id="298ca-354">ただし、適用された変換やレイアウト変更により要素の相対座標系が調整されて、指定された場所でどの要素が見つかるかに影響する場合があります。</span><span class="sxs-lookup"><span data-stu-id="298ca-354">However, applied transforms and layout changes can adjust the relative coordinate system of an element, and therefore affect which elements are found at a given location.</span></span>

## <a name="commanding"></a><span data-ttu-id="298ca-355">コマンド実行</span><span class="sxs-lookup"><span data-stu-id="298ca-355">Commanding</span></span>

<span data-ttu-id="298ca-356">*コマンド実行*がサポートされる UI 要素は少数です。</span><span class="sxs-lookup"><span data-stu-id="298ca-356">A small number of UI elements support *commanding*.</span></span> <span data-ttu-id="298ca-357">コマンド実行では、基になる実装で入力関連のルーティング イベントを使用し、1 つのコマンド ハンドラーを呼び出して関連する UI 入力 (特定のポインター操作、特定のショートカット キー) の処理を有効にします。</span><span class="sxs-lookup"><span data-stu-id="298ca-357">Commanding uses input-related routed events in its underlying implementation and enables processing of related UI input (a certain pointer action, a specific accelerator key) by invoking a single command handler.</span></span> <span data-ttu-id="298ca-358">UI 要素でコマンド実行を使うことができる場合は、個々の入力イベントではなく、コマンド実行 API を使うことを検討してください。</span><span class="sxs-lookup"><span data-stu-id="298ca-358">If commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events.</span></span> <span data-ttu-id="298ca-359">通常は **Binding** を使って、データのビュー モデルを定義するクラスのプロパティを参照します。</span><span class="sxs-lookup"><span data-stu-id="298ca-359">You typically use a **Binding** reference into properties of a class that defines the view model for data.</span></span> <span data-ttu-id="298ca-360">それらのプロパティに対応する名前付きコマンドで、言語固有の **ICommand** コマンド実行パターンを実装します。</span><span class="sxs-lookup"><span data-stu-id="298ca-360">The properties hold named commands that implement the language-specific **ICommand** commanding pattern.</span></span> <span data-ttu-id="298ca-361">詳しくは、「[**ButtonBase.Command**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.command)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-361">For more info, see [**ButtonBase.Command**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.command).</span></span>

## <a name="custom-events-in-the-windows-runtime"></a><span data-ttu-id="298ca-362">Windows ランタイムでのカスタム イベント</span><span class="sxs-lookup"><span data-stu-id="298ca-362">Custom events in the Windows Runtime</span></span>

<span data-ttu-id="298ca-363">カスタム イベントを定義するにあたっては、使われるプログラミング言語に応じて、イベントの追加方法や、それがクラスの設計でどのような意味を帯びるのかが大きく異なります。</span><span class="sxs-lookup"><span data-stu-id="298ca-363">For purposes of defining custom events, how you add the event and what that means for your class design is highly dependent on which programming language you are using.</span></span>

- <span data-ttu-id="298ca-364">C# と Visual Basic では、CLR のイベントを定義します。</span><span class="sxs-lookup"><span data-stu-id="298ca-364">For C# and Visual Basic, you are defining a CLR event.</span></span> <span data-ttu-id="298ca-365">カスタム アクセサー (**add**/**remove**) を使っていない限り、標準の .NET イベントのパターンを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="298ca-365">You can use the standard .NET event pattern, so long as you aren't using custom accessors (**add**/**remove**).</span></span> <span data-ttu-id="298ca-366">次の点にも注意してください。</span><span class="sxs-lookup"><span data-stu-id="298ca-366">Additional tips:</span></span>
    - <span data-ttu-id="298ca-367">イベント ハンドラーには、Windows ランタイムの汎用イベント デリゲート [**EventHandler<T>** ](https://docs.microsoft.com/uwp/api/windows.foundation.eventhandler) への組み込みの変換がある [**System.EventHandler<TEventArgs>** ](https://docs.microsoft.com/dotnet/api/system.eventhandler-1?redirectedfrom=MSDN) を使うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="298ca-367">For the event handler it's a good idea to use [**System.EventHandler<TEventArgs>**](https://docs.microsoft.com/dotnet/api/system.eventhandler-1?redirectedfrom=MSDN) because it has built-in translation to the Windows Runtime generic event delegate [**EventHandler<T>**](https://docs.microsoft.com/uwp/api/windows.foundation.eventhandler).</span></span>
    - <span data-ttu-id="298ca-368">Windows ランタイムに変換されないため、イベント データ クラスが [**System.EventArgs**](https://docs.microsoft.com/dotnet/api/system.eventargs?redirectedfrom=MSDN) に基づくことのないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="298ca-368">Don't base your event data class on [**System.EventArgs**](https://docs.microsoft.com/dotnet/api/system.eventargs?redirectedfrom=MSDN) because it doesn't translate to the Windows Runtime.</span></span> <span data-ttu-id="298ca-369">既にあるイベント データ クラスを使うか、基底クラスをまったく使わないかのいずれかにします。</span><span class="sxs-lookup"><span data-stu-id="298ca-369">Use an existing event data class or no base class at all.</span></span>
    - <span data-ttu-id="298ca-370">カスタム アクセサーを使う場合は、「[Windows ランタイム コンポーネントのカスタム イベントとイベント アクセサー](https://docs.microsoft.com/previous-versions/windows/apps/hh972883(v=vs.140))」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-370">If you are using custom accessors, see [Custom events and event accessors in Windows Runtime Components](https://docs.microsoft.com/previous-versions/windows/apps/hh972883(v=vs.140)).</span></span>
    - <span data-ttu-id="298ca-371">標準の .NET イベントのパターンがよくわからない場合には、「[Silverlight のカスタム クラスのイベントの定義](https://docs.microsoft.com/previous-versions/windows/)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-371">If you're not clear on what the standard .NET event pattern is, see [Defining Events for Custom Silverlight Classes](https://docs.microsoft.com/previous-versions/windows/).</span></span> <span data-ttu-id="298ca-372">これは、Microsoft Silverlight 向けに書かれたものですが、.NET イベントのパターンのコードと概念がよくまとまっています。</span><span class="sxs-lookup"><span data-stu-id="298ca-372">This is written for Microsoft Silverlight but it's still a good summation of the code and concepts for the standard .NET event pattern.</span></span>
- <span data-ttu-id="298ca-373">C++/CX については、「[イベント (C++/CX)](https://docs.microsoft.com/cpp/cppcx/events-c-cx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-373">For C++/CX, see [Events (C++/CX)](https://docs.microsoft.com/cpp/cppcx/events-c-cx).</span></span>
    - <span data-ttu-id="298ca-374">カスタム イベントを自ら使う場合であっても、名前付き参照を使ってください。</span><span class="sxs-lookup"><span data-stu-id="298ca-374">Use named references even for your own usages of custom events.</span></span> <span data-ttu-id="298ca-375">カスタム イベントにラムダは使えません。ラムダを使うと、循環参照が作られることになります。</span><span class="sxs-lookup"><span data-stu-id="298ca-375">Don't use lambda for custom events, it can create a circular reference.</span></span>

<span data-ttu-id="298ca-376">Windows ランタイムでカスタム ルーティング イベントは宣言できません。ルーティング イベントは、Windows ランタイムのセットに限定されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-376">You can't declare a custom routed event for Windows Runtime; routed events are limited to the set that comes from the Windows Runtime.</span></span>

<span data-ttu-id="298ca-377">カスタム イベントの定義は通常、カスタム コントロールを定義する一環として実行されます。</span><span class="sxs-lookup"><span data-stu-id="298ca-377">Defining a custom event is usually done as part of the exercise of defining a custom control.</span></span> <span data-ttu-id="298ca-378">プロパティ変更コールバックのある依存関係プロパティだけでなく、その依存関係プロパティのコールバックで (必ずまたはときどき) 発生するカスタム イベントを定義するのがよくあるパターンです。</span><span class="sxs-lookup"><span data-stu-id="298ca-378">It's a common pattern to have a dependency property that has a property-changed callback, and to also define a custom event that's fired by the dependency property callback in some or all cases.</span></span> <span data-ttu-id="298ca-379">コントロールのユーザーには定義したプロパティ変更コールバックに対するアクセス権がないものの、通知イベントは利用可能にするというのが次善策です。</span><span class="sxs-lookup"><span data-stu-id="298ca-379">Consumers of your control don't have access to the property-changed callback you defined, but having a notification event available is the next best thing.</span></span> <span data-ttu-id="298ca-380">詳しくは、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="298ca-380">For more info, see [Custom dependency properties](custom-dependency-properties.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="298ca-381">関連トピック</span><span class="sxs-lookup"><span data-stu-id="298ca-381">Related topics</span></span>

* [<span data-ttu-id="298ca-382">XAML の概要</span><span class="sxs-lookup"><span data-stu-id="298ca-382">XAML overview</span></span>](xaml-overview.md)
* <span data-ttu-id="298ca-383">[クイック スタート:タッチ入力](https://docs.microsoft.com/previous-versions/windows/apps/hh465387(v=win.10))</span><span class="sxs-lookup"><span data-stu-id="298ca-383">[Quickstart: Touch input](https://docs.microsoft.com/previous-versions/windows/apps/hh465387(v=win.10))</span></span>
* [<span data-ttu-id="298ca-384">キーボードの相互作用</span><span class="sxs-lookup"><span data-stu-id="298ca-384">Keyboard interactions</span></span>](https://docs.microsoft.com/windows/uwp/input-and-devices/keyboard-interactions)
* [<span data-ttu-id="298ca-385">.NET のイベントとデリゲート</span><span class="sxs-lookup"><span data-stu-id="298ca-385">.NET events and delegates</span></span>](https://go.microsoft.com/fwlink/p/?linkid=214364)
* <span data-ttu-id="298ca-386">[Windows ランタイム コンポーネントの作成](https://docs.microsoft.com/previous-versions/windows/apps/hh441572(v=vs.140))</span><span class="sxs-lookup"><span data-stu-id="298ca-386">[Creating Windows Runtime components](https://docs.microsoft.com/previous-versions/windows/apps/hh441572(v=vs.140))</span></span>
* [<span data-ttu-id="298ca-387">**AddHandler**</span><span class="sxs-lookup"><span data-stu-id="298ca-387">**AddHandler**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler)
