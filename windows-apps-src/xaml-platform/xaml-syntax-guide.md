---
author: jwmsft
description: ここでは、XAML 構文の規則と、XAML 構文に存在する制限や選択肢を説明する用語について説明します。
title: XAML 構文のガイド
ms.assetid: A57FE7B4-9947-4AA0-BC99-5FE4686B611D
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 7c74b05974bcfd9dd8c592d18f6f5fe4ff388f03
ms.sourcegitcommit: 2470c6596d67e1f5ca26b44fad56a2f89773e9cc
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2018
ms.locfileid: "1675349"
---
# <a name="xaml-syntax-guide"></a><span data-ttu-id="23634-104">XAML 構文のガイド</span><span class="sxs-lookup"><span data-stu-id="23634-104">XAML syntax guide</span></span>


<span data-ttu-id="23634-105">ここでは、XAML 構文の規則と、XAML 構文に存在する制限や選択肢を説明する用語について説明します。</span><span class="sxs-lookup"><span data-stu-id="23634-105">We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</span></span> <span data-ttu-id="23634-106">このトピックは、XAML 言語の初心者を対象に作成されています。XAML の用語や構文の復習にも使用できます。また、XAML 言語のしくみや背景知識を知ることもできます。</span><span class="sxs-lookup"><span data-stu-id="23634-106">You'll find this topic useful if you are new to using the XAML language, you want a refresher on the terminology or parts of syntax, or you are curious about how the XAML language works and want more background and context.</span></span>

## <a name="xaml-is-xml"></a><span data-ttu-id="23634-107">XAML は XML</span><span class="sxs-lookup"><span data-stu-id="23634-107">XAML is XML</span></span>

<span data-ttu-id="23634-108">Extensible Application Markup Language (XAML) の基本的な構文は XML に基づいています。したがって、有効な XAML は有効な XML である必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-108">Extensible Application Markup Language (XAML) has a basic syntax that builds on XML, and by definition valid XAML must be valid XML.</span></span> <span data-ttu-id="23634-109">ただし、XAML には XML を拡張した独自の構文概念もあります。</span><span class="sxs-lookup"><span data-stu-id="23634-109">But XAML also has its own syntax concepts that extend XML.</span></span> <span data-ttu-id="23634-110">ある XML エンティティの構文がプレーン XML で有効であったとしても、XAML では別のより完全な意味を持つことがあります。</span><span class="sxs-lookup"><span data-stu-id="23634-110">A given XML entity might be valid in plain XML, but that syntax might have a different and more complete meaning as XAML.</span></span> <span data-ttu-id="23634-111">ここでは、次の XAML 構文の概念について説明します。</span><span class="sxs-lookup"><span data-stu-id="23634-111">This topic explains these XAML syntax concepts.</span></span>

## <a name="xaml-vocabularies"></a><span data-ttu-id="23634-112">XAML ボキャブラリ</span><span class="sxs-lookup"><span data-stu-id="23634-112">XAML vocabularies</span></span>

<span data-ttu-id="23634-113">XAML がほとんどの XML 応用言語と異なる点としては、XAML には通常、XSD ファイルのようなスキーマが必須でないという点があります。</span><span class="sxs-lookup"><span data-stu-id="23634-113">One area where XAML differs from most XML usages is that XAML is not typically enforced with a schema, such as an XSD file.</span></span> <span data-ttu-id="23634-114">これは、XAML が拡張可能であることを目的としているためです。XAML という略語の "X" はそういう意味 (Extensible) です。</span><span class="sxs-lookup"><span data-stu-id="23634-114">That's because XAML is intended to be extensible, that's what the "X" in the acronym XAML means.</span></span> <span data-ttu-id="23634-115">XAML を解析すると、XAML で参照される要素と属性は、Windows ランタイムで定義された中核となる型、または、Windows ランタイムを拡張または基にした型として、なんらかのバッキング コード表現に存在することが期待されます。</span><span class="sxs-lookup"><span data-stu-id="23634-115">Once XAML is parsed, the elements and attributes you reference in XAML are expected to exist in some backing code representation, either in the core types defined by the Windows Runtime, or in types that extend or are based off the Windows Runtime.</span></span> <span data-ttu-id="23634-116">SDK ドキュメントでは、Windows ランタイムで既に定義されていて XAML で使うことのできる型を Windows ランタイムの *XAML ボキャブラリ*と呼ぶことがあります。</span><span class="sxs-lookup"><span data-stu-id="23634-116">The SDK documentation sometimes refers to the types that are already built-in to the Windows Runtime and can be used in XAML as being the *XAML vocabulary* for the Windows Runtime.</span></span> <span data-ttu-id="23634-117">Microsoft Visual Studio では、この XAML ボキャブラリ内で有効なマークアップを作成できます。</span><span class="sxs-lookup"><span data-stu-id="23634-117">Microsoft Visual Studio helps you to produce markup that's valid within this XAML vocabulary.</span></span> <span data-ttu-id="23634-118">Visual Studio では、カスタム型のソースがプロジェクトで正しく参照されている限り、XAML で使うカスタム型を含めることもできます。</span><span class="sxs-lookup"><span data-stu-id="23634-118">Visual Studio can also include your custom types for XAML usage so long as the source of those types is referenced correctly in the project.</span></span> <span data-ttu-id="23634-119">XAML とカスタム型について詳しくは、「[XAML 名前空間と名前空間マッピング](xaml-namespaces-and-namespace-mapping.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-119">For more info about XAML and custom types, see [XAML namespaces and namespace mapping](xaml-namespaces-and-namespace-mapping.md).</span></span>

##  <a name="declaring-objects"></a><span data-ttu-id="23634-120">オブジェクトの宣言</span><span class="sxs-lookup"><span data-stu-id="23634-120">Declaring objects</span></span>

<span data-ttu-id="23634-121">プログラミングの際にはオブジェクトとメンバーの観点から考えるのが一般的ですが、マークアップ言語は要素と属性で概念化されています。</span><span class="sxs-lookup"><span data-stu-id="23634-121">Programmers often think in terms of objects and members, whereas a markup language is conceptualized as elements and attributes.</span></span> <span data-ttu-id="23634-122">最も基本的な意味においては、XAML マークアップで宣言する要素はバッキング ランタイム オブジェクト表現のオブジェクトになります。</span><span class="sxs-lookup"><span data-stu-id="23634-122">In the most basic sense, an element that you declare in XAML markup becomes an object in a backing runtime object representation.</span></span> <span data-ttu-id="23634-123">アプリのランタイム オブジェクトを作成するには、XAML マークアップで XAML 要素を宣言します。</span><span class="sxs-lookup"><span data-stu-id="23634-123">To create a run-time object for your app, you declare a XAML element in the XAML markup.</span></span> <span data-ttu-id="23634-124">オブジェクトは、Windows ランタイムによって XAML が読み込まれたときに作成されます。</span><span class="sxs-lookup"><span data-stu-id="23634-124">The object is created when the Windows Runtime loads your XAML.</span></span>

<span data-ttu-id="23634-125">XAML ファイルには、ルートとして機能する要素が常に 1 つあります。ルートは、ページなどのいくつかのプログラミング構造の概念上のルートとなるオブジェクトまたはアプリケーションのランタイム定義全体のオブジェクト グラフを宣言します。</span><span class="sxs-lookup"><span data-stu-id="23634-125">A XAML file always has exactly one element serving as its root, which declares an object that will be the conceptual root of some programming structure such as a page, or the object graph of the entire run-time definition of an application.</span></span>

<span data-ttu-id="23634-126">XAML 構文では、次の 3 つの方法を使って XAML でオブジェクトを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="23634-126">In terms of XAML syntax, there are three ways to declare objects in XAML:</span></span>

-   <span data-ttu-id="23634-127">**オブジェクト要素構文を直接使用:** 開始タグと終了タグを使って、オブジェクトを XML 形式の要素としてインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="23634-127">**Directly, using object element syntax:** This uses opening and closing tags to instantiate an object as an XML-form element.</span></span> <span data-ttu-id="23634-128">この構文を使うと、ルート オブジェクトを宣言することも、プロパティ値を設定する入れ子になったオブジェクトを作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="23634-128">You can use this syntax to declare root objects or to create nested objects that set property values.</span></span>
-   <span data-ttu-id="23634-129">**属性構文を間接的に使用:** オブジェクトの作成方法に関する命令が含まれるインライン文字列値を使います。</span><span class="sxs-lookup"><span data-stu-id="23634-129">**Indirectly, using attribute syntax:** This uses an inline string value that has instructions for how to create an object.</span></span> <span data-ttu-id="23634-130">XAML パーサーは、この文字列を使って、新しく作成した参照値にプロパティ値を設定します。</span><span class="sxs-lookup"><span data-stu-id="23634-130">The XAML parser uses this string to set the value of a property to a newly created reference value.</span></span> <span data-ttu-id="23634-131">この方法に対するサポートは、共通のオブジェクトとプロパティの一部に限定されます。</span><span class="sxs-lookup"><span data-stu-id="23634-131">Support for it is limited to certain common objects and properties.</span></span>
-   <span data-ttu-id="23634-132">マークアップ拡張を使用。</span><span class="sxs-lookup"><span data-stu-id="23634-132">Using a markup extension.</span></span>

<span data-ttu-id="23634-133">これは、XAML ボキャブラリでオブジェクトの作成用にどの構文を使うかをいつも選択できるというわけではありません。</span><span class="sxs-lookup"><span data-stu-id="23634-133">This does not mean that you always have the choice of any syntax for object creation in a XAML vocabulary.</span></span> <span data-ttu-id="23634-134">一部のオブジェクトは、作成時にオブジェクト要素構文しか使用できません。</span><span class="sxs-lookup"><span data-stu-id="23634-134">Some objects can be created only by using object element syntax.</span></span> <span data-ttu-id="23634-135">また、オブジェクトのなかには、最初から属性に設定する方法でしか作成できないものもあります。</span><span class="sxs-lookup"><span data-stu-id="23634-135">Some objects can be created only by being initially set in an attribute.</span></span> <span data-ttu-id="23634-136">実際、オブジェクト要素構文または属性構文のどちらを使っても作成できるというオブジェクトは、XAML ボキャブラリでは比較的まれです。</span><span class="sxs-lookup"><span data-stu-id="23634-136">In fact, objects that can be created with either object element or attribute syntax are comparatively rare in XAML vocabularies.</span></span> <span data-ttu-id="23634-137">構文形式が両方とも使用できたとしても、スタイルとしてはどちらか一方が使われることが多くなります。</span><span class="sxs-lookup"><span data-stu-id="23634-137">Even if both syntax forms are possible, one of the syntaxes will be more common as a matter of style.</span></span>
<span data-ttu-id="23634-138">また、XAML で新しい値を作成するのではなく、今あるオブジェクトを参照するために使用できる手法もあります。</span><span class="sxs-lookup"><span data-stu-id="23634-138">There are also techniques you can use in XAML to reference existing objects rather than creating new values.</span></span> <span data-ttu-id="23634-139">今あるオブジェクトは、XAML の他の領域で定義されていることもあれば、プラットフォームとそのアプリケーションまたはプログラミング モデルの特定の動作を介して暗黙的に存在することもあります。</span><span class="sxs-lookup"><span data-stu-id="23634-139">The existing objects might be defined either in other areas of XAML, or might exist implicitly through some behavior of the platform and its application or programming models.</span></span>

### <a name="declaring-an-object-by-using-object-element-syntax"></a><span data-ttu-id="23634-140">オブジェクト要素構文を使用したオブジェクトの宣言</span><span class="sxs-lookup"><span data-stu-id="23634-140">Declaring an object by using object element syntax</span></span>

<span data-ttu-id="23634-141">オブジェクト要素構文を使ってオブジェクトを宣言するには、`<objectName>  </objectName>` のようにタグを記述します。ここで、*objectName* は、インスタンス化するオブジェクトの型名を表します。</span><span class="sxs-lookup"><span data-stu-id="23634-141">To declare an object with object element syntax, you write tags like this: `<objectName>  </objectName>`, where *objectName* is the type name for the object you want to instantiate.</span></span> <span data-ttu-id="23634-142">[**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) オブジェクトを宣言するためのオブジェクト要素の使用方法は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="23634-142">Here's object element usage to declare a [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) object:</span></span>

```xml
<Canvas>
</Canvas>
```

<span data-ttu-id="23634-143">オブジェクトに他のオブジェクトを含めない場合は、開始タグと終了タグのペアを使う代わりに、1 つの自己終了タグ () を使ってオブジェクト要素を宣言できます。</span><span class="sxs-lookup"><span data-stu-id="23634-143">If the object does not contain other objects, you can declare the object element by using one self-closing tag instead of an opening/closing pair:</span></span> `<Canvas />`

### <a name="containers"></a><span data-ttu-id="23634-144">コンテナー</span><span class="sxs-lookup"><span data-stu-id="23634-144">Containers</span></span>

<span data-ttu-id="23634-145">UI 要素として使われるオブジェクト ([**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) など) の多くは、他のオブジェクトを格納することができます。</span><span class="sxs-lookup"><span data-stu-id="23634-145">Many objects used as UI elements, such as [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267), can contain other objects.</span></span> <span data-ttu-id="23634-146">そのようなオブジェクトは、コンテナーとも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="23634-146">These are sometimes referred to as containers.</span></span> <span data-ttu-id="23634-147">次の例は、要素 [**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle) を 1 つ格納している **Canvas** コンテナーを示しています。</span><span class="sxs-lookup"><span data-stu-id="23634-147">The following example shows a **Canvas** container that contains one element, a [**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle).</span></span>

```xml
<Canvas>
  <Rectangle />
</Canvas>
```

### <a name="declaring-an-object-by-using-attribute-syntax"></a><span data-ttu-id="23634-148">属性構文を使用したオブジェクトの宣言</span><span class="sxs-lookup"><span data-stu-id="23634-148">Declaring an object by using attribute syntax</span></span>

<span data-ttu-id="23634-149">この動作はプロパティの設定に関連付けられているため、次のセクションでさらに詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="23634-149">Because this behavior is tied to property setting, we'll talk about this more in upcoming sections.</span></span>

### <a name="initialization-text"></a><span data-ttu-id="23634-150">初期化テキスト</span><span class="sxs-lookup"><span data-stu-id="23634-150">Initialization text</span></span>

<span data-ttu-id="23634-151">一部のオブジェクトでは、構造の初期値として使われる内部テキストを使って新しい値を宣言できます。</span><span class="sxs-lookup"><span data-stu-id="23634-151">For some objects you can declare new values using inner text that's used as initialization values for construction.</span></span> <span data-ttu-id="23634-152">XAML では、この手法と構文を*初期化テキスト*と呼びます。</span><span class="sxs-lookup"><span data-stu-id="23634-152">In XAML, this technique and syntax is called *initialization text*.</span></span> <span data-ttu-id="23634-153">初期化テキストは概念的に、パラメーターを持つコンストラクターの呼び出しに似ています。</span><span class="sxs-lookup"><span data-stu-id="23634-153">Conceptually, initialization text is similar to calling a constructor that has parameters.</span></span> <span data-ttu-id="23634-154">初期化テキストは、一部の構造体の初期値を設定するのに便利です。</span><span class="sxs-lookup"><span data-stu-id="23634-154">Initialization text is useful for setting initial values of certain structures.</span></span>

<span data-ttu-id="23634-155">構造体の値に **x:Key** を持たせ、[**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794) 内に存在できるようにする必要がある場合にはよく、オブジェクト要素構文を初期化テキストと共に使います。</span><span class="sxs-lookup"><span data-stu-id="23634-155">You often use an object element syntax with initialization text if you want a structure value with an **x:Key**, so it can exist in a [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794).</span></span> <span data-ttu-id="23634-156">この手法は、その構造体の値を複数のターゲット プロパティで共有する場合に使用できます。</span><span class="sxs-lookup"><span data-stu-id="23634-156">You might do this if you share that structure value among multiple target properties.</span></span> <span data-ttu-id="23634-157">一部の構造体では、属性構文を使って構造体の値を設定することができません。このため、初期化テキストが、便利で共有可能な [**CornerRadius**](https://msdn.microsoft.com/library/windows/apps/br242343)、[**Thickness**](https://msdn.microsoft.com/library/windows/apps/br208864)、[**GridLength**](https://msdn.microsoft.com/library/windows/apps/br208754)、[**Color**](https://msdn.microsoft.com/library/windows/apps/hh673723) リソースを生成するための唯一の方法になります。</span><span class="sxs-lookup"><span data-stu-id="23634-157">For some structures, you can't use attribute syntax to set the structure's values: initialization text is the only way to produce a useful and shareable [**CornerRadius**](https://msdn.microsoft.com/library/windows/apps/br242343), [**Thickness**](https://msdn.microsoft.com/library/windows/apps/br208864), [**GridLength**](https://msdn.microsoft.com/library/windows/apps/br208754) or [**Color**](https://msdn.microsoft.com/library/windows/apps/hh673723) resource.</span></span>

<span data-ttu-id="23634-158">この省略された例では、初期化テキストを使って [**Thickness**](https://msdn.microsoft.com/library/windows/apps/br208864) の値 (**Left** と **Right** を 20 に、**Top** と **Bottom** を 10 に設定する値) を指定しています。</span><span class="sxs-lookup"><span data-stu-id="23634-158">This abbreviated example uses initialization text to specify values for a [**Thickness**](https://msdn.microsoft.com/library/windows/apps/br208864), in this case specifying values that set both **Left** and **Right** to 20, and both **Top** and **Bottom** to 10.</span></span> <span data-ttu-id="23634-159">この例は、キーを持つリソースとして作成された **Thickness** と、そのリソースへの参照を示しています。</span><span class="sxs-lookup"><span data-stu-id="23634-159">This example shows the **Thickness** created as a keyed resource, and then the reference to that resource.</span></span> <span data-ttu-id="23634-160">[**Thickness**](https://msdn.microsoft.com/library/windows/apps/br208864) の初期化テキストについて詳しくは、「[**Thickness**](https://msdn.microsoft.com/library/windows/apps/br208864)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-160">For more info on [**Thickness**](https://msdn.microsoft.com/library/windows/apps/br208864) initialization text, see [**Thickness**](https://msdn.microsoft.com/library/windows/apps/br208864).</span></span>

```xml
<UserControl ...>
  <UserControl.Resources>
    <Thickness x:Key="TwentyTenThickness">20,10</Thickness>
    ....
  </UserControl.Resources>
  ...
  <Grid Margin="{StaticResource TwentyTenThickness}">
  ...
  </Grid>
</UserControl ...>
```

<span data-ttu-id="23634-161">**注:** 一部の構造体は、オブジェクト要素として宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="23634-161">**Note**  Some structures can't be declared as object elements.</span></span> <span data-ttu-id="23634-162">初期化テキストがサポートされておらず、リソースとして使うことができません。</span><span class="sxs-lookup"><span data-stu-id="23634-162">Initialization text isn't supported and they can't be used as resources.</span></span> <span data-ttu-id="23634-163">XAML でそれらの値にプロパティを設定するには、属性構文を使う必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-163">You must use an attribute syntax in order to set properties to these values in XAML.</span></span> <span data-ttu-id="23634-164">そのような型には、[**Duration**](https://msdn.microsoft.com/library/windows/apps/br242377)、[**RepeatBehavior**](https://msdn.microsoft.com/library/windows/apps/br210411)、[**Point**](https://msdn.microsoft.com/library/windows/apps/br225870)、[**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994)、[**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) などがあります。</span><span class="sxs-lookup"><span data-stu-id="23634-164">These types are: [**Duration**](https://msdn.microsoft.com/library/windows/apps/br242377), [**RepeatBehavior**](https://msdn.microsoft.com/library/windows/apps/br210411), [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870), [**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994) and [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995).</span></span>

## <a name="setting-properties"></a><span data-ttu-id="23634-165">プロパティの設定</span><span class="sxs-lookup"><span data-stu-id="23634-165">Setting properties</span></span>

<span data-ttu-id="23634-166">オブジェクト要素構文を使用して宣言したオブジェクトのプロパティを設定できます。</span><span class="sxs-lookup"><span data-stu-id="23634-166">You can set properties on objects that you declared by using object element syntax.</span></span> <span data-ttu-id="23634-167">XAML では、複数の方法でプロパティを設定できます。</span><span class="sxs-lookup"><span data-stu-id="23634-167">There are multiple ways to set properties in XAML:</span></span>

-   <span data-ttu-id="23634-168">属性構文を使用する。</span><span class="sxs-lookup"><span data-stu-id="23634-168">By using attribute syntax.</span></span>
-   <span data-ttu-id="23634-169">プロパティ要素構文を使用する。</span><span class="sxs-lookup"><span data-stu-id="23634-169">By using property element syntax.</span></span>
-   <span data-ttu-id="23634-170">コンテンツ (内部テキストまたは子要素) によってオブジェクトの XAML コンテンツ プロパティが設定される要素構文を使用する。</span><span class="sxs-lookup"><span data-stu-id="23634-170">By using element syntax where the content (inner text or child elements) is setting the XAML content property of an object.</span></span>
-   <span data-ttu-id="23634-171">コレクション構文を使用する (通常は暗黙的なコレクション構文)。</span><span class="sxs-lookup"><span data-stu-id="23634-171">By using a collection syntax (which is usually the implicit collection syntax).</span></span>

<span data-ttu-id="23634-172">オブジェクトの宣言の場合と同様に、プロパティを設定する際にどの方法でも使用できるというわけではありません。</span><span class="sxs-lookup"><span data-stu-id="23634-172">As with object declaration, this list doesn't imply that any property could be set with each of the techniques.</span></span> <span data-ttu-id="23634-173">一部のプロパティでは、1 種類の方法しかサポートされません。</span><span class="sxs-lookup"><span data-stu-id="23634-173">Some properties support only one of the techniques.</span></span>
<span data-ttu-id="23634-174">プロパティのなかには、複数の形式をサポートしているものもあります。たとえば、プロパティ要素構文と属性構文のどちらも使用できるプロパティもあります。</span><span class="sxs-lookup"><span data-stu-id="23634-174">Some properties support more than one form; for example, there are properties that can use property element syntax, or attribute syntax.</span></span> <span data-ttu-id="23634-175">どれを使用できるかは、プロパティと、そのプロパティが使うオブジェクト型の両方に応じて決まります。</span><span class="sxs-lookup"><span data-stu-id="23634-175">What's possible depends both on the property and on the object type that the property uses.</span></span> <span data-ttu-id="23634-176">Windows ランタイム API リファレンスでは、「**構文**」セクションに、使うことができる XAML の使用方法が表示されます。</span><span class="sxs-lookup"><span data-stu-id="23634-176">In the Windows Runtime API reference, you'll see the XAML usages you can use in the **Syntax** section.</span></span> <span data-ttu-id="23634-177">ときには、使うことができても冗長な別の方法が存在することがあります。</span><span class="sxs-lookup"><span data-stu-id="23634-177">Sometimes there is an alternative usage that would work but would be more verbose.</span></span> <span data-ttu-id="23634-178">そのような冗長な方法は、表示されないこともあります。それは、リファレンスでは XAML でそのプロパティを使うためのベスト プラクティスや実世界のシナリオを示すようにしているためです。</span><span class="sxs-lookup"><span data-stu-id="23634-178">Those verbose usages aren't always shown because we are trying to show you the best practices or the real world scenarios for using that property in XAML.</span></span> <span data-ttu-id="23634-179">XAML で設定できるプロパティのリファレンス ページにある **XAML の使用方法**に関するセクションに、XAML 構文に関するガイダンスが記載されています。</span><span class="sxs-lookup"><span data-stu-id="23634-179">Guidance for XAML syntax is provided in the **XAML Usage** sections of reference pages for properties that can be set in XAML.</span></span>

<span data-ttu-id="23634-180">オブジェクトのプロパティには、XAML では設定できず、コードを使った場合にのみ設定できるプロパティもあります。</span><span class="sxs-lookup"><span data-stu-id="23634-180">Some properties on objects that cannot be set in XAML by any means, and can only be set using code.</span></span> <span data-ttu-id="23634-181">このようなプロパティは通常、XAML よりコード ビハインドで使う方が適しています。</span><span class="sxs-lookup"><span data-stu-id="23634-181">Usually these are properties that are more appropriate to work with in the code-behind, not in XAML.</span></span>

<span data-ttu-id="23634-182">読み取り専用プロパティは、XAML で設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="23634-182">A read-only property cannot be set in XAML.</span></span> <span data-ttu-id="23634-183">コードでも、所有する型はコンストラクター オーバーロード、ヘルパー メソッド、集計プロパティのサポートなど、他の設定方法をサポートしている必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-183">Even in code, the owning type would have to support some other way to set it, like a constructor overload, helper method, or calculated property support.</span></span> <span data-ttu-id="23634-184">集計プロパティは、設定可能な他のプロパティの値のほか、組み込み処理のあるイベントに依存することもあります。これらの機能は、依存関係プロパティ システムで使用できます。</span><span class="sxs-lookup"><span data-stu-id="23634-184">A calculated property relies on the values of other settable properties plus sometimes an event with built-in handling; these features are available in the dependency property system.</span></span> <span data-ttu-id="23634-185">集計プロパティをサポートするうえで依存関係プロパティがいかに便利であるかについて詳しくは、「[依存関係プロパティの概要](dependency-properties-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-185">For more info on how dependency properties are useful for calculated property support, see [Dependency properties overview](dependency-properties-overview.md).</span></span>

<span data-ttu-id="23634-186">XAML のコレクション構文の場合、一見、読み取り専用のプロパティを設定しているかのように見えますが、実際は違います。</span><span class="sxs-lookup"><span data-stu-id="23634-186">Collection syntax in XAML gives an appearance that you are setting a read-only property, but in fact you are not.</span></span> <span data-ttu-id="23634-187">このトピックの「コレクション構文によるプロパティの設定」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-187">See "Setting a Property by Using a Collection Syntax" section later in this topic.</span></span>

### <a name="setting-a-property-by-using-attribute-syntax"></a><span data-ttu-id="23634-188">属性構文によるプロパティの設定</span><span class="sxs-lookup"><span data-stu-id="23634-188">Setting a property by using attribute syntax</span></span>

<span data-ttu-id="23634-189">XML や HTML などのマークアップ言語でプロパティ値を設定するには、属性値を設定するのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="23634-189">Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</span></span> <span data-ttu-id="23634-190">XAML 属性は、XML で属性値を設定する場合と同じように設定できます。</span><span class="sxs-lookup"><span data-stu-id="23634-190">Setting XAML attributes is similar to how you set attribute values in XML.</span></span> <span data-ttu-id="23634-191">タグで囲まれ、要素名に続く任意の場所で属性名を指定します。要素名との間は少なくとも 1 つの空白で区切ります。</span><span class="sxs-lookup"><span data-stu-id="23634-191">The attribute name is specified at any point within the tags following the element name, separated from element name by at least one whitespace.</span></span> <span data-ttu-id="23634-192">属性名の後に、等号を挟んで、</span><span class="sxs-lookup"><span data-stu-id="23634-192">The attribute name is followed by an equals sign.</span></span> <span data-ttu-id="23634-193">引用符で囲んだ属性値を指定します。</span><span class="sxs-lookup"><span data-stu-id="23634-193">The attribute value is contained within a pair of quotes.</span></span> <span data-ttu-id="23634-194">引用符は、値の前後で対応していれば二重引用符と単一引用符のどちらでもかまいません。</span><span class="sxs-lookup"><span data-stu-id="23634-194">The quotes can be either double quotes or single quotes so long as they match and enclose the value.</span></span> <span data-ttu-id="23634-195">属性値は、文字列として表現できる値である必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-195">The attribute value itself must be expressible as a string.</span></span> <span data-ttu-id="23634-196">文字列には数字が含まれることが多いものの、XAML では、XAML パーサーが関与して基本的な値の変換を実行するまで、属性値がすべて文字列値となります。</span><span class="sxs-lookup"><span data-stu-id="23634-196">The string often contains numerals, but to XAML, all attribute values are string values until the XAML parser gets involved and does some basic value conversion.</span></span>

<span data-ttu-id="23634-197">この例では、4 つの属性の属性構文を使用して、[**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle) オブジェクトの [**Name**](https://msdn.microsoft.com/library/windows/apps/br208735)、[**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width)、[**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height)、[**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) の各プロパティを設定しています。</span><span class="sxs-lookup"><span data-stu-id="23634-197">This example uses attribute syntax for four attributes to set the [**Name**](https://msdn.microsoft.com/library/windows/apps/br208735), [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width), [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height), and [**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) properties of a [**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle) object.</span></span>

```xml
<Rectangle Name="rectangle1" Width="100" Height="100" Fill="Blue" />
```

### <a name="setting-a-property-by-using-property-element-syntax"></a><span data-ttu-id="23634-198">プロパティ要素構文によるプロパティの設定</span><span class="sxs-lookup"><span data-stu-id="23634-198">Setting a property by using property element syntax</span></span>

<span data-ttu-id="23634-199">オブジェクトの多くのプロパティは、プロパティ要素構文を使って設定できます。</span><span class="sxs-lookup"><span data-stu-id="23634-199">Many properties of an object can be set by using property element syntax.</span></span> <span data-ttu-id="23634-200">プロパティ要素は次のようになります。`<`*object*`.`*property*`>`</span><span class="sxs-lookup"><span data-stu-id="23634-200">A property element looks like this: `<`*object*`.`*property*`>`.</span></span>

<span data-ttu-id="23634-201">プロパティ要素構文を使うには、設定するプロパティに対応する XAML プロパティ要素を作成します。</span><span class="sxs-lookup"><span data-stu-id="23634-201">To use property element syntax, you create XAML property elements for the property that you want to set.</span></span> <span data-ttu-id="23634-202">標準 XML の場合、この要素は、その名前にドットが含まれている要素と見なされます。</span><span class="sxs-lookup"><span data-stu-id="23634-202">In standard XML, this element would just be considered an element that has a dot in its name.</span></span> <span data-ttu-id="23634-203">しかし、XAML では、要素名に含まれるドットによって、その要素がプロパティ要素であること、つまり、バッキング オブジェクト モデルの実装で *property* が *object* のメンバーになると想定されていることがわかります。</span><span class="sxs-lookup"><span data-stu-id="23634-203">However, in XAML, the dot in the element name identifies the element as a property element, with *property* expected to a member of *object* in a backing object model implementation.</span></span> <span data-ttu-id="23634-204">プロパティ要素構文を使うには、プロパティ要素タグに "設定する" ためにオブジェクト要素を指定できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-204">To use property element syntax, it must be possible to specify an object element in order to "fill" the property element tags.</span></span> <span data-ttu-id="23634-205">プロパティ要素にはコンテンツ (単一の要素、複数の要素、または内部テキスト) が常に存在します。自己終了プロパティ要素を使う意味はありません。</span><span class="sxs-lookup"><span data-stu-id="23634-205">A property element will always have some content (single element, multiple elements, or inner text); there's no point in having a self-closing property element.</span></span>

<span data-ttu-id="23634-206">次の文法では、*property* は設定するプロパティの名前、*propertyValueAsObjectElement* はプロパティの値の型の要件を満たす単一のオブジェクト要素をそれぞれ表します。</span><span class="sxs-lookup"><span data-stu-id="23634-206">In the following grammar, *property* is the name of the property that you want to set and *propertyValueAsObjectElement* is a single object element, that's expected to satisfy the value type requirements of the property.</span></span>

`<`*<span data-ttu-id="23634-207">object</span><span class="sxs-lookup"><span data-stu-id="23634-207">object</span></span>*`>`

`<`<span data-ttu-id="23634-208">*object*`.`*property*</span><span class="sxs-lookup"><span data-stu-id="23634-208">*object*`.`*property*</span></span>`>`

*<span data-ttu-id="23634-209">propertyValueAsObjectElement</span><span class="sxs-lookup"><span data-stu-id="23634-209">propertyValueAsObjectElement</span></span>*

`</`<span data-ttu-id="23634-210">*object*`.`*property*</span><span class="sxs-lookup"><span data-stu-id="23634-210">*object*`.`*property*</span></span>`>`

`</`*<span data-ttu-id="23634-211">object</span><span class="sxs-lookup"><span data-stu-id="23634-211">object</span></span>*`>`

<span data-ttu-id="23634-212">次の例では、プロパティ要素構文を使用して、[**SolidColorBrush**](https://msdn.microsoft.com/library/windows/apps/br242962) オブジェクト要素で [**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle) の [**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) を設定しています </span><span class="sxs-lookup"><span data-stu-id="23634-212">The following example uses property element syntax to set the [**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) of a [**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle) with a [**SolidColorBrush**](https://msdn.microsoft.com/library/windows/apps/br242962) object element.</span></span> <span data-ttu-id="23634-213">(**SolidColorBrush** 内では [**Color**](/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush.Color) が属性として設定されています)。この XAML を解析すると、属性構文を使用して **Fill** を設定した上記の XAML の例とまったく同じ結果になります。</span><span class="sxs-lookup"><span data-stu-id="23634-213">(Within the **SolidColorBrush**, [**Color**](/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush.Color) is set as an attribute.) The parsed result of this XAML is identical to the previous XAML example that set **Fill** using attribute syntax.</span></span>

```xml
<Rectangle
  Name="rectangle1"
  Width="100" 
  Height="100"
> 
  <Rectangle.Fill> 
    <SolidColorBrush Color="Blue"/> 
  </Rectangle.Fill>
</Rectangle>
```

### <a name="xaml-vocabularies-and-object-oriented-programming"></a><span data-ttu-id="23634-214">XAML ボキャブラリとオブジェクト指向のプログラミング</span><span class="sxs-lookup"><span data-stu-id="23634-214">XAML vocabularies and object-oriented programming</span></span>

<span data-ttu-id="23634-215">Windows ランタイムの XAML 型の XAML メンバーとして表示されるプロパティとイベントは、ほとんどの場合基本型から継承されます。</span><span class="sxs-lookup"><span data-stu-id="23634-215">Properties and events as they appear as XAML members of a Windows Runtime XAML type are often inherited from base types.</span></span> <span data-ttu-id="23634-216">`<Button Background="Blue" .../>` を例にして考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="23634-216">Consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="23634-217">[**Background**](https://msdn.microsoft.com/library/windows/apps/br209395) プロパティは、[**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) クラスで即座に宣言されるプロパティではありません。</span><span class="sxs-lookup"><span data-stu-id="23634-217">The [**Background**](https://msdn.microsoft.com/library/windows/apps/br209395) property is not an immediately declared property on the [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) class.</span></span> <span data-ttu-id="23634-218">代わりに、[**Control**](https://msdn.microsoft.com/library/windows/apps/br209390) 基底クラスから **Background** が継承されます。</span><span class="sxs-lookup"><span data-stu-id="23634-218">Instead, **Background** is inherited from the base [**Control**](https://msdn.microsoft.com/library/windows/apps/br209390) class.</span></span> <span data-ttu-id="23634-219">実際、**Button** に関するリファレンスのトピックを見ると、メンバーのリストには連続した基底クラス ([**ButtonBase**](https://msdn.microsoft.com/library/windows/apps/br227736)、[**Control**](https://msdn.microsoft.com/library/windows/apps/br209390)、[**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706)、[**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911)、[**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)) の各チェーンから継承されたメンバーが少なくとも 1 つ含まれることがわかります。</span><span class="sxs-lookup"><span data-stu-id="23634-219">In fact, if you look at the reference topic for **Button** you'll see that the members lists contain at least one inherited member from each of a chain of successive base classes: [**ButtonBase**](https://msdn.microsoft.com/library/windows/apps/br227736), [**Control**](https://msdn.microsoft.com/library/windows/apps/br209390), [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706), [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911), [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356).</span></span> <span data-ttu-id="23634-220">**[プロパティ]** の一覧では、読み取り/書き込みプロパティとコレクション プロパティがすべて、XAML ボキャブラリという意味で継承されます。</span><span class="sxs-lookup"><span data-stu-id="23634-220">In the **Properties** list, all the read-write properties and collection properties are inherited in a XAML vocabulary sense.</span></span> <span data-ttu-id="23634-221">ほかには、イベント (さまざまな [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) イベントなど) が継承されます。</span><span class="sxs-lookup"><span data-stu-id="23634-221">Events (like the various [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) events) are inherited too.</span></span>

<span data-ttu-id="23634-222">XAML のガイダンスに Windows ランタイム リファレンスを使う場合には、構文やコード例に示されている要素名が、プロパティを定義する型の名前のこともあります。これは、リファレンスのそのトピックが基底クラスからプロパティを継承する型になる可能性のあるものすべてに共通するものであるためです。</span><span class="sxs-lookup"><span data-stu-id="23634-222">If you use the Windows Runtime reference for XAML guidance, the element name that's shown in a syntax or even in example code is sometimes for the type that originally defines the property, because that reference topic is shared by all the possible types that inherit it from a base class.</span></span> <span data-ttu-id="23634-223">Visual Studio の XML エディターで IntelliSense for XAML を使うと、IntelliSense とそのドロップダウン リストによって継承が結合されるほか、クラス インスタンスのオブジェクト要素を開始した時点で設定に利用できる属性の正確な一覧が提供されます。</span><span class="sxs-lookup"><span data-stu-id="23634-223">If you use Visual Studio's IntelliSense for XAML in the XML editor, the IntelliSense and its drop-downs do a great job of coalescing the inheritance and providing an accurate list of attributes that are available for setting once you've started with an object element for a class instance.</span></span>

### <a name="xaml-content-properties"></a><span data-ttu-id="23634-224">XAML コンテンツ プロパティ</span><span class="sxs-lookup"><span data-stu-id="23634-224">XAML content properties</span></span>

<span data-ttu-id="23634-225">一部の型には、XAML コンテンツ構文を有効にするように定義されたプロパティが 1 つ含まれています。</span><span class="sxs-lookup"><span data-stu-id="23634-225">Some types define one of their properties such that the property enables a XAML content syntax.</span></span> <span data-ttu-id="23634-226">型に XAML コンテンツ プロパティが含まれている場合には、XAML でプロパティ要素を指定するときにそのプロパティのプロパティ要素を省略できます。</span><span class="sxs-lookup"><span data-stu-id="23634-226">For the XAML content property of a type, you can omit the property element for that property when specifying it in XAML.</span></span> <span data-ttu-id="23634-227">つまり、所有する型のオブジェクト要素タグ内で直接内部テキストを指定することによって、プロパティをその内部テキストの値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="23634-227">Or, you can set the property to an inner text value by providing that inner text directly within the owning type's object element tags.</span></span> <span data-ttu-id="23634-228">XAML コンテンツ プロパティでは、そのプロパティのマークアップ構文を単純化できるため、入れ子の数を少なくすることによって XAML をわかりやすくすることができます。</span><span class="sxs-lookup"><span data-stu-id="23634-228">XAML content properties support straightforward markup syntax for that property and makes the XAML more human-readable by reducing the nesting.</span></span>

<span data-ttu-id="23634-229">XAML コンテンツ構文が利用できる場合、Windows ランタイム リファレンス ドキュメントでは、該当するプロパティの「**構文**」の XAML に関するセクションにその構文が示されています。</span><span class="sxs-lookup"><span data-stu-id="23634-229">If a XAML content syntax is available, that syntax will be shown in the "XAML" sections of **Syntax** for that property in the Windows Runtime reference documentation.</span></span> <span data-ttu-id="23634-230">たとえば、[**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) の [**Child**](https://msdn.microsoft.com/library/windows/apps/br209258) プロパティのページには、プロパティ要素構文の代わりに、**Border** の単一オブジェクト **Border.Child** 値を設定する XAML コンテンツ構文が示されています。</span><span class="sxs-lookup"><span data-stu-id="23634-230">For example, the [**Child**](https://msdn.microsoft.com/library/windows/apps/br209258) property page for [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) shows XAML content syntax instead of property element syntax to set the single-object **Border.Child** value of a **Border**, like this:</span></span>

```xml
<Border>
  <Button .../>
</Border>
```

<span data-ttu-id="23634-231">XAML コンテンツ プロパティとして宣言されているプロパティで、プロパティの型が **Object** と **String** のいずれかの場合には、基本的に XML ドキュメント モデルの内部テキストになるもの (開始オブジェクト タグと終了オブジェクト タグの間の文字列) が XAML コンテンツ構文でサポートされます。</span><span class="sxs-lookup"><span data-stu-id="23634-231">If the property that is declared as the XAML content property is the **Object** type, or is type **String**, then the XAML content syntax supports what's basically inner text in the XML document model: a string between the opening and closing object tags.</span></span> <span data-ttu-id="23634-232">たとえば、[**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) の [**Text**](https://msdn.microsoft.com/library/windows/apps/br209676) プロパティのページには、**Text** を設定する内部テキスト値のある XAML 構文が示されていますが、文字列 "Text" が表示されることはありません。</span><span class="sxs-lookup"><span data-stu-id="23634-232">For example, the [**Text**](https://msdn.microsoft.com/library/windows/apps/br209676) property page for [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) shows XAML content syntax that has an inner text value to set **Text**, but the string "Text" never appears in the markup.</span></span> <span data-ttu-id="23634-233">次に使用方法の例を示します。</span><span class="sxs-lookup"><span data-stu-id="23634-233">Here's an example usage:</span></span>

```xml
<TextBlock>Hello!</TextBlock>
```

<span data-ttu-id="23634-234">あるクラスに XAML コンテンツ プロパティが存在する場合には、そのクラスに関するリファレンス トピックの「属性」のセクションに記載されています。</span><span class="sxs-lookup"><span data-stu-id="23634-234">If a XAML content property exists for a class, that's indicated in the reference topic for the class, in the "Attributes" section.</span></span> <span data-ttu-id="23634-235">[**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011) の値を検索します。</span><span class="sxs-lookup"><span data-stu-id="23634-235">Look for the value of the [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011).</span></span> <span data-ttu-id="23634-236">この属性は名前の付いたフィールド、"Name" を使います。</span><span class="sxs-lookup"><span data-stu-id="23634-236">This attribute uses a named field "Name".</span></span> <span data-ttu-id="23634-237">"Name" の値は、XAML コンテンツ プロパティとなるクラスのプロパティの名前です。</span><span class="sxs-lookup"><span data-stu-id="23634-237">The value of "Name" is the name of the property of that class that is the XAML content property.</span></span> <span data-ttu-id="23634-238">たとえば、[**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) リファレンス ページでは、ContentProperty("Name=Child") と表示されています。</span><span class="sxs-lookup"><span data-stu-id="23634-238">For example, on the [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) reference page, you'll see this: ContentProperty("Name=Child").</span></span>

<span data-ttu-id="23634-239">ここで重要になる XAML 構文の規則の 1 つは、XAML コンテンツ プロパティ要素と、その要素で設定する他のプロパティ要素は混在できないというものです。</span><span class="sxs-lookup"><span data-stu-id="23634-239">One important XAML syntax rule we should mention is that you can't intermix the XAML content property and other property elements you set on the element.</span></span> <span data-ttu-id="23634-240">XAML コンテンツ プロパティは、プロパティ要素の前か、後に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-240">The XAML content property must be set entirely before any property elements, or entirely after.</span></span> <span data-ttu-id="23634-241">たとえば、このような XAML は無効です。</span><span class="sxs-lookup"><span data-stu-id="23634-241">For example this is invalid XAML:</span></span>

``` syntax
<StackPanel>
  <Button>This example</Button>
  <StackPanel.Resources>
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>
  </StackPanel.Resources>
  <Button>... is illegal XAML</Button>
</StackPanel>
```

## <a name="collection-syntax"></a><span data-ttu-id="23634-242">コレクション構文</span><span class="sxs-lookup"><span data-stu-id="23634-242">Collection syntax</span></span>

<span data-ttu-id="23634-243">これまでに見てきた構文はすべて、プロパティを 1 つのオブジェクトに設定しています。</span><span class="sxs-lookup"><span data-stu-id="23634-243">All of the syntaxes shown thus far are setting properties to single objects.</span></span> <span data-ttu-id="23634-244">しかし、複数の子要素を持つ親要素が必要な UI シナリオも数多くあります。</span><span class="sxs-lookup"><span data-stu-id="23634-244">But many UI scenarios require that a given parent element can have multiple child elements.</span></span> <span data-ttu-id="23634-245">たとえば、入力フォームの UI では、複数のテキスト ボックス要素、いくつかのラベル、そしておそらくは 1 つの "Submit" ボタンが必要になります。</span><span class="sxs-lookup"><span data-stu-id="23634-245">For example, a UI for an input form needs several text box elements, some labels, and perhaps a "Submit" button.</span></span> <span data-ttu-id="23634-246">それでも、プログラミング オブジェクト モデルを使用してそれらの要素にアクセスする場合は、別々のプロパティの値としてアクセスするのではなく、1 つのコレクション プロパティの項目としてアクセスするのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="23634-246">Still, if you were to use a programming object model to access these multiple elements, they would typically be items in a single collection property, rather than each item being the value of different properties.</span></span> <span data-ttu-id="23634-247">XAML では、複数の子要素や、一般的なバッキング コレクション モデルがサポートされています。これは、暗黙的にコレクション型を使うプロパティを扱い、コレクション型の子要素を特別な方法で処理することによって実現されます。</span><span class="sxs-lookup"><span data-stu-id="23634-247">XAML supports multiple child elements as well as supporting a typical backing collection model by treating properties that use a collection type as implicit, and performing special handling for any child elements of a collection type.</span></span>

<span data-ttu-id="23634-248">このほか、多くのコレクション プロパティが、クラスの XAML コンテンツ プロパティとして識別されます。</span><span class="sxs-lookup"><span data-stu-id="23634-248">Many collection properties are also identified as the XAML content property for the class.</span></span> <span data-ttu-id="23634-249">暗黙的なコレクション処理と XAML コンテンツ構文を組み合わせた記述は、パネル、ビュー、項目コントロールなどのコントロールを合成するために広く使われる型によく見られます。</span><span class="sxs-lookup"><span data-stu-id="23634-249">The combination of implicit collection processing and XAML content syntax is frequently seen in types used for control compositing, such as panels, views, or items controls.</span></span> <span data-ttu-id="23634-250">次の例は、[**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) 内で 2 つのピア UI 要素を合成させる XAML を可能な限り単純化したものです。</span><span class="sxs-lookup"><span data-stu-id="23634-250">For example, the following examples show the simplest possible XAML for compositing two peer UI elements within a [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635).</span></span>

```xml
<StackPanel>
  <TextBlock>Hello</TextBlock>
  <TextBlock>World</TextBlock>
</StackPanel>
```

### <a name="the-mechanism-of-xaml-collection-syntax"></a><span data-ttu-id="23634-251">XAML コレクション構文のメカニズム</span><span class="sxs-lookup"><span data-stu-id="23634-251">The mechanism of XAML collection syntax</span></span>

<span data-ttu-id="23634-252">最初は、XAML で読み取り専用のコレクションのプロパティを "設定" しているかのように思えます。</span><span class="sxs-lookup"><span data-stu-id="23634-252">It might at first appear that XAML is enabling a "set" of the read-only collection property.</span></span> <span data-ttu-id="23634-253">しかし、実際には、XAML によって実現されているのは、既にあるコレクションに項目を追加することです。</span><span class="sxs-lookup"><span data-stu-id="23634-253">In reality, what XAML enables here is adding items to an existing collection.</span></span> <span data-ttu-id="23634-254">XAML のサポートを実装する XAML 言語および XAML プロセッサは、この構文を有効にするためにバッキング コレクション型の規則に依存します。</span><span class="sxs-lookup"><span data-stu-id="23634-254">The XAML language and XAML processors implementing XAML support rely on a convention in backing collection types to enable this syntax.</span></span> <span data-ttu-id="23634-255">通常は、コレクションの特定の項目を参照するインデクサーや **Items** プロパティなどのバッキング プロパティが存在しますが、</span><span class="sxs-lookup"><span data-stu-id="23634-255">Typically there is a backing property such as an indexer or **Items** property that refers to specific items of the collection.</span></span> <span data-ttu-id="23634-256">XAML 構文では、一般にそのようなプロパティは明示されません。</span><span class="sxs-lookup"><span data-stu-id="23634-256">Generally, that property is not explicit in the XAML syntax.</span></span> <span data-ttu-id="23634-257">コレクションの場合、XAML の解析の基になるメカニズムは、プロパティではなくメソッド (ほとんどの場合 **Add** メソッド) です。</span><span class="sxs-lookup"><span data-stu-id="23634-257">For collections, the underlying mechanism for XAML parsing is not a property, but a method: specifically, the **Add** method in most cases.</span></span> <span data-ttu-id="23634-258">XAML プロセッサが XAML コレクション構文内に 1 つまたは複数のオブジェクト要素を見つけると、各オブジェクトが要素から作成され、次に、コレクションの **Add** メソッドの呼び出しによって、新しく作成された各オブジェクトが格納先のコレクションに順番に追加されます。</span><span class="sxs-lookup"><span data-stu-id="23634-258">When the XAML processor encounters one or more object elements within a XAML collection syntax, each such object is first created from an element, then each new object is added in order to the containing collection by calling the collection's **Add** method.</span></span>

<span data-ttu-id="23634-259">XAML パーサーによってコレクションに項目が追加されるときに、特定の XAML 要素がコレクション オブジェクトの子項目として許容されるかどうかは、**Add** メソッドのロジックによって決まります。</span><span class="sxs-lookup"><span data-stu-id="23634-259">When a XAML parser adds items to a collection, it is the logic of the **Add** method that determines whether a given XAML element is a permissible item child of the collection object.</span></span> <span data-ttu-id="23634-260">多くのコレクション型はバッキング実装によって厳密に型指定されているため、**Add** の入力パラメーターに渡される値の型が **Add** のパラメーター型と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-260">Many collection types are strongly typed by the backing implementation, meaning that the input parameter of **Add** expects that whatever is passed must be a type match with the **Add** parameter type.</span></span>

<span data-ttu-id="23634-261">コレクション プロパティでは、オブジェクト要素としてコレクションを明示的に指定するときには注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="23634-261">For collection properties, be careful about when you try to specify the collection explicitly as an object element.</span></span> <span data-ttu-id="23634-262">XAML パーサーは、オブジェクト要素を検出するたびに新しいオブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="23634-262">A XAML parser will create a new object whenever it encounters an object element.</span></span> <span data-ttu-id="23634-263">使おうとしているコレクション プロパティが読み取り専用の場合には、XAML 解析で例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="23634-263">If the collection property you're trying to use is read-only, this can throw a XAML parse exception.</span></span> <span data-ttu-id="23634-264">暗黙的なコレクション構文だけを使えば、その例外が表示されることはありません。</span><span class="sxs-lookup"><span data-stu-id="23634-264">Just use the implicit collection syntax, and you won't see that exception.</span></span>

## <a name="when-to-use-attribute-or-property-element-syntax"></a><span data-ttu-id="23634-265">属性構文を使用する状況とプロパティ要素構文を使用する状況</span><span class="sxs-lookup"><span data-stu-id="23634-265">When to use attribute or property element syntax</span></span>

<span data-ttu-id="23634-266">XAML で設定可能なプロパティはいずれも、直接値を設定するための属性構文またはプロパティ要素構文をサポートしますが、両方の構文をサポートしない可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="23634-266">All properties that support being set in XAML will support attribute or property element syntax for direct value setting, but potentially will not support either syntax interchangeably.</span></span> <span data-ttu-id="23634-267">いずれかの構文をサポートするプロパティもあれば、XAML コンテンツ プロパティなど、他の構文オプションをサポートしているプロパティもあります。</span><span class="sxs-lookup"><span data-stu-id="23634-267">Some properties do support either syntax, and some properties support additional syntax options like a XAML content property.</span></span> <span data-ttu-id="23634-268">プロパティでサポートされる XAML 構文の種類は、そのプロパティでプロパティの型として使われるオブジェクトの型によって決まります。</span><span class="sxs-lookup"><span data-stu-id="23634-268">The type of XAML syntax supported by a property depends on the type of object that the property uses as its property type.</span></span> <span data-ttu-id="23634-269">プロパティ型が double (float または decimal)、integer、Boolean、string など、プリミティブ型の場合には、そのプロパティは常に属性構文をサポートします。</span><span class="sxs-lookup"><span data-stu-id="23634-269">If the property type is a primitive type, such as a double (float or decimal), integer, Boolean, or string, the property always supports attribute syntax.</span></span>

<span data-ttu-id="23634-270">プロパティを設定する際、その設定に使うオブジェクト型を文字列の処理によって作成できる場合も、属性構文を使用できます。</span><span class="sxs-lookup"><span data-stu-id="23634-270">You can also use attribute syntax to set a property if the object type you use to set that property can be created by processing a string.</span></span> <span data-ttu-id="23634-271">プリミティブではこれが常に当てはまり、パーサーには型変換が組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="23634-271">For primitives, this is always the case, the type conversion is built in to the parser.</span></span> <span data-ttu-id="23634-272">ただし、その他のオブジェクト型のなかにも、プロパティ要素内のオブジェクト要素ではなく、属性値として指定された文字列を使って作成できるものがあります。</span><span class="sxs-lookup"><span data-stu-id="23634-272">However, certain other object types can also be created by using a string specified as an attribute value, rather than an object element within a property element.</span></span> <span data-ttu-id="23634-273">これを正しく機能させるには、基になる型変換が必要です。この型変換は、特定のプロパティでサポートされるか、該当するプロパティ型を使う値すべてでサポートされます。</span><span class="sxs-lookup"><span data-stu-id="23634-273">For this to work, there has to be an underlying type conversion, supported either by that particular property or supported generally for all values that use that property type.</span></span> <span data-ttu-id="23634-274">属性の文字列値を使って、新しいオブジェクト値の初期化にとって重要なプロパティが設定されます。</span><span class="sxs-lookup"><span data-stu-id="23634-274">The string value of the attribute is used to set properties that are important for the initialization of the new object value.</span></span> <span data-ttu-id="23634-275">型コンバーターによっては、文字列の情報を処理する方法に応じて、一般的なプロパティ型のさまざまなサブクラスが作成される可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="23634-275">Potentially, a specific type converter can also create different subclasses of a common property type, depending on how it uniquely processes information in the string.</span></span> <span data-ttu-id="23634-276">この動作をサポートするオブジェクト型は、リファレンス ドキュメントの構文のセクションに特別な文法が記載されます。</span><span class="sxs-lookup"><span data-stu-id="23634-276">Object types that support this behavior will have a special grammar listed in the syntax section of the reference documentation.</span></span> <span data-ttu-id="23634-277">たとえば、[**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) の XAML 構文では、属性構文を使って **Brush** 型のプロパティの新しい [**SolidColorBrush**](https://msdn.microsoft.com/library/windows/apps/br242962) 値を作成する方法を示しています (Windows ランタイム XAML には多数の **Brush** プロパティがあります)。</span><span class="sxs-lookup"><span data-stu-id="23634-277">As an example, the XAML syntax for [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) shows how an attribute syntax can be used to create a new [**SolidColorBrush**](https://msdn.microsoft.com/library/windows/apps/br242962) value for any property of type **Brush** (and there are many **Brush** properties in Windows Runtime XAML).</span></span>

## <a name="xaml-parsing-logic-and-rules"></a><span data-ttu-id="23634-278">XAML 解析のロジックと規則</span><span class="sxs-lookup"><span data-stu-id="23634-278">XAML parsing logic and rules</span></span>

<span data-ttu-id="23634-279">XAML パーサーが XAML を読み取るのと似た (文字列トークンのセットを順番に読み取っていく) 方法で XAML を読んでみると、有益な情報が得られることがあります。</span><span class="sxs-lookup"><span data-stu-id="23634-279">Sometime's it's informative to read the XAML in a similar way to how a XAML parser must read it: as a set of string tokens encountered in a linear order.</span></span> <span data-ttu-id="23634-280">XAML パーサーは、XAML の動作に関する定義に含まれる規則に基づいて、トークンを解釈する必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-280">A XAML parser must interpret these tokens under a set of rules that are part of the definition of how XAML works.</span></span>

<span data-ttu-id="23634-281">XML や HTML などのマークアップ言語でプロパティ値を設定するには、属性値を設定するのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="23634-281">Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</span></span> <span data-ttu-id="23634-282">次の構文では、*objectName* はインスタンス化するオブジェクト、*propertyName* はそのオブジェクトに設定するプロパティの名前、*propertyValue* は設定する値をそれぞれ表します。</span><span class="sxs-lookup"><span data-stu-id="23634-282">In the following syntax, *objectName* is the object you want to instantiate, *propertyName* is the name of the property that you want to set on that object, and *propertyValue* is the value to set.</span></span>

```xml
<objectName propertyName="propertyValue" .../>

-or-

<objectName propertyName="propertyValue">

...<!--element children -->

</objectName>
```

<span data-ttu-id="23634-283">このどちらの構文でも、オブジェクトを宣言し、そのオブジェクトのプロパティを設定できます。</span><span class="sxs-lookup"><span data-stu-id="23634-283">Either syntax enables you to declare an object and set a property on that object.</span></span> <span data-ttu-id="23634-284">最初のサンプルは、1 つのマークアップ要素ですが、このマークアップの解析は、実際には XAML プロセッサで別々の手順で行われます。</span><span class="sxs-lookup"><span data-stu-id="23634-284">Although the first example is a single element in markup, there are actually discrete steps here with regard to how a XAML processor parses this markup.</span></span>

<span data-ttu-id="23634-285">まず、オブジェクト要素があるので、新しい *objectName* オブジェクトをインスタンス化する必要があることがわかります。</span><span class="sxs-lookup"><span data-stu-id="23634-285">First, the presence of the object element indicates that a new *objectName* object must be instantiated.</span></span> <span data-ttu-id="23634-286">そのようなインスタンスが作成された後にのみ、そのインスタンスにインスタンス プロパティ *propertyName* を設定できます。</span><span class="sxs-lookup"><span data-stu-id="23634-286">Only after such an instance exists can the instance property *propertyName* can be set on it.</span></span>

<span data-ttu-id="23634-287">XAML のもう 1 つの規則は、要素の属性がどのような順序でも設定できる必要があるというものです。</span><span class="sxs-lookup"><span data-stu-id="23634-287">Another rule of XAML is that attributes of an element must be able to be set in any order.</span></span> <span data-ttu-id="23634-288">たとえば、`<Rectangle Height="50" Width="100" />` と `<Rectangle Width="100"  Height="50" />` の間には違いがありません。</span><span class="sxs-lookup"><span data-stu-id="23634-288">For example, there's no difference between `<Rectangle Height="50" Width="100" />` and `<Rectangle Width="100"  Height="50" />`.</span></span> <span data-ttu-id="23634-289">順序をどちらにするかは、スタイルの問題です。</span><span class="sxs-lookup"><span data-stu-id="23634-289">Which order you use is a matter of style.</span></span>

<span data-ttu-id="23634-290">**注:** XML エディター以外のデザイン サーフェイスを使うと、通常は XAML デザイナーによって並び順の規則が提示されますが、その XAML は後で自由に編集して、属性を並べ替えたり、新たな属性を導入したりできます。</span><span class="sxs-lookup"><span data-stu-id="23634-290">**Note**  XAML designers often promote ordering conventions if you use design surfaces other than the XML editor, but you can freely edit that XAML later, to reorder the attributes or introduce new ones.</span></span>

## <a name="attached-properties"></a><span data-ttu-id="23634-291">添付プロパティ</span><span class="sxs-lookup"><span data-stu-id="23634-291">Attached properties</span></span>

<span data-ttu-id="23634-292">XAML は、*添付プロパティ*と呼ばれる構文要素を追加することによって XML を拡張したものです。</span><span class="sxs-lookup"><span data-stu-id="23634-292">XAML extends XML by adding a syntax element known as an *attached property*.</span></span> <span data-ttu-id="23634-293">プロパティ要素構文と同様に、添付プロパティ構文にはドットが含まれます。このドットは XAML 解析にとって特別な意味があります。</span><span class="sxs-lookup"><span data-stu-id="23634-293">Similar to the property element syntax, the attached property syntax contains a dot, and the dot holds special meaning to XAML parsing.</span></span> <span data-ttu-id="23634-294">具体的には、添付プロパティの所有者プロバイダーとプロパティ名がドットで区切られます。</span><span class="sxs-lookup"><span data-stu-id="23634-294">Specifically, the dot separates the owner provider of the attached property, and the property name.</span></span>

<span data-ttu-id="23634-295">XAML では、*AttachedPropertyProvider*.*PropertyName* 構文を使って添付プロパティを設定します。XAML で添付プロパティ [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) を設定する例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23634-295">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName* Here is an example of how you can set the attached property [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) in XAML:</span></span>

```xml
<Canvas>
  <Button Canvas.Left="50">Hello</Button>
</Canvas>
```

<span data-ttu-id="23634-296">添付プロパティは、バッキング型に同じ名前のプロパティがない要素に設定できます。そのため、添付プロパティの機能は、グローバル プロパティ、または異なる XML 名前空間によって定義される属性 (**xml:space** 属性など) に似ています。</span><span class="sxs-lookup"><span data-stu-id="23634-296">You can set the attached property on elements that don't have a property of that name in the backing type, and in that way they function somewhat like a global property, or an attribute defined by a different XML namespace like the **xml:space** attribute.</span></span>

<span data-ttu-id="23634-297">Windows ランタイム XAML には、次のシナリオをサポートする添付プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="23634-297">In Windows Runtime XAML you'll see attached properties that support these scenarios:</span></span>

-   <span data-ttu-id="23634-298">子要素が親コンテナーのパネルにレイアウト内での動作を通知する: [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267)、[**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704)、[**VariableSizedWrapGrid**](https://msdn.microsoft.com/library/windows/apps/br227651)。</span><span class="sxs-lookup"><span data-stu-id="23634-298">Child elements can inform parent container panels how they should behave in layout: [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267), [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704), [**VariableSizedWrapGrid**](https://msdn.microsoft.com/library/windows/apps/br227651).</span></span>
-   <span data-ttu-id="23634-299">コントロールの使用が、コントロール テンプレートから取得するコントロールの重要性の高い部分の動作に影響を及ぼす: [**ScrollViewer**](https://msdn.microsoft.com/library/windows/apps/br209527)、[**VirtualizingStackPanel**](https://msdn.microsoft.com/library/windows/apps/br227689)。</span><span class="sxs-lookup"><span data-stu-id="23634-299">Control usages can influence behavior of an important control part that comes from the control template: [**ScrollViewer**](https://msdn.microsoft.com/library/windows/apps/br209527), [**VirtualizingStackPanel**](https://msdn.microsoft.com/library/windows/apps/br227689).</span></span>
-   <span data-ttu-id="23634-300">サービスと、そのサービスを使うクラスが継承を共有しない場合に、関連クラスで利用できるサービスを利用する: [**Typography**](https://msdn.microsoft.com/library/windows/apps/hh702143)、[**VisualStateManager**](https://msdn.microsoft.com/library/windows/apps/br209021)、[**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/br209081)、[**ToolTipService**](https://msdn.microsoft.com/library/windows/apps/br227609)。</span><span class="sxs-lookup"><span data-stu-id="23634-300">Using a service that's available in a related class, where the service and the class that uses it don't share inheritance: [**Typography**](https://msdn.microsoft.com/library/windows/apps/hh702143), [**VisualStateManager**](https://msdn.microsoft.com/library/windows/apps/br209021), [**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/br209081), [**ToolTipService**](https://msdn.microsoft.com/library/windows/apps/br227609).</span></span>
-   <span data-ttu-id="23634-301">アニメーションのターゲット設定: [**Storyboard**](https://msdn.microsoft.com/library/windows/apps/br210490)。</span><span class="sxs-lookup"><span data-stu-id="23634-301">Animation targeting: [**Storyboard**](https://msdn.microsoft.com/library/windows/apps/br210490).</span></span>

<span data-ttu-id="23634-302">詳しくは、「[添付プロパティの概要](attached-properties-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-302">For more info, see [Attached properties overview](attached-properties-overview.md).</span></span>

## <a name="literal--values"></a><span data-ttu-id="23634-303">リテラルの "{" 値</span><span class="sxs-lookup"><span data-stu-id="23634-303">Literal "{" values</span></span>

<span data-ttu-id="23634-304">左中かっこ記号 (\{) はマークアップ拡張シーケンスの開始を表すため、この記号で始まるリテラル文字列値を指定するには、エスケープ シーケンスを使う必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-304">Because the opening brace symbol \{ is the opening of the markup extension sequence, you use an escape sequence to specify a literal string value that starts with "\{".</span></span> <span data-ttu-id="23634-305">エスケープ シーケンスは "\{\}" です。</span><span class="sxs-lookup"><span data-stu-id="23634-305">The escape sequence is "\{\}".</span></span> <span data-ttu-id="23634-306">たとえば、単一の左中かっこを表す文字列値を指定するには、属性値を "\{\}\{" として指定します。</span><span class="sxs-lookup"><span data-stu-id="23634-306">For example, to specify a string value that is a single opening brace, specify the attribute value as "\{\}\{".</span></span> <span data-ttu-id="23634-307">このほか、"\{" 値を文字列として指定するために、代替引用符 (**""** で区切られた属性値内の **'** など) を使うこともできます。</span><span class="sxs-lookup"><span data-stu-id="23634-307">You can also use the alternative quotation marks (for example, a **'** within an attribute value delimited by **""**) to provide a "\{" value as a string.</span></span>

<span data-ttu-id="23634-308">**注:** "\\}" は、引用符で囲まれている属性の内側にある場合にも機能します。</span><span class="sxs-lookup"><span data-stu-id="23634-308">**Note**  "\\}" also works if it's inside a quoted attribute.</span></span>
 
## <a name="enumeration-values"></a><span data-ttu-id="23634-309">列挙値</span><span class="sxs-lookup"><span data-stu-id="23634-309">Enumeration values</span></span>

<span data-ttu-id="23634-310">Windows ランタイム API の多くのプロパティでは、値として列挙型が使われます。</span><span class="sxs-lookup"><span data-stu-id="23634-310">Many properties in the Windows Runtime API use enumerations as values.</span></span> <span data-ttu-id="23634-311">メンバーが読み取り/書き込みプロパティの場合には、属性値を指定することによって設定できます。</span><span class="sxs-lookup"><span data-stu-id="23634-311">If the member is a read-write property you can set such a property by providing an attribute value.</span></span> <span data-ttu-id="23634-312">プロパティの値に使う列挙値を指定するには、定数名の非修飾名を使います。</span><span class="sxs-lookup"><span data-stu-id="23634-312">You identify which enumeration value to use as the value of the property by using the unqualified name of the constant name .</span></span> <span data-ttu-id="23634-313">たとえば、XAML で [**UIElement.Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992) を設定するには、`<Button Visibility="Visible"/>` のように記述します。</span><span class="sxs-lookup"><span data-stu-id="23634-313">For example here's how to set [**UIElement.Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992) in XAML: `<Button Visibility="Visible"/>`.</span></span> <span data-ttu-id="23634-314">次に、文字列として "Visible" が [**Visibility**](https://msdn.microsoft.com/library/windows/apps/br209006) 列挙値、**Visible** の名前付きの定数に直接マップされます。</span><span class="sxs-lookup"><span data-stu-id="23634-314">Here the "Visible" as a string is directly mapped to a named constant of the [**Visibility**](https://msdn.microsoft.com/library/windows/apps/br209006) enumeration, **Visible**.</span></span>

-   <span data-ttu-id="23634-315">修飾された形式は機能しないので、使わないでください。</span><span class="sxs-lookup"><span data-stu-id="23634-315">Don't use a qualified form, it won't work.</span></span> <span data-ttu-id="23634-316">たとえば、`<Button Visibility="Visibility.Visible"/>` のような XAML は無効です。</span><span class="sxs-lookup"><span data-stu-id="23634-316">For example, this is invalid XAML: `<Button Visibility="Visibility.Visible"/>`.</span></span>
-   <span data-ttu-id="23634-317">定数の値を使わないでください。</span><span class="sxs-lookup"><span data-stu-id="23634-317">Don't use the value of the constant.</span></span> <span data-ttu-id="23634-318">要するに、列挙体の整数値に依存しないようにしてください。この整数値は、明示的または暗黙的な列挙体の定義方法に応じて変わります。</span><span class="sxs-lookup"><span data-stu-id="23634-318">In other words, don't rely on the integer value of the enumeration that's there explicitly or implicitly depending on how the enumeration was defined.</span></span> <span data-ttu-id="23634-319">一見、機能しているように見えても、永続的でない実装の詳細となるものに依存しているため、XAML でもコードでも好ましくない方法です。</span><span class="sxs-lookup"><span data-stu-id="23634-319">Although it might appear to work, it's a bad practice either in XAML or in code because you're relying on what could be a transient implementation detail.</span></span> <span data-ttu-id="23634-320">たとえば、`<Button Visibility="1"/>` のように記述しないでください。</span><span class="sxs-lookup"><span data-stu-id="23634-320">For example, don't do this: `<Button Visibility="1"/>`.</span></span>

<span data-ttu-id="23634-321">**注:** XAML と列挙体を使う API のリファレンス トピックで、「**構文**」の「**プロパティ値**」セクションに表示される列挙型へのリンクをクリックします。</span><span class="sxs-lookup"><span data-stu-id="23634-321">**Note**  In reference topics for APIs that use XAML and use enumerations, click the link to the enumeration type in the **Property value** section of **Syntax**.</span></span> <span data-ttu-id="23634-322">列挙体のページに移動するので、その列挙体の名前付き定数を確認できます。</span><span class="sxs-lookup"><span data-stu-id="23634-322">This links to the enumeration page where you can discover the named constants for that enumeration.</span></span>

<span data-ttu-id="23634-323">列挙体は、フラグのように機能します。つまり、**FlagsAttribute** で属性が設定されます。</span><span class="sxs-lookup"><span data-stu-id="23634-323">Enumerations can be flagwise, meaning that they are attributed with **FlagsAttribute**.</span></span> <span data-ttu-id="23634-324">フラグのように機能する列挙体の値の組み合わせを XAML 属性値として指定する必要がある場合は、各列挙体定数の名前を使います。各名前はコンマ (,) で区切り、空白文字は含めません。</span><span class="sxs-lookup"><span data-stu-id="23634-324">If you need to specify a combination of values for a flagwise enumeration as a XAML attribute value, use the name of each enumeration constant, with a comma (,) between each name, and no intervening space characters.</span></span> <span data-ttu-id="23634-325">フラグのような属性は、Windows ランタイム XAML ボキャブラリでは一般的ではありませんが、それが利用できる例の 1 つが [**ManipulationModes**](https://msdn.microsoft.com/library/windows/apps/br227934) で、XAML でフラグのように機能する列挙値の設定がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="23634-325">Flagwise attributes aren't common in the Windows Runtime XAML vocabulary, but [**ManipulationModes**](https://msdn.microsoft.com/library/windows/apps/br227934) is an example where setting a flagwise enumeration value in XAML is supported.</span></span>

## <a name="interfaces-in-xaml"></a><span data-ttu-id="23634-326">XAML でのインターフェイス</span><span class="sxs-lookup"><span data-stu-id="23634-326">Interfaces in XAML</span></span>

<span data-ttu-id="23634-327">まれに、プロパティの型がインターフェイスである XAML 構文があります。</span><span class="sxs-lookup"><span data-stu-id="23634-327">In rare cases you'll see a XAML syntax where the type of a property is an interface.</span></span> <span data-ttu-id="23634-328">XAML の型システムでは、インターフェイスを実装する型は解析時に値として許容されます。</span><span class="sxs-lookup"><span data-stu-id="23634-328">In the XAML type system, a type that implements that interface is acceptable as a value when parsed.</span></span> <span data-ttu-id="23634-329">値として使えるように、このような型の作成済みのインスタンスが必要になります。</span><span class="sxs-lookup"><span data-stu-id="23634-329">There must be a created instance of such a type available to serve as the value.</span></span> <span data-ttu-id="23634-330">型として使われるインターフェイスは、[**ButtonBase**](https://msdn.microsoft.com/library/windows/apps/br227736) の [**Command**](https://msdn.microsoft.com/library/windows/apps/br227740) と [**CommandParameter**](https://msdn.microsoft.com/library/windows/apps/br227741) プロパティの XAML 構文で見ることができます。</span><span class="sxs-lookup"><span data-stu-id="23634-330">You'll see an interface used as a type in the XAML syntax for [**Command**](https://msdn.microsoft.com/library/windows/apps/br227740) and [**CommandParameter**](https://msdn.microsoft.com/library/windows/apps/br227741) properties of [**ButtonBase**](https://msdn.microsoft.com/library/windows/apps/br227736).</span></span> <span data-ttu-id="23634-331">これらのプロパティは、Model-View-ViewModel (MVVM) 設計パターンをサポートしています。この設計パターンでは、**ICommand** インターフェイスはビューとモデルがどのように相互作用するかのコントラクトです。</span><span class="sxs-lookup"><span data-stu-id="23634-331">These properties support Model-View-ViewModel (MVVM) design patterns where the **ICommand** interface is the contract for how the views and models interact.</span></span>

## <a name="xaml-placeholder-conventions-in-windows-runtime-reference"></a><span data-ttu-id="23634-332">Windows ランタイム リファレンスでの XAML プレースホルダーの規則</span><span class="sxs-lookup"><span data-stu-id="23634-332">XAML placeholder conventions in Windows Runtime reference</span></span>

<span data-ttu-id="23634-333">XAML を使用できる Windows ランタイム API のリファレンス トピックでいずれかの「**構文**」セクションを調べたことがあれば、構文にかなりの数のプレースホルダーが含まれていることに気付いたことでしょう。</span><span class="sxs-lookup"><span data-stu-id="23634-333">If you've examined any of the **Syntax** section of reference topics for Windows Runtime APIs that can use XAML, you've probably seen that the syntax includes quite a few placeholders.</span></span> <span data-ttu-id="23634-334">XAML 構文は使用法構文なので、C#、Microsoft Visual Basic、または Visual C++ コンポーネント拡張機能 (C++/CX) の構文とは異なります。</span><span class="sxs-lookup"><span data-stu-id="23634-334">XAML syntax is different than the C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) syntax because the XAML syntax is a usage syntax.</span></span> <span data-ttu-id="23634-335">独自の XAML ファイルでの具体的な使い方を示しますが、使用できる値について説明し過ぎないようにしています。</span><span class="sxs-lookup"><span data-stu-id="23634-335">It's hinting at your eventual usage in your own XAML files, but without being over-prescriptive about the values you can use.</span></span> <span data-ttu-id="23634-336">そのため、通常は使用法としてリテラルとプレースホルダーを混ぜて文法を説明し、プレースホルダーの一部は「**XAML 値**」のセクションで定義します。</span><span class="sxs-lookup"><span data-stu-id="23634-336">So usually the usage describes a type of grammar that mixes literals and placeholders, and defines some of the placeholders in the **XAML Values** section.</span></span>

<span data-ttu-id="23634-337">プロパティの XAML 構文で型名または要素名が表示されている場合、それらの名前は、元はプロパティを定義する型のための名前です。</span><span class="sxs-lookup"><span data-stu-id="23634-337">When you see type names / element names in a XAML syntax for a property, the name that's shown is for the type that originally defines the property.</span></span> <span data-ttu-id="23634-338">しかし、Windows ランタイム XAML は、[**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) ベースのクラスのクラス継承モデルをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="23634-338">But Windows Runtime XAML supports a class inheritance model for the [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)-based classes.</span></span> <span data-ttu-id="23634-339">そのため、多くの場合、実際の定義クラスではなく、プロパティまたは属性を最初に定義したクラスから派生したクラスの属性を使います。</span><span class="sxs-lookup"><span data-stu-id="23634-339">So you can often use an attribute on a class that's not literally the defining class, but instead derives from a class that first defined the property/attribute.</span></span> <span data-ttu-id="23634-340">たとえば、深い継承を使って、任意の [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) 派生クラスの属性として [**Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992) を設定できます </span><span class="sxs-lookup"><span data-stu-id="23634-340">For example, you can set [**Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992) as an attribute on any [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) derived class using a deep inheritance.</span></span> <span data-ttu-id="23634-341">(例: `<Button Visibility="Visible" />`)。</span><span class="sxs-lookup"><span data-stu-id="23634-341">For example: `<Button Visibility="Visible" />`.</span></span> <span data-ttu-id="23634-342">そのため、XAML 使用方法の構文で示されている要素名が厳密に文字どおりであるとは考えないでください。そのクラスを表す要素と、派生クラスを表す要素でも、その構文が使用できることがあります。</span><span class="sxs-lookup"><span data-stu-id="23634-342">So don't take the element name shown in any XAML usage syntax too literally; the syntax may be viable for elements representing that class, and also elements that represent a derived class.</span></span> <span data-ttu-id="23634-343">定義要素として示されている型が、現実に使うことはまれであるか不可能である場合、その型の名前は構文内で意図的に小文字にしてあります。</span><span class="sxs-lookup"><span data-stu-id="23634-343">In cases where it's rare or impossible for the type shown as the defining element to be in a real-world usage, that type name is deliberately lowercased in the syntax.</span></span> <span data-ttu-id="23634-344">たとえば、**UIElement.Visibility** の構文は、次のようになっています。</span><span class="sxs-lookup"><span data-stu-id="23634-344">For example, the syntax you see for **UIElement.Visibility** is :</span></span>

``` syntax
<uiElement Visibility="Visible"/>
-or-
<uiElement Visibility="Collapsed"/>
```

<span data-ttu-id="23634-345">多くの XAML 構文のセクションでは、「使用方法」にプレースホルダーが含まれており、それらは「**構文**」セクションのすぐ下の「**XAML 値**」セクションで定義されています。</span><span class="sxs-lookup"><span data-stu-id="23634-345">Many XAML syntax sections include placeholders in the "Usage" that are then defined in a **XAML Values** section that's directly under the **Syntax** section.</span></span>

<span data-ttu-id="23634-346">XAML の使用方法のセクションでも、さまざまな一般化されたプレースホルダーが使われています。</span><span class="sxs-lookup"><span data-stu-id="23634-346">XAML usage sections also use various generalized placeholders.</span></span> <span data-ttu-id="23634-347">これらのプレースホルダーは、「**XAML 値**」で毎回再定義されるわけではありません。何を表しているかを推測したり、しだいに覚えることができるためです。</span><span class="sxs-lookup"><span data-stu-id="23634-347">These placeholders aren't redefined every time in **XAML Values**, because you'll guess or eventually learn what they represent.</span></span> <span data-ttu-id="23634-348">ほとんどの読者は、「**XAML 値**」で定義を繰り返し見ることに飽きてしまうと思われるので、定義しないままにしています。</span><span class="sxs-lookup"><span data-stu-id="23634-348">We think most readers would get tired of seeing them in **XAML Values** again and again so we left them out of the definitions.</span></span> <span data-ttu-id="23634-349">参考までに、これらのプレースホルダーの一部と、それらの一般的な意味を、次の一覧に示しておきます。</span><span class="sxs-lookup"><span data-stu-id="23634-349">For reference, here's a list of some of these placeholders and what they mean in a general sense:</span></span>

-   <span data-ttu-id="23634-350">*object*: 理論上は任意のオブジェクト値ですが、多くの場合、実際には特定の型のオブジェクトに限定されます (文字列かオブジェクトかの選択など)。詳しくは、リファレンス ページの「解説」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-350">*object*: theoretically any object value, but often practically limited to certain types of objects such as a string-or-object choice, and you should check the Remarks on the reference page for more info.</span></span>
-   <span data-ttu-id="23634-351">*object* *property*: *object* *property* の組み合わせは、示されている構文が多くのプロパティの属性値として使用できる型のための構文である場合に使われます。</span><span class="sxs-lookup"><span data-stu-id="23634-351">*object* *property*: *object* *property* in combination is used for cases where the syntax being shown is the syntax for a type that can be used as an attribute value for many properties.</span></span> <span data-ttu-id="23634-352">たとえば、[**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) の「**XAML 属性の使用方法**」には、<*object* *property*="*predefinedColorName*"/> が含まれています。</span><span class="sxs-lookup"><span data-stu-id="23634-352">For example, the **Xaml Attribute Usage** shown for [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) includes: <*object* *property*="*predefinedColorName*"/></span></span>
-   <span data-ttu-id="23634-353">*eventhandler*: これは、イベント属性のために示される各 XAML 構文の属性値を表します。</span><span class="sxs-lookup"><span data-stu-id="23634-353">*eventhandler*: This appears as the attribute value for every XAML syntax shown for an event attribute.</span></span> <span data-ttu-id="23634-354">これに対して指定するのは、イベント ハンドラー関数の関数名です。</span><span class="sxs-lookup"><span data-stu-id="23634-354">What you're supplying here is the function name for an event handler function.</span></span> <span data-ttu-id="23634-355">この関数は、XAML ページのコード ビハインドで定義されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="23634-355">That function must be defined in the code-behind for the XAML page.</span></span> <span data-ttu-id="23634-356">プログラミングのレベルでは、その関数は処理するイベントのデリゲート シグネチャと一致する必要があり、一致しない場合はアプリのコードがコンパイルされません。</span><span class="sxs-lookup"><span data-stu-id="23634-356">At the programming level, that function must match the delegate signature of the event that you're handling, or your app code won't compile.</span></span> <span data-ttu-id="23634-357">ただし、それは実際にはプログラミングでの考慮事項であり、XAML での考慮事項ではないため、XAML 構文ではデリゲート型について何も言及しようとはしていません。</span><span class="sxs-lookup"><span data-stu-id="23634-357">But that's really a programming consideration, not a XAML consideration, so we don't try to hint anything about the delegate type in the XAML syntax.</span></span> <span data-ttu-id="23634-358">イベントのためにどのデリゲートを実装する必要があるかを知りたい場合は、イベントのリファレンス トピックにある「**イベント情報**」セクションの表で、" **デリゲート**" というラベルの行をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-358">If you want to know which delegate you should be implementing for an event, that's in the **Event information** section of the reference topic for the event, in a table row that's labeled **Delegate**.</span></span>
-   <span data-ttu-id="23634-359">*enumMemberName*: すべての列挙体の属性構文に示されます。</span><span class="sxs-lookup"><span data-stu-id="23634-359">*enumMemberName*: shown in attribute syntax for all enumerations.</span></span> <span data-ttu-id="23634-360">列挙値を使うプロパティのための同じようなプレースホルダーがありますが、通常は、列挙体の名前を示すプレフィックスがプレースホルダーに付けられます。</span><span class="sxs-lookup"><span data-stu-id="23634-360">There's a similar placeholder for properties that use an enumeration value, but it usually prefixes the placeholder with a hint of the enumeration's name.</span></span> <span data-ttu-id="23634-361">たとえば、[**FrameworkElement.FlowDirection**](https://msdn.microsoft.com/library/windows/apps/br208716) で示される構文は、<*frameworkElement***FlowDirection**="* flowDirectionMemberName*"/> です。</span><span class="sxs-lookup"><span data-stu-id="23634-361">For example, the syntax shown for [**FrameworkElement.FlowDirection**](https://msdn.microsoft.com/library/windows/apps/br208716) is <*frameworkElement***FlowDirection**="* flowDirectionMemberName*"/>.</span></span> <span data-ttu-id="23634-362">これらのプロパティのリファレンス ページで、「**プロパティ値**」のセクションの "**型:**" というテキストの横に表示される、列挙型へのリンクをクリックしてください。</span><span class="sxs-lookup"><span data-stu-id="23634-362">If you're on one of those property reference pages, click the link to the enumeration type that appears in the **Property Value** section, next to the text **Type:**.</span></span> <span data-ttu-id="23634-363">その列挙体を使うプロパティの属性値には、「**メンバー**」の表の「**メンバー名**」列に表示される任意の文字列を使用できます。</span><span class="sxs-lookup"><span data-stu-id="23634-363">For the attribute value of a property that uses that enumeration, you can use any string that is listed in the **Member** column of the **Members** list.</span></span>
-   <span data-ttu-id="23634-364">*double*、*int*、*string*、*bool*: これらは、XAML 言語既知のプリミティブ型です。</span><span class="sxs-lookup"><span data-stu-id="23634-364">*double*, *int*, *string*, *bool*: These are primitive types known to the XAML language.</span></span> <span data-ttu-id="23634-365">C# または Visual Basic を使ってプログラミングを行う場合は、これらの型が Microsoft .NET での対応する型 ([**Double**](https://msdn.microsoft.com/library/windows/apps/xaml/system.double.aspx)、[**Int32**](https://msdn.microsoft.com/library/windows/apps/xaml/system.int32.aspx)、[**String**](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx)、[**Boolean**](https://msdn.microsoft.com/library/windows/apps/xaml/system.boolean.aspx) など) に対応付けられ、XAML で定義された値を .NET コード ビハインドで扱うときには、それらの .NET 型の任意のメンバーを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="23634-365">If you're programming using C# or Visual Basic, these types are projected to Microsoft .NET equivalent types such as [**Double**](https://msdn.microsoft.com/library/windows/apps/xaml/system.double.aspx), [**Int32**](https://msdn.microsoft.com/library/windows/apps/xaml/system.int32.aspx), [**String**](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx) and [**Boolean**](https://msdn.microsoft.com/library/windows/apps/xaml/system.boolean.aspx), and you can use any members on those .NET types when you work with your XAML-defined values in .NET code-behind.</span></span> <span data-ttu-id="23634-366">C++/CX を使ってプログラミングを行う場合は、C++ のプリミティブ型を使いますが、[**Platform**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx) 名前空間で定義されている、それらと同等の型 (たとえば [**Platform::String**](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)) を使うこともできます。</span><span class="sxs-lookup"><span data-stu-id="23634-366">If you're programming using C++/CX, you'll use the C++ primitive types but you can also consider these equivalent to types defined by the [**Platform**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx) namespace, for example [**Platform::String**](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx).</span></span> <span data-ttu-id="23634-367">場合によっては、特定のプロパティに対して、追加の値の制限があります。</span><span class="sxs-lookup"><span data-stu-id="23634-367">There will sometimes be additional value restrictions for particular properties.</span></span> <span data-ttu-id="23634-368">しかし、そのような制限はコードの使用方法と XAML の使用方法の両方に適用されるので、それらの注は通常は「XAML」セクションではなく「**プロパティ値**」または「解説」セクションに記載されます。</span><span class="sxs-lookup"><span data-stu-id="23634-368">But you'll usually see these noted in a **Property value** section or Remarks section and not in a XAML section, because any such restrictions apply both to code usages and XAML usages.</span></span>

## <a name="tips-and-tricks-notes-on-style"></a><span data-ttu-id="23634-369">スタイルに関するヒントと注意事項</span><span class="sxs-lookup"><span data-stu-id="23634-369">Tips and tricks, notes on style</span></span>

-   <span data-ttu-id="23634-370">マークアップ拡張の全般的な説明は、メインの「[XAML の概要](xaml-overview.md)」に記載されています。</span><span class="sxs-lookup"><span data-stu-id="23634-370">Markup extensions in general are described in the main [XAML overview](xaml-overview.md).</span></span> <span data-ttu-id="23634-371">ただし、このトピックで示されているガイダンスに最も大きな影響を及ぼすマークアップ拡張は、[StaticResource](staticresource-markup-extension.md) マークアップ拡張 (および関連する [ThemeResource](themeresource-markup-extension.md)) です。</span><span class="sxs-lookup"><span data-stu-id="23634-371">But the markup extension that most impacts the guidance given in this topic is the [StaticResource](staticresource-markup-extension.md) markup extension (and related [ThemeResource](themeresource-markup-extension.md)).</span></span> <span data-ttu-id="23634-372">StaticResource マークアップ拡張の機能は、XAML を XAML の [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794) の再利用可能なリソースにファクタリングできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="23634-372">The function of the StaticResource markup extension is to enable factoring your XAML into reusable resources that come from a XAML [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794).</span></span> <span data-ttu-id="23634-373">ほとんどの場合、**ResourceDictionary** でコントロール テンプレートと関連スタイルを定義します。</span><span class="sxs-lookup"><span data-stu-id="23634-373">You almost always define control templates and related styles in a **ResourceDictionary**.</span></span> <span data-ttu-id="23634-374">コントロール テンプレートの定義またはアプリ固有のスタイルの小さな部分についても、**ResourceDictionary** で定義します。たとえば、[**SolidColorBrush**](https://msdn.microsoft.com/library/windows/apps/br242962) ではアプリが UI の各部分で何度も使う色を定義します。</span><span class="sxs-lookup"><span data-stu-id="23634-374">You often define the smaller parts of a control template definition or app-specific style in a **ResourceDictionary** too, for example a [**SolidColorBrush**](https://msdn.microsoft.com/library/windows/apps/br242962) for a color that your app uses more than once for different parts of UI.</span></span> <span data-ttu-id="23634-375">StaticResource を使うと、設定にプロパティ要素を使う必要のあるプロパティが、属性構文で設定できるようになります。</span><span class="sxs-lookup"><span data-stu-id="23634-375">By using a StaticResource, any property that would otherwise require a property element usage to set can now be set in attribute syntax.</span></span> <span data-ttu-id="23634-376">XAML をファクタリングして再利用するメリットは、ページ レベルの構文を簡略化するだけにとどまりません。</span><span class="sxs-lookup"><span data-stu-id="23634-376">But the benefits of factoring XAML for reuse go beyond just simplifying the page-level syntax.</span></span> <span data-ttu-id="23634-377">詳しくは、「[ResourceDictionary と XAML リソースの参照](https://msdn.microsoft.com/library/windows/apps/mt187273)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-377">For more info, see [ResourceDictionary and XAML resource references](https://msdn.microsoft.com/library/windows/apps/mt187273).</span></span>
-   <span data-ttu-id="23634-378">XAML の例では、空白や改行がどのように適用されるかに関するさまざまな規則が確認できます。</span><span class="sxs-lookup"><span data-stu-id="23634-378">You'll see several different conventions for how white space and line feeds are applied in XAML examples.</span></span> <span data-ttu-id="23634-379">特に、多くの異なる属性が設定されたオブジェクト要素の分割方法に関してはさまざまな規則があります。</span><span class="sxs-lookup"><span data-stu-id="23634-379">In particular, there are different conventions for how to break up object elements that have a lot of different attributes set.</span></span> <span data-ttu-id="23634-380">これは、単にスタイルの問題です。</span><span class="sxs-lookup"><span data-stu-id="23634-380">That's just a matter of style.</span></span> <span data-ttu-id="23634-381">Visual Studio の XML エディターでは、XAML を編集するときに既定のスタイル規則が適用されますが、設定で変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="23634-381">The Visual Studio XML editor applies some default style rules when you edit XAML, but you can change these in the settings.</span></span> <span data-ttu-id="23634-382">まれではあるものの、XAML ファイル内の空白が意味を持つこともあります。このような場合について詳しくは、「[XAML と空白](xaml-and-whitespace.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="23634-382">There are a small number of cases where the white space in a XAML file is considered significant; for more info see [XAML and whitespace](xaml-and-whitespace.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="23634-383">関連トピック</span><span class="sxs-lookup"><span data-stu-id="23634-383">Related topics</span></span>

* [<span data-ttu-id="23634-384">XAML の概要</span><span class="sxs-lookup"><span data-stu-id="23634-384">XAML overview</span></span>](xaml-overview.md)
* [<span data-ttu-id="23634-385">XAML 名前空間と名前空間マッピング</span><span class="sxs-lookup"><span data-stu-id="23634-385">XAML namespaces and namespace mapping</span></span>](xaml-namespaces-and-namespace-mapping.md)
* [<span data-ttu-id="23634-386">ResourceDictionary と XAML リソースの参照</span><span class="sxs-lookup"><span data-stu-id="23634-386">ResourceDictionary and XAML resource references</span></span>](https://msdn.microsoft.com/library/windows/apps/mt187273)
 

