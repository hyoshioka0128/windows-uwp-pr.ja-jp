---
description: XAML 名前スコープには、XAML で定義されたオブジェクトの名前とそれに対応するインスタンスとの関係が格納されます。 この概念は、他のプログラミング言語やテクノロジで使われている用語 "名前スコープ" と広い意味で似ています。
title: XAML 名前スコープ
ms.assetid: EB060CBD-A589-475E-B83D-B24068B54C21
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: f4e3ea460977a5ef99f97626c95ca865ab3f98b0
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/29/2019
ms.locfileid: "66365869"
---
# <a name="xaml-namescopes"></a><span data-ttu-id="f91b1-105">XAML 名前スコープ</span><span class="sxs-lookup"><span data-stu-id="f91b1-105">XAML namescopes</span></span>


<span data-ttu-id="f91b1-106">*XAML 名前スコープ* には、XAML で定義されたオブジェクトの名前とそれに対応するインスタンスとの関係が格納されます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-106">A *XAML namescope* stores relationships between the XAML-defined names of objects and their instance equivalents.</span></span> <span data-ttu-id="f91b1-107">この概念は、他のプログラミング言語やテクノロジで使われている用語 "*名前スコープ*" と広い意味で似ています。</span><span class="sxs-lookup"><span data-stu-id="f91b1-107">This concept is similar to the wider meaning of the term *namescope* in other programming languages and technologies.</span></span>

## <a name="how-xaml-namescopes-are-defined"></a><span data-ttu-id="f91b1-108">XAML 名前スコープの定義方法</span><span class="sxs-lookup"><span data-stu-id="f91b1-108">How XAML namescopes are defined</span></span>

<span data-ttu-id="f91b1-109">XAML 名前スコープ内で名前を使うと、最初に XAML で定義されたオブジェクトをユーザー コードで参照できます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-109">Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</span></span> <span data-ttu-id="f91b1-110">XAML を解析すると、内部的に、XAML 宣言で保持していた一部またはすべての関係を維持する一連のオブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-110">The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</span></span> <span data-ttu-id="f91b1-111">これらの関係が、作成されたオブジェクトの特定のオブジェクト プロパティとして保持されるか、プログラミング モデル API のユーティリティ メソッドとして公開されます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-111">These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</span></span>

<span data-ttu-id="f91b1-112">XAML 名前スコープ内の名前の最も一般的な用途は、オブジェクト インスタンスに対する直接参照です。これは、マークアップ コンパイル パスを部分クラス テンプレートに生成された **InitializeComponent** メソッドと組み合わせてプロジェクト ビルド アクションとして使うことで、有効化されます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-112">The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated **InitializeComponent** method in the partial class templates.</span></span>

<span data-ttu-id="f91b1-113">[  **FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) ユーティリティ メソッドを実行時に使って、XAML マークアップで名前を定義されているオブジェクトへの参照を返すこともできます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-113">You can also use the utility method [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</span></span>

### <a name="more-about-build-actions-and-xaml"></a><span data-ttu-id="f91b1-114">ビルド アクションと XAML の詳細</span><span class="sxs-lookup"><span data-stu-id="f91b1-114">More about build actions and XAML</span></span>

<span data-ttu-id="f91b1-115">技術的には、XAML 自体はマークアップ コンパイラ パスを使います。この際、XAML と、コード ビハインド用に定義した部分クラスがまとめてコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-115">What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</span></span> <span data-ttu-id="f91b1-116">マークアップで定義された **Name** 属性または [x:Name](x-name-attribute.md) 属性を持つ各オブジェクト要素が、XAML と同名の内部フィールドを生成します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-116">Each object element with a **Name** or [x:Name attribute](x-name-attribute.md) defined in the markup generates an internal field with a name that matches the XAML name.</span></span> <span data-ttu-id="f91b1-117">初期状態では、このフィールドは空です。</span><span class="sxs-lookup"><span data-stu-id="f91b1-117">This field is initially empty.</span></span> <span data-ttu-id="f91b1-118">続いて、クラスが **InitializeComponent** メソッドを生成します。このメソッドは、すべての XAML が読み込まれた後にのみ呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-118">Then the class generates an **InitializeComponent** method that is called only after all the XAML is loaded.</span></span> <span data-ttu-id="f91b1-119">**InitializeComponent** ロジックにおいて、各内部フィールドには、名前文字列が等しいかどうかを評価した結果を表す [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) の戻り値が設定されます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-119">Within the **InitializeComponent** logic, each internal field is then populated with the [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) return value for the equivalent name string.</span></span> <span data-ttu-id="f91b1-120">このインフラストラクチャは、コンパイル後に Windows ランタイム アプリ プロジェクトの /obj サブフォルダーに XAML ページごとに作成される ".g" (生成) ファイルで確認できます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-120">You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</span></span> <span data-ttu-id="f91b1-121">リフレクションを実行した場合は、結果として作成されるアセンブリのメンバーとしてのフィールドや **InitializeComponent** メソッドの存在を確認することもできます。それ以外の場合は、インターフェイス言語の内容を調べます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-121">You can also see the fields and **InitializeComponent** method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</span></span>

<span data-ttu-id="f91b1-122">**注**  向けの Visual C コンポーネント拡張 (C +/cli CX) アプリ、バッキング フィールドは、 **X:name** XAML ファイルのルート要素の参照は作成されません。</span><span class="sxs-lookup"><span data-stu-id="f91b1-122">**Note**  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an **x:Name** reference is not created for the root element of a XAML file.</span></span> <span data-ttu-id="f91b1-123">C++/CX のコード ビハインドからルート オブジェクトを参照する必要がある場合は、他の API またはツリー走査を使ってください。</span><span class="sxs-lookup"><span data-stu-id="f91b1-123">If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</span></span> <span data-ttu-id="f91b1-124">たとえば、既知の名前付き子要素に対して [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) を呼び出した後、[**Parent**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.parent) を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-124">For example you can call [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) for a known named child element and then call [**Parent**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.parent).</span></span>

## <a name="creating-objects-at-run-time-with-xamlreaderload"></a><span data-ttu-id="f91b1-125">XamlReader.Load を使った実行時におけるオブジェクトの作成</span><span class="sxs-lookup"><span data-stu-id="f91b1-125">Creating objects at run time with XamlReader.Load</span></span>

<span data-ttu-id="f91b1-126">XAML は、初期の XAML ソース解析操作に対して同じように動作する [**XamlReader.Load**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load) メソッドの文字列入力としても使用できます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-126">XAML can be also be used as the string input for the [**XamlReader.Load**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load) method, which acts analogously to the initial XAML source parse operation.</span></span> <span data-ttu-id="f91b1-127">**XamlReader.Load** は、実行時にオブジェクトの切断されたツリーを新規作成します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-127">**XamlReader.Load** creates a new disconnected tree of objects at run time.</span></span> <span data-ttu-id="f91b1-128">この切断されたツリーは、メイン オブジェクト ツリーのいずれかのポイントにアタッチできます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-128">The disconnected tree can then be attached to some point on the main object tree.</span></span> <span data-ttu-id="f91b1-129">作成したオブジェクト ツリーは、**Children** などのコンテンツ プロパティ コレクションに追加するか、オブジェクト値を受け取る他のプロパティを設定する (たとえば、[**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) プロパティの値に新しい [**ImageBrush**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.ImageBrush) を読み込む) ことで、明示的に接続する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-129">You must explicitly connect your created object tree, either by adding it to a content property collection such as **Children**, or by setting some other property that takes an object value (for example, loading a new [**ImageBrush**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.ImageBrush) for a [**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) property value).</span></span>

### <a name="xaml-namescope-implications-of-xamlreaderload"></a><span data-ttu-id="f91b1-130">XamlReader.Load が XAML 名前スコープに与える影響</span><span class="sxs-lookup"><span data-stu-id="f91b1-130">XAML namescope implications of XamlReader.Load</span></span>

<span data-ttu-id="f91b1-131">[  **XamlReader.Load**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load) によって作成された新しいオブジェクト ツリーで定義される暫定的な XAML 名前スコープは、指定された XAML で定義名が一意であるかどうかを評価します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-131">The preliminary XAML namescope defined by the new object tree created by [**XamlReader.Load**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load) evaluates any defined names in the provided XAML for uniqueness.</span></span> <span data-ttu-id="f91b1-132">指定された XAML 内の名前がこの時点で内部的に一意でない場合、**XamlReader.Load** によって例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-132">If names in the provided XAML are not internally unique at this point, **XamlReader.Load** throws an exception.</span></span> <span data-ttu-id="f91b1-133">切断されたオブジェクト ツリーがメインのアプリ オブジェクト ツリーに接続されている場合、切断されたオブジェクト ツリーの XAML 名前スコープは、メインのアプリ XAML 名前スコープには結合されません。</span><span class="sxs-lookup"><span data-stu-id="f91b1-133">The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</span></span> <span data-ttu-id="f91b1-134">ツリーの接続後、アプリのオブジェクト ツリーは結合されていますが、そのツリーの XAML 名前スコープは分離されています。</span><span class="sxs-lookup"><span data-stu-id="f91b1-134">After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</span></span> <span data-ttu-id="f91b1-135">オブジェクト間の接続ポイントでは、分岐が発生します。ここで、**XamlReader.Load** の呼び出しによって返される値をプロパティに設定します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-135">The divisions occur at the connection points between objects, where you set some property to be the value returned from a **XamlReader.Load** call.</span></span>

<span data-ttu-id="f91b1-136">切断された異なる XAML 名前スコープを持つことに伴う問題は、マネージ オブジェクトの直接参照と同様に、[**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) メソッドの呼び出しが、結合された XAML 名前スコープでは動作しなくなることです。</span><span class="sxs-lookup"><span data-stu-id="f91b1-136">The complication of having discrete and disconnected XAML namescopes is that calls to the [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) method as well as direct managed object references no longer operate against a unified XAML namescope.</span></span> <span data-ttu-id="f91b1-137">代わりに、**FindName** の呼び出しの対象となった特定のオブジェクトがスコープを意味し、そのスコープは呼び出し元オブジェクトが存在する XAML 名前スコープになります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-137">Instead, the particular object that **FindName** is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</span></span> <span data-ttu-id="f91b1-138">マネージ オブジェクトの直接参照では、スコープは、コードが存在するクラスによって暗黙的に指定されます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-138">In the direct managed object reference case, the scope is implied by the class where the code exists.</span></span> <span data-ttu-id="f91b1-139">一般に、アプリ コンテンツの "ページ" における実行時の対話に使うコード ビハインドは、ルート "ページ" をサポートする部分クラスに存在するため、XAML 名前スコープはルート XAML 名前スコープになります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-139">Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</span></span>

<span data-ttu-id="f91b1-140">ルート XAML 名前スコープで指定したオブジェクトを取得するために [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) を呼び出した場合、[**XamlReader.Load**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load) によって作成された、異なる XAML 名前スコープのオブジェクトは検索されません。</span><span class="sxs-lookup"><span data-stu-id="f91b1-140">If you call [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by [**XamlReader.Load**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load).</span></span> <span data-ttu-id="f91b1-141">逆に、異なる XAML 名前スコープの外部で取得したオブジェクトから **FindName** を呼び出した場合は、ルート XAML 名前スコープで指定したオブジェクトは検索されません。</span><span class="sxs-lookup"><span data-stu-id="f91b1-141">Conversely, if you call **FindName** from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</span></span>

<span data-ttu-id="f91b1-142">異なる XAML 名前スコープの問題によって影響を受けるのは、[**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) 呼び出しを使って XAML 名前スコープで名前に基づいてオブジェクトを検索する処理だけです。</span><span class="sxs-lookup"><span data-stu-id="f91b1-142">This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) call.</span></span>

<span data-ttu-id="f91b1-143">異なる XAML 名前スコープに定義されているオブジェクトを参照するには、次のような手法を使用できます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-143">To get references to objects that are defined in a different XAML namescope, you can use several techniques:</span></span>

-   <span data-ttu-id="f91b1-144">[  **Parent**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.parent) や、オブジェクト ツリー構造内に存在することが判明しているコレクション プロパティ ([**Panel.Children**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.panel.children) によって返されるコレクションなど) を使って、分離されたステップでツリー全体を移動します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-144">Walk the entire tree in discrete steps with [**Parent**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.parent) and/or collection properties that are known to exist in your object tree structure (such as the collection returned by [**Panel.Children**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.panel.children)).</span></span>
-   <span data-ttu-id="f91b1-145">異なる XAML 名前スコープから呼び出していて、ルート XAML 名前スコープを対象とする必要がある場合は、現在表示されているメイン ウィンドウへの参照を取得すると簡単です。</span><span class="sxs-lookup"><span data-stu-id="f91b1-145">If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</span></span> <span data-ttu-id="f91b1-146">`Window.Current.Content`を呼び出す 1 行のコードを使って、現在のアプリ ウィンドウからの表示ルート (ルート XAML 要素、"コンテンツ ソース" とも呼ばれます) を取得できます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-146">You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call `Window.Current.Content`.</span></span> <span data-ttu-id="f91b1-147">次に [**FrameworkElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.FrameworkElement) にキャストし、このスコープから [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-147">You can then cast to [**FrameworkElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.FrameworkElement) and call [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) from this scope.</span></span>
-   <span data-ttu-id="f91b1-148">ルート XAML 名前スコープから呼び出していて、異なる XAML 名前スコープ内のオブジェクトを対象とする必要がある場合は、[**XamlReader.Load**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load) から返されてメイン オブジェクト ツリーに追加されたオブジェクトへの参照を、あらかじめコードに記述して保持しておくことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f91b1-148">If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by [**XamlReader.Load**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load) and then added to the main object tree.</span></span> <span data-ttu-id="f91b1-149">これにより、このオブジェクトが、異なる XAML 名前スコープ内で [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) を呼び出すための有効なオブジェクトになります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-149">This object is now a valid object for calling [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) within the discrete XAML namescope.</span></span> <span data-ttu-id="f91b1-150">このオブジェクトはグローバル変数として保持できるほか、メソッドのパラメーターを使って渡すこともできます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-150">You could keep this object available as a global variable or otherwise pass it by using method parameters.</span></span>
-   <span data-ttu-id="f91b1-151">ビジュアル ツリーを走査することにより、名前と XAML 名前スコープの考慮事項を完全に回避できます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-151">You can avoid names and XAML namescope considerations entirely by examining the visual tree.</span></span> <span data-ttu-id="f91b1-152">[  **VisualTreeHelper**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.VisualTreeHelper) API を使うと、位置とインデックスだけを基に、親オブジェクトと子コレクションの観点からビジュアル ツリーを走査できます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-152">The [**VisualTreeHelper**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.VisualTreeHelper) API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</span></span>

## <a name="xaml-namescopes-in-templates"></a><span data-ttu-id="f91b1-153">テンプレートにおける XAML 名前スコープ</span><span class="sxs-lookup"><span data-stu-id="f91b1-153">XAML namescopes in templates</span></span>

<span data-ttu-id="f91b1-154">XAML のテンプレートを使うと、コンテンツを簡単に再利用および再適用できます。ただし、テンプレートには、テンプレート レベルで定義された名前を持つ要素も含まれている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-154">Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</span></span> <span data-ttu-id="f91b1-155">同一のテンプレートが、ページ内で複数回使われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-155">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="f91b1-156">このため、テンプレートに、適用先のページに依存しない独自の XAML 名前スコープを定義します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-156">For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</span></span> <span data-ttu-id="f91b1-157">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-157">Consider this example:</span></span>

```xml
<Page
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  >
  <Page.Resources>
    <ControlTemplate x:Key="MyTemplate">
      ....
      <TextBlock x:Name="MyTextBlock" />
    </ControlTemplate>
  </Page.Resources>
  <StackPanel>
    <SomeControl Template="{StaticResource MyTemplate}" />
    <SomeControl Template="{StaticResource MyTemplate}" />
  </StackPanel>
</Page>
```

<span data-ttu-id="f91b1-158">ここでは、同一のテンプレートを 2 つの異なるコントロールに適用しています。</span><span class="sxs-lookup"><span data-stu-id="f91b1-158">Here, the same template is applied to two different controls.</span></span> <span data-ttu-id="f91b1-159">これらのテンプレートがそれぞれ異なる XAML 名前スコープを持たなければ、テンプレート内で使われている "MyTextBlock" という名前により、名前の競合が発生することになります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-159">If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</span></span> <span data-ttu-id="f91b1-160">テンプレートの各インスタンスは独自の XAML 名前スコープを持つため、この例の場合、インスタンス化された各テンプレートの XAML 名前スコープに、名前が必ず 1 つずつ含まれます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-160">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span> <span data-ttu-id="f91b1-161">ただし、ルート XAML 名前スコープには、どちらのテンプレートの名前も含まれていません。</span><span class="sxs-lookup"><span data-stu-id="f91b1-161">However, the root XAML namescope does not contain the name from either template.</span></span>

<span data-ttu-id="f91b1-162">XAML 名前スコープが複数存在するため、テンプレートが適用されるページのスコープからテンプレート内の指定要素を検索するには、別の手法が必要になります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-162">Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</span></span> <span data-ttu-id="f91b1-163">オブジェクト ツリー内のオブジェクトに対して [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) を呼び出すのではなく、まずテンプレートが適用されているオブジェクトを取得し、その後で [**GetTemplateChild**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.gettemplatechild) を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f91b1-163">Rather than calling [**FindName**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname) on some object in the object tree, you first obtain the object that has the template applied, and then call [**GetTemplateChild**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.gettemplatechild).</span></span> <span data-ttu-id="f91b1-164">コントロールの作成者が生成している規則で、適用されたテンプレートの特定の指定要素を、コントロール自体によって定義される動作の対象とする場合は、コントロール実装コードから **GetTemplateChild** メソッドを使用できます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-164">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the **GetTemplateChild** method from your control implementation code.</span></span> <span data-ttu-id="f91b1-165">**GetTemplateChild** メソッドはプロテクトされているため、コントロールの作成者のみがアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="f91b1-165">The **GetTemplateChild** method is protected, so only the control author has access to it.</span></span> <span data-ttu-id="f91b1-166">また、パーツやテンプレート パーツに名前を付け、これらをコントロール クラスに適用される属性値として報告するために、コントロールの作成者が従う規則があります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-166">Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</span></span> <span data-ttu-id="f91b1-167">この方法を使うと、異なるテンプレートを適用しようとしているコントロール ユーザーは重要なパーツ名を検出できるようになります。コントロールの機能を維持するには、名前付きパーツをそのテンプレートに置き換える必要があります。</span><span class="sxs-lookup"><span data-stu-id="f91b1-167">This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f91b1-168">関連トピック</span><span class="sxs-lookup"><span data-stu-id="f91b1-168">Related topics</span></span>

* [<span data-ttu-id="f91b1-169">XAML の概要</span><span class="sxs-lookup"><span data-stu-id="f91b1-169">XAML overview</span></span>](xaml-overview.md)
* [<span data-ttu-id="f91b1-170">X:name 属性</span><span class="sxs-lookup"><span data-stu-id="f91b1-170">x:Name attribute</span></span>](x-name-attribute.md)
* <span data-ttu-id="f91b1-171">[クイック スタート:コントロール テンプレート](https://docs.microsoft.com/previous-versions/windows/apps/hh465374(v=win.10))</span><span class="sxs-lookup"><span data-stu-id="f91b1-171">[Quickstart: Control templates](https://docs.microsoft.com/previous-versions/windows/apps/hh465374(v=win.10))</span></span>
* [<span data-ttu-id="f91b1-172">**XamlReader.Load**</span><span class="sxs-lookup"><span data-stu-id="f91b1-172">**XamlReader.Load**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.markup.xamlreader.load)
* [<span data-ttu-id="f91b1-173">**FindName**</span><span class="sxs-lookup"><span data-stu-id="f91b1-173">**FindName**</span></span>](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.findname)
 

