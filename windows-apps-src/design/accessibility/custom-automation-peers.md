---
author: Xansky
Description: Describes the concept of automation peers for Microsoft UI Automation, and how you can provide automation support for your own custom UI class.
ms.assetid: AA8DA53B-FE6E-40AC-9F0A-CB09637C87B4
title: カスタム オートメーション ピア
label: Custom automation peers
template: detail.hbs
ms.author: mhopkins
ms.date: 07/13/2018
ms.topic: article
keywords: windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 37f75686c51e876cd4e6b608d0f527d3e32e4e24
ms.sourcegitcommit: 70ab58b88d248de2332096b20dbd6a4643d137a4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/01/2018
ms.locfileid: "5936185"
---
# <a name="custom-automation-peers"></a><span data-ttu-id="ca842-103">カスタム オートメーション ピア</span><span class="sxs-lookup"><span data-stu-id="ca842-103">Custom automation peers</span></span>  

<span data-ttu-id="ca842-104">Microsoft UI オートメーションに対するオートメーション ピアの概念について説明します。また、独自のカスタム UI クラスに対してオートメーションのサポートを提供する方法についても説明します。</span><span class="sxs-lookup"><span data-stu-id="ca842-104">Describes the concept of automation peers for Microsoft UI Automation, and how you can provide automation support for your own custom UI class.</span></span>

<span data-ttu-id="ca842-105">UI オートメーションにより、オートメーション クライアントが多様な UI プラットフォームやフレームワークのユーザー インターフェイスを検証、または操作するときに利用できるフレームワークが提供されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-105">UI Automation provides a framework that automation clients can use to examine or operate the user interfaces of a variety of UI platforms and frameworks.</span></span> <span data-ttu-id="ca842-106">ユニバーサル Windows プラットフォーム (UWP) アプリを作っている場合は、UI で使うクラスによって既に UI オートメーション サポートが提供されています。</span><span class="sxs-lookup"><span data-stu-id="ca842-106">If you are writing a Universal Windows Platform (UWP) app, the classes that you use for your UI already provide UI Automation support.</span></span> <span data-ttu-id="ca842-107">既にある非シール クラスから派生させて、新しい種類の UI コントロールやサポート クラスを定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-107">You can derive from existing, non-sealed classes to define a new kind of UI control or support class.</span></span> <span data-ttu-id="ca842-108">これを行う手順の間に、既定の UI オートメーション サポートでは対応していないがアクセシビリティ サポートを必要とする動作が、クラスによって追加されることがあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-108">In the process of doing so, your class might add behavior that should have accessibility support but that the default UI Automation support does not cover.</span></span> <span data-ttu-id="ca842-109">この場合は、まず基本実装で使った [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) クラスを派生させ、ピアの実装に必要なサポートを追加した後、ユニバーサル Windows プラットフォーム (UWP) コントロールのインフラストラクチャに対し、新しいピアを作る必要があることを通知することにより、既存の UI オートメーション サポートを拡張する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-109">In this case, you should extend the existing UI Automation support by deriving from the [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) class that the base implementation used, adding any necessary support to your peer implementation, and informing the Universal Windows Platform (UWP) control infrastructure that it should create your new peer.</span></span>

<span data-ttu-id="ca842-110">UI オートメーションにより、スクリーン リーダーなどのアクセシビリティ アプリや支援技術だけでなく、品質保証 (テスト) コードも有効になります。</span><span class="sxs-lookup"><span data-stu-id="ca842-110">UI Automation enables not only accessibility applications and assistive technologies, such as screen readers, but also quality-assurance (test) code.</span></span> <span data-ttu-id="ca842-111">いずれのシナリオについても、UI オートメーション クライアントでは、ユーザー インターフェイス要素を検証し、アプリの外部の他のコードからアプリに対するユーザー操作のシミュレーションを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-111">In either scenario, UI Automation clients can examine user-interface elements and simulate user interaction with your app from other code outside your app.</span></span> <span data-ttu-id="ca842-112">すべてのプラットフォームを対象とした UI オートメーション、およびその広範な意味については、「[UI オートメーションの概要](https://msdn.microsoft.com/library/windows/desktop/Ee684076)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-112">For info about UI Automation across all platforms and in its wider meaning, see [UI Automation Overview](https://msdn.microsoft.com/library/windows/desktop/Ee684076).</span></span>

<span data-ttu-id="ca842-113">UI オートメーション フレームワークは次の 2 種類のオーディエンスによって使われます。</span><span class="sxs-lookup"><span data-stu-id="ca842-113">There are two distinct audiences who use the UI Automation framework.</span></span>

* <span data-ttu-id="ca842-114">**UI オートメーション *クライアント*** 現在ユーザーに表示されているすべての UI に関する情報を取得するために UI オートメーション API を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ca842-114">**UI Automation *clients*** call UI Automation APIs to learn about all of the UI that is currently displayed to the user.</span></span> <span data-ttu-id="ca842-115">たとえば、スクリーン リーダーなどの支援技術は UI オートメーション クライアントとして機能します。</span><span class="sxs-lookup"><span data-stu-id="ca842-115">For example, an assistive technology such as a screen reader acts as a UI Automation client.</span></span> <span data-ttu-id="ca842-116">UI は、関連するオートメーション要素のツリーとして提示されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-116">The UI is presented as a tree of automation elements that are related.</span></span> <span data-ttu-id="ca842-117">UI オートメーション クライアントの関心の対象は、一度に 1 つのアプリに限定される場合もあれば、ツリー全体である場合もあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-117">The UI Automation client might be interested in just one app at a time, or in the entire tree.</span></span> <span data-ttu-id="ca842-118">UI オートメーション クライアントは、UI オートメーション API を使ってツリーを操作して、オートメーション要素の情報を読み上げたり変更したりできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-118">The UI Automation client can use UI Automation APIs to navigate the tree and to read or change information in the automation elements.</span></span>
* <span data-ttu-id="ca842-119">**UI オートメーション *プロバイダー*** アプリの一部として導入された UI の要素を公開する API を実装して、UI オートメーション ツリーに情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="ca842-119">**UI Automation *providers*** contribute information to the UI Automation tree, by implementing APIs that expose the elements in the UI that they introduced as part of their app.</span></span> <span data-ttu-id="ca842-120">新しいコントロールを作るときには、UI オートメーション プロバイダーのシナリオの参加者としての役割を果たしてください。</span><span class="sxs-lookup"><span data-stu-id="ca842-120">When you create a new control, you should now act as a participant in the UI Automation provider scenario.</span></span> <span data-ttu-id="ca842-121">プロバイダーとして配慮する点は、アクセシビリティ目的とテスト目的の両方で、すべての UI オートメーション クライアントが UI オートメーション フレームワークを使ってコントロールを操作できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="ca842-121">As a provider, you should ensure that all UI Automation clients can use the UI Automation framework to interact with your control for both accessibility and testing purposes.</span></span>

<span data-ttu-id="ca842-122">UI オートメーション フレームワークには、通常、対応する 2 つの API があります。1 つは UI オートメーション クライアント用の API、もう 1 つは、似た名前を持つ UI オートメーション プロバイダー用の API です。</span><span class="sxs-lookup"><span data-stu-id="ca842-122">Typically there are parallel APIs in the UI Automation framework: one API for UI Automation clients and another, similarly named API for UI Automation providers.</span></span> <span data-ttu-id="ca842-123">このトピックでは主に、UI オートメーション プロバイダー用の API、特にこの UI フレームワークでプロバイダーの拡張性を可能にするクラスとインターフェイスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="ca842-123">For the most part, this topic covers the APIs for the UI Automation provider, and specifically the classes and interfaces that enable provider extensibility in that UI framework.</span></span> <span data-ttu-id="ca842-124">全体像を示すために、UI オートメーション クライアント用の UI オートメーション API に触れる場合もあります。また、クライアントとプロバイダー API の相関関係を示す表も含まれています。</span><span class="sxs-lookup"><span data-stu-id="ca842-124">Occasionally we mention UI Automation APIs that the UI Automation clients use, to provide some perspective, or provide a lookup table that correlates the client and provider APIs.</span></span> <span data-ttu-id="ca842-125">クライアント側から見た説明については、「[UI オートメーション クライアントのプログラマ ガイド](https://msdn.microsoft.com/library/windows/desktop/Ee684021)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-125">For more info about the client perspective, see [UI Automation Client Programmer's Guide](https://msdn.microsoft.com/library/windows/desktop/Ee684021).</span></span>

> [!NOTE]
> <span data-ttu-id="ca842-126">UI オートメーション クライアントは通常、マネージ コードを使用せず、UWP アプリ (一般にはデスクトップ アプリ) としては実装されません。</span><span class="sxs-lookup"><span data-stu-id="ca842-126">UI Automation clients don't typically use managed code and aren't typically implemented as a UWP app (they are usually desktop apps).</span></span> <span data-ttu-id="ca842-127">UI オートメーションは、特定の実装またはフレームワークではなく、標準に基づいています。</span><span class="sxs-lookup"><span data-stu-id="ca842-127">UI Automation is based on a standard and not a specific implementation or framework.</span></span> <span data-ttu-id="ca842-128">スクリーン リーダーなどの支援技術製品を含め、多くの既存の UI オートメーション クライアントは、コンポーネント オブジェクト モデル (COM) インターフェイスを使って UI オートメーション、システム、子ウィンドウで実行するアプリを操作します。</span><span class="sxs-lookup"><span data-stu-id="ca842-128">Many existing UI Automation clients, including assistive technology products such as screen readers, use Component Object Model (COM) interfaces to interact with UI Automation, the system, and the apps that run in child windows.</span></span> <span data-ttu-id="ca842-129">COM インターフェイスの情報と COM を使った UI オートメーション クライアントの作成方法について詳しくは、「[UI オートメーションの基礎](https://msdn.microsoft.com/library/windows/desktop/Ee684007)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-129">For more info on the COM interfaces and how to write a UI Automation client using COM, see [UI Automation Fundamentals](https://msdn.microsoft.com/library/windows/desktop/Ee684007).</span></span>

<span id="Determining_the_existing_state_of_UI_Automation_support_for_your_custom_UI_class"/>
<span id="determining_the_existing_state_of_ui_automation_support_for_your_custom_ui_class"/>
<span id="DETERMINING_THE_EXISTING_STATE_OF_UI_AUTOMATION_SUPPORT_FOR_YOUR_CUSTOM_UI_CLASS"/>

## <a name="determining-the-existing-state-of-ui-automation-support-for-your-custom-ui-class"></a><span data-ttu-id="ca842-130">カスタム UI クラスに対する UI オートメーション サポートの既存状態の特定</span><span class="sxs-lookup"><span data-stu-id="ca842-130">Determining the existing state of UI Automation support for your custom UI class</span></span>  
<span data-ttu-id="ca842-131">カスタム コントロールに対するオートメーション ピアを実装する前にまず、基底クラスとそのオートメーション ピアによって、必要なアクセシビリティやオートメーションのサポートが既に提供されているかどうかをテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-131">Before you attempt to implement an automation peer for a custom control, you should test whether the base class and its automation peer already provides the accessibility or automation support that you need.</span></span> <span data-ttu-id="ca842-132">多くの場合、[**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) の実装、特定のピア、および実装するパターンを組み合わせれば、基本的だが十分なアクセシビリティ エクスペリエンスが確保されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-132">In many cases, the combination of the [**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) implementations, specific peers, and the patterns they implement can provide a basic but satisfactory accessibility experience.</span></span> <span data-ttu-id="ca842-133">これが当てはまるかどうかは、コントロールと対応する基底クラスに対するオブジェクト モデルの公開に対し、どの程度変更を加えたかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="ca842-133">Whether this is true depends on how many changes you made to the object model exposure to your control versus its base class.</span></span> <span data-ttu-id="ca842-134">また、基底クラス機能に対する追加がテンプレート コントラクト中の新しい UI 要素、またはコントロールの外観のどちらに対応しているかにも依存します。</span><span class="sxs-lookup"><span data-stu-id="ca842-134">Also, this depends on whether your additions to base class functionality correlate to new UI elements in the template contract or to the visual appearance of the control.</span></span> <span data-ttu-id="ca842-135">状況によっては、それらの変更により、追加的なアクセシビリティ サポートが必要になる新しい側面を伴うユーザー エクスペリエンスが導入される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-135">In some cases your changes might introduce new aspects of user experience that require additional accessibility support.</span></span>

<span data-ttu-id="ca842-136">既にある基本ピア クラスを使って基本的なアクセシビリティ サポートを確保できる場合でも、自動テストのシナリオで UI オートメーションに正確な **ClassName** 情報を報告できるように、ピアを定義することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ca842-136">Even if using the existing base peer class provides the basic accessibility support, it is still a best practice to define a peer so that you can report precise **ClassName** information to UI Automation for automated testing scenarios.</span></span> <span data-ttu-id="ca842-137">これは、第三者が使うコントロールを作る場合には特に重要になります。</span><span class="sxs-lookup"><span data-stu-id="ca842-137">This consideration is especially important if you are writing a control that is intended for third-party consumption.</span></span>

<span id="Automation_peer_classes__"/>
<span id="automation_peer_classes__"/>
<span id="AUTOMATION_PEER_CLASSES__"/>

## <a name="automation-peer-classes"></a><span data-ttu-id="ca842-138">オートメーション ピア クラス</span><span class="sxs-lookup"><span data-stu-id="ca842-138">Automation peer classes</span></span>  
<span data-ttu-id="ca842-139">UWP は、Windows フォーム、Windows Presentation Foundation (WPF)、Microsoft Silverlight などの従来のマネージ コードによる UI フレームワークで使われていた既存の UI オートメーションに伴う手法と慣例に基づいて構築されています。</span><span class="sxs-lookup"><span data-stu-id="ca842-139">The UWP builds on existing UI Automation techniques and conventions used by previous managed-code UI frameworks such as Windows Forms, Windows Presentation Foundation (WPF) and Microsoft Silverlight.</span></span> <span data-ttu-id="ca842-140">コントロール クラス、各関数、およびその用途の多くが、従来の UI フレームワークを起源としています。</span><span class="sxs-lookup"><span data-stu-id="ca842-140">Many of the control classes and their function and purpose also have their origin in a previous UI framework.</span></span>

<span data-ttu-id="ca842-141">ピア クラスの名前は、慣例に従い、コントロール クラス名から始まり、"AutomationPeer" で終わります。</span><span class="sxs-lookup"><span data-stu-id="ca842-141">By convention, peer class names begin with the control class name and end with "AutomationPeer".</span></span> <span data-ttu-id="ca842-142">たとえば、[**ButtonAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242458) は、[**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265) コントロール クラスのピア クラスです。</span><span class="sxs-lookup"><span data-stu-id="ca842-142">For example, [**ButtonAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242458) is the peer class for the [**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265) control class.</span></span>

> [!NOTE]
> <span data-ttu-id="ca842-143">ここでは、このトピックの目的に合わせて、アクセシビリティに関連するプロパティを、コントロール ピアを実装するときの重要な要素として扱っています。</span><span class="sxs-lookup"><span data-stu-id="ca842-143">For purposes of this topic, we treat the properties that are related to accessibility as being more important when you implement a control peer.</span></span> <span data-ttu-id="ca842-144">UI オートメーション サポートのより一般的な概念と、ピアを実装する際の推奨事項については、「[UI オートメーション プロバイダーのプログラマ ガイド](https://msdn.microsoft.com/library/windows/desktop/Ee671596)」と「[UI オートメーションの基礎](https://msdn.microsoft.com/library/windows/desktop/Ee684007)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-144">But for a more general concept of UI Automation support, you should implement a peer in accordance with recommendations as documented by the [UI Automation Provider Programmer's Guide](https://msdn.microsoft.com/library/windows/desktop/Ee671596) and [UI Automation Fundamentals](https://msdn.microsoft.com/library/windows/desktop/Ee684007).</span></span> <span data-ttu-id="ca842-145">これらのトピックには、UWP フレームワークの情報を UI オートメーションに提供するために使う個々の [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) API の情報は含まれていませんが、クラスを識別したりその他の情報や対話式操作を提供したりするプロパティの情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="ca842-145">Those topics don't cover the specific [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) APIs that you would use to provide the information in the UWP framework for UI Automation, but they do describe the properties that identify your class or provide other information or interaction.</span></span>

<span id="Peers__patterns_and_control_types"/>
<span id="peers__patterns_and_control_types"/>
<span id="PEERS__PATTERNS_AND_CONTROL_TYPES"/>

## <a name="peers-patterns-and-control-types"></a><span data-ttu-id="ca842-146">ピア、パターン、コントロール型</span><span class="sxs-lookup"><span data-stu-id="ca842-146">Peers, patterns and control types</span></span>  
<span data-ttu-id="ca842-147">*コントロール パターン*は、コントロールの機能に関する特定の側面を UI オートメーション クライアントに公開するインターフェイス実装です。</span><span class="sxs-lookup"><span data-stu-id="ca842-147">A *control pattern* is an interface implementation that exposes a particular aspect of a control's functionality to a UI Automation client.</span></span> <span data-ttu-id="ca842-148">UI オートメーション クライアントでは、コントロール パターンによって公開されたプロパティやメソッドを使って、コントロールの機能に関する情報を取得したり、実行時にコントロールの動作を操作したりします。</span><span class="sxs-lookup"><span data-stu-id="ca842-148">UI Automation clients use the properties and methods exposed through a control pattern to retrieve information about capabilities of the control, or to manipulate the control's behavior at run time.</span></span>

<span data-ttu-id="ca842-149">コントロール パターンは、コントロール型やコントロールの外観に関係なくコントロールの機能を分類したり公開したりするための方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="ca842-149">Control patterns provide a way to categorize and expose a control's functionality independent of the control type or the appearance of the control.</span></span> <span data-ttu-id="ca842-150">たとえば、表形式のインターフェイスを表示するコントロールでは、**Grid** コントロール パターンを使って、表中の行と列の数を公開します。これにより UI オートメーション クライアント側では、表中の項目を取得できるようになります。</span><span class="sxs-lookup"><span data-stu-id="ca842-150">For example, a control that presents a tabular interface uses the **Grid** control pattern to expose the number of rows and columns in the table, and to enable a UI Automation client to retrieve items from the table.</span></span> <span data-ttu-id="ca842-151">ほかにもさまざまなコントロール パターンがあります。たとえば、**Invoke** コントロール パターンは、UI オートメーション クライアントでボタンなどの起動可能なコントロールに使います。また **Scroll** コントロール パターンは、リスト ボックス、リスト ビュー、コンボ ボックスなどのスクロール バーを含むコントロールに使います。</span><span class="sxs-lookup"><span data-stu-id="ca842-151">As other examples, the UI Automation client can use the **Invoke** control pattern for controls that can be invoked, such as buttons, and the **Scroll** control pattern for controls that have scroll bars, such as list boxes, list views, or combo boxes.</span></span> <span data-ttu-id="ca842-152">各コントロール パターンは、それぞれ個別の機能に対応します。複数のコントロール パターンを組み合わせることにより、特定のコントロールでサポートする全体的な機能セットを記述することもできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-152">Each control pattern represents a separate type of functionality, and control patterns can be combined to describe the full set of functionality supported by a particular control.</span></span>

<span data-ttu-id="ca842-153">コントロール パターンと UI の関係は、インターフェイスと COM オブジェクトの関係に似ています。</span><span class="sxs-lookup"><span data-stu-id="ca842-153">Control patterns relate to UI as interfaces relate to COM objects.</span></span> <span data-ttu-id="ca842-154">COM では、サポートしているインターフェイスをオブジェクトに問い合わせて、それらのインターフェイスを使って機能にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-154">In COM, you can query an object to ask what interfaces it supports and then use those interfaces to access functionality.</span></span> <span data-ttu-id="ca842-155">UI オートメーションでは、UI オートメーション クライアントが UI オートメーション要素にどのコントロール パターンがサポートされているかを照会し、サポートされているコントロール パターンによって公開されるプロパティ、メソッド、イベント、構造体を使って、要素とそのピア対象のコントロールを操作できます。</span><span class="sxs-lookup"><span data-stu-id="ca842-155">In UI Automation, UI Automation clients can query a UI Automation element to find out which control patterns it supports, and then interact with the element and its peered control through the properties, methods, events, and structures exposed by the supported control patterns.</span></span>

<span data-ttu-id="ca842-156">オートメーション ピアの主な目的の 1 つは、UI 要素がそのピアを通じてどのコントロール パターンをサポートできるのかを UI オートメーション クライアントに伝えることです。</span><span class="sxs-lookup"><span data-stu-id="ca842-156">One of the main purposes of an automation peer is to report to a UI Automation client which control patterns the UI element can support through its peer.</span></span> <span data-ttu-id="ca842-157">そのために、UI オートメーション プロバイダーは、[**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) メソッドを上書きして [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) メソッドの動作を変更する新しいピアを実装しています。</span><span class="sxs-lookup"><span data-stu-id="ca842-157">To do this, UI Automation providers implement new peers that change the [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) method behavior by overriding the [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) method.</span></span> <span data-ttu-id="ca842-158">UI オートメーション クライアントは、UI オートメーション プロバイダーを呼び出し元の **GetPattern** にマップする呼び出しを実行します。</span><span class="sxs-lookup"><span data-stu-id="ca842-158">UI Automation clients make calls that the UI Automation provider maps to calling **GetPattern**.</span></span> <span data-ttu-id="ca842-159">UI オートメーション クライアントは、操作する個々の具体的なパターンを照会します。</span><span class="sxs-lookup"><span data-stu-id="ca842-159">UI Automation clients query for each specific pattern that they want to interact with.</span></span> <span data-ttu-id="ca842-160">ピアでパターンがサポートされる場合は、パターンへのオブジェクト参照が返されます。サポートされない場合は、**null** が返されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-160">If the peer supports the pattern, it returns an object reference to itself; otherwise it returns **null**.</span></span> <span data-ttu-id="ca842-161">**null** 以外が返された場合、UI オートメーション クライアントでは、そのコントロール パターンとやり取りするために、クライアントとしてパターン インターフェイスの API を呼び出すことができると想定します。</span><span class="sxs-lookup"><span data-stu-id="ca842-161">If the return is not **null**, the UI Automation client expects that it can call APIs of the pattern interface as a client, in order to interact with that control pattern.</span></span>

<span data-ttu-id="ca842-162">*コントロール型*は、ピアによって表されるコントロールの機能を広く定義する手段です。</span><span class="sxs-lookup"><span data-stu-id="ca842-162">A *control type* is a way to broadly define the functionality of a control that the peer represents.</span></span> <span data-ttu-id="ca842-163">これはコントロール パターンとは異なる概念です。パターンでは、特定のインターフェイスを通じて取得できる情報や実行できる操作を UI オートメーションに通知しますが、コントロール型は、それよりも 1 つ上のレベルに位置するものです。</span><span class="sxs-lookup"><span data-stu-id="ca842-163">This is a different concept than a control pattern because while a pattern informs UI Automation what info it can get or what actions it can perform through a particular interface, the control type exists one level above that.</span></span> <span data-ttu-id="ca842-164">各コントロール型には、UI オートメーションの次の側面に関するガイダンスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="ca842-164">Each control type has guidance about these aspects of UI Automation:</span></span>

* <span data-ttu-id="ca842-165">UI オートメーション コントロール パターン: コントロール型によっては、異なる分類の情報や操作を表す複数のパターンをサポートしている場合があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-165">UI Automation control patterns: A control type might support more than one pattern, each of which represents a different classification of info or interaction.</span></span> <span data-ttu-id="ca842-166">各コントロール型には、そのコントロールでサポートする必要のあるコントロール パターンのセット、省略可能なセット、コントロールでサポートしてはいけないセットがあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-166">Each control type has a set of control patterns that the control must support, a set that is optional, and a set that the control must not support.</span></span>
* <span data-ttu-id="ca842-167">UI オートメーション プロパティ値: 各コントロール型には、そのコントロールでサポートする必要のあるプロパティのセットがあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-167">UI Automation property values: Each control type has a set of properties that the control must support.</span></span> <span data-ttu-id="ca842-168">これらは、「[UI オートメーション プロパティの概要](https://msdn.microsoft.com/library/windows/desktop/Ee671594)」で説明されている全般的なプロパティであり、パターン固有のプロパティではありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-168">These are the general properties, as described in [UI Automation Properties Overview](https://msdn.microsoft.com/library/windows/desktop/Ee671594), not the ones that are pattern-specific.</span></span>
* <span data-ttu-id="ca842-169">UI オートメーション イベント: 各コントロール型には、そのコントロールでサポートする必要のあるイベントのセットがあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-169">UI Automation events: Each control type has a set of events that the control must support.</span></span> <span data-ttu-id="ca842-170">これらも、「[UI オートメーション イベントの概要](https://msdn.microsoft.com/library/windows/desktop/Ee671221)」で説明されている全般的なイベントであり、パターン固有のものではありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-170">Again these are general, not pattern-specific, as described in [UI Automation Events Overview](https://msdn.microsoft.com/library/windows/desktop/Ee671221).</span></span>
* <span data-ttu-id="ca842-171">UI オートメーション ツリー構造: 各コントロール型は、そのコントロールが UI コントロール ツリー構造にどのように現れるかを定義します。</span><span class="sxs-lookup"><span data-stu-id="ca842-171">UI Automation tree structure: Each control type defines how the control must appear in the UI Automation tree structure.</span></span>

<span data-ttu-id="ca842-172">フレームワークのオートメーション ピアの実装方法にかかわらず、UI オートメーション クライアントの機能は、UWP に縛られるものではありません。実際、支援技術などの既にある UI オートメーション クライアントでは、COM などの他のプログラミング モデルが使われていることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-172">Regardless of how automation peers for the framework are implemented, UI Automation client functionality isn't tied to the UWP, and in fact it's likely that existing UI Automation clients such as assistive technologies will use other programming models, such as COM.</span></span> <span data-ttu-id="ca842-173">COM では、クライアントから **QueryInterface** を呼び出すことで、必要なパターンや、プロパティ、イベント、またはツリーの検査のための一般的な UI オートメーション フレームワークを実装する COM コントロール パターン インターフェイスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="ca842-173">In COM, clients can **QueryInterface** for the COM control pattern interface that implements the requested pattern or the general UI Automation framework for properties, events or tree examination.</span></span> <span data-ttu-id="ca842-174">パターンの場合は、そのインターフェイス コードが、UI オートメーション フレームワークにより、アプリの UI オートメーション プロバイダーとその関連ピアに対して実行されている UWP コードにマーシャリングされます。</span><span class="sxs-lookup"><span data-stu-id="ca842-174">For the patterns, the UI Automation framework marshals that interface code across into UWP code running against the app's UI Automation provider and the relevant peer.</span></span>

<span data-ttu-id="ca842-175">C\# または Microsoft Visual Basic を使った UWP アプリなど、マネージ コードのフレームワークに対するコントロール パターンを実装すると、COM インターフェイスの表現ではなく、.NET Framework インターフェイスを使って、各パターンを表すことができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-175">When you implement control patterns for a managed-code framework such as a UWP app using C\# or Microsoft Visual Basic, you can use .NET Framework interfaces to represent these patterns instead of using the COM interface representation.</span></span> <span data-ttu-id="ca842-176">たとえば、**Invoke** というパターンの Microsoft .NET プロバイダーによる実装に対応した UI オートメーション パターン インターフェイスは、[**IInvokeProvider**](https://msdn.microsoft.com/library/windows/apps/BR242582) となります。</span><span class="sxs-lookup"><span data-stu-id="ca842-176">For example, the UI Automation pattern interface for a Microsoft .NET provider implementation of the **Invoke** pattern is [**IInvokeProvider**](https://msdn.microsoft.com/library/windows/apps/BR242582).</span></span>

<span data-ttu-id="ca842-177">コントロール パターン、プロバイダー インターフェイス、それらの目的の一覧については、「[コントロール パターンとインターフェイス](control-patterns-and-interfaces.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-177">For a list of control patterns, provider interfaces, and their purpose, see [Control patterns and interfaces](control-patterns-and-interfaces.md).</span></span> <span data-ttu-id="ca842-178">コントロール型の一覧については、「[UI オートメーション コントロール型の概要](https://msdn.microsoft.com/library/windows/desktop/Ee671197)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca842-178">For the list of the control types, see [UI Automation Control Types Overview](https://msdn.microsoft.com/library/windows/desktop/Ee671197).</span></span>

<span id="Guidance_for_how_to_implement_control_patterns"/>
<span id="guidance_for_how_to_implement_control_patterns"/>
<span id="GUIDANCE_FOR_HOW_TO_IMPLEMENT_CONTROL_PATTERNS"/>

### <a name="guidance-for-how-to-implement-control-patterns"></a><span data-ttu-id="ca842-179">コントロール パターンの実装方法に関するガイダンス</span><span class="sxs-lookup"><span data-stu-id="ca842-179">Guidance for how to implement control patterns</span></span>  
<span data-ttu-id="ca842-180">コントロール パターンとその用途は、より広範囲にわたる UI オートメーション フレームワークの定義の一部であり、UWP アプリのアクセシビリティ サポートに適用されるだけにとどまりません。</span><span class="sxs-lookup"><span data-stu-id="ca842-180">The control patterns and what they're intended for are part of a larger definition of the UI Automation framework, and don't just apply to the accessibility support for a UWP app.</span></span> <span data-ttu-id="ca842-181">コントロール パターンを実装するときは、MSDN に説明されているガイダンスに従っていることを確かめる必要があります。このガイダンスは UI オートメーション仕様にも含まれています。</span><span class="sxs-lookup"><span data-stu-id="ca842-181">When you implement a control pattern you should make sure you're implementing it in a way that matches the guidance as documented on MSDN and also in the UI Automation specification.</span></span> <span data-ttu-id="ca842-182">通常、ガイダンスが必要な場合は MSDN のトピックを使うことができ、仕様を参照する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-182">If you're looking for guidance, you can generally use the MSDN topics and won't need to refer to the specification.</span></span> <span data-ttu-id="ca842-183">各パターンのガイダンスは、「[UI オートメーション コントロール パターンの実装](https://msdn.microsoft.com/library/windows/desktop/Ee671292)」で説明されています。</span><span class="sxs-lookup"><span data-stu-id="ca842-183">Guidance for each pattern is documented here: [Implementing UI Automation Control Patterns](https://msdn.microsoft.com/library/windows/desktop/Ee671292).</span></span> <span data-ttu-id="ca842-184">この分野の各トピックには、「実装のガイドラインと規則」と「必須メンバー」というセクションが含まれています。</span><span class="sxs-lookup"><span data-stu-id="ca842-184">You'll notice that each topic under this area has an "Implementation Guidelines and Conventions" section and "Required Members" section.</span></span> <span data-ttu-id="ca842-185">ガイダンスは、通常、「[プロバイダー向けコントロール パターン インターフェイス](https://msdn.microsoft.com/library/windows/desktop/Ee671201)」リファレンスにある関連するコントロール パターン インターフェイスの特定の API を参照しています。</span><span class="sxs-lookup"><span data-stu-id="ca842-185">The guidance usually refers to specific APIs of the relevant control pattern interface in the [Control Pattern Interfaces for Providers](https://msdn.microsoft.com/library/windows/desktop/Ee671201) reference.</span></span> <span data-ttu-id="ca842-186">これらのインターフェイスはネイティブ/COM インターフェイスです (API では COM 形式の構文が使われます)。</span><span class="sxs-lookup"><span data-stu-id="ca842-186">Those interfaces are the native/COM interfaces (and their APIs use COM-style syntax).</span></span> <span data-ttu-id="ca842-187">ただし、いずれも [**Windows.UI.Xaml.Automation.Provider**](https://msdn.microsoft.com/library/windows/apps/BR209225) 名前空間に同等のものが用意されています。</span><span class="sxs-lookup"><span data-stu-id="ca842-187">But everything you see there has an equivalent in the [**Windows.UI.Xaml.Automation.Provider**](https://msdn.microsoft.com/library/windows/apps/BR209225) namespace.</span></span>

<span data-ttu-id="ca842-188">既定のオートメーション ピアを使ってその動作を拡張している場合、それらのピアは、既に UI オートメーション ガイドラインに準拠するように記述されています。</span><span class="sxs-lookup"><span data-stu-id="ca842-188">If you're using the default automation peers and expanding on their behavior, those peers have already been written in conformance to UI Automation guidelines.</span></span> <span data-ttu-id="ca842-189">それらのピアがコントロール パターンをサポートしている場合は、そのパターン サポートを使えば、「[UI オートメーション コントロール パターンの実装](https://msdn.microsoft.com/library/windows/desktop/Ee671292)」のガイダンスに従うことができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-189">If they support control patterns, you can rely on that pattern support conforming with guidance at [Implementing UI Automation Control Patterns](https://msdn.microsoft.com/library/windows/desktop/Ee671292).</span></span> <span data-ttu-id="ca842-190">コントロール ピアが自身を UI オートメーションで定義されるコントロール型の表現として報告する場合、そのピアは「[UI オートメーション コントロール型](https://msdn.microsoft.com/library/windows/desktop/Ee671633)」のガイダンスに従っていることになります。</span><span class="sxs-lookup"><span data-stu-id="ca842-190">If a control peer reports that it's representative of a control type defined by UI Automation, then the guidance documented at [Supporting UI Automation Control Types](https://msdn.microsoft.com/library/windows/desktop/Ee671633) has been followed by that peer.</span></span>

<span data-ttu-id="ca842-191">ただし、UI オートメーションの推奨事項に従ってピアを実装するためには、コントロール パターンやコントロール型に関する追加のガイダンスが必要になることもあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-191">Nevertheless you might need additional guidance for control patterns or control types in order to follow the UI Automation recommendations in your peer implementation.</span></span> <span data-ttu-id="ca842-192">これは特に、まだ UWP コントロールに既定の実装として含まれていないパターンやコントロール型のサポートを実装する場合に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="ca842-192">That would be particularly true if you're implementing pattern or control type support that doesn't yet exist as a default implementation in a UWP control.</span></span> <span data-ttu-id="ca842-193">たとえば、既定の XAML コントロールには、いずれも注釈のパターンは実装されていません。</span><span class="sxs-lookup"><span data-stu-id="ca842-193">For example, the pattern for annotations isn't implemented in any of the default XAML controls.</span></span> <span data-ttu-id="ca842-194">しかし、注釈を広く利用するアプリを作っている場合は、この機能を表面に押し出してアクセスしやすくすると便利です。</span><span class="sxs-lookup"><span data-stu-id="ca842-194">But you might have an app that uses annotations extensively and therefore you want to surface that functionality to be accessible.</span></span> <span data-ttu-id="ca842-195">このようなシナリオでは、ピアで [**IAnnotationProvider**](https://msdn.microsoft.com/library/windows/apps/Hh738493) を実装し、適切なプロパティを持つ **Document** コントロール型として自身を報告して、ドキュメントが注釈をサポートしていることを示します。</span><span class="sxs-lookup"><span data-stu-id="ca842-195">For this scenario, your peer should implement [**IAnnotationProvider**](https://msdn.microsoft.com/library/windows/apps/Hh738493) and should probably report itself as the **Document** control type with appropriate properties to indicate that your documents support annotation.</span></span>

<span data-ttu-id="ca842-196">「[UI オートメーション コントロール パターンの実装](https://msdn.microsoft.com/library/windows/desktop/Ee671292)」で説明されているパターンに関するガイダンス、または「[UI オートメーション コントロール型のサポート](https://msdn.microsoft.com/library/windows/desktop/Ee671633)」で説明されているコントロール型に関するガイダンスを、方向性を示す全般的なガイダンスとして使うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ca842-196">We recommend that you use the guidance that you see for the patterns under [Implementing UI Automation Control Patterns](https://msdn.microsoft.com/library/windows/desktop/Ee671292) or control types under [Supporting UI Automation Control Types](https://msdn.microsoft.com/library/windows/desktop/Ee671633) as orientation and general guidance.</span></span> <span data-ttu-id="ca842-197">各 API の目的に関する説明や注意事項については、その API のリンク先をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-197">You might even try following some of the API links for descriptions and remarks as to the purpose of the APIs.</span></span> <span data-ttu-id="ca842-198">ただし、UWP アプリのプログラミングに必要な構文について詳しくは、[**Windows.UI.Xaml.Automation.Provider**](https://msdn.microsoft.com/library/windows/apps/BR209225) 名前空間にある同等の API を検索して、そのリファレンス ページをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-198">But for syntax specifics that are needed for UWP app programming, find the equivalent API within the [**Windows.UI.Xaml.Automation.Provider**](https://msdn.microsoft.com/library/windows/apps/BR209225) namespace and use those reference pages for more info.</span></span>

<span id="Built-in_automation_peer_classes"/>
<span id="built-in_automation_peer_classes"/>
<span id="BUILT-IN_AUTOMATION_PEER_CLASSES"/>

## <a name="built-in-automation-peer-classes"></a><span data-ttu-id="ca842-199">ビルトイン オートメーション ピア クラス</span><span class="sxs-lookup"><span data-stu-id="ca842-199">Built-in automation peer classes</span></span>  
<span data-ttu-id="ca842-200">通常、UI 要素でユーザーからの UI アクティビティを受け入れる場合や、アプリの対話型の UI や意味のある UI を表す支援技術のユーザーが必要とする情報が要素の中に存在する場合は、要素によってオートメーション ピア クラスを実装します。</span><span class="sxs-lookup"><span data-stu-id="ca842-200">In general, elements implement an automation peer class if they accept UI activity from the user, or if they contain information needed by users of assistive technologies that represent the interactive or meaningful UI of apps.</span></span> <span data-ttu-id="ca842-201">UWP のすべてのビジュアル要素にオートメーション ピアがあるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-201">Not all UWP visual elements have automation peers.</span></span> <span data-ttu-id="ca842-202">オートメーション ピアを実装するクラスの例として、[**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265) や [**TextBox**](https://msdn.microsoft.com/library/windows/apps/BR209683) があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-202">Examples of classes that implement automation peers are [**Button**](https://msdn.microsoft.com/library/windows/apps/BR209265) and [**TextBox**](https://msdn.microsoft.com/library/windows/apps/BR209683).</span></span> <span data-ttu-id="ca842-203">一方、オートメーション ピアを実装しないクラスの例として、[**Border**](https://msdn.microsoft.com/library/windows/apps/BR209250) のほか、[**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) や [**Canvas**](https://msdn.microsoft.com/library/windows/apps/BR209267) など [**Panel**](https://msdn.microsoft.com/library/windows/apps/BR227511) ベースのクラスがあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-203">Examples of classes that do not implement automation peers are [**Border**](https://msdn.microsoft.com/library/windows/apps/BR209250) and classes based on [**Panel**](https://msdn.microsoft.com/library/windows/apps/BR227511), such as [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) and [**Canvas**](https://msdn.microsoft.com/library/windows/apps/BR209267).</span></span> <span data-ttu-id="ca842-204">**Panel** にはピアはありません。これは、ビジュアル専用のレイアウト動作が提供され、</span><span class="sxs-lookup"><span data-stu-id="ca842-204">A **Panel** has no peer because it is providing a layout behavior that is visual only.</span></span> <span data-ttu-id="ca842-205">ユーザーが **Panel** とやり取りするためのアクセシビリティに関連する方法がないためです。</span><span class="sxs-lookup"><span data-stu-id="ca842-205">There is no accessibility-relevant way for the user to interact with a **Panel**.</span></span> <span data-ttu-id="ca842-206">代わりに、**Panel** に含まれる子要素はいずれも UI オートメーション ツリーに対し、ピアまたは要素の表現が存在するツリー中で次に利用できる親の子要素として報告されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-206">Whatever child elements a **Panel** contains are instead reported to UI Automation trees as child elements of the next available parent in the tree that has a peer or element representation.</span></span>

<span id="UI_Automation_and_UWP_process_boundaries"/>
<span id="ui_automation_and_uwp_process_boundaries"/>
<span id="UI_AUTOMATION_AND_UWP_PROCESS_BOUNDARIES"/>

## <a name="ui-automation-and-uwp-process-boundaries"></a><span data-ttu-id="ca842-207">UI オートメーションと UWP のプロセス境界</span><span class="sxs-lookup"><span data-stu-id="ca842-207">UI Automation and UWP process boundaries</span></span>  
<span data-ttu-id="ca842-208">UWP アプリにアクセスする UI オートメーション クライアントのコードは、通常はアウトプロセスで実行されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-208">Typically, UI Automation client code that accesses a UWP app runs out-of-process.</span></span> <span data-ttu-id="ca842-209">UI オートメーション フレームワークのインフラストラクチャを使うと、プロセス境界を越えて情報をやり取りできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-209">The UI Automation framework infrastructure enables information to get across the process boundary.</span></span> <span data-ttu-id="ca842-210">この概念について詳しくは、「[UI オートメーションの基礎](https://msdn.microsoft.com/library/windows/desktop/Ee684007)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-210">This concept is explained in more detail in [UI Automation Fundamentals](https://msdn.microsoft.com/library/windows/desktop/Ee684007).</span></span>

<span id="OnCreateAutomationPeer"/>
<span id="oncreateautomationpeer"/>
<span id="ONCREATEAUTOMATIONPEER"/>

## <a name="oncreateautomationpeer"></a><span data-ttu-id="ca842-211">OnCreateAutomationPeer</span><span class="sxs-lookup"><span data-stu-id="ca842-211">OnCreateAutomationPeer</span></span>  
<span data-ttu-id="ca842-212">[**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) から派生されたクラスにはいずれも、保護された仮想メソッド [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) が含まれます。</span><span class="sxs-lookup"><span data-stu-id="ca842-212">All classes that derive from [**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) contain the protected virtual method [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer).</span></span> <span data-ttu-id="ca842-213">オートメーション ピアに対するオブジェクト初期化シーケンスでは、**OnCreateAutomationPeer** を呼び出すことにより、個々のコントロールに対するオートメーション ピア オブジェクトを取得します。これにより、UI オートメーション ツリーを構築して実行時に使うことができるようにします。</span><span class="sxs-lookup"><span data-stu-id="ca842-213">The object initialization sequence for automation peers calls **OnCreateAutomationPeer** to get the automation peer object for each control and thus to construct a UI Automation tree for run-time use.</span></span> <span data-ttu-id="ca842-214">UI オートメーション コードでは、ピアを使ってコントロールの特性と機能に関する情報を取得し、そのコントロール パターンに基づいて対話型の使用方法をシミュレートできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-214">UI Automation code can use the peer to get information about a control’s characteristics and features and to simulate interactive use by means of its control patterns.</span></span> <span data-ttu-id="ca842-215">オートメーションをサポートするカスタム コントロールでは、**OnCreateAutomationPeer** を上書きし、[**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) から派生するクラスのインスタンスを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-215">A custom control that supports automation must override **OnCreateAutomationPeer** and return an instance of a class that derives from [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185).</span></span> <span data-ttu-id="ca842-216">たとえば、あるカスタム コントロールを [**ButtonBase**](https://msdn.microsoft.com/library/windows/apps/BR227736) クラスから派生させる場合、**OnCreateAutomationPeer** が返すオブジェクトは、[**ButtonBaseAutomationPeer**](https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.automation.peers.buttonbaseautomationpeer) から派生させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-216">For example, if a custom control derives from the [**ButtonBase**](https://msdn.microsoft.com/library/windows/apps/BR227736) class, the object returned by **OnCreateAutomationPeer** should derive from [**ButtonBaseAutomationPeer**](https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.automation.peers.buttonbaseautomationpeer).</span></span>

<span data-ttu-id="ca842-217">カスタム コントロール クラスを作成し、新しいオートメーション ピアも指定する場合には、ピアの新しいインスタンスが返されるようにするために、カスタム コントロールに関して [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) メソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-217">If you're writing a custom control class and intend to also supply a new automation peer, you should override the [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) method for your custom control so that it returns a new instance of your peer.</span></span> <span data-ttu-id="ca842-218">ピア クラスは [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) から直接的または間接的に派生していることが必要です。</span><span class="sxs-lookup"><span data-stu-id="ca842-218">Your peer class must derive directly or indirectly from [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185).</span></span>

<span data-ttu-id="ca842-219">たとえば、次のコードでは、カスタム コントロール `NumericUpDown` により UI オートメーション用としてピア `NumericUpDownPeer` を使うことを宣言しています。</span><span class="sxs-lookup"><span data-stu-id="ca842-219">For example, the following code declares that the custom control `NumericUpDown` should use the peer `NumericUpDownPeer` for UI Automation purposes.</span></span>

```csharp
using Windows.UI.Xaml.Automation.Peers;
...
public class NumericUpDown : RangeBase {
    public NumericUpDown() {
    // other initialization; DefaultStyleKey etc.
    }
    ...
    protected override AutomationPeer OnCreateAutomationPeer()
    {
        return new NumericUpDownAutomationPeer(this);
    }
}
```

```vb
Public Class NumericUpDown
    Inherits RangeBase
    ' other initialization; DefaultStyleKey etc.
       Public Sub New()
       End Sub
       Protected Overrides Function OnCreateAutomationPeer() As AutomationPeer
              Return New NumericUpDownAutomationPeer(Me)
       End Function
End Class
```

```cppwinrt
// NumericUpDown.idl
namespace MyNamespace
{
    runtimeclass NumericUpDown : Windows.UI.Xaml.Controls.Primitives.RangeBase
    {
        NumericUpDown();
        Int32 MyProperty;
    }
}

// NumericUpDown.h
...
struct NumericUpDown : NumericUpDownT<NumericUpDown>
{
    ...
    Windows::UI::Xaml::Automation::Peers::AutomationPeer OnCreateAutomationPeer()
    {
        return winrt::make<MyNamespace::implementation::NumericUpDownAutomationPeer>(*this);
    }
};
```

```cpp
//.h
public ref class NumericUpDown sealed : Windows::UI::Xaml::Controls::Primitives::RangeBase
{
// other initialization not shown
protected:
    virtual AutomationPeer^ OnCreateAutomationPeer() override
    {
         return ref new NumericUpDownAutomationPeer(this);
    }
};
```

> [!NOTE]
> <span data-ttu-id="ca842-220">[**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) の実装では、カスタム オートメーション ピアの新しいインスタンスを初期化して呼び出し元のコントロールを所有者として渡し、そのインスタンスを返すだけにします。</span><span class="sxs-lookup"><span data-stu-id="ca842-220">The [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) implementation should do nothing more than initialize a new instance of your custom automation peer, passing the calling control as owner, and return that instance.</span></span> <span data-ttu-id="ca842-221">このメソッドで追加のロジックを実行しないでください。</span><span class="sxs-lookup"><span data-stu-id="ca842-221">Do not attempt additional logic in this method.</span></span> <span data-ttu-id="ca842-222">特に、[**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) のデストラクションにつながる可能性のあるロジックが同じ呼び出し内にあると、ランタイムで予期しない動作が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-222">In particular, any logic that could potentially lead to destruction of the [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) within the same call may result in unexpected runtime behavior.</span></span>

<span data-ttu-id="ca842-223">[**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) の典型的な実装の場合、メソッドの上書きは、残りのコントロール クラス定義と同じスコープで行われるため、*owner* は、**this** または **Me** として指定されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-223">In typical implementations of [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer), the *owner* is specified as **this** or **Me** because the method override is in the same scope as the rest of the control class definition.</span></span>

<span data-ttu-id="ca842-224">実際のピア クラスは、コントロールと同じコード ファイル、または別個のコード ファイルで定義できます。</span><span class="sxs-lookup"><span data-stu-id="ca842-224">The actual peer class definition can be done in the same code file as the control or in a separate code file.</span></span> <span data-ttu-id="ca842-225">ピア定義はいずれも、ピアを提供するコントロールとは別の [**Windows.UI.Xaml.Automation.Peers**](https://msdn.microsoft.com/library/windows/apps/BR242563) という名前空間に存在します。</span><span class="sxs-lookup"><span data-stu-id="ca842-225">The peer definitions all exist in the [**Windows.UI.Xaml.Automation.Peers**](https://msdn.microsoft.com/library/windows/apps/BR242563) namespace that is a separate namespace from the controls that they provide peers for.</span></span> <span data-ttu-id="ca842-226">独自のピアも、[**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) メソッドの呼び出しに必要な名前空間を参照している限り、別個の名前空間に宣言できます。</span><span class="sxs-lookup"><span data-stu-id="ca842-226">You can choose to declare your peers in separate namespaces also, as long as you reference the necessary namespaces for the [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) method call.</span></span>

<span id="Choosing_the_correct_peer_base_class"/>
<span id="choosing_the_correct_peer_base_class"/>
<span id="CHOOSING_THE_CORRECT_PEER_BASE_CLASS"/>

### <a name="choosing-the-correct-peer-base-class"></a><span data-ttu-id="ca842-227">正しいピアの基底クラスの選択</span><span class="sxs-lookup"><span data-stu-id="ca842-227">Choosing the correct peer base class</span></span>  
<span data-ttu-id="ca842-228">派生元となるコントロール クラスの既存のピア ロジックに合致する基底クラスから [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) を派生させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-228">Make sure that your [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) is derived from a base class that gives you the best match for the existing peer logic of the control class you are deriving from.</span></span> <span data-ttu-id="ca842-229">前の例の場合、[**RangeBase**](https://msdn.microsoft.com/library/windows/apps/BR227863) から `NumericUpDown` が派生されるため、ピアのベースにする必要がある [**RangeBaseAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242506) クラスが使用できます。</span><span class="sxs-lookup"><span data-stu-id="ca842-229">In the case of the previous example, because `NumericUpDown` derives from [**RangeBase**](https://msdn.microsoft.com/library/windows/apps/BR227863), there is a [**RangeBaseAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242506) class available that you should base your peer on.</span></span> <span data-ttu-id="ca842-230">コントロール自体の派生方法に最も合致するピア クラスを使うことにより、[**IRangeValueProvider**](https://msdn.microsoft.com/library/windows/apps/BR242590) は既に基本ピア クラスで実装されているため、少なくともその機能の一部は上書きせずに済みます。</span><span class="sxs-lookup"><span data-stu-id="ca842-230">By using the closest matching peer class in parallel to how you derive the control itself, you can avoid overriding at least some of the [**IRangeValueProvider**](https://msdn.microsoft.com/library/windows/apps/BR242590) functionality because the base peer class already implements it.</span></span>

<span data-ttu-id="ca842-231">基底クラス [**Control**](https://msdn.microsoft.com/library/windows/apps/BR209390) には、対応するピア クラスがありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-231">The base [**Control**](https://msdn.microsoft.com/library/windows/apps/BR209390) class does not have a corresponding peer class.</span></span> <span data-ttu-id="ca842-232">**Control** から派生させたカスタム コントロールにピア クラスを対応させる場合は、[**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) からカスタム ピア クラスを派生させます。</span><span class="sxs-lookup"><span data-stu-id="ca842-232">If you need a peer class to correspond to a custom control that derives from **Control**, derive the custom peer class from [**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472).</span></span>

<span data-ttu-id="ca842-233">[**ContentControl**](https://msdn.microsoft.com/library/windows/apps/BR209365) からクラスを直接派生させる場合、そのクラスには、ピア クラスを参照する [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) の実装がないため、既定のオートメーション ピア動作は伴いません。</span><span class="sxs-lookup"><span data-stu-id="ca842-233">If you derive from [**ContentControl**](https://msdn.microsoft.com/library/windows/apps/BR209365) directly, that class has no default automation peer behavior because there is no [**OnCreateAutomationPeer**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer) implementation that references a peer class.</span></span> <span data-ttu-id="ca842-234">したがって、**OnCreateAutomationPeer** を実装して独自のピアを使うか、[**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) をピアとして使います (コントロールにとってこのレベルのアクセシビリティ サポートで十分である場合)。</span><span class="sxs-lookup"><span data-stu-id="ca842-234">So make sure either to implement **OnCreateAutomationPeer** to use your own peer, or to use [**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) as the peer if that level of accessibility support is adequate for your control.</span></span>

> [!NOTE]
> <span data-ttu-id="ca842-235">通常、[**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) ではなく [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) からは派生しません。</span><span class="sxs-lookup"><span data-stu-id="ca842-235">You don't typically derive from [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) rather than [**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472).</span></span> <span data-ttu-id="ca842-236">**AutomationPeer** から直接派生する場合、それ以外の場合に **FrameworkElementAutomationPeer** から得られる多くの基本的なアクセシビリティ サポートを複製する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-236">If you did derive directly from **AutomationPeer** you'll need to duplicate a lot of basic accessibility support that would otherwise come from **FrameworkElementAutomationPeer**.</span></span>

<span id="Initialization_of_a_custom_peer_class"/>
<span id="initialization_of_a_custom_peer_class"/>
<span id="INITIALIZATION_OF_A_CUSTOM_PEER_CLASS"/>

## <a name="initialization-of-a-custom-peer-class"></a><span data-ttu-id="ca842-237">カスタム ピア クラスの初期化</span><span class="sxs-lookup"><span data-stu-id="ca842-237">Initialization of a custom peer class</span></span>  
<span data-ttu-id="ca842-238">オートメーション ピアでは、基底クラスの初期化に所有者コントロールのインスタンスを使うタイプ セーフなコンストラクターを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-238">The automation peer should define a type-safe constructor that uses an instance of the owner control for base initialization.</span></span> <span data-ttu-id="ca842-239">次の例では、実装により *owner* の値が基本 [**RangeBaseAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242506) に渡されます。最終的に *owner* を使って [**FrameworkElementAutomationPeer.Owner**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.owner) を設定するのは [**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) です。</span><span class="sxs-lookup"><span data-stu-id="ca842-239">In the next example, the implementation passes the *owner* value on to the [**RangeBaseAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242506) base, and ultimately it is the [**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) that actually uses *owner* to set [**FrameworkElementAutomationPeer.Owner**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.owner).</span></span>

```csharp
public NumericUpDownAutomationPeer(NumericUpDown owner): base(owner)
{}
```

```vb
Public Sub New(owner As NumericUpDown)
    MyBase.New(owner)
End Sub
```

```cppwinrt
// NumericUpDownAutomationPeer.idl
import "NumericUpDown.idl";
namespace MyNamespace
{
    runtimeclass NumericUpDownAutomationPeer : Windows.UI.Xaml.Automation.Peers.AutomationPeer
    {
        NumericUpDownAutomationPeer(NumericUpDown owner);
        Int32 MyProperty;
    }
}

// NumericUpDownAutomationPeer.h
...
struct NumericUpDownAutomationPeer : NumericUpDownAutomationPeerT<NumericUpDownAutomationPeer>
{
    ...
    NumericUpDownAutomationPeer(MyNamespace::NumericUpDown const& owner);
};
```

```cpp
//.h
public ref class NumericUpDownAutomationPeer sealed :  Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer
//.cpp
public:    NumericUpDownAutomationPeer(NumericUpDown^ owner);
```

<span id="Core_methods_of_AutomationPeer"/>
<span id="core_methods_of_automationpeer"/>
<span id="CORE_METHODS_OF_AUTOMATIONPEER"/>

## <a name="core-methods-of-automationpeer"></a><span data-ttu-id="ca842-240">AutomationPeer の Core メソッド</span><span class="sxs-lookup"><span data-stu-id="ca842-240">Core methods of AutomationPeer</span></span>  
<span data-ttu-id="ca842-241">UWP のインフラストラクチャ上の理由から、オートメーション ピアの上書き可能メソッドは、次の 2 つのメソッドのペアで構成されます。UI オートメーション プロバイダーが UI オートメーション クライアントの転送ポイントとして使用するパブリック アクセス メソッドと、UWP クラスが動作に影響を与えるために上書きできる保護された "Core" カスタマイズ メソッドの 2 つです。</span><span class="sxs-lookup"><span data-stu-id="ca842-241">For UWP infrastructure reasons, the overridable methods of an automation peer are part of a pair of methods: the public access method that the UI Automation provider uses as a forwarding point for UI Automation clients, and the protected "Core" customization method that a UWP class can override to influence the behavior.</span></span> <span data-ttu-id="ca842-242">既定では、メソッドのペアは互いに結合されており、アクセス メソッドが呼び出されるたびに、対応するプロバイダーの実装を含む "Core" メソッドが (または、フォールバックとして基底クラスの既定の実装が) 呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-242">The method pair is wired together by default in such a way that the call to the access method always invokes the parallel "Core" method that has the provider implementation, or as a fallback, invokes a default implementation from the base classes.</span></span>

<span data-ttu-id="ca842-243">カスタム コントロールのピアを実装するときは、そのカスタム コントロールに固有の動作を公開するオートメーション ピア基底クラスから、すべての "Core" メソッドを上書きします。</span><span class="sxs-lookup"><span data-stu-id="ca842-243">When implementing a peer for a custom control, override any of the "Core" methods from the base automation peer class where you want to expose behavior that is unique to your custom control.</span></span> <span data-ttu-id="ca842-244">UI オートメーション コードは、ピア クラスのパブリック メソッドを呼び出すことにより、コントロールに関する情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="ca842-244">UI Automation code gets information about your control by calling public methods of the peer class.</span></span> <span data-ttu-id="ca842-245">コントロールに関する情報を提供するにあたり、コントロールの実装と設計によって作るアクセシビリティまたはその他の UI オートメーションのシナリオが、オートメーション ピアの基底クラスによってサポートされているものとは異なる場合は、名前の末尾が "Core" というメソッドをすべて上書きする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-245">To provide information about your control, override each method with a name that ends with "Core" when your control implementation and design creates accessibility scenarios or other UI Automation scenarios that differ from what's supported by the base automation peer class.</span></span>

<span data-ttu-id="ca842-246">少なくとも、新規のピア クラスを定義するときは必ず、次の例に示すように、[**GetClassNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getclassnamecore) メソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="ca842-246">At a minimum, whenever you define a new peer class, implement the [**GetClassNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getclassnamecore) method, as shown in the next example.</span></span>

```csharp
protected override string GetClassNameCore()
{
    return "NumericUpDown";
}
```

> [!NOTE]
> <span data-ttu-id="ca842-247">文字列をメソッドの本文に直接格納する代わりに、定数として格納することもできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-247">You might want to store the strings as constants rather than directly in the method body, but that is up to you.</span></span> <span data-ttu-id="ca842-248">[**GetClassNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getclassnamecore) では、この文字列をローカライズする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-248">For [**GetClassNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getclassnamecore), you won't need to localize this string.</span></span> <span data-ttu-id="ca842-249">UI オートメーション クライアントで、**ClassName** ではなくローカライズした文字列が必要とされる場合はいつも **LocalizedControlType** プロパティが使用されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-249">The **LocalizedControlType** property is used any time a localized string is needed by a UI Automation client, not **ClassName**.</span></span>

### <span id="GetAutomationControlType"/>
<span id="getautomationcontroltype"/>
<span id="GETAUTOMATIONCONTROLTYPE"/><span data-ttu-id="ca842-250">GetAutomationControlType</span><span class="sxs-lookup"><span data-stu-id="ca842-250">GetAutomationControlType</span></span>

<span data-ttu-id="ca842-251">一部の支援技術では、UI オートメーション ツリー中の項目に関する特性を報告するときに、UI オートメーションの **Name** 以外の追加情報として、[**GetAutomationControlType**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltype) の値を直接使っている場合があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-251">Some assistive technologies use the [**GetAutomationControlType**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltype) value directly when reporting characteristics of the items in a UI Automation tree, as additional information beyond the UI Automation **Name**.</span></span> <span data-ttu-id="ca842-252">派生元のコントロールと大幅に異なるコントロールで、基本ピア クラスで報告されるものとは異なるコントロール型を報告する場合は、ピアを実装して [**GetAutomationControlTypeCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltypecore) をオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-252">If your control is significantly different from the control you are deriving from and you want to report a different control type from what is reported by the base peer class used by the control, you must implement a peer and override [**GetAutomationControlTypeCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltypecore) in your peer implementation.</span></span> <span data-ttu-id="ca842-253">[**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803)、[**ContentControl**](https://msdn.microsoft.com/library/windows/apps/BR209365) などの汎用の基底クラスを派生元として使う場合は、コントロール型に関する正確な情報が基本ピアから提供されないため、このことが特に重要になります。</span><span class="sxs-lookup"><span data-stu-id="ca842-253">This is particularly important if you derive from a generalized base class such as [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803) or [**ContentControl**](https://msdn.microsoft.com/library/windows/apps/BR209365), where the base peer doesn't provide precise information about control type.</span></span>

<span data-ttu-id="ca842-254">[**GetAutomationControlTypeCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltypecore) の実装で、[**AutomationControlType**](https://msdn.microsoft.com/library/windows/apps/BR209182) 値を返すことにより、コントロールを記述します。</span><span class="sxs-lookup"><span data-stu-id="ca842-254">Your implementation of [**GetAutomationControlTypeCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltypecore) describes your control by returning an [**AutomationControlType**](https://msdn.microsoft.com/library/windows/apps/BR209182) value.</span></span> <span data-ttu-id="ca842-255">**AutomationControlType.Custom** を返すこともできますが、コントロールのメイン シナリオを正確に記述している場合は、より具体的なコントロール タイプのいずれかを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-255">Although you can return **AutomationControlType.Custom**, you should return one of the more specific control types if it accurately describes your control's main scenarios.</span></span> <span data-ttu-id="ca842-256">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="ca842-256">Here's an example.</span></span>

```csharp
protected override AutomationControlType GetAutomationControlTypeCore()
{
    return AutomationControlType.Spinner;
}
```

> [!NOTE]
> <span data-ttu-id="ca842-257">[**AutomationControlType.Custom**](https://msdn.microsoft.com/library/windows/apps/BR209182) を指定する場合以外は、[**GetLocalizedControlTypeCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getlocalizedcontroltypecore) を実装して **LocalizedControlType** プロパティ値をクライアントに提供する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-257">Unless you specify [**AutomationControlType.Custom**](https://msdn.microsoft.com/library/windows/apps/BR209182), you don't have to implement [**GetLocalizedControlTypeCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getlocalizedcontroltypecore) to provide a **LocalizedControlType** property value to clients.</span></span> <span data-ttu-id="ca842-258">**AutomationControlType.Custom** 以外のすべての **AutomationControlType** 値では、UI オートメーションの共通インフラストラクチャによって翻訳済みの文字列が提供されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-258">UI Automation common infrastructure provides translated strings for every possible **AutomationControlType** value other than **AutomationControlType.Custom**.</span></span>

<span id="GetPattern_and_GetPatternCore"/>
<span id="getpattern_and_getpatterncore"/>
<span id="GETPATTERN_AND_GETPATTERNCORE"/>

### <a name="getpattern-and-getpatterncore"></a><span data-ttu-id="ca842-259">GetPattern と GetPatternCore</span><span class="sxs-lookup"><span data-stu-id="ca842-259">GetPattern and GetPatternCore</span></span>  
<span data-ttu-id="ca842-260">[**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) をピアで実装することにより、入力パラメーターで要求したパターンをサポートするオブジェクトが返されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-260">A peer's implementation of [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) returns the object that supports the pattern that is requested in the input parameter.</span></span> <span data-ttu-id="ca842-261">具体的には、UI オートメーション クライアントで、プロバイダーの [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) メソッドに転送されるメソッドを呼び出して、要求されたパターンを示す [**PatternInterface**](https://msdn.microsoft.com/library/windows/apps/BR242496) 列挙値を指定します。</span><span class="sxs-lookup"><span data-stu-id="ca842-261">Specifically, a UI Automation client calls a method that is forwarded to the provider's [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) method, and specifies a [**PatternInterface**](https://msdn.microsoft.com/library/windows/apps/BR242496) enumeration value that names the requested pattern.</span></span> <span data-ttu-id="ca842-262">**GetPatternCore** を上書きすると、指定されたパターンを実装するオブジェクトが返されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-262">Your override of **GetPatternCore** should return the object that implements the specified pattern.</span></span> <span data-ttu-id="ca842-263">ピアは、パターンのサポートを報告する対象である、対応するパターン インターフェイスを実装している必要があるため、そのオブジェクトはピア自身です。</span><span class="sxs-lookup"><span data-stu-id="ca842-263">That object is the peer itself, because the peer should implement the corresponding pattern interface any time that it reports that it supports a pattern.</span></span> <span data-ttu-id="ca842-264">ピアにパターンのカスタム実装が含まれていないが、ピアの基本型にそのパターンが実装されていることがわかっている場合は、基本型の **GetPatternCore** の実装を **GetPatternCore** から呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-264">If your peer does not have a custom implementation of a pattern, but you know that the peer's base does implement the pattern, you can call the base type's implementation of **GetPatternCore** from your **GetPatternCore**.</span></span> <span data-ttu-id="ca842-265">ピアでパターンがサポートされていない場合は、ピアの **GetPatternCore** で **null** を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-265">A peer's **GetPatternCore** should return **null** if a pattern is not supported by the peer.</span></span> <span data-ttu-id="ca842-266">ただし、通常は、独自の実装から直接 **null** を返すのではなく、基本実装の呼び出しを利用して **null** を返すようにします。</span><span class="sxs-lookup"><span data-stu-id="ca842-266">However, instead of returning **null** directly from your implementation, you would usually rely on the call to the base implementation to return **null** for any unsupported pattern.</span></span>

<span data-ttu-id="ca842-267">パターンがサポートされている場合、[**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) 実装では **this** または **Me** を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-267">When a pattern is supported, the [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) implementation can return **this** or **Me**.</span></span> <span data-ttu-id="ca842-268">ここでは、[**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) の戻り値が **null** 以外の場合は UI オートメーション クライアントが戻り値を要求されたパターン インターフェイスにキャストすることが前提とされています。</span><span class="sxs-lookup"><span data-stu-id="ca842-268">The expectation is that the UI Automation client will cast the [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) return value to the requested pattern interface whenever it is not **null**.</span></span>

<span data-ttu-id="ca842-269">あるピア クラスが別のピアから継承された場合、必要なサポートとパターン報告がすべて基底クラスによって既に処理されていれば、[**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) の実装は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-269">If a peer class inherits from another peer, and all necessary support and pattern reporting is already handled by the base class, implementing [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) isn't necessary.</span></span> <span data-ttu-id="ca842-270">たとえば、[**RangeBase**](https://msdn.microsoft.com/library/windows/apps/BR227863) から派生させた範囲コントロールを実装する場合、ピアが [**RangeBaseAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242506) から派生されていれば、このピアは、[**PatternInterface.RangeValue**](https://msdn.microsoft.com/library/windows/apps/BR242496) に対して自身を返し、パターンをサポートする [**IRangeValueProvider**](https://msdn.microsoft.com/library/windows/apps/BR242590) インターフェイスの現行の実装を使います。</span><span class="sxs-lookup"><span data-stu-id="ca842-270">For example, if you are implementing a range control that derives from [**RangeBase**](https://msdn.microsoft.com/library/windows/apps/BR227863), and your peer derives from [**RangeBaseAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242506), that peer returns itself for [**PatternInterface.RangeValue**](https://msdn.microsoft.com/library/windows/apps/BR242496) and has working implementations of the [**IRangeValueProvider**](https://msdn.microsoft.com/library/windows/apps/BR242590) interface that supports the pattern.</span></span>

<span data-ttu-id="ca842-271">次の例は、実際のコードそのものではありませんが、[**RangeBaseAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242506) 中に既に存在している [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) の実装の概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="ca842-271">Although it is not the literal code, this example approximates the implementation of [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) already present in [**RangeBaseAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242506).</span></span>


```csharp
protected override object GetPatternCore(PatternInterface patternInterface)
{
    if (patternInterface == PatternInterface.RangeValue)
    {
        return this;
    }
    return base.GetPattern(patternInterface);
}
```

<span data-ttu-id="ca842-272">ピアの実装時に、必要なすべてのサポートが基本ピア クラスから得られない場合、またはピアがサポートできる基本継承パターンのセットに変更や追加が必要な場合は、[**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) を上書きして、UI オートメーション クライアントがパターンを使うことができるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-272">If you are implementing a peer where you don't have all the support you need from a base peer class, or you want to change or add to the set of base-inherited patterns that your peer can support, then you should override [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) to enable UI Automation clients to use the patterns.</span></span>

<span data-ttu-id="ca842-273">UI オートメーションに対応した UWP 実装で利用可能なプロバイダー パターンの一覧については、「[**Windows.UI.Xaml.Automation.Provider**](https://msdn.microsoft.com/library/windows/apps/BR209225)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-273">For a list of the provider patterns that are available in the UWP implementation of UI Automation support, see [**Windows.UI.Xaml.Automation.Provider**](https://msdn.microsoft.com/library/windows/apps/BR209225).</span></span> <span data-ttu-id="ca842-274">このような個々のパターンにはそれぞれ、[**PatternInterface**](https://msdn.microsoft.com/library/windows/apps/BR242496) 列挙に対応する値があります。この値により、UI オートメーション クライアントが [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) の呼び出しでパターンを要求します。</span><span class="sxs-lookup"><span data-stu-id="ca842-274">Each such pattern has a corresponding value of the [**PatternInterface**](https://msdn.microsoft.com/library/windows/apps/BR242496) enumeration, which is how UI Automation clients request the pattern in a [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) call.</span></span>

<span data-ttu-id="ca842-275">ピアでは、複数のパターンをサポートしていることを伝えることができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-275">A peer can report that it supports more than one pattern.</span></span> <span data-ttu-id="ca842-276">この場合、上書きのときに、サポートされる個々の [**PatternInterface**](https://msdn.microsoft.com/library/windows/apps/BR242496) 値に対するリターン パス ロジックを指定して、一致するケースごとにペアが返されるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-276">If so, the override should include return path logic for each supported [**PatternInterface**](https://msdn.microsoft.com/library/windows/apps/BR242496) value and return the peer in each matching case.</span></span> <span data-ttu-id="ca842-277">このとき、呼び出し元では 1 回に 1 個ずつインターフェイスを要求すること、さらに予期されるインターフェイスへのキャストは呼び出し元が行うことが前提となります。</span><span class="sxs-lookup"><span data-stu-id="ca842-277">It is expected that the caller will request only one interface at a time, and it is up to the caller to cast to the expected interface.</span></span>

<span data-ttu-id="ca842-278">次にカスタム ピアに対する [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) の上書きの例を示します。</span><span class="sxs-lookup"><span data-stu-id="ca842-278">Here's an example of a [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) override for a custom peer.</span></span> <span data-ttu-id="ca842-279">[**IRangeValueProvider**](https://msdn.microsoft.com/library/windows/apps/BR242590) と [**IToggleProvider**](https://msdn.microsoft.com/library/windows/apps/BR242653) の 2 つのパターンに対するサポートが報告されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-279">It reports the support for two patterns, [**IRangeValueProvider**](https://msdn.microsoft.com/library/windows/apps/BR242590) and [**IToggleProvider**](https://msdn.microsoft.com/library/windows/apps/BR242653).</span></span> <span data-ttu-id="ca842-280">このコントロールは、全画面表示として表示できるメディア表示コントロール (トグル モード) です。進行状況バーの表示位置は変更可能 (範囲コントロール) です。</span><span class="sxs-lookup"><span data-stu-id="ca842-280">The control here is a media display control that can display as full-screen (the toggle mode) and that has a progress bar within which users can select a position (the range control).</span></span> <span data-ttu-id="ca842-281">このコードは、[XAML アクセシビリティ サンプル](http://go.microsoft.com/fwlink/p/?linkid=238570)の抜粋です。</span><span class="sxs-lookup"><span data-stu-id="ca842-281">This code came from the [XAML accessibility sample](http://go.microsoft.com/fwlink/p/?linkid=238570).</span></span>


```csharp
protected override object GetPatternCore(PatternInterface patternInterface)
{
    if (patternInterface == PatternInterface.RangeValue)
    {
        return this;
    }
    else if (patternInterface == PatternInterface.Toggle)
    {
        return this;
    }
    return null;
}
```

<span id="Forwarding_patterns_from_sub-elements"/>
<span id="forwarding_patterns_from_sub-elements"/>
<span id="FORWARDING_PATTERNS_FROM_sub-elementS"/>

### <a name="forwarding-patterns-from-sub-elements"></a><span data-ttu-id="ca842-282">子要素からのパターンの転送</span><span class="sxs-lookup"><span data-stu-id="ca842-282">Forwarding patterns from sub-elements</span></span>  
<span data-ttu-id="ca842-283">[**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) メソッドの実装では、ホストのパターン プロバイダーとして子要素や一部分を指定できます。</span><span class="sxs-lookup"><span data-stu-id="ca842-283">A [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) method implementation can also specify a sub-element or part as a pattern provider for its host.</span></span> <span data-ttu-id="ca842-284">この例は、[**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803) が内部の [**ScrollViewer**](https://msdn.microsoft.com/library/windows/apps/BR209527) コントロールのピアに向けてスクロール パターン処理を転送する方法を模したものです。</span><span class="sxs-lookup"><span data-stu-id="ca842-284">This example mimics how [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/BR242803) transfers scroll-pattern handling to the peer of its internal [**ScrollViewer**](https://msdn.microsoft.com/library/windows/apps/BR209527) control.</span></span> <span data-ttu-id="ca842-285">パターン処理の子要素を指定するために、このコードではまず子要素オブジェクトを取得して、[**FrameworkElementAutomationPeer.CreatePeerForElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.createpeerforelement) メソッドにより子要素のピアを作り、新しいピアを返します。</span><span class="sxs-lookup"><span data-stu-id="ca842-285">To specify a sub-element for pattern handling, this code gets the sub-element object, creates a peer for the sub-element by using the [**FrameworkElementAutomationPeer.CreatePeerForElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.createpeerforelement) method, and returns the new peer.</span></span>


```csharp
protected override object GetPatternCore(PatternInterface patternInterface)
{
    if (patternInterface == PatternInterface.Scroll)
    {
        ItemsControl owner = (ItemsControl) base.Owner;
        UIElement itemsHost = owner.ItemsHost;
        ScrollViewer element = null;
        while (itemsHost != owner)
        {
            itemsHost = VisualTreeHelper.GetParent(itemsHost) as UIElement;
            element = itemsHost as ScrollViewer;
            if (element != null)
            {
                break;
            }
        }
        if (element != null)
        {
            AutomationPeer peer = FrameworkElementAutomationPeer.CreatePeerForElement(element);
            if ((peer != null) && (peer is IScrollProvider))
            {
                return (IScrollProvider) peer;
            }
        }
    }
    return base.GetPatternCore(patternInterface);
}
```

<span id="Other_Core_methods"/>
<span id="other_core_methods"/>
<span id="OTHER_CORE_METHODS"/>

### <a name="other-core-methods"></a><span data-ttu-id="ca842-286">その他の Core メソッド</span><span class="sxs-lookup"><span data-stu-id="ca842-286">Other Core methods</span></span>  
<span data-ttu-id="ca842-287">コントロールで、主要なシナリオに対してキーボードの同等機能のサポートが必要になる場合があります。これが必要になる理由について詳しくは、「[キーボードのアクセシビリティ](keyboard-accessibility.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-287">Your control may need to support keyboard equivalents for primary scenarios; for more info about why this might be necessary, see [Keyboard accessibility](keyboard-accessibility.md).</span></span> <span data-ttu-id="ca842-288">キー サポートの実装は、コントロールのロジックの一部であるため、ピア コードではなくコントロール コードの一部になりますが、ピア クラスでは、[**GetAcceleratorKeyCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getacceleratorkeycore) と [**GetAccessKeyCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getaccesskeycore) のメソッドを上書きすることにより、現在どのキーが使われているかを UI オートメーション クライアントに報告する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-288">Implementing the key support is necessarily part of the control code and not the peer code because that is part of a control's logic, but your peer class should override the [**GetAcceleratorKeyCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getacceleratorkeycore) and [**GetAccessKeyCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getaccesskeycore) methods to report to UI Automation clients which keys are used.</span></span> <span data-ttu-id="ca842-289">キーの情報を報告する文字列はローカライズされる可能性があるため、リソースから取得し、ハードコードした文字列は使いません。</span><span class="sxs-lookup"><span data-stu-id="ca842-289">Consider that the strings that report key information might need to be localized, and should therefore come from resources, not hard-coded strings.</span></span>

<span data-ttu-id="ca842-290">コレクションをサポートするクラスのピアを提供する場合は、同じ種類のコレクション サポートが既に存在する機能クラスとピア クラスの両方から派生させるのが最もよい方法です。</span><span class="sxs-lookup"><span data-stu-id="ca842-290">If you are providing a peer for a class that supports a collection, it's best to derive from both functional classes and peer classes that already have that kind of collection support.</span></span> <span data-ttu-id="ca842-291">これができない場合は、子コレクションを維持しているコントロールのピアでコレクションに関連するピア メソッド、[**GetChildrenCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getchildrencore) を上書きして、UI オートメーション ツリーに親子の関係を正しく報告する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-291">If you can't do so, peers for controls that maintain child collections may have to override the collection-related peer method [**GetChildrenCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getchildrencore) to properly report the parent-child relationships to the UI Automation tree.</span></span>

<span data-ttu-id="ca842-292">[**IsContentElementCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.iscontentelementcore) メソッドと [**IsControlElementCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.iscontrolelementcore) メソッドを実装して、コントロールにデータ コンテンツが含まれているのか、またはユーザー インターフェイスで対話型の役割を果たすのか (あるいはその両方なのか) を指示します。</span><span class="sxs-lookup"><span data-stu-id="ca842-292">Implement the [**IsContentElementCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.iscontentelementcore) and [**IsControlElementCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.iscontrolelementcore) methods to indicate whether your control contains data content or fulfills an interactive role in the user interface (or both).</span></span> <span data-ttu-id="ca842-293">既定では、両方のメソッドで **true** が返されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-293">By default, both methods return **true**.</span></span> <span data-ttu-id="ca842-294">これらの設定により、各メソッドを使ってオートメーション ツリーをフィルターするスクリーン リーダーなどの支援技術の操作性が改善されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-294">These settings improve the usability of assistive technologies such as screen readers, which may use these methods to filter the automation tree.</span></span> <span data-ttu-id="ca842-295">[**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) メソッドで、子要素ピアにパターン処理を転送すると、子要素ピアの **IsControlElementCore** メソッドが、子要素ピアをオートメーション ツリーから隠すために、**false** を返すことがあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-295">If your [**GetPatternCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) method transfers pattern handling to a sub-element peer, the sub-element peer's **IsControlElementCore** method can return **false** to hide the sub-element peer from the automation tree.</span></span>

<span data-ttu-id="ca842-296">コントロールの中には、テキスト ラベルの部分がテキスト以外の部分の情報を提供したり、コントロールと UI の別のコントロールとの間にラベル付けの関係が確立されたりする、ラベル付けのシナリオをサポートするものもあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-296">Some controls may support labeling scenarios, where a text label part supplies information for a non-text part, or a control is intended to be in a known labeling relationship with another control in the UI.</span></span> <span data-ttu-id="ca842-297">クラス ベースの有用な動作を提供できる場合は、[**GetLabeledByCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getlabeledbycore) をオーバーライドしてこの動作を提供できます。</span><span class="sxs-lookup"><span data-stu-id="ca842-297">If it's possible to provide a useful class-based behavior, you can override [**GetLabeledByCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getlabeledbycore) to provide this behavior.</span></span>

<span data-ttu-id="ca842-298">[**GetBoundingRectangleCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getboundingrectanglecore) と [**GetClickablePointCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getclickablepointcore) は、主に自動テストのシナリオに使われます。</span><span class="sxs-lookup"><span data-stu-id="ca842-298">[**GetBoundingRectangleCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getboundingrectanglecore) and [**GetClickablePointCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getclickablepointcore) are used mainly for automated testing scenarios.</span></span> <span data-ttu-id="ca842-299">コントロールの自動テストをサポートする場合は、これらのメソッドを上書きする必要があることがあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-299">If you want to support automated testing for your control, you might want to override these methods.</span></span> <span data-ttu-id="ca842-300">範囲型のコントロールでは、座標空間でユーザーがクリックした場所によって範囲への効果が異なり、1 つのポイントのみを提案できないため、これが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-300">This might be desired for range-type controls, where you can't suggest just a single point because where the user clicks in coordinate space has a different effect on a range.</span></span> <span data-ttu-id="ca842-301">たとえば、既定の [**ScrollBar**](https://msdn.microsoft.com/library/windows/apps/BR209745) オートメーション ピアは **GetClickablePointCore** を上書きして、"数字ではない" [**Point**](https://msdn.microsoft.com/library/windows/apps/BR225870) 値を返します。</span><span class="sxs-lookup"><span data-stu-id="ca842-301">For example, the default [**ScrollBar**](https://msdn.microsoft.com/library/windows/apps/BR209745) automation peer overrides **GetClickablePointCore** to return a "not a number" [**Point**](https://msdn.microsoft.com/library/windows/apps/BR225870) value.</span></span>

<span data-ttu-id="ca842-302">[**GetLiveSettingCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getlivesettingcore) は、UI オートメーションの **LiveSetting** 値のコントロール既定値に影響します。</span><span class="sxs-lookup"><span data-stu-id="ca842-302">[**GetLiveSettingCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getlivesettingcore) influences the control default for the **LiveSetting** value for UI Automation.</span></span> <span data-ttu-id="ca842-303">これをオーバーライドして、コントロールが [**AutomationLiveSetting.Off**](https://msdn.microsoft.com/library/windows/apps/JJ191519) 以外の値を返すようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-303">You might want to override this if you want your control to return a value other than [**AutomationLiveSetting.Off**](https://msdn.microsoft.com/library/windows/apps/JJ191519).</span></span> <span data-ttu-id="ca842-304">**LiveSetting** が何を表すかについて詳しくは、「[**AutomationProperties.LiveSetting**](https://msdn.microsoft.com/library/windows/apps/JJ191516)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-304">For more info on what **LiveSetting** represents, see [**AutomationProperties.LiveSetting**](https://msdn.microsoft.com/library/windows/apps/JJ191516).</span></span>

<span data-ttu-id="ca842-305">コントロールが、[**GetOrientationCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getorientationcore) にマップできる設定可能な向きのプロパティを持っている場合は、[**AutomationOrientation**](https://msdn.microsoft.com/library/windows/apps/BR209184) を上書きできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-305">You might override [**GetOrientationCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getorientationcore) if your control has a settable orientation property that can map to [**AutomationOrientation**](https://msdn.microsoft.com/library/windows/apps/BR209184).</span></span> <span data-ttu-id="ca842-306">[**ScrollBarAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242522) クラスと [**SliderAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242546) クラスがこれを行います。</span><span class="sxs-lookup"><span data-stu-id="ca842-306">The [**ScrollBarAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242522) and [**SliderAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242546) classes do this.</span></span>

<span id="Base_implementation_in_FrameworkElementAutomationPeer"/>
<span id="base_implementation_in_frameworkelementautomationpeer"/>
<span id="BASE_IMPLEMENTATION_IN_FRAMEWORKELEMENTAUTOMATIONPEER"/>

### <a name="base-implementation-in-frameworkelementautomationpeer"></a><span data-ttu-id="ca842-307">FrameworkElementAutomationPeer の基本実装</span><span class="sxs-lookup"><span data-stu-id="ca842-307">Base implementation in FrameworkElementAutomationPeer</span></span>  
<span data-ttu-id="ca842-308">[**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) の基本実装は、フレームワーク レベルで定義されるレイアウトや動作のさまざまなプロパティから解釈できる UI オートメーションの情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="ca842-308">The base implementation of [**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) provides some UI Automation information that can be interpreted from various layout and behavior properties that are defined at the framework level.</span></span>

* <span data-ttu-id="ca842-309">[**GetBoundingRectangleCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getboundingrectanglecore): 既知のレイアウト特性に基づいて [**Rect**](https://msdn.microsoft.com/library/windows/apps/BR225994) 構造体を返します。</span><span class="sxs-lookup"><span data-stu-id="ca842-309">[**GetBoundingRectangleCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getboundingrectanglecore): Returns a [**Rect**](https://msdn.microsoft.com/library/windows/apps/BR225994) structure based on the known layout characteristics.</span></span> <span data-ttu-id="ca842-310">[**IsOffscreen**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.isoffscreen) が **true** の場合は、値が 0 の **Rect** を返します。</span><span class="sxs-lookup"><span data-stu-id="ca842-310">Returns a 0-value **Rect** if [**IsOffscreen**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.isoffscreen) is **true**.</span></span>
* <span data-ttu-id="ca842-311">[**GetClickablePointCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getclickablepointcore): 既知のレイアウト特性に基づいて [**Point**](https://msdn.microsoft.com/library/windows/apps/BR225870) 構造体を返します (値が 0 でない **BoundingRectangle** がある場合)。</span><span class="sxs-lookup"><span data-stu-id="ca842-311">[**GetClickablePointCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getclickablepointcore): Returns a [**Point**](https://msdn.microsoft.com/library/windows/apps/BR225870) structure based on the known layout characteristics, as long as there is a nonzero **BoundingRectangle**.</span></span>
* <span data-ttu-id="ca842-312">[**GetNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getnamecore): このメソッドの動作は多岐にわたるため、ここでは紹介しきれません。詳しくは、「[**GetNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getnamecore)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-312">[**GetNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getnamecore): More extensive behavior than can be summarized here; see [**GetNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getnamecore).</span></span> <span data-ttu-id="ca842-313">基本的には、[**ContentControl**](https://msdn.microsoft.com/library/windows/apps/BR209365) やコンテンツを持つ関連クラスの既知のコンテンツの文字列変換を試行します。</span><span class="sxs-lookup"><span data-stu-id="ca842-313">Basically, it attempts a string conversion on any known content of a [**ContentControl**](https://msdn.microsoft.com/library/windows/apps/BR209365) or related classes that have content.</span></span> <span data-ttu-id="ca842-314">また、[**LabeledBy**](https://msdn.microsoft.com/library/windows/apps/Hh759769) の値がある場合は、その項目の **Name** の値が **Name** として使われます。</span><span class="sxs-lookup"><span data-stu-id="ca842-314">Also, if there is a value for [**LabeledBy**](https://msdn.microsoft.com/library/windows/apps/Hh759769), that item's **Name** value is used as the **Name**.</span></span>
* <span data-ttu-id="ca842-315">[**HasKeyboardFocusCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.haskeyboardfocuscore): 所有者の [**FocusState**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.focusstate) プロパティと [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.isenabled) プロパティに基づいて評価されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-315">[**HasKeyboardFocusCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.haskeyboardfocuscore): Evaluated based on the owner's [**FocusState**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.focusstate) and [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.isenabled) properties.</span></span> <span data-ttu-id="ca842-316">コントロールではない要素は常に **false** を返します。</span><span class="sxs-lookup"><span data-stu-id="ca842-316">Elements that aren't controls always return **false**.</span></span>
* <span data-ttu-id="ca842-317">[**IsEnabledCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.isenabledcore): 所有者の [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.isenabled) プロパティに基づいて評価されます (所有者が [**Control**](https://msdn.microsoft.com/library/windows/apps/BR209390) の場合)。</span><span class="sxs-lookup"><span data-stu-id="ca842-317">[**IsEnabledCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.isenabledcore): Evaluated based on the owner's [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.isenabled) property if it is a [**Control**](https://msdn.microsoft.com/library/windows/apps/BR209390).</span></span> <span data-ttu-id="ca842-318">コントロールではない要素は常に **true** を返します。</span><span class="sxs-lookup"><span data-stu-id="ca842-318">Elements that aren't controls always return **true**.</span></span> <span data-ttu-id="ca842-319">これは、従来の対話式操作の意味で所有者が有効であることを示すのではなく、所有者に **IsEnabled** プロパティがなくてもピアは有効であることを示します。</span><span class="sxs-lookup"><span data-stu-id="ca842-319">This doesn't mean that the owner is enabled in the conventional interaction sense; it means that the peer is enabled despite the owner not having an **IsEnabled** property.</span></span>
* <span data-ttu-id="ca842-320">[**IsKeyboardFocusableCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.iskeyboardfocusablecore): 所有者が [**Control**](https://msdn.microsoft.com/library/windows/apps/BR209390) の場合は **true**、それ以外の場合は **false** を返します。</span><span class="sxs-lookup"><span data-stu-id="ca842-320">[**IsKeyboardFocusableCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.iskeyboardfocusablecore): Returns **true** if owner is a [**Control**](https://msdn.microsoft.com/library/windows/apps/BR209390); otherwise it is **false**.</span></span>
* <span data-ttu-id="ca842-321">[**IsOffscreenCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.isoffscreencore): 所有者要素またはそのいずれかの親の [**Visibility**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.visibility) が [**Collapsed**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visibility) の場合に [**IsOffscreen**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.isoffscreen) の値が **true** になります。</span><span class="sxs-lookup"><span data-stu-id="ca842-321">[**IsOffscreenCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.isoffscreencore): A [**Visibility**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.visibility) of [**Collapsed**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visibility) on the owner element or any of its parents equates to a **true** value for [**IsOffscreen**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.isoffscreen).</span></span> <span data-ttu-id="ca842-322">[**Popup**](https://msdn.microsoft.com/library/windows/apps/BR227842) オブジェクトは例外で、所有者の親が表示されていなくても表示される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-322">Exception: a [**Popup**](https://msdn.microsoft.com/library/windows/apps/BR227842) object can be visible even if its owner's parents are not.</span></span>
* <span data-ttu-id="ca842-323">[**SetFocusCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.setfocuscore): [**Focus**](https://msdn.microsoft.com/library/windows/apps/hh702161) を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ca842-323">[**SetFocusCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.setfocuscore): Calls [**Focus**](https://msdn.microsoft.com/library/windows/apps/hh702161).</span></span>
* <span data-ttu-id="ca842-324">[**GetParent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getparent): 所有者から [**FrameworkElement.Parent**](https://msdn.microsoft.com/library/windows/apps/BR208739) を呼び出して適切なピアを検索します。</span><span class="sxs-lookup"><span data-stu-id="ca842-324">[**GetParent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getparent): Calls [**FrameworkElement.Parent**](https://msdn.microsoft.com/library/windows/apps/BR208739) from the owner, and looks up the appropriate peer.</span></span> <span data-ttu-id="ca842-325">これは、"Core" メソッドを含む上書きペアではないため、この動作を変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="ca842-325">This isn't an override pair with a "Core" method, so you can't change this behavior.</span></span>

> [!NOTE]
> <span data-ttu-id="ca842-326">UWP の既定のピアは、UWP を実装する内部のネイティブ コードを使って動作を実装します。実際の UWP コードが使われるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="ca842-326">Default UWP peers implement a behavior by using internal native code that implements the UWP, not necessarily by using actual UWP code.</span></span> <span data-ttu-id="ca842-327">共通言語ランタイム (CLR) のリフレクションやその他の手法を使って実装のコードやロジックを見ることはできません。</span><span class="sxs-lookup"><span data-stu-id="ca842-327">You won't be able to see the code or logic of the implementation through common language runtime (CLR) reflection or other techniques.</span></span> <span data-ttu-id="ca842-328">また、基本ピアの動作のサブクラス固有のオーバーライドに対応する個別のリファレンス ページはありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-328">You also won't see distinct reference pages for subclass-specific overrides of base peer behavior.</span></span> <span data-ttu-id="ca842-329">たとえば、[**TextBoxAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242550) の [**GetNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getnamecore) には、**AutomationPeer.GetNameCore** のリファレンス ページでは説明されていない追加の動作がある可能性がありますが、**TextBoxAutomationPeer.GetNameCore** にはリファレンス ページがありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-329">For example, there might be additional behavior for [**GetNameCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getnamecore) of a [**TextBoxAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242550), which won't be described on the **AutomationPeer.GetNameCore** reference page, and there is no reference page for **TextBoxAutomationPeer.GetNameCore**.</span></span> <span data-ttu-id="ca842-330">そもそも、**TextBoxAutomationPeer.GetNameCore** のリファレンス ページは存在しません。</span><span class="sxs-lookup"><span data-stu-id="ca842-330">There isn't even a **TextBoxAutomationPeer.GetNameCore** reference page.</span></span> <span data-ttu-id="ca842-331">代わりに、最も近いピア クラスのリファレンス トピックを参照して、「注釈」セクションで実装の注釈を探してください。</span><span class="sxs-lookup"><span data-stu-id="ca842-331">Instead, read the reference topic for the most immediate peer class, and look for implementation notes in the Remarks section.</span></span>

<span id="Peers_and_AutomationProperties"/>
<span id="peers_and_automationproperties"/>
<span id="PEERS_AND_AUTOMATIONPROPERTIES"/>

## <a name="peers-and-automationproperties"></a><span data-ttu-id="ca842-332">ピアと AutomationProperties</span><span class="sxs-lookup"><span data-stu-id="ca842-332">Peers and AutomationProperties</span></span>  
<span data-ttu-id="ca842-333">オートメーション ピアでは、コントロールのアクセシビリティに関連する情報に対して適切な既定値を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-333">Your automation peer should provide appropriate default values for your control's accessibility-related information.</span></span> <span data-ttu-id="ca842-334">コントロールを使うアプリ コードでは、添付プロパティ [**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/BR209081) の値をコントロール インスタンスに取り込むことにより、その動作の一部をオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-334">Note that any app code that uses the control can override some of that behavior by including [**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/BR209081) attached-property values on control instances.</span></span> <span data-ttu-id="ca842-335">呼び出し元では、既定コントロールまたはカスタム コントロールのいずれにも、この操作を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-335">Callers can do this either for the default controls or for custom controls.</span></span> <span data-ttu-id="ca842-336">たとえば、次の XAML では、カスタマイズした 2 つの UI オートメーション プロパティを使うボタンを作ります。</span><span class="sxs-lookup"><span data-stu-id="ca842-336">For example, the following XAML creates a button that has two customized UI Automation properties:</span></span> `<Button AutomationProperties.Name="Special"      AutomationProperties.HelpText="This is a special button."/>`

<span data-ttu-id="ca842-337">[**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/BR209081) 添付プロパティについて詳しくは、「[基本的なアクセシビリティ情報](basic-accessibility-information.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ca842-337">For more info about [**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/BR209081) attached properties, see [Basic accessibility information](basic-accessibility-information.md).</span></span>

<span data-ttu-id="ca842-338">[**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) メソッドの一部は、UI オートメーション プロバイダーがどのように情報を報告するかを定める一般的なコントラクトのために存在しています。ただし、通常これらのメソッドはコントロール ピアでは実装されません。</span><span class="sxs-lookup"><span data-stu-id="ca842-338">Some of the [**AutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR209185) methods exist because of the general contract of how UI Automation providers are expected to report information, but these methods are not typically implemented in control peers.</span></span> <span data-ttu-id="ca842-339">理由は、この情報が、特定の UI にあるコントロールを使ったアプリ コードに適用する [**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/BR209081) 値から提供されることを前提としているためです。</span><span class="sxs-lookup"><span data-stu-id="ca842-339">This is because that info is expected to be provided by [**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/BR209081) values applied to the app code that uses the controls in a specific UI.</span></span> <span data-ttu-id="ca842-340">たとえば、大半のアプリでは、[**AutomationProperties.LabeledBy**](https://msdn.microsoft.com/library/windows/apps/Hh759769) 値を適用することにより、UI 内の異なる 2 つのコントロール間でラベル付けの関係を定義します。</span><span class="sxs-lookup"><span data-stu-id="ca842-340">For example, most apps would define the labeling relationship between two different controls in the UI by applying a [**AutomationProperties.LabeledBy**](https://msdn.microsoft.com/library/windows/apps/Hh759769) value.</span></span> <span data-ttu-id="ca842-341">ただし、コントロール中のデータや項目の関係を表す特定のピアでは [**LabeledByCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getlabeledbycore) が実装されています。たとえば、ヘッダー部分を使ってデータ フィールドの部分にラベルを付けたり、項目にコンテナーのラベルを付けたりする場合です。</span><span class="sxs-lookup"><span data-stu-id="ca842-341">However, [**LabeledByCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getlabeledbycore) is implemented in certain peers that represent data or item relationships in a control, such as using a header part to label a data-field part, labeling items with their containers, or similar scenarios.</span></span>

<span id="Implementing_patterns"/>
<span id="implementing_patterns"/>
<span id="IMPLEMENTING_PATTERNS"/>

## <a name="implementing-patterns"></a><span data-ttu-id="ca842-342">パターンの実装</span><span class="sxs-lookup"><span data-stu-id="ca842-342">Implementing patterns</span></span>  
<span data-ttu-id="ca842-343">展開/折りたたみのコントロール パターン インターフェイスを実装することによって展開/折りたたみの動作を実装するコントロールに対するピアを作る方法を見てみます。</span><span class="sxs-lookup"><span data-stu-id="ca842-343">Let's look at how to write a peer for a control that implements an expand-collapse behavior by implementing the control pattern interface for expand-collapse.</span></span> <span data-ttu-id="ca842-344">ピアでは、[**PatternInterface.ExpandCollapse**](https://msdn.microsoft.com/library/windows/apps/BR242496) の値で [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) が呼び出されたら必ず自身を返して、展開/折りたたみの動作のアクセシビリティを有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-344">The peer should enable the accessibility for the expand-collapse behavior by returning itself whenever [**GetPattern**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getpattern) is called with a value of [**PatternInterface.ExpandCollapse**](https://msdn.microsoft.com/library/windows/apps/BR242496).</span></span> <span data-ttu-id="ca842-345">次に、そのパターンに対するプロバイダー インターフェイスを継承 ([**IExpandCollapseProvider**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.iexpandcollapseprovider)) して、そのプロバイダー インターフェイスの各メンバーに対し実装を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-345">The peer should then inherit the provider interface for that pattern ([**IExpandCollapseProvider**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.iexpandcollapseprovider)) and provide implementations for each of the members of that provider interface.</span></span> <span data-ttu-id="ca842-346">この例の場合、インターフェイスで次の 3 つのメンバーを上書きします。[**Expand**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.iexpandcollapseprovider.expand)、[**Collapse**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.iexpandcollapseprovider.collapse)、[**ExpandCollapseState**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.iexpandcollapseprovider.expandcollapsestate)。</span><span class="sxs-lookup"><span data-stu-id="ca842-346">In this case the interface has three members to override: [**Expand**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.iexpandcollapseprovider.expand), [**Collapse**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.iexpandcollapseprovider.collapse), [**ExpandCollapseState**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.iexpandcollapseprovider.expandcollapsestate).</span></span>

<span data-ttu-id="ca842-347">クラスの API 設計自体にアクセシビリティについて事前に考慮しておくと効果的です。</span><span class="sxs-lookup"><span data-stu-id="ca842-347">It's helpful to plan ahead for accessibility in the API design of the class itself.</span></span> <span data-ttu-id="ca842-348">UI を使って作業をするユーザーとの典型的な対話式操作、またはオートメーション プロバイダー パターンのどちらかを介して要求する動作が想定される場合は必ず、UI の応答、またはオートメーション パターンのどちらからでも呼び出し可能な単一のメソッドを用意しておきます。</span><span class="sxs-lookup"><span data-stu-id="ca842-348">Whenever you have a behavior that is potentially requested either as a result of typical interactions with a user who is working in the UI or through an automation provider pattern, provide a single method that either the UI response or the automation pattern can call.</span></span> <span data-ttu-id="ca842-349">たとえば、コントロールに、展開/折りたたみ可能なイベント ハンドラーを結合したボタン部分と、各操作に対応するキーボードの同等機能を持たせる場合は、ピア中で使う [**IExpandCollapseProvider**](https://msdn.microsoft.com/library/windows/desktop/Ee671242) の [**Expand**](https://msdn.microsoft.com/library/windows/apps/BR242570) または [**Collapse**](https://msdn.microsoft.com/library/windows/apps/BR242569) の実装本体から呼び出すのと同じメソッドを、個々のイベント ハンドラーから呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-349">For example, if your control has button parts that have wired event handlers that can expand or collapse the control, and has keyboard equivalents for those actions, have these event handlers call the same method that you call from within the body of the [**Expand**](https://msdn.microsoft.com/library/windows/apps/BR242570) or [**Collapse**](https://msdn.microsoft.com/library/windows/apps/BR242569) implementations for [**IExpandCollapseProvider**](https://msdn.microsoft.com/library/windows/desktop/Ee671242) in the peer.</span></span> <span data-ttu-id="ca842-350">共通のロジック メソッドを使うことにより、コントロールの表示状態が更新されるため、動作の起動方法に依存することなく、ロジックの状態が一貫した方法で表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="ca842-350">Using a common logic method can also be a useful way to make sure that your control's visual states are updated to show logical state in a uniform way, regardless of how the behavior was invoked.</span></span>

<span data-ttu-id="ca842-351">典型的な実装として、まずプロバイダー API から実行時にコントロール インスタンスにアクセスするために [**Owner**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.owner) を呼び出し、</span><span class="sxs-lookup"><span data-stu-id="ca842-351">A typical implementation is that the provider APIs first call [**Owner**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.owner) for access to the control instance at run time.</span></span> <span data-ttu-id="ca842-352">次にこのオブジェクトに対して必要な動作メソッドを呼び出すという方法が考えられます。</span><span class="sxs-lookup"><span data-stu-id="ca842-352">Then the necessary behavior methods can be called on that object.</span></span>


```csharp
public class IndexCardAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider {
    private IndexCard ownerIndexCard;
    public IndexCardAutomationPeer(IndexCard owner) : base(owner)
    {
         ownerIndexCard = owner;
    }
}
```

<span data-ttu-id="ca842-353">別の実装は、コントロール自体がピアを参照する方法です。</span><span class="sxs-lookup"><span data-stu-id="ca842-353">An alternate implementation is that the control itself can reference its peer.</span></span> <span data-ttu-id="ca842-354">[**RaiseAutomationEvent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.raiseautomationevent) メソッドがピア メソッドであるため、これはコントロールからオートメーション イベントを生成する場合の一般的なパターンです。</span><span class="sxs-lookup"><span data-stu-id="ca842-354">This is a common pattern if you are raising automation events from the control, because the [**RaiseAutomationEvent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.raiseautomationevent) method is a peer method.</span></span>

<span id="UI_Automation_events"/>
<span id="ui_automation_events"/>
<span id="UI_AUTOMATION_EVENTS"/>

## <a name="ui-automation-events"></a><span data-ttu-id="ca842-355">UI オートメーションのイベント</span><span class="sxs-lookup"><span data-stu-id="ca842-355">UI Automation events</span></span>  

<span data-ttu-id="ca842-356">UI オートメーションのイベントは、次のカテゴリに分類されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-356">UI Automation events fall into the following categories.</span></span>

| <span data-ttu-id="ca842-357">イベント</span><span class="sxs-lookup"><span data-stu-id="ca842-357">Event</span></span> | <span data-ttu-id="ca842-358">説明</span><span class="sxs-lookup"><span data-stu-id="ca842-358">Description</span></span> |
|-------|-------------|
| <span data-ttu-id="ca842-359">プロパティの変更</span><span class="sxs-lookup"><span data-stu-id="ca842-359">Property change</span></span> | <span data-ttu-id="ca842-360">UI オートメーション要素またはコントロール パターンのプロパティが変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="ca842-360">Fires when a property on a UI Automation element or control pattern changes.</span></span> <span data-ttu-id="ca842-361">たとえば、クライアントでアプリのチェック ボックス コントロールを監視する必要がある場合は、[**ToggleState**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.itoggleprovider.togglestate) プロパティのプロパティ変更イベントをリッスンするように登録します。</span><span class="sxs-lookup"><span data-stu-id="ca842-361">For example, if a client needs to monitor an app's check box control, it can register to listen for a property change event on the [**ToggleState**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.provider.itoggleprovider.togglestate) property.</span></span> <span data-ttu-id="ca842-362">チェック ボックス コントロールがオンまたはオフになると、プロバイダーがこのイベントを発生させるため、クライアントで必要に応じて対処できます。</span><span class="sxs-lookup"><span data-stu-id="ca842-362">When the check box control is checked or unchecked, the provider fires the event and the client can act as necessary.</span></span> |
| <span data-ttu-id="ca842-363">要素の操作</span><span class="sxs-lookup"><span data-stu-id="ca842-363">Element action</span></span> | <span data-ttu-id="ca842-364">ユーザーまたはプログラムによる操作の結果として UI が変更された場合に発生します (ボタンがクリックされた場合、**Invoke** パターンによって呼び出された場合など)。</span><span class="sxs-lookup"><span data-stu-id="ca842-364">Fires when a change in the UI results from user or programmatic activity; for example, when a button is clicked or invoked through the **Invoke** pattern.</span></span> |
| <span data-ttu-id="ca842-365">構造の変更</span><span class="sxs-lookup"><span data-stu-id="ca842-365">Structure change</span></span> | <span data-ttu-id="ca842-366">UI オートメーション ツリーの構造が変更された場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="ca842-366">Fires when the structure of the UI Automation tree changes.</span></span> <span data-ttu-id="ca842-367">構造は、新しい UI 項目が表示された場合、非表示になった場合、またはデスクトップから削除された場合に変更されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-367">The structure changes when new UI items become visible, hidden, or removed on the desktop.</span></span> |
| <span data-ttu-id="ca842-368">グローバルな変更</span><span class="sxs-lookup"><span data-stu-id="ca842-368">Global change</span></span> | <span data-ttu-id="ca842-369">クライアントのグローバルな関心の対象となる操作が行われた場合に発生します (要素のフォーカスが別の要素に移動した場合、子ウィンドウが閉じられた場合など)。</span><span class="sxs-lookup"><span data-stu-id="ca842-369">Fires when actions of global interest to the client occur, such as when the focus shifts from one element to another, or when a child window closes.</span></span> <span data-ttu-id="ca842-370">一部のイベントは、必ずしも UI の状態の変化を表すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="ca842-370">Some events do not necessarily mean that the state of the UI has changed.</span></span> <span data-ttu-id="ca842-371">たとえば、ユーザーが Tab キーを押してテキスト入力フィールドに移動し、ボタンをクリックしてフィールドを更新した場合、[**TextChanged**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.textchanged) イベントが発生しますが、実際にはテキストは変更されていません。</span><span class="sxs-lookup"><span data-stu-id="ca842-371">For example, if the user tabs to a text-entry field and then clicks a button to update the field, a [**TextChanged**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.textchanged) event fires even if the user did not actually change the text.</span></span> <span data-ttu-id="ca842-372">クライアント アプリでイベントを処理するときには、処理を開始する前に、実際に何か変更されているかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-372">When processing an event, it may be necessary for a client application to check whether anything has actually changed before taking action.</span></span> |

<span id="AutomationEvents_identifiers"/>
<span id="automationevents_identifiers"/>
<span id="AUTOMATIONEVENTS_IDENTIFIERS"/>

### <a name="automationevents-identifiers"></a><span data-ttu-id="ca842-373">AutomationEvents の識別子</span><span class="sxs-lookup"><span data-stu-id="ca842-373">AutomationEvents identifiers</span></span>  
<span data-ttu-id="ca842-374">UI オートメーションのイベントは、[**AutomationEvents**](https://msdn.microsoft.com/library/windows/apps/BR209183) の値によって識別されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-374">UI Automation events are identified by [**AutomationEvents**](https://msdn.microsoft.com/library/windows/apps/BR209183) values.</span></span> <span data-ttu-id="ca842-375">この列挙体の値は、イベントの種類を一意に識別します。</span><span class="sxs-lookup"><span data-stu-id="ca842-375">The values of the enumeration uniquely identify the kind of event.</span></span>

<span id="Raising_events"/>
<span id="raising_events"/>
<span id="RAISING_EVENTS"/>

### <a name="raising-events"></a><span data-ttu-id="ca842-376">イベントの発生</span><span class="sxs-lookup"><span data-stu-id="ca842-376">Raising events</span></span>  
<span data-ttu-id="ca842-377">UI オートメーション クライアントでは、オートメーション イベントを受信登録することができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-377">UI Automation clients can subscribe to automation events.</span></span> <span data-ttu-id="ca842-378">オートメーション ピア モデルの場合、カスタム コントロールのピアでは [**RaiseAutomationEvent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.raiseautomationevent) メソッドを呼び出すことによって、アクセシビリティに関連するコントロール状態に生じた変化を報告しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="ca842-378">In the automation peer model, peers for custom controls must report changes to control state that are relevant to accessibility by calling the [**RaiseAutomationEvent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.raiseautomationevent) method.</span></span> <span data-ttu-id="ca842-379">同様に、キー UI オートメーション プロパティ値に変更があった場合は、カスタム コントロール ピアから、[**RaisePropertyChangedEvent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.raisepropertychangedevent) メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-379">Similarly, when a key UI Automation property value changes, custom control peers should call the [**RaisePropertyChangedEvent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.raisepropertychangedevent) method.</span></span>

<span data-ttu-id="ca842-380">次のコード例は、コントロール定義コードの内部からピア オブジェクトを取得し、そのピアからイベントを発生させるメソッドを呼び出す方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ca842-380">The next code example shows how to get the peer object from within the control definition code and call a method to fire an event from that peer.</span></span> <span data-ttu-id="ca842-381">最適化のために、コードではこのイベント タイプのリスナーがいるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="ca842-381">As an optimization, the code determines whether there are any listeners for this event type.</span></span> <span data-ttu-id="ca842-382">リスナーがいるときにのみイベントを発生させてピア オブジェクトを作ることにより、不要なオーバーヘッドがなくなり、コントロールが応答性を維持できるようになります。</span><span class="sxs-lookup"><span data-stu-id="ca842-382">Firing the event and creating the peer object only when there are listeners avoids unnecessary overhead and helps the control remain responsive.</span></span>


```csharp
if (AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged))
{
    NumericUpDownAutomationPeer peer =
        FrameworkElementAutomationPeer.FromElement(nudCtrl) as NumericUpDownAutomationPeer;
    if (peer != null)
    {
        peer.RaisePropertyChangedEvent(
            RangeValuePatternIdentifiers.ValueProperty,
            (double)oldValue,
            (double)newValue);
    }
}
```

<span id="Peer_navigation"/>
<span id="peer_navigation"/>
<span id="PEER_NAVIGATION"/>

## <a name="peer-navigation"></a><span data-ttu-id="ca842-383">ピアのナビゲーション</span><span class="sxs-lookup"><span data-stu-id="ca842-383">Peer navigation</span></span>  
<span data-ttu-id="ca842-384">オートメーション ピアが特定された後、UI オートメーション クライアントではピア オブジェクトの [**GetChildren**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getchildren) メソッドと [**GetParent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getparent) メソッドを呼び出すことにより、アプリのピア構造をナビゲートすることができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-384">After locating an automation peer, a UI Automation client can navigate the peer structure of an app by calling the peer object's [**GetChildren**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getchildren) and [**GetParent**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getparent) methods.</span></span> <span data-ttu-id="ca842-385">コントロール内部での UI 要素間のナビゲーションは、[**GetChildrenCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getchildrencore) メソッドをピアで実装することにより、サポートされます。</span><span class="sxs-lookup"><span data-stu-id="ca842-385">Navigation among UI elements within a control is supported by the peer's implementation of the [**GetChildrenCore**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.peers.automationpeer.getchildrencore) method.</span></span> <span data-ttu-id="ca842-386">UI オートメーション システムでは、このメソッドを呼び出して、コントロールに含まれる子要素 (たとえば、リスト ボックス中のリスト項目) のツリーを構築します。</span><span class="sxs-lookup"><span data-stu-id="ca842-386">The UI Automation system calls this method to build up a tree of sub-elements contained within a control; for example, list items in a list box.</span></span> <span data-ttu-id="ca842-387">[**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) に含まれる既定の **GetChildrenCore** メソッドでは、要素のビジュアル ツリーを走査してオートメーション ピアのツリーを構築します。</span><span class="sxs-lookup"><span data-stu-id="ca842-387">The default **GetChildrenCore** method in [**FrameworkElementAutomationPeer**](https://msdn.microsoft.com/library/windows/apps/BR242472) traverses the visual tree of elements to build the tree of automation peers.</span></span> <span data-ttu-id="ca842-388">カスタム コントロールでは、このメソッドを上書きして、子要素を表す別の表示をオートメーション クライアントに公開することにより、情報の伝達やユーザー操作の許可を行う各要素のオートメーション ピアを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-388">Custom controls can override this method to expose a different representation of child elements to automation clients, returning the automation peers of elements that convey information or allow user interaction.</span></span>

<span id="Native_automation_support_for_text_patterns"/>
<span id="native_automation_support_for_text_patterns"/>
<span id="NATIVE_AUTOMATION_SUPPORT_FOR_TEXT_PATTERNS"/>

## <a name="native-automation-support-for-text-patterns"></a><span data-ttu-id="ca842-389">テキスト パターンのネイティブ オートメーション サポート</span><span class="sxs-lookup"><span data-stu-id="ca842-389">Native automation support for text patterns</span></span>  
<span data-ttu-id="ca842-390">既定の UWP アプリのオートメーション ピアの一部は、テキスト パターンに対するコントロール パターンのサポートを提供します ([**PatternInterface.Text**](https://msdn.microsoft.com/library/windows/apps/BR242496))。</span><span class="sxs-lookup"><span data-stu-id="ca842-390">Some of the default UWP app automation peers provide control pattern support for the text pattern ([**PatternInterface.Text**](https://msdn.microsoft.com/library/windows/apps/BR242496)).</span></span> <span data-ttu-id="ca842-391">ただし、このサポートはネイティブな方法で提供され、関係するピアは (管理された) 継承の [**ITextProvider**](https://msdn.microsoft.com/library/windows/apps/BR242627) インターフェイスに注目しません。</span><span class="sxs-lookup"><span data-stu-id="ca842-391">But they provide this support through native methods, and the peers involved won't note the [**ITextProvider**](https://msdn.microsoft.com/library/windows/apps/BR242627) interface in the (managed) inheritance.</span></span> <span data-ttu-id="ca842-392">それでも、管理されている、または管理されていない UI オートメーション クライアントがピアでパターンを照会すると、テキスト パターンに対するサポートが報告され、クライアント API が呼び出されたときにパターンの一部の動作が提供されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-392">Still, if a managed or non-managed UI Automation client queries the peer for patterns, it will report support for the text pattern, and provide behavior for parts of the pattern when client APIs are called.</span></span>

<span data-ttu-id="ca842-393">UWP アプリのテキスト コントロールの 1 つから派生させ、テキスト関連ピアの 1 つから派生するカスタム ピアを作る場合は、ピアの「注釈」セクションをご覧になることで、パターンのネイティブ レベル サポートについて詳しく知ることができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-393">If you intend to derive from one of the UWP app text controls and also create a custom peer that derives from one of the text-related peers, check the Remarks sections for the peer to learn more about any native-level support for patterns.</span></span> <span data-ttu-id="ca842-394">管理されているプロバイダー インターフェイスの実装から基本実装を呼び出すと、カスタム ピアのネイティブ ベースの動作にアクセスできますが、ピアのネイティブ インターフェイスとその所有者のコントロールは両方とも公開されるため、基本実装で行われる動作を変更するのは困難です。</span><span class="sxs-lookup"><span data-stu-id="ca842-394">You can access the native base behavior in your custom peer if you call the base implementation from your managed provider interface implementations, but it's difficult to modify what the base implementation does because the native interfaces on both the peer and its owner control aren't exposed.</span></span> <span data-ttu-id="ca842-395">一般的に、基本実装をそのまま使うか (基本実装のみを呼び出す)、基本実装を呼び出さないで機能を独自のマネージ コードで完全に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="ca842-395">Generally you should either use the base implementations as-is (call base only) or completely replace the functionality with your own managed code and don't call the base implementation.</span></span> <span data-ttu-id="ca842-396">後者は高度なシナリオであり、コントロールでテキスト サービス フレームワークを使う場合は、アクセシビリティ要件をサポートするためにフレームワークに関する詳しい知識が必要となります。</span><span class="sxs-lookup"><span data-stu-id="ca842-396">The latter is an advanced scenario, you'll need good familiarity with the text services framework being used by your control in order to support the accessibility requirements when using that framework.</span></span>

<span id="AutomationProperties.AccessibilityView"/>
<span id="automationproperties.accessibilityview"/>
<span id="AUTOMATIONPROPERTIES.ACCESSIBILITYVIEW"/>

## <a name="automationpropertiesaccessibilityview"></a><span data-ttu-id="ca842-397">AutomationProperties.AccessibilityView</span><span class="sxs-lookup"><span data-stu-id="ca842-397">AutomationProperties.AccessibilityView</span></span>  
<span data-ttu-id="ca842-398">カスタム ピアの提供に加えて、XAML で [**AutomationProperties.AccessibilityView**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.automationproperties.accessibilityview) を設定することにより、コントロール インスタンスのツリー ビュー表現を調整することもできます。</span><span class="sxs-lookup"><span data-stu-id="ca842-398">In addition to providing a custom peer, you can also adjust the tree view representation for any control instance, by setting [**AutomationProperties.AccessibilityView**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.automationproperties.accessibilityview) in XAML.</span></span> <span data-ttu-id="ca842-399">これはピア クラスの一部としては実装されませんが、カスタム コントロールまたはカスタマイズしたテンプレートでの全体的なアクセシビリティのサポートに密接な関係があるため、ここで触れておきます。</span><span class="sxs-lookup"><span data-stu-id="ca842-399">This isn't implemented as part of a peer class, but we'll mention it here because it's germane to overall accessibility support either for custom controls or for templates you customize.</span></span>

<span data-ttu-id="ca842-400">**AutomationProperties.AccessibilityView** を使う主なシナリオでは、コントロール全体のアクセシビリティ ビューに対して有意に貢献しないので、UI オートメーション ビューから意図的にテンプレート内の特定のコントロールを省略します。</span><span class="sxs-lookup"><span data-stu-id="ca842-400">The main scenario for using **AutomationProperties.AccessibilityView** is to deliberately omit certain controls in a template from the UI Automation views, because they don't meaningfully contribute to the accessibility view of the entire control.</span></span> <span data-ttu-id="ca842-401">これを避けるために、**AutomationProperties.AccessibilityView** を "Raw" に設定します。</span><span class="sxs-lookup"><span data-stu-id="ca842-401">To prevent this, set **AutomationProperties.AccessibilityView** to "Raw".</span></span>

<span id="Throwing_exceptions_from_automation_peers"/>
<span id="throwing_exceptions_from_automation_peers"/>
<span id="THROWING_EXCEPTIONS_FROM_AUTOMATION_PEERS"/>

## <a name="throwing-exceptions-from-automation-peers"></a><span data-ttu-id="ca842-402">オートメーション ピアからの例外のスロー</span><span class="sxs-lookup"><span data-stu-id="ca842-402">Throwing exceptions from automation peers</span></span>  
<span data-ttu-id="ca842-403">オートメーション ピア サポートのために実装する API では、例外をスローすることが許されています。</span><span class="sxs-lookup"><span data-stu-id="ca842-403">The APIs that you are implementing for your automation peer support are permitted to throw exceptions.</span></span> <span data-ttu-id="ca842-404">リッスンしている UI オートメーション クライアントはいずれも堅牢に作られていると想定され、例外がスローされても、ほとんどの場合は続行できることが求められています。</span><span class="sxs-lookup"><span data-stu-id="ca842-404">It's expected any UI Automation clients that are listening are robust enough to continue on after most exceptions are thrown.</span></span> <span data-ttu-id="ca842-405">リスナーが対象としているのは自分自身だけでなく他のアプリを含めたオートメーション ツリー全体であり、クライアントが API を呼び出したときにツリーの一部でピア ベースの例外がスローされたからといって、クライアント全体が停止するような設計は望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="ca842-405">In all likelihood that listener is looking at an all-up automation tree that includes apps other than your own, and it's an unacceptable client design to bring down the entire client just because one area of the tree threw a peer-based exception when the client called its APIs.</span></span>

<span data-ttu-id="ca842-406">ピアに渡されたパラメーターについて入力を検証することは許容されます。たとえば、**null** が渡された場合、それを有効な値として扱わない実装では [**ArgumentNullException**](https://msdn.microsoft.com/library/windows/apps/system.argumentnullexception) をスローすることができます。</span><span class="sxs-lookup"><span data-stu-id="ca842-406">For parameters that are passed in to your peer, it's acceptable to validate the input, and for example throw [**ArgumentNullException**](https://msdn.microsoft.com/library/windows/apps/system.argumentnullexception) if it was passed **null** and that's not a valid value for your implementation.</span></span> <span data-ttu-id="ca842-407">ただし、ピアで実行される後続の操作がある場合、ホストしているコントロールとピアとのやり取りには非同期的な性質があることに注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="ca842-407">However, if there are subsequent operations performed by your peer, remember that the peer's interactions with the hosting control have something of an asynchronous character to them.</span></span> <span data-ttu-id="ca842-408">ピアで実行した操作によって、必ずしもコントロールの UI スレッドがブロックされるとは限りません (そのような動作になることはほとんどありません)。</span><span class="sxs-lookup"><span data-stu-id="ca842-408">Anything a peer does won't necessarily block the UI thread in the control (and it probably shouldn't).</span></span> <span data-ttu-id="ca842-409">したがって、ピアの作成時やオートメーション ピア メソッドの初回の呼び出し時に、あるオブジェクトが使用可能であったり、特定のプロパティが設定されていたりしても、処理を行っている間にコントロールの状態が変わる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-409">So you could have situations where an object was available or had certain properties when the peer was created or when an automation peer method was first called, but in the meantime the control state has changed.</span></span> <span data-ttu-id="ca842-410">このような場合にスローできる専用の例外が 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="ca842-410">For these cases, there are two dedicated exceptions that a provider can throw:</span></span>

* <span data-ttu-id="ca842-411">自身の API に渡された元の情報に基づいてピアの所有者または関連するピア要素にアクセスできない場合は、[**ElementNotAvailableException**](https://msdn.microsoft.com/library/system.windows.automation.elementnotavailableexception) をスローします。</span><span class="sxs-lookup"><span data-stu-id="ca842-411">Throw [**ElementNotAvailableException**](https://msdn.microsoft.com/library/system.windows.automation.elementnotavailableexception) if you're unable to access either the peer's owner or a related peer element based on the original info your API was passed.</span></span> <span data-ttu-id="ca842-412">たとえば、ピアでメソッドを実行しようとしているときに、モーダル ダイアログが閉じられたなどの理由で、UI から所有者が削除された場合が当てはまります。</span><span class="sxs-lookup"><span data-stu-id="ca842-412">For example, you might have a peer that's trying to run its methods but the owner has since been removed from the UI, such as a modal dialog that's been closed.</span></span> <span data-ttu-id="ca842-413">.NET 以外のクライアントでは、これは [**UIA\_E\_ELEMENTNOTAVAILABLE**](https://msdn.microsoft.com/library/windows/desktop/Ee671218) にマップされます。</span><span class="sxs-lookup"><span data-stu-id="ca842-413">For a non-.NET client, this maps to [**UIA\_E\_ELEMENTNOTAVAILABLE**](https://msdn.microsoft.com/library/windows/desktop/Ee671218).</span></span>
* <span data-ttu-id="ca842-414">所有者はまだ存在するものの、その所有者が [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.isenabled)`=`**false** などのモードになっていて、ピアで実行しようとしている特定の変更をプログラムで実現することができない場合は、[**ElementNotEnabledException**](https://msdn.microsoft.com/library/system.windows.automation.elementnotenabledexception) をスローします。</span><span class="sxs-lookup"><span data-stu-id="ca842-414">Throw [**ElementNotEnabledException**](https://msdn.microsoft.com/library/system.windows.automation.elementnotenabledexception) if there still is an owner, but that owner is in a mode such as [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.isenabled)`=`**false** that's blocking some of the specific programmatic changes that your peer is trying to accomplish.</span></span> <span data-ttu-id="ca842-415">.NET 以外のクライアントでは、これは [**UIA\_E\_ELEMENTNOTENABLED**](https://msdn.microsoft.com/library/windows/desktop/Ee671218) にマップされます。</span><span class="sxs-lookup"><span data-stu-id="ca842-415">For a non-.NET client, this maps to [**UIA\_E\_ELEMENTNOTENABLED**](https://msdn.microsoft.com/library/windows/desktop/Ee671218).</span></span>

<span data-ttu-id="ca842-416">他にも、ピア サポートからの例外のスローに関して、ピアでは比較的保守的な対応をとる必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-416">Beyond this, peers should be relatively conservative regarding exceptions that they throw from their peer support.</span></span> <span data-ttu-id="ca842-417">ほとんどのクライアントでは、ピアからの例外を処理することができないため、発生した例外は、ユーザーに選択を求める対話操作に変換されます。</span><span class="sxs-lookup"><span data-stu-id="ca842-417">Most clients won't be able to handle exceptions from peers and turn these into actionable choices that their users can make when interacting with the client.</span></span> <span data-ttu-id="ca842-418">このため、ピアでの操作が失敗するたびに例外をスローするよりは、ピアの実装内で例外をキャッチし、再スローもせずに何もしない戦略の方が適している場合があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-418">So sometimes a no-op, and catching exceptions without rethrowing within your peer implementations, is a better strategy than is throwing exceptions every time something the peer tries to do doesn't work.</span></span> <span data-ttu-id="ca842-419">また、多くの UI オートメーション クライアントはマネージ コードで作られているわけではない点にも考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca842-419">Consider also that most UI Automation clients aren't written in managed code.</span></span> <span data-ttu-id="ca842-420">ほとんどは COM で記述されているため、ピアにアクセスする UI オートメーション クライアント メソッドを呼び出すときは、**HRESULT** が **S\_OK** かどうかをチェックするだけになります。</span><span class="sxs-lookup"><span data-stu-id="ca842-420">Most are written in COM and are just checking for **S\_OK** in an **HRESULT** whenever they call a UI Automation client method that ends up accessing your peer.</span></span>

<span id="related_topics"/>

## <a name="related-topics"></a><span data-ttu-id="ca842-421">関連トピック</span><span class="sxs-lookup"><span data-stu-id="ca842-421">Related topics</span></span>  
* [<span data-ttu-id="ca842-422">アクセシビリティ</span><span class="sxs-lookup"><span data-stu-id="ca842-422">Accessibility</span></span>](accessibility.md)
* [<span data-ttu-id="ca842-423">XAML アクセシビリティ サンプル</span><span class="sxs-lookup"><span data-stu-id="ca842-423">XAML accessibility sample</span></span>](http://go.microsoft.com/fwlink/p/?linkid=238570)
* [**<span data-ttu-id="ca842-424">FrameworkElementAutomationPeer</span><span class="sxs-lookup"><span data-stu-id="ca842-424">FrameworkElementAutomationPeer</span></span>**](https://msdn.microsoft.com/library/windows/apps/BR242472)
* [**<span data-ttu-id="ca842-425">AutomationPeer</span><span class="sxs-lookup"><span data-stu-id="ca842-425">AutomationPeer</span></span>**](https://msdn.microsoft.com/library/windows/apps/BR209185)
* [**<span data-ttu-id="ca842-426">OnCreateAutomationPeer</span><span class="sxs-lookup"><span data-stu-id="ca842-426">OnCreateAutomationPeer</span></span>**](https://msdn.microsoft.com/ibrary/windows/apps/windows.ui.xaml.uielement.oncreateautomationpeer)
* [<span data-ttu-id="ca842-427">コントロール パターンとインターフェイス</span><span class="sxs-lookup"><span data-stu-id="ca842-427">Control patterns and interfaces</span></span>](control-patterns-and-interfaces.md)
