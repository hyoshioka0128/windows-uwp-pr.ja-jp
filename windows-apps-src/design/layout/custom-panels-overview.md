---
author: muhsinking
Description: You can define custom panels for XAML layout by deriving a custom class from the Panel class.
MS-HAID: dev\_ctrl\_layout\_txt.xaml\_custom\_panels\_overview
MSHAttr: PreferredLib:/library/windows/apps
Search.Product: eADQiWindows 10XVcnh
title: XAML カスタム パネルの概要
ms.assetid: 0CD395CD-E2AB-429D-BB49-56A71C5CC35D
label: XAML custom panels overview (Windows apps)
template: detail.hbs
op-migration-status: ready
ms.author: mukin
ms.date: 05/19/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: d9856d564ffd36226a841c38eba65df0b62ee306
ms.sourcegitcommit: 753e0a7160a88830d9908b446ef0907cc71c64e7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/29/2018
ms.locfileid: "5747549"
---
# <a name="xaml-custom-panels-overview"></a><span data-ttu-id="d1a29-103">XAML カスタム パネルの概要</span><span class="sxs-lookup"><span data-stu-id="d1a29-103">XAML custom panels overview</span></span>

 

<span data-ttu-id="d1a29-104">*パネル*は、Extensible Application Markup Language (XAML) レイアウト システムが実行されて、アプリの UI が表示されるときに、含まれている子要素のレイアウト動作を提供するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-104">A *panel* is an object that provides a layout behavior for child elements it contains, when the Extensible Application Markup Language (XAML) layout system runs and your app UI is rendered.</span></span> 


> <span data-ttu-id="d1a29-105">**重要な API**: [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)、[**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)、[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)</span><span class="sxs-lookup"><span data-stu-id="d1a29-105">**Important APIs**: [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711), [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)</span></span>

<span data-ttu-id="d1a29-106">[**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) クラスからカスタム クラスを派生させて、XAML レイアウトのカスタム パネルを定義できます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-106">You can define custom panels for XAML layout by deriving a custom class from the [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class.</span></span> <span data-ttu-id="d1a29-107">パネルの動作は、[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) と [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) をオーバーライドすることで子要素を評価して配置するロジックを提供して実行します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-107">You provide behavior for your panel by overriding the [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) and [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711), supplying logic that measures and arranges the child elements.</span></span>

## <a name="the-panel-base-class"></a><span data-ttu-id="d1a29-108">**Panel** 基底クラス</span><span class="sxs-lookup"><span data-stu-id="d1a29-108">The **Panel** base class</span></span>


<span data-ttu-id="d1a29-109">カスタム パネル クラスを定義するには、[**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) クラスから直接派生させるか、[**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) や [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) などの、シールされていない実用的なパネル クラスの 1 つから派生させます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-109">To define a custom panel class, you can either derive from the [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class directly, or derive from one of the practical panel classes that aren't sealed, such as [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) or [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635).</span></span> <span data-ttu-id="d1a29-110">より容易なのは、**Panel** から派生させることです。これは、既にレイアウト動作があるパネルの既存のレイアウト ロジックを回避することは難しい場合があるためです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-110">It's easier to derive from **Panel**, because it can be difficult to work around the existing layout logic of a panel that already has layout behavior.</span></span> <span data-ttu-id="d1a29-111">また、動作があるパネルの既存のプロパティが、パネルのレイアウト機能に関連していない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-111">Also, a panel with behavior might have existing properties that aren't relevant for your panel's layout features.</span></span>

<span data-ttu-id="d1a29-112">[**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) から、カスタム パネルは次の API を継承します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-112">From [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), your custom panel inherits these APIs:</span></span>

-   <span data-ttu-id="d1a29-113">[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) プロパティ</span><span class="sxs-lookup"><span data-stu-id="d1a29-113">The [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property.</span></span>
-   <span data-ttu-id="d1a29-114">[**Background**](https://msdn.microsoft.com/library/windows/apps/br227512)、[**ChildrenTransitions**](https://msdn.microsoft.com/library/windows/apps/br227515)、[**IsItemsHost**](https://msdn.microsoft.com/library/windows/apps/br227517) プロパティと、依存関係プロパティの識別子。</span><span class="sxs-lookup"><span data-stu-id="d1a29-114">The [**Background**](https://msdn.microsoft.com/library/windows/apps/br227512), [**ChildrenTransitions**](https://msdn.microsoft.com/library/windows/apps/br227515) and [**IsItemsHost**](https://msdn.microsoft.com/library/windows/apps/br227517) properties, and the dependency property identifiers.</span></span> <span data-ttu-id="d1a29-115">これらのプロパティはどれも仮想プロパティではないため、通常は、オーバーライドしたり、置き換えたりすることはありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-115">None of these properties are virtual, so you don't typically override or replace them.</span></span> <span data-ttu-id="d1a29-116">これらのプロパティは、通常、カスタム パネルのシナリオでは不要です。値の読み取りにも使用しません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-116">You don't typically need these properties for custom panel scenarios, not even for reading values.</span></span>
-   <span data-ttu-id="d1a29-117">レイアウト オーバーライド メソッド ([**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) と [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711))。</span><span class="sxs-lookup"><span data-stu-id="d1a29-117">The layout override methods [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) and [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711).</span></span> <span data-ttu-id="d1a29-118">これらは、最初は [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) で定義されていました。</span><span class="sxs-lookup"><span data-stu-id="d1a29-118">These were originally defined by [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706).</span></span> <span data-ttu-id="d1a29-119">[**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) 既定クラスは、これらをオーバーライドしませんが、[**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) のような実用的なパネルには、ネイティブ コードとして実装されたオーバーライド実装があり、システムによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-119">The base [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class doesn't override these, but practical panels like [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) do have override implementations that are implemented as native code and are run by the system.</span></span> <span data-ttu-id="d1a29-120">カスタム パネルを定義するために必要な作業の大部分は、**ArrangeOverride** と **MeasureOverride** に新しい (または付加的な) 実装を提供することです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-120">Providing new (or additive) implementations for **ArrangeOverride** and **MeasureOverride** is the bulk of the effort you need to define a custom panel.</span></span>
-   <span data-ttu-id="d1a29-121">[**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706)、[**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911)、および [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) のその他のすべての API ([**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height)、[**Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992) など)。</span><span class="sxs-lookup"><span data-stu-id="d1a29-121">All the other APIs of [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706), [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) and [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356), such as [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height), [**Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992) and so on.</span></span> <span data-ttu-id="d1a29-122">これらのプロパティの値は、レイアウト オーバーライドで参照することがありますが、仮想値ではないため、オーバーライドしたり、置き換えたりすることはありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-122">You sometimes reference values of these properties in your layout overrides, but they aren't virtual so you don't typically override or replace them.</span></span>

<span data-ttu-id="d1a29-123">ここでは、カスタム パネルがレイアウトで可能な動作および必要な動作についてのすべての可能性を考慮できるように、XAML レイアウトの概念について説明します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-123">This focus here is to describe XAML layout concepts, so you can consider all the possibilities for how a custom panel can and should behave in layout.</span></span> <span data-ttu-id="d1a29-124">すぐに作業を開始できるようにカスタム パネルの実装例を参照する場合は、「[BoxPanel、カスタム パネルの例](boxpanel-example-custom-panel.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d1a29-124">If you'd rather jump right in and see an example custom panel implementation, see [BoxPanel, an example custom panel](boxpanel-example-custom-panel.md).</span></span>

## <a name="the-children-property"></a><span data-ttu-id="d1a29-125">**Children** プロパティ</span><span class="sxs-lookup"><span data-stu-id="d1a29-125">The **Children** property</span></span>


<span data-ttu-id="d1a29-126">[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) プロパティは、カスタム パネルに関連しています。これは、[**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) から派生したすべてのクラスが、コレクションに含まれている子要素を保存する場所として **Children** プロパティを使うためです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-126">The [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property is relevant to a custom panel because all classes derived from [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) use the **Children** property as the place to store their contained child elements in a collection.</span></span> <span data-ttu-id="d1a29-127">**Children** は、**Panel** クラスの XAML コンテンツ プロパティとして指定されており、**Panel** から派生したすべてのクラスは、XAML コンテンツ プロパティの動作を継承できます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-127">**Children** is designated as the XAML content property for the **Panel** class, and all classes derived from **Panel** can inherit the XAML content property behavior.</span></span> <span data-ttu-id="d1a29-128">プロパティが XAML コンテンツ プロパティを指定している場合は、その XAML マークアップが、マークアップでそのプロパティを指定するときにプロパティ要素を省略でき、直接の子マークアップ (「コンテンツ」) として値が設定されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-128">If a property is designated the XAML content property, that means that XAML markup can omit a property element when specifying that property in markup, and the values are set as immediate markup children (the "content").</span></span> <span data-ttu-id="d1a29-129">たとえば、**Panel** から、**CustomPanel** という名前のクラスを派生させ、これによって新しい動作が定義されない場合は、まだ、次のマークアップを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-129">For example, if you derive a class named **CustomPanel** from **Panel** that defines no new behavior, you can still use this markup:</span></span>

```XAML
<local:CustomPanel>
  <Button Name="button1"/>
  <Button Name="button2"/>
</local:CustomPanel>
```

<span data-ttu-id="d1a29-130">XAML パーサーがこのマークアップを読み取るときに、[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) は、すべての [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) 派生型の XAML コンテンツ プロパティであると認識されるため、パーサーは、[**Children** プロパティの [**UIElementCollection**](https://msdn.microsoft.com/library/windows/apps/br227633) 値に 2 つの **Button**](https://msdn.microsoft.com/library/windows/apps/br209265) 要素を追加します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-130">When a XAML parser reads this markup, [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) is known to be the XAML content property for all [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) derived types, so the parser will add the two [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) elements to the [**UIElementCollection**](https://msdn.microsoft.com/library/windows/apps/br227633) value of the **Children** property.</span></span> <span data-ttu-id="d1a29-131">XAML コンテンツ プロパティにより、UI 定義の XAML マークアップで親子関係を効率化しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-131">The XAML content property facilitates a streamlined parent-child relationship in the XAML markup for a UI definition.</span></span> <span data-ttu-id="d1a29-132">XAML コンテンツ プロパティの詳細と、XAML の解析時のコレクション プロパティの設定方法については、「[基本的な XAML 構文のガイド](https://msdn.microsoft.com/library/windows/apps/mt185596)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d1a29-132">For more info about XAML content properties, and how collection properties are populated when XAML is parsed, see the [XAML syntax guide](https://msdn.microsoft.com/library/windows/apps/mt185596).</span></span>

<span data-ttu-id="d1a29-133">[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) プロパティの値を維持しているコレクション型は [**UIElementCollection**](https://msdn.microsoft.com/library/windows/apps/br227633) クラスです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-133">The collection type that's maintaining the value of the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property is the [**UIElementCollection**](https://msdn.microsoft.com/library/windows/apps/br227633) class.</span></span> <span data-ttu-id="d1a29-134">**UIElementCollection** は、適用された項目の型として [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) を使う、厳密に型指定されたコレクションです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-134">**UIElementCollection** is a strongly typed collection that uses [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) as its enforced item type.</span></span> <span data-ttu-id="d1a29-135">**UIElement** は、多くの実用的な UI 要素型によって継承されている基本型であるため、ここでは、型が意図的に緩やかに適用されています。</span><span class="sxs-lookup"><span data-stu-id="d1a29-135">**UIElement** is a base type that's inherited by hundreds of practical UI element types, so the type enforcement here is deliberately loose.</span></span> <span data-ttu-id="d1a29-136">ただし、[**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) が [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) の直接の子になることができない点は適用されます。これは一般に、UI に表示され、レイアウトに含まれると予想されている要素のみが、**Panel** の子要素となることを意味します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-136">But it does enforce that you couldn't have a [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) as a direct child of a [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), and it generally means that only elements that are expected to be visible in UI and participate in layout will be found as child elements in a **Panel**.</span></span>

<span data-ttu-id="d1a29-137">通常、XAML 定義では、カスタム パネルは、[**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) プロパティの特性をそのまま使用して、あらゆる [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) 子要素を受け入れます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-137">Typically, a custom panel accepts any [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) child element by a XAML definition, by simply using the characteristics of the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property as-is.</span></span> <span data-ttu-id="d1a29-138">高度なシナリオとしては、レイアウトのオーバーライドでコレクションの反復処理を行う場合に、子要素の型の詳細な確認をサポートできます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-138">As an advanced scenario, you could support further type checking of child elements, when you iterate over the collection in your layout overrides.</span></span>

<span data-ttu-id="d1a29-139">パネルのロジックは、[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) コレクションでループ処理を行うだけでなく、`Children.Count` によって影響される場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-139">Besides looping through the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) collection in the overrides, your panel logic might also be influenced by `Children.Count`.</span></span> <span data-ttu-id="d1a29-140">個々の項目の目的のサイズやその他の特性ではなく、少なくとも項目の数に部分的に基づいて、スペースを割り当てているロジックがある場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-140">You might have logic that is allocating space at least partly based on the number of items, rather than desired sizes and the other characteristics of individual items.</span></span>

## <a name="overriding-the-layout-methods"></a><span data-ttu-id="d1a29-141">レイアウト メソッドのオーバーライド</span><span class="sxs-lookup"><span data-stu-id="d1a29-141">Overriding the layout methods</span></span>


<span data-ttu-id="d1a29-142">レイアウト オーバーライド メソッドの基本的なモデル ([**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) と [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)) は、すべての子で反復処理を行い、各子要素の特定のレイアウト メソッドを呼び出す必要があることです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-142">The basic model for the layout override methods ([**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) and [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)) is that they should iterate through all the children and call each child element's specific layout method.</span></span> <span data-ttu-id="d1a29-143">最初のレイアウトのサイクルは、XAML レイアウト システムがルート ウィンドウの視覚効果を設定すると、開始されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-143">The first layout cycle starts when the XAML layout system sets the visual for the root window.</span></span> <span data-ttu-id="d1a29-144">それぞれの親はその子でレイアウトを呼び出すため、これによって、レイアウトの一部となる可能性のあるすべての UI 要素に対するレイアウト メソッドへの呼び出しが伝達されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-144">Because each parent invokes layout on its children, this propagates a call to layout methods to every possible UI element that is supposed to be part of a layout.</span></span> <span data-ttu-id="d1a29-145">XAML レイアウトでは、測定と配置という 2 つの段階があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-145">In XAML layout, there are two stages: measure, then arrange.</span></span>

<span data-ttu-id="d1a29-146">[**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) 基底クラスからの [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) と [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) についての組み込みのレイアウト メソッドの動作は発生しません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-146">You don't get any built-in layout method behavior for [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) and [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) from the base [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class.</span></span> <span data-ttu-id="d1a29-147">[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) の項目は、XAML のビジュアル ツリーの一部として自動的には表示されません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-147">Items in [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) won't automatically render as part of the XAML visual tree.</span></span> <span data-ttu-id="d1a29-148">**MeasureOverride** と **ArrangeOverride** の実装内のレイアウト パスを介して **Children** で見つかる各項目でレイアウトのメソッドを呼び出すことによって項目がレイアウト プロセスに認識されるようにするかどうかはユーザーが決定します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-148">It is up to you to make the items known to the layout process, by invoking layout methods on each of the items you find in **Children** through a layout pass within your **MeasureOverride** and **ArrangeOverride** implementations.</span></span>

<span data-ttu-id="d1a29-149">独自の継承がある場合を除き、レイアウトのオーバーライドの基本実装を呼び出す理由はありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-149">There's no reason to call base implementations in layout overrides unless you have your own inheritance.</span></span> <span data-ttu-id="d1a29-150">いずれの場合も、レイアウト動作のネイティブ メソッド (存在する場合) は動作し、オーバーライドから基本実装を呼び出さなくても、ネイティブ動作が発生しなくなることはありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-150">The native methods for layout behavior (if they exist) run regardless, and not calling base implementation from overrides won't prevent the native behavior from happening.</span></span>

<span data-ttu-id="d1a29-151">測定パスの間に、レイアウトのロジックは、子要素の [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) メソッドを呼び出して、望ましいサイズを各子要素に照会します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-151">During the measure pass, your layout logic queries each child element for its desired size, by calling the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on that child element.</span></span> <span data-ttu-id="d1a29-152">**Measure** メソッドを呼び出すと、[**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) プロパティの値が設定されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-152">Calling the **Measure** method establishes the value for the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property.</span></span> <span data-ttu-id="d1a29-153">パネル自体の望ましいサイズは、[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) の戻り値です。</span><span class="sxs-lookup"><span data-stu-id="d1a29-153">The [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) return value is the desired size for the panel itself.</span></span>

<span data-ttu-id="d1a29-154">配置パスでは、子要素の位置とサイズが x-y スペースで決定され、レイアウト構成を表示する準備を行います。</span><span class="sxs-lookup"><span data-stu-id="d1a29-154">During the arrange pass, the positions and sizes of child elements are determined in x-y space and the layout composition is prepared for rendering.</span></span> <span data-ttu-id="d1a29-155">コードは、[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) の各子要素で [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) を呼び出す必要があります。これによって、要素がレイアウトに含まれることがレイアウト システムで検出されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-155">Your code must call [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) on each child element in [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) so that the layout system detects that the element belongs in the layout.</span></span> <span data-ttu-id="d1a29-156">**Arrange** 呼び出しは、構成とレンダリングに先行して行われます。つまり、要素の配置先がレイアウト システムに通知され、表示のために構成が送信されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-156">The **Arrange** call is a precursor to composition and rendering; it informs the layout system where that element goes, when the composition is submitted for rendering.</span></span>

<span data-ttu-id="d1a29-157">レイアウトのロジックが実行時にどのように動作するかは、多くのプロパティと値によって決まります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-157">Many properties and values contribute to how the layout logic will work at runtime.</span></span> <span data-ttu-id="d1a29-158">レイアウト プロセスについての考え方の 1 つは、子 (一般に、UI で最も深く入れ子になっている要素) のない要素が最初に測定を完了できる要素であるということです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-158">A way to think about the layout process is that the elements with no children (generally the most deeply nested element in the UI) are the ones that can finalize measurements first.</span></span> <span data-ttu-id="d1a29-159">このような要素には、望ましいサイズに影響する子要素の依存関係がありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-159">They don't have any dependencies on child elements that influence their desired size.</span></span> <span data-ttu-id="d1a29-160">それぞれの要素には、望ましいサイズがある場合がありますが、レイアウトが実際に発生するまでは、サイズの候補にすぎません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-160">They might have their own desired sizes, and these are size suggestions until the layout actually takes place.</span></span> <span data-ttu-id="d1a29-161">次に、測定パスは、ルート要素に測定値が与えられ、すべての測定を完了できるまで、ビジュアル ツリーを上へとたどり続けます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-161">Then, the measure pass continues walking up the visual tree until the root element has its measurements and all the measurements can be finalized.</span></span>

<span data-ttu-id="d1a29-162">候補のレイアウトは、現在のアプリ ウィンドウ内に収まる必要があります。収まらない場合は、UI の一部がクリップされます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-162">The candidate layout must fit within the current app window or else parts of the UI will be clipped.</span></span> <span data-ttu-id="d1a29-163">パネルでは、クリッピング ロジックが決定されることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-163">Panels often are the place where the clipping logic is determined.</span></span> <span data-ttu-id="d1a29-164">パネルのロジックは、[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) の実装内から利用できるサイズを特定できます。また、サイズ制限を子にも適用し、すべてが最適に収まるように複数の子の間でスペースを分割することが必要な場合もよくあります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-164">Panel logic can determine what size is available from within the [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementation, and may have to push the size restrictions onto the children and divide space amongst children so that everything fits as best it can.</span></span> <span data-ttu-id="d1a29-165">理想的なレイアウトの結果は、レイアウトすべての部分のさまざまなプロパティを使い、しかも、アプリ ウィンドウ内に収まることです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-165">The result of layout is ideally something that uses various properties of all parts of the layout but still fits within the app window.</span></span> <span data-ttu-id="d1a29-166">これには、パネルのレイアウト ロジックを最適に実装するだけでなく、そのパネルを使って UI を構築するあらゆるアプリ コードで慎重に UI を設計することが必要です。</span><span class="sxs-lookup"><span data-stu-id="d1a29-166">That requires both a good implementation for layout logic of the panels, and also a judicious UI design on the part of any app code that builds a UI using that panel.</span></span> <span data-ttu-id="d1a29-167">全体的な UI 設計に含まれる子要素が多すぎてアプリに収まらない場合は、パネル設計が適切に表示されることはありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-167">No panel design is going to look good if the overall UI design includes more child elements than can possibly fit in the app.</span></span>

<span data-ttu-id="d1a29-168">レイアウト システムが機能するための要件の大部分は、[**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) に基づく要素のいずれかに、コンテナーで子として機能するときの固有の動作の一部が既に含まれることです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-168">A large part of what makes the layout system work is that any element that's based on [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) already has some of its own inherent behavior when acting as a child in a container.</span></span> <span data-ttu-id="d1a29-169">たとえば、**FrameworkElement** のいくつかの API は、レイアウト動作を通知する API であるか、またはレイアウトが機能するための必須 API です。</span><span class="sxs-lookup"><span data-stu-id="d1a29-169">For example, there are several APIs of **FrameworkElement** that either inform layout behavior or are needed to make layout work at all.</span></span> <span data-ttu-id="d1a29-170">たとえば、次のような場合です。</span><span class="sxs-lookup"><span data-stu-id="d1a29-170">These include:</span></span>

-   <span data-ttu-id="d1a29-171">[**DesiredSize**
            ](https://msdn.microsoft.com/library/windows/apps/br208921) (実際は [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) プロパティ)</span><span class="sxs-lookup"><span data-stu-id="d1a29-171">[**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) (actually a [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) property)</span></span>
-   <span data-ttu-id="d1a29-172">[**ActualHeight**
            ](https://msdn.microsoft.com/library/windows/apps/br208707) および [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709)</span><span class="sxs-lookup"><span data-stu-id="d1a29-172">[**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) and [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709)</span></span>
-   <span data-ttu-id="d1a29-173">[**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) および [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width)</span><span class="sxs-lookup"><span data-stu-id="d1a29-173">[**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) and [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width)</span></span>
-   [**<span data-ttu-id="d1a29-174">余白</span><span class="sxs-lookup"><span data-stu-id="d1a29-174">Margin</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208724)
-   <span data-ttu-id="d1a29-175">[**LayoutUpdated**
            ](https://msdn.microsoft.com/library/windows/apps/br208722) イベント</span><span class="sxs-lookup"><span data-stu-id="d1a29-175">[**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) event</span></span>
-   <span data-ttu-id="d1a29-176">[**HorizontalAlignment**
            ](https://msdn.microsoft.com/library/windows/apps/br208720) および [**VerticalAlignment**](https://msdn.microsoft.com/library/windows/apps/br208749)</span><span class="sxs-lookup"><span data-stu-id="d1a29-176">[**HorizontalAlignment**](https://msdn.microsoft.com/library/windows/apps/br208720) and [**VerticalAlignment**](https://msdn.microsoft.com/library/windows/apps/br208749)</span></span>
-   <span data-ttu-id="d1a29-177">[**ArrangeOverride**
            ](https://msdn.microsoft.com/library/windows/apps/br208711) メソッドと [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) メソッド</span><span class="sxs-lookup"><span data-stu-id="d1a29-177">[**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) and [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) methods</span></span>
-   <span data-ttu-id="d1a29-178">[**Arrange**
            ](https://msdn.microsoft.com/library/windows/apps/br208914) メソッドと [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) メソッド: これらには、要素レベルのレイアウト動作を処理する [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) レベルで定義されたネイティブ実装があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-178">[**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) and [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) methods: these have native implementations defined at the [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) level, which handle the element-level layout action</span></span>

## **<a name="measureoverride"></a><span data-ttu-id="d1a29-179">MeasureOverride</span><span class="sxs-lookup"><span data-stu-id="d1a29-179">MeasureOverride</span></span>**


<span data-ttu-id="d1a29-180">[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) メソッドには、[**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) メソッドがレイアウト内のその親によってパネルで呼び出されるときに、パネル自体の開始 [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) としてレイアウト システムで使われる戻り値があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-180">The [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) method has a return value that's used by the layout system as the starting [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) for the panel itself, when the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method is called on the panel by its parent in layout.</span></span> <span data-ttu-id="d1a29-181">どのロジックをメソッドで選択するかは、その戻り値と同様に重要であり、多くの場合、返される値はロジックに影響されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-181">The logic choices within the method are just as important as what it returns, and the logic often influences what value is returned.</span></span>

<span data-ttu-id="d1a29-182">すべての [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) 実装は、[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) でループし、各子要素で [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-182">All [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementations should loop through [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514), and call the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on each child element.</span></span> <span data-ttu-id="d1a29-183">**Measure** メソッドを呼び出すと、[**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) プロパティの値が設定されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-183">Calling the **Measure** method establishes the value for the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property.</span></span> <span data-ttu-id="d1a29-184">これにより、パネル自体に必要なスペースの大きさだけでなく、そのスペースを要素間で分割したり、特定の子要素のためにサイズ調整したりする方法がわかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-184">This might inform how much space the panel itself needs, as well as how that space is divided among elements or sized for a particular child element.</span></span>

<span data-ttu-id="d1a29-185">次に示すのは、[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) メソッドの非常に基本的なスケルトンです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-185">Here's a very basic skeleton of a [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) method:</span></span>

```CSharp
protected override Size MeasureOverride(Size availableSize)
{
    Size returnSize; //TODO might return availableSize, might do something else
     
    //loop through each Child, call Measure on each
    foreach (UIElement child in Children)
    {
        child.Measure(new Size()); // TODO determine how much space the panel allots for this child, that's what you pass to Measure
        Size childDesiredSize = child.DesiredSize; //TODO determine how the returned Size is influenced by each child's DesiredSize
        //TODO, logic if passed-in Size and net DesiredSize are different, does that matter?
    }
    return returnSize;
}
```

<span data-ttu-id="d1a29-186">要素は、多くの場合、レイアウトの準備ができた時点で自然なサイズになっています。</span><span class="sxs-lookup"><span data-stu-id="d1a29-186">Elements often have a natural size by the time they're ready for layout.</span></span> <span data-ttu-id="d1a29-187">[**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) について渡した *availableSize* が小さい場合は、測定パスの後に、[**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) が自然なサイズを示す場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-187">After the measure pass, the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) might indicate that natural size, if the *availableSize* you passed for [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) was smaller.</span></span> <span data-ttu-id="d1a29-188">自然なサイズが、**Measure** について渡した *availableSize* よりも大きい場合は、**DesiredSize** が *availableSize* に制限されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-188">If the natural size is larger than *availableSize* you passed for **Measure**, the **DesiredSize** is constrained to *availableSize*.</span></span> <span data-ttu-id="d1a29-189">これは、**Measure** の内部実装の動作であり、レイアウトのオーバーライドは、この動作を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-189">That's how **Measure**'s internal implementation behaves, and your layout overrides should take that behavior into account.</span></span>

<span data-ttu-id="d1a29-190">自然なサイズのない要素もあります。このような要素には、[**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) と [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) の **Auto** 値があるためです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-190">Some elements don't have a natural size because they have **Auto** values for [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) and [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width).</span></span> <span data-ttu-id="d1a29-191">これらの要素は、**Auto** 値が表すとおり、完全な *availableSize* を使用します。つまり、要素を使用可能な最大サイズに調整します。直接のレイアウトの親は、[**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) と共に *availableSize* を呼び出して、このサイズを伝えます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-191">These elements use the full *availableSize*, because that's what an **Auto** value represents: size the element to the maximum available size, which the immediate layout parent communicates by calling [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) with *availableSize*.</span></span> <span data-ttu-id="d1a29-192">実際には、(トップレベル ウィンドウである場合でも) UI がサイズ設定される測定値が常に存在します。最終的に測定パスは、すべての **Auto** 値を親の制約へと解決し、すべての **Auto** 値要素に実際の測定値 (レイアウトが完了した後に [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) と [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) をチェックして取得できます) が与えられます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-192">In practice, there's always some measurement that a UI is sized to (even if that's the top level window.) Eventually, the measure pass resolves all the **Auto** values to parent constraints and all **Auto** value elements get real measurements (which you can get by checking [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) and [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707), after layout completes).</span></span>

<span data-ttu-id="d1a29-193">少なくとも 1 つの無限サイズを含む [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) にサイズを渡すこともできます。これは、パネルがそれ自体のサイズを、コンテンツの測定値に収まるように調整できることを示します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-193">It's legal to pass a size to [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) that has at least one infinite dimension, to indicate that the panel can attempt to size itself to fit measurements of its content.</span></span> <span data-ttu-id="d1a29-194">測定される各子要素の [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) 値が、その要素の自然なサイズを使用して設定されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-194">Each child element being measured sets its [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) value using its natural size.</span></span> <span data-ttu-id="d1a29-195">配置パスでは、通常、そのサイズを使用してパネルが配置されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-195">Then, during the arrange pass, the panel typically arranges using that size.</span></span>

<span data-ttu-id="d1a29-196">[**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) などのテキスト要素には、[**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) 値と [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) 値のいずれも設定されていない場合でも、そのテキスト文字列とテキスト プロパティに基づいて計算された [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) と [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) があります。パネルのロジックでは、これらのサイズを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-196">Text elements such as [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) have a calculated [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) and [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) based on their text string and text properties even if no [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) or [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) value is set, and these dimensions should be respected by your panel logic.</span></span> <span data-ttu-id="d1a29-197">テキストのクリッピングは、特に不適切な UI 動作です。</span><span class="sxs-lookup"><span data-stu-id="d1a29-197">Clipping text is a particularly bad UI experience.</span></span>

<span data-ttu-id="d1a29-198">望ましいサイズの測定値が実装で使用されない場合でも、各子要素で [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) メソッドを呼び出すことをお勧めします。これは、**Measure** によってトリガーされる内部動作とネイティブ動作が呼び出されるためです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-198">Even if your implementation doesn't use the desired size measurements, it's best to call the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on each child element, because there are internal and native behaviors that are triggered by **Measure** being called.</span></span> <span data-ttu-id="d1a29-199">要素がレイアウトに関与するには、各子要素について、測定パスで **Measure** が、配置パスで [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) メソッドが呼び出される必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-199">For an element to participate in layout, each child element must have **Measure** called on it during the measure pass and the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method called on it during the arrange pass.</span></span> <span data-ttu-id="d1a29-200">これらのメソッドを呼び出すと、オブジェクトの内部フラグが設定されます。また、ビジュアル ツリーをビルドして UI を表示するときにシステムのレイアウト ロジックに必要な値 ([**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) プロパティなど) が入力されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-200">Calling these methods sets internal flags on the object and populates values (such as the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property) that the system's layout logic needs when it builds the visual tree and renders the UI.</span></span>

<span data-ttu-id="d1a29-201">[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) 戻り値は、[**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921)、または [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) が呼び出されるときの [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) の各子要素のその他のサイズの考慮事項を解釈するパネルのロジックに基づいています。</span><span class="sxs-lookup"><span data-stu-id="d1a29-201">The [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) return value is based on the panel's logic interpreting the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) or other size considerations for each of the child elements in [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) when [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) is called on them.</span></span> <span data-ttu-id="d1a29-202">子からの **DesiredSize** 値の取り扱いと、**MeasureOverride** 戻り値でのこの値の使用方法は、ロジックの解釈によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-202">What to do with **DesiredSize** values from children and how the **MeasureOverride** return value should use them is up to your own logic's interpretation.</span></span> <span data-ttu-id="d1a29-203">通常は値を変更せずに、加算することはありません。これは、**MeasureOverride** の入力値は、パネルの親が示す使用可能な固定サイズであることが多いためです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-203">You don't typically add up the values without modification, because the input of **MeasureOverride** is often a fixed available size that's being suggested by the panel's parent.</span></span> <span data-ttu-id="d1a29-204">そのサイズを超えると、パネル自体がクリップされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-204">If you exceed that size, the panel itself might get clipped.</span></span> <span data-ttu-id="d1a29-205">通常は、子の合計サイズとパネルで使用可能なサイズを比較し、必要に応じて調整します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-205">You'd typically compare the total size of children to the panel's available size and make adjustments if necessary.</span></span>

### <a name="tips-and-guidance"></a><span data-ttu-id="d1a29-206">ヒントとガイダンス</span><span class="sxs-lookup"><span data-stu-id="d1a29-206">Tips and guidance</span></span>

-   <span data-ttu-id="d1a29-207">望ましいのは、カスタムのパネルが、UI の構成での最初の実際のビジュアルに適していることです。たとえば、[**Page**](https://msdn.microsoft.com/library/windows/apps/br227503)、[**UserControl**](https://msdn.microsoft.com/library/windows/apps/br227647)、または XAML ページのルートである別の要素のすぐ下のレベルにあることです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-207">Ideally, a custom panel should be suitable for being the first true visual in a UI composition, perhaps at a level immediately under [**Page**](https://msdn.microsoft.com/library/windows/apps/br227503), [**UserControl**](https://msdn.microsoft.com/library/windows/apps/br227647) or another element that is the XAML page root.</span></span> <span data-ttu-id="d1a29-208">[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) の実装では、値を検証せずに入力 [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) を返すことを、通常の動作にしないでください。</span><span class="sxs-lookup"><span data-stu-id="d1a29-208">In [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementations, don't routinely return the input [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) without examining the values.</span></span> <span data-ttu-id="d1a29-209">返される **Size** に **Infinity** 値が含まれる場合は、そのためにランタイムのレイアウト ロジックで例外がスローされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-209">If the return **Size** has an **Infinity** value in it, this can throw exceptions in runtime layout logic.</span></span> <span data-ttu-id="d1a29-210">**Infinity** 値がアプリのメイン ウィンドウにあり、このウィンドウは、スクロール可能であるために高さの最大値がない場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-210">An **Infinity** value can come from the main app window, which is scrollable and therefore doesn't have a maximum height.</span></span> <span data-ttu-id="d1a29-211">その他のスクロール可能なコンテンツも、同様に動作する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-211">Other scrollable content might have the same behavior.</span></span>
-   <span data-ttu-id="d1a29-212">[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) の実装のもう 1 つの一般的な間違いは、新しい既定の [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) (高さと幅の値が 0) を返すことです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-212">Another common mistake in [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementations is to return a new default [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) (values for height and width are 0).</span></span> <span data-ttu-id="d1a29-213">その値が開始値となる場合もあります。また、どの子も表示されないことがパネルで設定されているために、それが正しい値である場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-213">You might start with that value, and it might even be the correct value if your panel determines that none of the children should be rendered.</span></span> <span data-ttu-id="d1a29-214">ただし、既定の **Size** は、パネルでは、ホストによって適切なサイズに調整されなくなります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-214">But, a default **Size** results in your panel not being sized correctly by its host.</span></span> <span data-ttu-id="d1a29-215">UI でスペースを必要としないため、スペースが割り当てられず、表示されません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-215">It requests no space in the UI, and therefore gets no space and doesn't render.</span></span> <span data-ttu-id="d1a29-216">これ以外のパネルのコードはすべて適切に機能する可能性がありますが、高さと幅がゼロで構成されている場合は、そのパネルも、そのコンテンツも表示されません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-216">All your panel code otherwise might be functioning fine, but you still won't see your panel or contents thereof if it's being composed with zero height, zero width.</span></span>
-   <span data-ttu-id="d1a29-217">オーバーライド内では、子要素を [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) にキャストしないようにし、レイアウトの結果としての集計プロパティ、特に [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) と [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) を使ってください。</span><span class="sxs-lookup"><span data-stu-id="d1a29-217">Within the overrides, avoid the temptation to cast child elements to [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) and use properties that are calculated as a result of layout, particularly [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) and [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707).</span></span> <span data-ttu-id="d1a29-218">ほとんどの一般的なシナリオでは、子の [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) 値をロジックの基礎にすることができます。こうすると、子要素のプロパティのうち、[**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) または [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) に関連するものはいずれも必要ではなくなります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-218">For most common scenarios, you can base the logic on the child's [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) value and you won't need any of the [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) or [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) related properties of a child element.</span></span> <span data-ttu-id="d1a29-219">イメージ ファイルの自然なサイズなどのように、要素の型とその詳細情報がわかっている特殊なケースでは、レイアウト システムによってアクティブに変更される値ではないため、要素の特殊な情報を利用できます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-219">For specialized cases, where you know the type of element and have additional information, for example the natural size of an image file, you can use your element's specialized information because it's not a value that is actively being altered by layout systems.</span></span> <span data-ttu-id="d1a29-220">レイアウトによる集計プロパティをレイアウト ロジックの一部に含めると、意図しないレイアウト ループが定義される危険性が著しく増大します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-220">Including layout-calculated properties as part of layout logic substantially increases the risk of defining an unintentional layout loop.</span></span> <span data-ttu-id="d1a29-221">このようなループを定義すると、有効なレイアウトを作成できなくなるため、ループから回復できない場合は、システムが [**LayoutCycleException**](https://msdn.microsoft.com/library/windows/apps/hh673799) をスローする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-221">These loops cause a condition where a valid layout can't be created and the system can throw a [**LayoutCycleException**](https://msdn.microsoft.com/library/windows/apps/hh673799) if the loop is not recoverable.</span></span>
-   <span data-ttu-id="d1a29-222">パネルは、通常、使用可能なスペースを複数の子要素間で分割しますが、その分割方法はさまざまです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-222">Panels typically divide their available space between multiple child elements, although exactly how space is divided varies.</span></span> <span data-ttu-id="d1a29-223">たとえば、[**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) は、スター サイズ指定とピクセル値の両方をサポートし、[**RowDefinition**](https://msdn.microsoft.com/library/windows/apps/br227606) 値と [**ColumnDefinition**](https://msdn.microsoft.com/library/windows/apps/br209324) 値を使って **Grid** セルへとスペースを分割するレイアウト ロジックを実装します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-223">For example, [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) implements layout logic that uses its [**RowDefinition**](https://msdn.microsoft.com/library/windows/apps/br227606) and [**ColumnDefinition**](https://msdn.microsoft.com/library/windows/apps/br209324) values to divide the space into the **Grid** cells, supporting both star-sizing and pixel values.</span></span> <span data-ttu-id="d1a29-224">これらがピクセル値である場合は、それぞれの子に使用可能なサイズが既にわかっているため、これが、グリッド スタイルの [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) の入力サイズとして渡されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-224">If they're pixel values, the size available for each child is already known, so that's what is passed as input size for a grid-style [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952).</span></span>
-   <span data-ttu-id="d1a29-225">パネル自体で、予約されたスペースを項目間の余白として使用できます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-225">Panels themselves can introduce reserved space for padding between items.</span></span> <span data-ttu-id="d1a29-226">これを行う場合は、[**Margin**](https://msdn.microsoft.com/library/windows/apps/br208724) とあらゆる **Padding** プロパティのいずれとも異なるプロパティとして測定値を公開するようにします。</span><span class="sxs-lookup"><span data-stu-id="d1a29-226">If you do this, make sure to expose the measurements as a property that's distinct from [**Margin**](https://msdn.microsoft.com/library/windows/apps/br208724) or any **Padding** property.</span></span>
-   <span data-ttu-id="d1a29-227">要素には、前のレイアウト パスに基づき、[**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) プロパティと [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) プロパティの値がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-227">Elements might have values for their [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) and [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) properties based on a previous layout pass.</span></span> <span data-ttu-id="d1a29-228">値が変化する場合、実行する特別なロジックがあるが、パネルのロジックがイベント処理で変化を確認する必要がなければ、アプリの UI コードで要素に [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) のハンドラーを設定できます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-228">If values change, app UI code can put handlers for [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) on elements if there's special logic to run, but panel logic typically doesn't need to check for changes with event handling.</span></span> <span data-ttu-id="d1a29-229">レイアウト システムは既に、レイアウトを再実行するタイミングを決定しています。これは、レイアウト関連プロパティの値が変化し、適切な場合は、パネルの [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) または [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) が自動的に呼び出されるためです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-229">The layout system is already making the determinations of when to re-run layout because a layout-relevant property changed value, and a panel's [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) or [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) are called automatically in the appropriate circumstances.</span></span>

## **<a name="arrangeoverride"></a><span data-ttu-id="d1a29-230">ArrangeOverride</span><span class="sxs-lookup"><span data-stu-id="d1a29-230">ArrangeOverride</span></span>**


<span data-ttu-id="d1a29-231">[**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) メソッドには、[**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) 戻り値があり、これは、パネル自体を表示するときにレイアウト システムで使われます。このとき、[**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) メソッドが、レイアウト内のその親によってパネルで呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-231">The [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) method has a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) return value that's used by the layout system when rendering the panel itself, when the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method is called on the panel by its parent in layout.</span></span> <span data-ttu-id="d1a29-232">入力 *finalSize* と、**ArrangeOverride** によって返される **Size** は同じであるのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="d1a29-232">It's typical that the input *finalSize* and the **ArrangeOverride** returned **Size** are the same.</span></span> <span data-ttu-id="d1a29-233">同じでない場合は、パネルがそれ自体を、レイアウトに関与する他の要素が使用可能であることを示すサイズとは異なるサイズにしようとしていることを意味します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-233">If they aren't, that means the panel is attempting to make itself a different size than what the other participants in layout claim is available.</span></span> <span data-ttu-id="d1a29-234">最終的なサイズは、パネル コードでレイアウトの測定パスを以前に実行したことに基づいているため、一般的には、異なるサイズは返されません。したがって、意図的に測定ロジックを無視しようとしていることになります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-234">The final size was based on having previously run the measure pass of layout through your panel code, so that's why returning a different size isn't typical: it means you are deliberately ignoring measure logic.</span></span>

<span data-ttu-id="d1a29-235">**Infinity** コンポーネントを持つ [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) は返さないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="d1a29-235">Don't return a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) with an **Infinity** component.</span></span> <span data-ttu-id="d1a29-236">そうした **Size** を使おうとすると、内部レイアウトから例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-236">Trying to use such a **Size** throws an exception from internal layout.</span></span>

<span data-ttu-id="d1a29-237">すべての [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) 実装は、[**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) でループし、各子要素で [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-237">All [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementations should loop through [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514), and call the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method on each child element.</span></span> <span data-ttu-id="d1a29-238">[**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) と同様に、**Arrange** は値を返しません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-238">Like [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952), **Arrange** doesn't have a return value.</span></span> <span data-ttu-id="d1a29-239">**Measure** とは異なり、結果として集計プロパティが設定されることはありません (ただし、この要素には、通常、[**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) イベントが発生します)。</span><span class="sxs-lookup"><span data-stu-id="d1a29-239">Unlike **Measure**, no calculated property gets set as a result (however, the element in question typically fires a [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) event).</span></span>

<span data-ttu-id="d1a29-240">次に示すのは、[**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) メソッドの非常に基本的なスケルトンです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-240">Here's a very basic skeleton of an [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) method:</span></span>

```CSharp
protected override Size ArrangeOverride(Size finalSize)
{
    //loop through each Child, call Arrange on each
    foreach (UIElement child in Children)
    {
        Point anchorPoint = new Point(); //TODO more logic for topleft corner placement in your panel
       // for this child, and based on finalSize or other internal state of your panel
        child.Arrange(new Rect(anchorPoint, child.DesiredSize)); //OR, set a different Size 
    }
    return finalSize; //OR, return a different Size, but that's rare
}
```

<span data-ttu-id="d1a29-241">レイアウトの配置パスは、その前に測定パスが発生することなく発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-241">The arrange pass of layout might happen without being preceded by a measure pass.</span></span> <span data-ttu-id="d1a29-242">ただし、これが発生するのは、前の測定値に影響するようなプロパティは変更されていないとレイアウト システムが判断している場合のみです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-242">However, this only happens when the layout system has determined no properties have changed that would have affected the previous measurements.</span></span> <span data-ttu-id="d1a29-243">たとえば、配置が変更された場合、その特定の要素の [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) が、配置の選択が変わったときに変更されないため、この要素を測定し直す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-243">For example, if an alignment changes, there's no need to re-measure that particular element because its [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) would not change when its alignment choice changes.</span></span> <span data-ttu-id="d1a29-244">一方、レイアウトのいずれかの要素で [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) が変更された場合は、新しい測定パスが必要になります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-244">On the other hand, if [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) changes on any element in a layout, a new measure pass is needed.</span></span> <span data-ttu-id="d1a29-245">レイアウト システムは自動的に実際の測定の変更を検出し、もう一度測定パスを呼び出した後、別の配置パスを実行します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-245">The layout system automatically detects true measure changes and invokes the measure pass again, and then runs another arrange pass.</span></span>

<span data-ttu-id="d1a29-246">[**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) の入力は、[**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994) 値を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-246">The input for [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) takes a [**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994) value.</span></span> <span data-ttu-id="d1a29-247">この **Rect** を作成する一般的な方法は、[**Point**](https://msdn.microsoft.com/library/windows/apps/br225870) の入力と [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) の入力を持つコンストラクターを使うことです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-247">The most common way to construct this **Rect** is to use the constructor that has a [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870) input and a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) input.</span></span> <span data-ttu-id="d1a29-248">**Point** は、要素の境界ボックスの左上隅を配置するポイントです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-248">The **Point** is the point where the top left corner of the bounding box for the element should be placed.</span></span> <span data-ttu-id="d1a29-249">**Size** は、この特定の要素を表示するために使われるサイズです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-249">The **Size** is the dimensions used to render that particular element.</span></span> <span data-ttu-id="d1a29-250">多くの場合、この要素の [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) を、この **Size** 値として使います。これは、レイアウトに関与したすべての要素の **DesiredSize** を確立することが、レイアウトの測定パスの目的であったためです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-250">You often use the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) for that element as this **Size** value, because establishing the **DesiredSize** for all elements involved in layout was the purpose of the measure pass of layout.</span></span> <span data-ttu-id="d1a29-251">(測定パスは、反復される方法で要素のサイズ設定全体を決定します。このため、配置パスに到達した後は、レイアウト システムが要素の配置を最適化できます)。</span><span class="sxs-lookup"><span data-stu-id="d1a29-251">(The measure pass determines all-up sizing of the elements in an iterative way so that the layout system can optimize how elements are placed once it gets to the arrange pass.)</span></span>

<span data-ttu-id="d1a29-252">通常、各 [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) 実装で異なっているのは、それぞれの子の配置方法の [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870) コンポーネントをパネルが決定するためのロジックです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-252">What typically varies between [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementations is the logic by which the panel determines the [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870) component of how it arranges each child.</span></span> <span data-ttu-id="d1a29-253">[**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) などの絶対配置のパネルでは、[**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) 値と [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/hh759772) 値を介して各要素から取得する明示的な配置情報を使用します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-253">An absolute positioning panel such as [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) uses the explicit placement info that it gets from each element through [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/hh759772) values.</span></span> <span data-ttu-id="d1a29-254">[**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) などのスペース分割のパネルには、使用可能なスペースをセルに分割する数学演算があり、各セルには、そのコンテンツが配置され、位置調整される場所に関する x-y 値があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-254">A space-dividing panel such as [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) would have mathematical operations that divided the available space into cells and each cell would have an x-y value for where its content should be placed and arranged.</span></span> <span data-ttu-id="d1a29-255">[**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) などのアダプティブ パネルでは、コンテンツの向きとサイズに合わせてパネル自体を拡大する場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-255">An adaptive panel such as [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) might be expanding itself to fit content in its orientation dimension.</span></span>

<span data-ttu-id="d1a29-256">直接制御して [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) に渡すもの以外にも、レイアウトの要素の位置に影響するものがあります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-256">There are still additional positioning influences on elements in layout, beyond what you directly control and pass to [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914).</span></span> <span data-ttu-id="d1a29-257">これらは、すべての [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) 派生型に一般的な **Arrange** の内部ネイティブ実装によるもので、この実装は、テキスト要素などのあるその他の型によって拡張されます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-257">These come from the internal native implementation of **Arrange** that's common to all [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) derived types and augmented by some other types such as text elements.</span></span> <span data-ttu-id="d1a29-258">たとえば、要素には余白と配置を含めることができ、一部の要素には、パディングを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-258">For example, elements can have margin and alignment, and some can have padding.</span></span> <span data-ttu-id="d1a29-259">これらのプロパティは、多くの場合、相互に作用します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-259">These properties often interact.</span></span> <span data-ttu-id="d1a29-260">詳しくは、「[配置、余白、およびパディング](alignment-margin-padding.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1a29-260">For more info, see [Alignment, margin, and padding](alignment-margin-padding.md).</span></span>

## <a name="panels-and-controls"></a><span data-ttu-id="d1a29-261">パネルおよびコントロール</span><span class="sxs-lookup"><span data-stu-id="d1a29-261">Panels and controls</span></span>


<span data-ttu-id="d1a29-262">カスタム コントロールとして作成する必要のあるカスタム パネルには、機能を含めないようにします。</span><span class="sxs-lookup"><span data-stu-id="d1a29-262">Avoid putting functionality into a custom panel that should instead be built as a custom control.</span></span> <span data-ttu-id="d1a29-263">パネルの役割は、パネル内の子要素コンテンツを、自動的に実行されるレイアウトの機能として表示することです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-263">The role of a panel is to present any child element content that exists within it, as a function of layout that happens automatically.</span></span> <span data-ttu-id="d1a29-264">パネルでは、コンテンツに装飾を追加 ([**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) が、表示する要素の周りに境界線を追加する場合と同様に) したり、パディングなどのレイアウト関連の調整を実行したりすることがあります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-264">The panel might add decorations to content (similar to how a [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) adds the border around the element it presents), or perform other layout-related adjustments like padding.</span></span> <span data-ttu-id="d1a29-265">ただし、報告や、子からの情報の使用以上にビジュアル ツリーの出力を拡張する場合は、これ以上の機能を含めないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="d1a29-265">But that's about as far as you should go when extending the visual tree output beyond reporting and using information from the children.</span></span>

<span data-ttu-id="d1a29-266">ユーザーがアクセスできる対話式操作がある場合は、パネルではなく、カスタム コントロールを作る必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-266">If there's any interaction that's accessible to the user, you should write a custom control, not a panel.</span></span> <span data-ttu-id="d1a29-267">たとえば、クリッピングを防ぐことが目的である場合でも、パネルが、表示するコンテンツにスクロール ビューポートを追加しないようにします。スクロールバーや親指などは、対話式のコントロール パーツであるためです</span><span class="sxs-lookup"><span data-stu-id="d1a29-267">For example, a panel shouldn't add scrolling viewports to content it presents, even if the goal is to prevent clipping, because the scrollbars, thumbs and so on are interactive control parts.</span></span> <span data-ttu-id="d1a29-268">(最終的には、コンテンツにスクロール バーが含まれる場合がありますが、これは、子のロジックで実行されるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-268">(Content might have scrollbars after all, but you should leave that up to the child's logic.</span></span> <span data-ttu-id="d1a29-269">レイアウト処理としてスクロールを追加して強制的に実行しないでください)。コントロールのコンテンツを表示するには、コントロールを作成し、そのコントロールのビジュアル ツリーで重要な役割を果たすカスタム パネルを作ることもできます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-269">Don't force it by adding scrolling as a layout operation.) You might create a control and also write a custom panel that plays an important role in that control's visual tree, when it comes to presenting content in that control.</span></span> <span data-ttu-id="d1a29-270">ただし、コントロールとパネルは個別のコード オブジェクトである必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-270">But the control and the panel should be distinct code objects.</span></span>

<span data-ttu-id="d1a29-271">コントロールとパネルを区別することが重要な理由の 1 つは、Microsoft UI オートメーションとアクセシビリティです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-271">One reason the distinction between control and panel is important is because of Microsoft UI Automation and accessibility.</span></span> <span data-ttu-id="d1a29-272">パネルは、論理的な動作ではなく、視覚的レイアウト動作を提供します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-272">Panels provide a visual layout behavior, not a logical behavior.</span></span> <span data-ttu-id="d1a29-273">UI 要素が視覚的にどのように表示されるかは、通常はアクセシビリティのシナリオで重要である UI の要素ではありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-273">How a UI element appears visually is not an aspect of UI that is typically important to accessibility scenarios.</span></span> <span data-ttu-id="d1a29-274">アクセシビリティでは、UI を理解するうえで論理的に重要なアプリの構成要素を公開します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-274">Accessibility is about exposing the parts of an app that are logically important to understanding a UI.</span></span> <span data-ttu-id="d1a29-275">操作が必要な場合は、コントロールが UI オートメーション インフラストラクチャに操作の可能性を公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-275">When interaction is required, controls should expose the interaction possibilities to the UI Automation infrastructure.</span></span> <span data-ttu-id="d1a29-276">詳しくは、「[カスタム オートメーション ピア](https://msdn.microsoft.com/library/windows/apps/mt297667)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1a29-276">For more info, see [Custom automation peers](https://msdn.microsoft.com/library/windows/apps/mt297667).</span></span>

## <a name="other-layout-api"></a><span data-ttu-id="d1a29-277">その他のレイアウト API</span><span class="sxs-lookup"><span data-stu-id="d1a29-277">Other layout API</span></span>


<span data-ttu-id="d1a29-278">他にも、レイアウト システムの一部であるが、[**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) で宣言されていない API があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-278">There are some other APIs that are part of the layout system, but aren't declared by [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511).</span></span> <span data-ttu-id="d1a29-279">そうした API は、パネルの実装、またはパネルを使うカスタム コントロールで使うことができます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-279">You might use these in a panel implementation or in a custom control that uses panels.</span></span>

-   <span data-ttu-id="d1a29-280">[**UpdateLayout**
            ](https://msdn.microsoft.com/library/windows/apps/br208989)、[**InvalidateMeasure**](https://msdn.microsoft.com/library/windows/apps/br208930)、および [**InvalidateArrange**](https://msdn.microsoft.com/library/windows/apps/br208929) は、レイアウト パスを開始するメソッドです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-280">[**UpdateLayout**](https://msdn.microsoft.com/library/windows/apps/br208989), [**InvalidateMeasure**](https://msdn.microsoft.com/library/windows/apps/br208930), and [**InvalidateArrange**](https://msdn.microsoft.com/library/windows/apps/br208929) are methods that initiate a layout pass.</span></span> <span data-ttu-id="d1a29-281">**InvalidateArrange** は、測定パスをトリガーしない場合もありますが、他の 2 つは測定パスをトリガーします。</span><span class="sxs-lookup"><span data-stu-id="d1a29-281">**InvalidateArrange** might not trigger a measure pass, but the other two do.</span></span> <span data-ttu-id="d1a29-282">これらのメソッドは、レイアウト メソッド オーバーライドで呼び出さないでください。呼び出すと、ほとんどの場合、レイアウトのループが発生します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-282">Never call these methods from within a layout method override, because they're almost sure to cause a layout loop.</span></span> <span data-ttu-id="d1a29-283">通常、制御コードも、これらを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="d1a29-283">Control code doesn't typically need to call them either.</span></span> <span data-ttu-id="d1a29-284">レイアウトのほとんどの機能は、[**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) などのフレームワーク定義のレイアウト プロパティへの変更を検出することによって自動的にトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="d1a29-284">Most aspects of layout are triggered automatically by detecting changes to the framework-defined layout properties such as [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) and so on.</span></span>
-   <span data-ttu-id="d1a29-285">[**LayoutUpdated**
            ](https://msdn.microsoft.com/library/windows/apps/br208722) は、要素のレイアウトの機能が変化したときに発生するイベントです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-285">[**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) is an event that fires when some aspect of layout of the element has changed.</span></span> <span data-ttu-id="d1a29-286">これは、パネルに固有のイベントではなく、[**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) で定義されています。</span><span class="sxs-lookup"><span data-stu-id="d1a29-286">This isn't specific to panels; the event is defined by [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706).</span></span>
-   <span data-ttu-id="d1a29-287">[**SizeChanged**](https://msdn.microsoft.com/library/windows/apps/br208742) は、レイアウト パスが完了した後にのみ発生するイベントで、[**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) または [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) が、結果として変更されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="d1a29-287">[**SizeChanged**](https://msdn.microsoft.com/library/windows/apps/br208742) is an event that fires only after layout passes are finalized, and indicates that [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) or [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) have changed as a result.</span></span> <span data-ttu-id="d1a29-288">これは、もう 1 つの [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) イベントです。</span><span class="sxs-lookup"><span data-stu-id="d1a29-288">This is another [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) event.</span></span> <span data-ttu-id="d1a29-289">[**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) は発生するが、**SizeChanged** は発生しない場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1a29-289">There are cases where [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) fires, but **SizeChanged** does not.</span></span> <span data-ttu-id="d1a29-290">たとえば、内部コンテンツが再配置されたが、要素のサイズは変更されなかった場合です。</span><span class="sxs-lookup"><span data-stu-id="d1a29-290">For example the internal contents might be rearranged, but the element's size didn't change.</span></span>


## <a name="related-topics"></a><span data-ttu-id="d1a29-291">関連トピック</span><span class="sxs-lookup"><span data-stu-id="d1a29-291">Related topics</span></span>

**<span data-ttu-id="d1a29-292">リファレンス</span><span class="sxs-lookup"><span data-stu-id="d1a29-292">Reference</span></span>**
* [**<span data-ttu-id="d1a29-293">FrameworkElement.ArrangeOverride</span><span class="sxs-lookup"><span data-stu-id="d1a29-293">FrameworkElement.ArrangeOverride</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208711)
* [**<span data-ttu-id="d1a29-294">FrameworkElement.MeasureOverride</span><span class="sxs-lookup"><span data-stu-id="d1a29-294">FrameworkElement.MeasureOverride</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208730)
* [**<span data-ttu-id="d1a29-295">Panel</span><span class="sxs-lookup"><span data-stu-id="d1a29-295">Panel</span></span>**](https://msdn.microsoft.com/library/windows/apps/br227511)

**<span data-ttu-id="d1a29-296">概念</span><span class="sxs-lookup"><span data-stu-id="d1a29-296">Concepts</span></span>**
* [<span data-ttu-id="d1a29-297">配置、余白、およびパディング</span><span class="sxs-lookup"><span data-stu-id="d1a29-297">Alignment, margin, and padding</span></span>](alignment-margin-padding.md)
