---
author: eliotcowley
title: Marble Maze サンプルの基礎
description: このドキュメントには、Marble Maze プロジェクトの基本的な特性について説明します。たとえば、Windows ランタイム環境で Visual C を使用する方法を作成する方法と、構造化し、組み込まれている方法です。
ms.assetid: 73329b29-62e3-1b36-01db-b7744ee5b4c3
ms.author: elcowle
ms.date: 08/22/2017
ms.topic: article
keywords: Windows 10, UWP, ゲーム, サンプル, DirectX, 基礎
ms.localizationpriority: medium
ms.openlocfilehash: f595c8f429c93a13d6342c281a90f3b0f5741621
ms.sourcegitcommit: 38f06f1714334273d865935d9afb80efffe97a17
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/09/2018
ms.locfileid: "6200708"
---
# <a name="marble-maze-sample-fundamentals"></a><span data-ttu-id="f89d4-104">Marble Maze サンプルの基礎</span><span class="sxs-lookup"><span data-stu-id="f89d4-104">Marble Maze sample fundamentals</span></span>




<span data-ttu-id="f89d4-105">このトピックでは、Marble Maze プロジェクトの基本的な特性について説明します。たとえば、Windows ランタイム環境で Visual C++ をどのように使うか、どのように作られ、構成され、ビルドされるかなどです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-105">This topic describes the fundamental characteristics of the Marble Maze project&mdash;for example, how it uses Visual C++ in the Windows Runtime environment, how it is created and structured, and how it is built.</span></span> <span data-ttu-id="f89d4-106">また、コードで使われるいくつかの規則についても説明します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-106">The topic also describes several of the conventions that are used in the code.</span></span>

> [!NOTE]
> <span data-ttu-id="f89d4-107">このドキュメントに対応するサンプル コードは、[DirectX Marble Maze ゲームのサンプルに関するページ](http://go.microsoft.com/fwlink/?LinkId=624011)にあります。</span><span class="sxs-lookup"><span data-stu-id="f89d4-107">The sample code that corresponds to this document is found in the [DirectX Marble Maze game sample](http://go.microsoft.com/fwlink/?LinkId=624011).</span></span>

<span data-ttu-id="f89d4-108">このドキュメントでは、ユニバーサル Windows プラットフォーム (UWP) ゲームの計画と開発の際に重要となるいくつかの事柄について説明します。取り上げる内容は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-108">Here are some of the key points that this document discusses for when you plan and develop your Universal Windows Platform (UWP) game.</span></span>

-   <span data-ttu-id="f89d4-109">DirectX UWP ゲームを作るために、Visual Studio で \*\*DirectX 11 アプリ (ユニバーサル Windows) \*\*Visual C++ テンプレートを使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-109">Use the **DirectX 11 App (Universal Windows)** Visual C++ template in Visual Studio to create your DirectX UWP game.</span></span>
-   <span data-ttu-id="f89d4-110">より新しい、オブジェクト指向に沿った方法で UWP アプリを開発できるようなクラスとインターフェイスが、Windows ランタイムには用意されています。</span><span class="sxs-lookup"><span data-stu-id="f89d4-110">The Windows Runtime provides classes and interfaces so that you can develop UWP apps in a more modern, object-oriented manner.</span></span>
-   <span data-ttu-id="f89d4-111">Windows ランタイム変数の有効期間を管理するにはハット (^) 記号を付けたオブジェクト参照、COM オブジェクトの有効期間を管理するには [Microsoft::WRL::ComPtr](https://docs.microsoft.com/cpp/windows/comptr-class)、その他のすべてのヒープ割り当て C++ オブジェクトの有効期間を管理するには [std::shared\_ptr](https://docs.microsoft.com/cpp/standard-library/shared-ptr-class) または [std::unique\_ptr](https://docs.microsoft.com/cpp/standard-library/unique-ptr-class) を使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-111">Use object references with the hat (^) symbol to manage the lifetime of Windows Runtime variables, [Microsoft::WRL::ComPtr](https://docs.microsoft.com/cpp/windows/comptr-class) to manage the lifetime of COM objects, and [std::shared\_ptr](https://docs.microsoft.com/cpp/standard-library/shared-ptr-class) or [std::unique\_ptr](https://docs.microsoft.com/cpp/standard-library/unique-ptr-class) to manage the lifetime of all other heap-allocated C++ objects.</span></span>
-   <span data-ttu-id="f89d4-112">ほとんどの場合、予期しないエラーを処理するには、結果コードではなく例外処理を使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-112">In most cases, use exception handling, instead of result codes, to deal with unexpected errors.</span></span>
-   <span data-ttu-id="f89d4-113">コード分析ツールと共に[SAL 注釈](https://docs.microsoft.com/visualstudio/code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects)を使用して、アプリのエラーを検出できるようにします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-113">Use [SAL annotations](https://docs.microsoft.com/visualstudio/code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects) together with code analysis tools to help discover errors in your app.</span></span>

## <a name="creating-the-visual-studio-project"></a><span data-ttu-id="f89d4-114">Visual Studio プロジェクトの作成</span><span class="sxs-lookup"><span data-stu-id="f89d4-114">Creating the Visual Studio project</span></span>


<span data-ttu-id="f89d4-115">ダウンロードし、サンプルを抽出した場合、 **MarbleMaze_VS2017.sln**フォルダーにファイル ( **C++** ) は、Visual Studio で開くことができ、コードがあります。</span><span class="sxs-lookup"><span data-stu-id="f89d4-115">If you've downloaded and extracted the sample, you can open the **MarbleMaze_VS2017.sln** file (in the **C++** folder) in Visual Studio, and you'll have the code in front of you.</span></span>

<span data-ttu-id="f89d4-116">Marble Maze の Visual Studio プロジェクトを作ったときには、既にあるプロジェクトを利用しました。</span><span class="sxs-lookup"><span data-stu-id="f89d4-116">When we created the Visual Studio project for Marble Maze, we started with an existing project.</span></span> <span data-ttu-id="f89d4-117">しかし、DirectX UWP ゲームで必要となる基本的な機能を持つプロジェクトがまだない場合は、Visual Studio **DirectX 11 アプリ (ユニバーサル Windows)** テンプレートに基づくプロジェクトを作ることをお勧めします。このテンプレートには、基本的な機能を備えた 3D アプリケーションが用意されているためです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-117">However, if you do not already have an existing project that provides the basic functionality that your DirectX UWP game requires, we recommend that you create a project based on the Visual Studio **DirectX 11 App (Universal Windows)** template because it provides a basic working 3D application.</span></span> <span data-ttu-id="f89d4-118">これを行うには、次の手順に従います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-118">To do this, follow these steps:</span></span>

1. <span data-ttu-id="f89d4-119">Visual Studio 2017 で選択**ファイル > 新規 > プロジェクト]**</span><span class="sxs-lookup"><span data-stu-id="f89d4-119">In Visual Studio 2017, select **File > New > Project...**</span></span>

2. <span data-ttu-id="f89d4-120">**新しいプロジェクト**] ウィンドウの左側のサイドバーで選択**インストール済み > テンプレート > Visual C**します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-120">In the **New Project** window, in the left sidebar, select **Installed > Templates > Visual C++**.</span></span>

3. <span data-ttu-id="f89d4-121">中央のリストでは、 **DirectX 11 アプリ (ユニバーサル Windows)** を選択します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-121">In the middle list, select **DirectX 11 App (Universal Windows)**.</span></span> <span data-ttu-id="f89d4-122">必要なコンポーネントをインストールする必要がありますしない場合、このオプションが表示されない、&mdash;その他のコンポーネントをインストールする方法についての情報の[追加または削除のワークロードとコンポーネントの Visual Studio 2017 の変更](https://docs.microsoft.com/visualstudio/install/modify-visual-studio)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-122">If you don't see this option, you may not have the required components installed&mdash;see [Modify Visual Studio 2017 by adding or removing workloads and components](https://docs.microsoft.com/visualstudio/install/modify-visual-studio) for information about how to install additional components.</span></span>

4. <span data-ttu-id="f89d4-123">**名前**、格納するファイルの**場所**および**ソリューション名**では、プロジェクトを提供し、 **[ok]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-123">Give your project a **Name**, a **Location** for the files to be stored, and a **Solution name**, and click **OK**.</span></span>

![新しいプロジェクト](images/marble-maze-sample-fundamentals-1.png)

<span data-ttu-id="f89d4-125">**DirectX 11 アプリ (ユニバーサル Windows)** テンプレートで重要なプロジェクト設定の 1 つは、プログラムが Windows ランタイム言語拡張機能を使えるようにする **/ZW** オプションです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-125">One important project setting in the **DirectX 11 App (Universal Windows)** template is the **/ZW** option, which enables the program to use the Windows Runtime language extensions.</span></span> <span data-ttu-id="f89d4-126">Visual Studio テンプレートを使う場合、このオプションは既定で有効になっています。</span><span class="sxs-lookup"><span data-stu-id="f89d4-126">This option is enabled by default when you use the Visual Studio template.</span></span> <span data-ttu-id="f89d4-127">Visual Studio でコンパイラ オプションを設定する方法について詳しくは、「[コンパイラ オプションの設定](https://docs.microsoft.com/cpp/build/reference/setting-compiler-options)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-127">See [Setting Compiler Options](https://docs.microsoft.com/cpp/build/reference/setting-compiler-options) for more info about how to set compiler options in Visual Studio.</span></span>

> <span data-ttu-id="f89d4-128">**注意:**  **/ZW**オプションは **/clr**などのオプションと互換性がありません。</span><span class="sxs-lookup"><span data-stu-id="f89d4-128">**Caution** The **/ZW** option is not compatible with options such as **/clr**.</span></span> <span data-ttu-id="f89d4-129">**/clr** の場合は、同じ Visual C++ プロジェクトで .NET Framework と Windows ランタイムの両方をターゲットにすることはできないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-129">In the case of **/clr**, this means that you cannot target both the .NET Framework and the Windows Runtime from the same Visual C++ project.</span></span>

 

<span data-ttu-id="f89d4-130">Microsoft Store から取得したすべての UWP アプリは、アプリ パッケージの形式で提供されます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-130">Every UWP app that you acquire from the Microsoft Store comes in the form of an app package.</span></span> <span data-ttu-id="f89d4-131">アプリ パッケージには、アプリについての情報が記載されたパッケージ マニフェストが含まれています。</span><span class="sxs-lookup"><span data-stu-id="f89d4-131">An app package contains a package manifest, which contains information about your app.</span></span> <span data-ttu-id="f89d4-132">たとえば、アプリの機能 (つまり、保護されたシステム リソースやユーザー データへの必要なアクセス) を指定できます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-132">For example, you can specify the capabilities (that is, the required access to protected system resources or user data) of your app.</span></span> <span data-ttu-id="f89d4-133">アプリで特定の機能が必須であると決めた場合は、パッケージ マニフェストを使って、必要な機能を宣言します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-133">If you determine that your app requires certain capabilities, use the package manifest to declare the required capabilities.</span></span> <span data-ttu-id="f89d4-134">マニフェストでは、サポートされているデバイスの回転、タイル画像、スプラッシュ画面など、プロジェクト プロパティを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-134">The manifest also lets you specify project properties such as supported device rotations, tile images, and the splash screen.</span></span> <span data-ttu-id="f89d4-135">プロジェクトで **Package.appxmanifest** を開いて、マニフェストを編集することができます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-135">You can edit the manifest by opening **Package.appxmanifest** in your project.</span></span> <span data-ttu-id="f89d4-136">アプリ パッケージについて詳しくは、「[アプリのパッケージ化](https://msdn.microsoft.com/library/windows/apps/mt270969)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-136">For more info about app packages, see [Packaging apps](https://msdn.microsoft.com/library/windows/apps/mt270969).</span></span>

##  <a name="building-deploying-and-running-the-game"></a><span data-ttu-id="f89d4-137">ゲームのビルド、展開、実行</span><span class="sxs-lookup"><span data-stu-id="f89d4-137">Building, deploying, and running the game</span></span>

<span data-ttu-id="f89d4-138">Visual Studio の上部の、緑色の再生ボタンの左のドロップダウン リストで、展開構成を選択します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-138">In the dropdown menus at the top of Visual Studio, to the left of the green play button, select your deployment configuration.</span></span> <span data-ttu-id="f89d4-139">デバイスのアーキテクチャ (32 ビットでは **x86**、64 ビットでは **x64**) による **ローカル コンピューター** をターゲットとする**デバッグ**として設定することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-139">We recommend setting it as **Debug** targeting your device's architecture (**x86** for 32-bit, **x64** for 64-bit) and to your **Local Machine**.</span></span> <span data-ttu-id="f89d4-140">**リモート コンピューター**でテストすることも、または USB で接続された**デバイス**を対象とすることも、可能です。</span><span class="sxs-lookup"><span data-stu-id="f89d4-140">You can also test on a **Remote Machine**, or to a **Device** that's connected via USB.</span></span> <span data-ttu-id="f89d4-141">次に、緑色の再生ボタンをクリックして、デバイスへビルドと展開を行います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-141">Then click the green play button to build and deploy to your device.</span></span>

![デバッグ、x64、ローカル コンピューター](images/marble-maze-sample-fundamentals-2.png)

###  <a name="controlling-the-game"></a><span data-ttu-id="f89d4-143">ゲームの制御</span><span class="sxs-lookup"><span data-stu-id="f89d4-143">Controlling the game</span></span>

<span data-ttu-id="f89d4-144">タッチ、加速度計、Xbox One コント ローラーで、またはマウスを Marble Maze の制御を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-144">You can use touch, the accelerometer, the Xbox One controller, or the mouse to control Marble Maze.</span></span>

-   <span data-ttu-id="f89d4-145">アクティブなメニュー項目を変更するには、コントローラーの方向パッドを使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-145">Use the directional pad on the controller to change the active menu item.</span></span>
-   <span data-ttu-id="f89d4-146">タッチ、A またはスタート画面を使用して、コント ローラーまたはマウスをメニュー項目を選択する] ボタンをします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-146">Use touch, the A or Start button on the controller, or the mouse to pick a menu item.</span></span>
-   <span data-ttu-id="f89d4-147">迷路を傾けるには、タッチ、加速度計、左スティック、マウスを使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-147">Use touch, the accelerometer, the left thumbstick, or the mouse to tilt the maze.</span></span>
-   <span data-ttu-id="f89d4-148">タッチ、A またはスタート画面を使用して、コント ローラーまたはマウスを高などのメニューを閉じるボタン スコア表。</span><span class="sxs-lookup"><span data-stu-id="f89d4-148">Use touch, the A or Start button on the controller, or the mouse to close menus such as the high score table.</span></span>
-   <span data-ttu-id="f89d4-149">一時停止または再開ゲーム コント ローラーまたはキーボードの P キーで、[スタート] ボタンを使用します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-149">Use the Start button on the controller or the P key on the keyboard to pause or resume the game.</span></span>
-   <span data-ttu-id="f89d4-150">ゲームを再開始するには、コントローラーの [戻る] ボタンやキーボードの Home キーを使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-150">Use the Back button on the controller or the Home key on the keyboard to restart the game.</span></span>
-   <span data-ttu-id="f89d4-151">ハイ スコア表が表示されている場合は、すべてのスコアをクリアする、コント ローラーまたはキーボードの Home キーで、戻るボタンを使用します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-151">When the high-score table is visible, use the Back button on the controller or the Home key on the keyboard to clear all scores.</span></span>

##  <a name="code-conventions"></a><span data-ttu-id="f89d4-152">コードの規則</span><span class="sxs-lookup"><span data-stu-id="f89d4-152">Code conventions</span></span>


<span data-ttu-id="f89d4-153">Windows ランタイムは、特別なアプリケーション環境だけで実行される UWP アプリの作成に使うプログラミング インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-153">The Windows Runtime is a programming interface that you can use to create UWP apps that run only in a special application environment.</span></span> <span data-ttu-id="f89d4-154">このようなアプリでは、認定された関数、データ型、およびデバイスを使用し、Microsoft Store から配布されます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-154">Such apps use authorized functions, data types, and devices, and are distributed from the Microsoft Store.</span></span> <span data-ttu-id="f89d4-155">Windows ランタイムの最も基本となる部分を構成しているのは、アプリケーション バイナリ インターフェイス (ABI) です。</span><span class="sxs-lookup"><span data-stu-id="f89d4-155">At the lowest level, the Windows Runtime consists of an Application Binary Interface (ABI).</span></span> <span data-ttu-id="f89d4-156">ABI は、JavaScript、.NET 言語、Visual C++ など、複数のプログラミング言語から Windows ランタイム API にアクセスできるようにするための基礎となるバイナリ コントラクトです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-156">The ABI is a low-level binary contract that makes Windows Runtime APIs accessible to multiple programming languages such as JavaScript, the .NET languages, and Visual C++.</span></span>

<span data-ttu-id="f89d4-157">Windows ランタイム API を JavaScript や .NET から呼び出すには、各言語環境に固有のプロジェクションが必要となります。</span><span class="sxs-lookup"><span data-stu-id="f89d4-157">In order to call Windows Runtime APIs from JavaScript and .NET, those languages require projections that are specific to each language environment.</span></span> <span data-ttu-id="f89d4-158">Windows ランタイム API を JavaScript または .NET から呼び出すとき、実際にはプロジェクションを呼び出し、そこからさらに、基になる ABI 関数を呼び出すことになります。</span><span class="sxs-lookup"><span data-stu-id="f89d4-158">When you call a Windows Runtime API from JavaScript or .NET, you are invoking the projection, which in turn calls the underlying ABI function.</span></span> <span data-ttu-id="f89d4-159">ABI 関数は C++ から直接呼び出すことができますが、Microsoft は、C++ 用のプロジェクションも併せて提供しています。そのようにすることで、Windows ランタイム API の扱いがシンプルになると共に、高いパフォーマンスを維持できるためです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-159">Although you can call the ABI functions directly in C++, Microsoft provides projections for C++ as well, because they make it much simpler to consume the Windows Runtime APIs, while still maintaining high performance.</span></span> <span data-ttu-id="f89d4-160">また、実際に Windows ランタイムのプロジェクションをサポートする、Visual C++ の言語拡張機能も Microsoft から提供されています。</span><span class="sxs-lookup"><span data-stu-id="f89d4-160">Microsoft also provides language extensions to Visual C++ that specifically support the Windows Runtime projections.</span></span> <span data-ttu-id="f89d4-161">こうした言語拡張機能の多くは、C++/CLI 言語の構文と似ています。</span><span class="sxs-lookup"><span data-stu-id="f89d4-161">Many of these language extensions resemble the syntax for the C++/CLI language.</span></span> <span data-ttu-id="f89d4-162">ただし、ネイティブ アプリはこの構文を使って、共通言語ランタイム (CLR) をターゲットにするのではなく、Windows ランタイムをターゲットにします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-162">However, instead of targeting the common language runtime (CLR), native apps use this syntax to target the Windows Runtime.</span></span> <span data-ttu-id="f89d4-163">オブジェクト参照、またはハット (^) 修飾子は、この新しい構文の重要な要素です。これによって、参照カウントに基づくランタイム オブジェクトの自動削除が可能になるためです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-163">The object reference, or hat (^), modifier is an important part of this new syntax because it enables the automatic deletion of runtime objects by means of reference counting.</span></span> <span data-ttu-id="f89d4-164">Windows ランタイム オブジェクトの有効期間を管理するために [AddRef](https://msdn.microsoft.com/library/windows/desktop/ms691379) や [Release](https://msdn.microsoft.com/library/windows/desktop/ms682317) などのメソッドを呼び出さなくても、他のコンポーネントがオブジェクトを参照していないときに (たとえばオブジェクトのスコープが終わったり、すべての参照が **nullptr** に設定されたりしたときに)、ランタイムがオブジェクトを削除します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-164">Instead of calling methods such as [AddRef](https://msdn.microsoft.com/library/windows/desktop/ms691379) and [Release](https://msdn.microsoft.com/library/windows/desktop/ms682317) to manage the lifetime of a Windows Runtime object, the runtime deletes the object when no other component references it, for example, when it leaves scope or you set all references to **nullptr**.</span></span> <span data-ttu-id="f89d4-165">Visual C++ を使った UWP アプリの作成に関して、もう 1 つの重要な要素は **ref new** キーワードです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-165">Another important part of using Visual C++ to create UWP apps is the **ref new** keyword.</span></span> <span data-ttu-id="f89d4-166">参照カウントで管理される Windows ランタイム オブジェクトを作成するには、**new** ではなく **ref new** を使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-166">Use **ref new** instead of **new** to create reference-counted Windows Runtime objects.</span></span> <span data-ttu-id="f89d4-167">詳しくは、「[型システム (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-167">For more info, see [Type System (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f89d4-168">**^** と **ref new** は、Windows ランタイム オブジェクトを作成するときと Windows ランタイム コンポーネントを作成するとき以外は使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-168">You only have to use **^** and **ref new** when you create Windows Runtime objects or create Windows Runtime components.</span></span> <span data-ttu-id="f89d4-169">Windows ランタイムを使わないコア アプリケーション コードを作成する際は、標準の C++ 構文を使うことができます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-169">You can use the standard C++ syntax when you write core application code that does not use the Windows Runtime.</span></span>

<span data-ttu-id="f89d4-170">Marble Maze は、ヒープに割り当てられたオブジェクトを **^** と **Microsoft::WRL::ComPtr** を使って管理し、メモリ リークを最小限に抑えます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-170">Marble Maze uses **^** together with **Microsoft::WRL::ComPtr** to manage heap-allocated objects and minimize memory leaks.</span></span> <span data-ttu-id="f89d4-171">使用することをお勧めします ^ 有効期間を管理、Windows ランタイム変数の**ComPtr** (など、使用する場合 DirectX)、COM 変数と**std::shared\_ptr**または他のすべての有効期間を管理する**std::unique\_ptr**の有効期間を管理するにはヒープ割り当て C++ オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f89d4-171">We recommend that you use ^ to manage the lifetime of Windows Runtime variables, **ComPtr** to manage the lifetime of COM variables (such as when you use DirectX), and **std::shared\_ptr** or **std::unique\_ptr** to manage the lifetime of all other heap-allocated C++ objects.</span></span>

 

<span data-ttu-id="f89d4-172">C++ UWP アプリで使える言語拡張機能について詳しくは、「[Visual C++ 言語のリファレンス (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh699871)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-172">For more info about the language extensions that are available to a C++ UWP app, see [Visual C++ Language Reference (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh699871).</span></span>

###  <a name="error-handling"></a><span data-ttu-id="f89d4-173">エラー処理</span><span class="sxs-lookup"><span data-stu-id="f89d4-173">Error handling</span></span>

<span data-ttu-id="f89d4-174">Marble Maze では、予期しないエラーに対応する主な方法として例外処理を使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-174">Marble Maze uses exception handling as the primary way to deal with unexpected errors.</span></span> <span data-ttu-id="f89d4-175">ゲーム コードでは従来、エラーを示すためにログやエラー コード (**HRESULT** 値など) を使ってきましたが、例外処理には 2 つの主な利点があります。</span><span class="sxs-lookup"><span data-stu-id="f89d4-175">Although game code traditionally uses logging or error codes, such as **HRESULT** values, to indicate errors, exception handling has two main advantages.</span></span> <span data-ttu-id="f89d4-176">1 つ目は、コードが読みやすく、保守しやすいことです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-176">First, it can make the code easier to read and maintain.</span></span> <span data-ttu-id="f89d4-177">コードの観点からは、例外処理はエラー処理ルーティンに効率よくエラーを伝達することができます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-177">From a code perspective, exception handling is a more efficient way to propagate an error to a routine that can handle that error.</span></span> <span data-ttu-id="f89d4-178">エラー コードを使った場合は通常、個々の関数で明示的にエラーを伝達する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f89d4-178">The use of error codes typically requires each function to explicitly propagate errors.</span></span> <span data-ttu-id="f89d4-179">2 つ目の利点は、例外が発生したところで中断するように Visual Studio デバッガーを構成すれば、エラーが発生したときに、その位置やコンテキストですぐに止めることができることです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-179">A second advantage is that you can configure the Visual Studio debugger to break when an exception occurs so that you can stop immediately at the location and context of the error.</span></span> <span data-ttu-id="f89d4-180">例外処理は、Windows ランタイムでも広く使われています。</span><span class="sxs-lookup"><span data-stu-id="f89d4-180">The Windows Runtime also uses exception handling extensively.</span></span> <span data-ttu-id="f89d4-181">したがって、自分のコード内で例外処理を使うことにより、あらゆるエラー処理を 1 つのモデルに統合することができます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-181">Therefore, by using exception handling in your code, you can combine all error handling into one model.</span></span>

<span data-ttu-id="f89d4-182">エラー処理モデルでは、次の規則を使うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-182">We recommend that you use the following conventions in your error handling model:</span></span>

-   <span data-ttu-id="f89d4-183">例外は、予期しないエラーを知らせるために使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-183">Use exceptions to communicate unexpected errors.</span></span>
-   <span data-ttu-id="f89d4-184">コードのフローを制御するためには、例外を使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-184">Do not use exceptions to control the flow of code.</span></span>
-   <span data-ttu-id="f89d4-185">キャッチする例外は安全に処理、回復できるものだけにしてください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-185">Catch only the exceptions that you can safely handle and recover from.</span></span> <span data-ttu-id="f89d4-186">それ以外の例外はキャッチせず、アプリを強制終了させます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-186">Otherwise, do not catch the exception and allow the app to terminate.</span></span>
-   <span data-ttu-id="f89d4-187">**HRESULT** を返す DirectX ルーチンを呼び出す場合は、**DX::ThrowIfFailed** 関数を使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-187">When you call a DirectX routine that returns **HRESULT**, use the **DX::ThrowIfFailed** function.</span></span> <span data-ttu-id="f89d4-188">この関数は、 [DirectXHelper.h](https://github.com/Microsoft/Windows-appsample-marble-maze/blob/master/C%2B%2B/Shared/DirectXHelper.h)で定義されます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-188">This function is defined in [DirectXHelper.h](https://github.com/Microsoft/Windows-appsample-marble-maze/blob/master/C%2B%2B/Shared/DirectXHelper.h).</span></span> <span data-ttu-id="f89d4-189">**ThrowIfFailed**提供されている**HRESULT**エラー コードは、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-189">**ThrowIfFailed** throws an exception if the provided **HRESULT** is an error code.</span></span> <span data-ttu-id="f89d4-190">たとえば、**E\_POINTER** では **ThrowIfFailed** が [Platform::NullReferenceException](https://msdn.microsoft.com/library/windows/apps/hh755823.aspx) をスローします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-190">For example, **E\_POINTER** causes **ThrowIfFailed** to throw [Platform::NullReferenceException](https://msdn.microsoft.com/library/windows/apps/hh755823.aspx).</span></span>

    <span data-ttu-id="f89d4-191">**ThrowIfFailed** を使うときは、次の例に示すように DirectX 呼び出しを別の行に記述して、コードが読みやすくなるようにします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-191">When you use **ThrowIfFailed**, put the DirectX call on a separate line to help improve code readability, as shown in the following example.</span></span>

    ```cpp
    // Identify the physical adapter (GPU or card) this device is running on.
    ComPtr<IDXGIAdapter> dxgiAdapter;
    DX::ThrowIfFailed(
        dxgiDevice->GetAdapter(&dxgiAdapter)
        );
    ```

-   <span data-ttu-id="f89d4-192">予期しないエラーの**HRESULT**の使用を避けることをお勧めしますが、コードのフローを制御する例外処理の使用を回避するためにさらに重要ながします。</span><span class="sxs-lookup"><span data-stu-id="f89d4-192">Although we recommend that you avoid the use of **HRESULT** for unexpected errors, it is more important to avoid the use of exception handling to control the flow of code.</span></span> <span data-ttu-id="f89d4-193">そのため、コードのフローを制御するために必要な場合は、**HRESULT** 戻り値を使う方が適切です。</span><span class="sxs-lookup"><span data-stu-id="f89d4-193">Therefore, it is preferred to use an **HRESULT** return value when necessary to control the flow of code.</span></span>

###  <a name="sal-annotations"></a><span data-ttu-id="f89d4-194">SAL 注釈</span><span class="sxs-lookup"><span data-stu-id="f89d4-194">SAL annotations</span></span>

<span data-ttu-id="f89d4-195">アプリのエラーの発見に役立てるために、コード分析ツールと共に SAL 注釈を使います。</span><span class="sxs-lookup"><span data-stu-id="f89d4-195">Use SAL annotations together with code analysis tools to help discover errors in your app.</span></span>

<span data-ttu-id="f89d4-196">Microsoft Source-code Annotation Language (SAL) を使うと、関数がパラメーターをどのように使うかを説明する注を付けることができます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-196">By using Microsoft source-code annotation language (SAL), you can annotate, or describe, how a function uses its parameters.</span></span> <span data-ttu-id="f89d4-197">SAL 注釈は、戻り値についても説明します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-197">SAL annotations also describe return values.</span></span> <span data-ttu-id="f89d4-198">SAL 注釈を C/C++ コード分析ツールと共に使うと、C や C++ ソース コードの潜在的な不具合を検出できます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-198">SAL annotations work with the C/C++ Code Analysis tool to discover possible defects in C and C++ source code.</span></span> <span data-ttu-id="f89d4-199">ツールによって報告される一般的なコーディング エラーは、バッファー オーバーラン、初期化されていないメモリ、null ポインターの逆参照、メモリとリソースのリークなどです。</span><span class="sxs-lookup"><span data-stu-id="f89d4-199">Common coding errors reported by the tool include buffer overruns, uninitialized memory, null pointer dereferences, and memory and resource leaks.</span></span>

<span data-ttu-id="f89d4-200">[BasicLoader.h](https://github.com/Microsoft/Windows-appsample-marble-maze/blob/e62d68a85499e208d591d2caefbd9df62af86809/C%2B%2B/Shared/BasicLoader.h)で宣言されている**basicloader::loadmesh**メソッドを検討してください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-200">Consider the **BasicLoader::LoadMesh** method, which is declared in [BasicLoader.h](https://github.com/Microsoft/Windows-appsample-marble-maze/blob/e62d68a85499e208d591d2caefbd9df62af86809/C%2B%2B/Shared/BasicLoader.h).</span></span> <span data-ttu-id="f89d4-201">このメソッドを使用して`_In_`*ファイル名*には、入力パラメーターを指定する (とそのためからのみ読み取られます)、 `_Out_` *筆者*と*indexBuffer*が出力パラメーターを指定する (とそのためのみに書き込まれます)`_Out_opt_` *vertexCount*と*indexCount*は省略可能なことを指定する出力パラメーター (とに書き込まれる可能性があります)。</span><span class="sxs-lookup"><span data-stu-id="f89d4-201">This method uses `_In_` to specify that *filename* is an input parameter (and therefore will only be read from), `_Out_` to specify that *vertexBuffer* and *indexBuffer* are output parameters (and therefore will only be written to), and `_Out_opt_` to specify that *vertexCount* and *indexCount* are optional output parameters (and might be written to).</span></span> <span data-ttu-id="f89d4-202">*vertexCount* と *indexCount* は省略可能な出力パラメーターであるため、**nullptr** にすることができます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-202">Because *vertexCount* and *indexCount* are optional output parameters, they are allowed to be **nullptr**.</span></span> <span data-ttu-id="f89d4-203">C/C++ コード分析ツールは、このメソッドの呼び出しを調べて、渡されるパラメーターが条件を満たしていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-203">The C/C++ Code Analysis tool examines calls to this method to ensure that the parameters it passes meet these criteria.</span></span>

```cpp
void LoadMesh(
    _In_ Platform::String^ filename,
    _Out_ ID3D11Buffer** vertexBuffer,
    _Out_ ID3D11Buffer** indexBuffer,
    _Out_opt_ uint32* vertexCount,
    _Out_opt_ uint32* indexCount
    );
```

<span data-ttu-id="f89d4-204">メニュー バーで、アプリのコード分析を実行するには選択**ビルド > ソリューションでコード分析を実行**します。</span><span class="sxs-lookup"><span data-stu-id="f89d4-204">To perform code analysis on your app, on the menu bar, choose **Build > Run Code Analysis on Solution**.</span></span> <span data-ttu-id="f89d4-205">コード分析について詳しくは、「[コード分析による C/C++ コード品質の分析](https://docs.microsoft.com/visualstudio/code-quality/analyzing-c-cpp-code-quality-by-using-code-analysis)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-205">For more info about code analysis, see [Analyzing C/C++ Code Quality by Using Code Analysis](https://docs.microsoft.com/visualstudio/code-quality/analyzing-c-cpp-code-quality-by-using-code-analysis).</span></span>

<span data-ttu-id="f89d4-206">利用できる注釈の完全なリストは、sal.h で定義されています。</span><span class="sxs-lookup"><span data-stu-id="f89d4-206">The complete list of available annotations is defined in sal.h.</span></span> <span data-ttu-id="f89d4-207">詳しくは、「[SAL 注釈](https://docs.microsoft.com/cpp/c-runtime-library/sal-annotations)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f89d4-207">For more info, see [SAL Annotations](https://docs.microsoft.com/cpp/c-runtime-library/sal-annotations).</span></span>

## <a name="next-steps"></a><span data-ttu-id="f89d4-208">次の手順</span><span class="sxs-lookup"><span data-stu-id="f89d4-208">Next steps</span></span>


<span data-ttu-id="f89d4-209">Marble Maze アプリケーション コードの構造と、DirectX UWP アプリの構造と従来のデスクトップ アプリケーションの構造の違いについての情報を、「[Marble Maze のアプリケーション構造](marble-maze-application-structure.md)」で読みます。</span><span class="sxs-lookup"><span data-stu-id="f89d4-209">Read [Marble Maze application structure](marble-maze-application-structure.md) for information about how the Marble Maze application code is structured and how the structure of a DirectX UWP app differs from that of a traditional desktop application.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f89d4-210">関連トピック</span><span class="sxs-lookup"><span data-stu-id="f89d4-210">Related topics</span></span>


* [<span data-ttu-id="f89d4-211">Marble Maze のアプリケーション構造</span><span class="sxs-lookup"><span data-stu-id="f89d4-211">Marble Maze application structure</span></span>](marble-maze-application-structure.md)
* [<span data-ttu-id="f89d4-212">Marble Maze、C++ と DirectX での UWP ゲームの開発</span><span class="sxs-lookup"><span data-stu-id="f89d4-212">Developing Marble Maze, a UWP game in C++ and DirectX</span></span>](developing-marble-maze-a-windows-store-game-in-cpp-and-directx.md)

 

 




