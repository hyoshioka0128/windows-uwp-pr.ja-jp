---
title: 非同期プログラミング (DirectX と C++)
description: このトピックでは、DirectX で非同期プログラミングやスレッディングを使う際のさまざまな考慮事項について取り上げます。
ms.assetid: 17613cd3-1d9d-8d2f-1b8d-9f8d31faaa6b
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10、UWP、ゲーム、非同期プログラミング、DirectX
ms.localizationpriority: medium
ms.openlocfilehash: 8551a49512d4b17ab1bab704596d9e5389de3eb6
ms.sourcegitcommit: a3dc929858415b933943bba5aa7487ffa721899f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/07/2018
ms.locfileid: "8780440"
---
# <a name="asynchronous-programming-directx-and-c"></a><span data-ttu-id="84eb7-104">非同期プログラミング (DirectX と C++)</span><span class="sxs-lookup"><span data-stu-id="84eb7-104">Asynchronous programming (DirectX and C++)</span></span>



<span data-ttu-id="84eb7-105">このトピックでは、DirectX で非同期プログラミングやスレッディングを使う際のさまざまな考慮事項について取り上げます。</span><span class="sxs-lookup"><span data-stu-id="84eb7-105">This topic covers various points to consider when you are using asynchronous programming and threading with DirectX.</span></span>

## <a name="async-programming-and-directx"></a><span data-ttu-id="84eb7-106">非同期プログラミングと DirectX</span><span class="sxs-lookup"><span data-stu-id="84eb7-106">Async programming and DirectX</span></span>


<span data-ttu-id="84eb7-107">DirectX の学習経験や使用経験にかかわらず、グラフィックス処理パイプラインはすべてシングル スレッドで実行することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="84eb7-107">If you're just learning about DirectX, or even if you're experienced with it, consider putting all your graphics processing pipeline on one thread.</span></span> <span data-ttu-id="84eb7-108">ゲーム内のシーンには、排他的アクセスを必要とするリソースがいたるところに使われています。ビットマップやシェーダーといった各種アセットはその代表的な例です。</span><span class="sxs-lookup"><span data-stu-id="84eb7-108">In any given scene in a game, there are common resources such as bitmaps, shaders, and other assets that require exclusive access.</span></span> <span data-ttu-id="84eb7-109">しかも、これらのリソースへのアクセスは、並列スレッド間ですべて同期させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="84eb7-109">These same resources require that you synchronize any access to these resources across the parallel threads.</span></span> <span data-ttu-id="84eb7-110">レンダリングは、複数のスレッドで並列化することの難しい処理です。</span><span class="sxs-lookup"><span data-stu-id="84eb7-110">Rendering is a difficult process to parallelize across multiple threads.</span></span>

<span data-ttu-id="84eb7-111">しかし、ゲームの構造に十分な複合性がある場合や、ゲームのパフォーマンスを強化する必要性がある場合、レンダリング パイプラインに直接関係しない一部のコンポーネントを非同期プログラミングによって並列化することは可能です。</span><span class="sxs-lookup"><span data-stu-id="84eb7-111">However, if your game is sufficiently complex, or if you are looking to get improved performance, you can use asynchronous programming to parallelize some of the components that are not specific to your rendering pipeline.</span></span> <span data-ttu-id="84eb7-112">最近のハードウェアは、マルチ コアとハイパースレッディングに対応した CPU を搭載しているので、ぜひそれを活かしましょう。</span><span class="sxs-lookup"><span data-stu-id="84eb7-112">Modern hardware features multiple core and hyperthreaded CPUs, and your app should take advantage of this!</span></span> <span data-ttu-id="84eb7-113">その確実な方法は、ゲームのコンポーネントのうち、Direct3D のデバイス コンテキストに直接アクセスする必要のないコンポーネントに非同期プログラミングを適用することです。たとえば、次のようなコンポーネントが該当します。</span><span class="sxs-lookup"><span data-stu-id="84eb7-113">You can ensure this by using asynchronous programming for some of the components of your game that don't need direct access to the Direct3D device context, such as:</span></span>

-   <span data-ttu-id="84eb7-114">ファイル I/O</span><span class="sxs-lookup"><span data-stu-id="84eb7-114">file I/O</span></span>
-   <span data-ttu-id="84eb7-115">物理</span><span class="sxs-lookup"><span data-stu-id="84eb7-115">physics</span></span>
-   <span data-ttu-id="84eb7-116">AI</span><span class="sxs-lookup"><span data-stu-id="84eb7-116">AI</span></span>
-   <span data-ttu-id="84eb7-117">ネットワーク</span><span class="sxs-lookup"><span data-stu-id="84eb7-117">networking</span></span>
-   <span data-ttu-id="84eb7-118">オーディオ</span><span class="sxs-lookup"><span data-stu-id="84eb7-118">audio</span></span>
-   <span data-ttu-id="84eb7-119">コントロール</span><span class="sxs-lookup"><span data-stu-id="84eb7-119">controls</span></span>
-   <span data-ttu-id="84eb7-120">XAML ベースの UI コンポーネント</span><span class="sxs-lookup"><span data-stu-id="84eb7-120">XAML-based UI components</span></span>

<span data-ttu-id="84eb7-121">こうしたコンポーネントについては、複数の同時実行スレッド上で処理することができます。</span><span class="sxs-lookup"><span data-stu-id="84eb7-121">Your app can handle these components on multiple concurrent threads.</span></span> <span data-ttu-id="84eb7-122">ファイル I/O (特にアセットの読み込み) を非同期で行うと、数メガバイトや数百メガバイトのアセットを読み込んだりストリーミングしたりしている間も、ゲームやアプリのインターフェイスを操作できるようになるため、マルチ スレッド化には非常に大きな意義があります。</span><span class="sxs-lookup"><span data-stu-id="84eb7-122">File I/O, especially asset loading, benefits greatly from asynchronous loading, because your game or app can be in an interactive state while several (or several hundred) megabytes of assets are being loaded or streamed.</span></span> <span data-ttu-id="84eb7-123">これらのスレッドは、[並列パターン ライブラリ](https://msdn.microsoft.com/library/dd492418.aspx) と **task** パターン (PPLTasks.h に定義されている **concurrency** 名前空間) を使って作成、管理するのが最も簡単です。</span><span class="sxs-lookup"><span data-stu-id="84eb7-123">The easiest way to create and manage these threads is by using the [Parallel Patterns Library](https://msdn.microsoft.com/library/dd492418.aspx) and the **task** pattern, as contained in the **concurrency** namespace defined in PPLTasks.h.</span></span> <span data-ttu-id="84eb7-124">[並列パターン ライブラリ](https://msdn.microsoft.com/library/dd492418.aspx) は、マルチ コアとハイパースレッディングに対応した CPU の利点をダイレクトに引き出し、体感的な読み込み時間から、CPU 計算やネットワーク処理の集中に伴う滞りや遅延にいたるまで、さまざまな側面を向上させます。</span><span class="sxs-lookup"><span data-stu-id="84eb7-124">Using the [Parallel Patterns Library](https://msdn.microsoft.com/library/dd492418.aspx) takes direct advantage of multiple core and hyperthreaded CPUs, and can improve everything from perceived load times to the hitches and lags that come with intensive CPU calculations or network processing.</span></span>

> <span data-ttu-id="84eb7-125">**注:** 完全にシングル スレッド アパートメント (STA) で、ユニバーサル Windows プラットフォーム (UWP) アプリ、ユーザー インターフェイスが実行されます。</span><span class="sxs-lookup"><span data-stu-id="84eb7-125">**Note** In a Universal Windows Platform (UWP) app, the user interface runs entirely in a single-threaded apartment (STA).</span></span> <span data-ttu-id="84eb7-126">DirectX ゲーム用の UI を [XAML の相互運用機能](directx-and-xaml-interop.md) を使って作成する場合、そのコントロールには、STA を使ってのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="84eb7-126">If you are creating a UI for your DirectX game using [XAML interop](directx-and-xaml-interop.md), you can only access the controls by using the STA.</span></span>

 

## <a name="multithreading-with-direct3d-devices"></a><span data-ttu-id="84eb7-127">Direct3D デバイスでのマルチスレッド化</span><span class="sxs-lookup"><span data-stu-id="84eb7-127">Multithreading with Direct3D devices</span></span>


<span data-ttu-id="84eb7-128">デバイス コンテキストのマルチスレッド化は、Direct3D 機能レベル 11\_0 以上をサポートするグラフィックス デバイスでしか利用できません。</span><span class="sxs-lookup"><span data-stu-id="84eb7-128">Multithreading for device contexts is only available on graphics devices that support a Direct3D feature level of 11\_0 or higher.</span></span> <span data-ttu-id="84eb7-129">しかし、ゲーム専用機など、数多くのプラットフォームに搭載されている強力な GPU は最大限に活用したいものです。</span><span class="sxs-lookup"><span data-stu-id="84eb7-129">However, you might want to maximize the use of the powerful GPU in many platforms, such as dedicated gaming platforms.</span></span> <span data-ttu-id="84eb7-130">たとえば、単純なケースでは、ヘッドアップ ディスプレイ (HUD) オーバーレイのレンダリングを 3D シーンのレンダリングとプロジェクションから切り離し、2 つのコンポーネントに独立した並列パイプラインを割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="84eb7-130">In the simplest case, you might want to separate the rendering of a heads-up display (HUD) overlay from the 3D scene rendering and projection and have both components use separate parallel pipelines.</span></span> <span data-ttu-id="84eb7-131">どちらのスレッドも、同じ [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) を使ってリソース オブジェクト (テクスチャ、メッシュ、シェーダーなど、各種アセット) を作成、管理する必要がありますが、ID3D11DeviceContext はシングル スレッドであり、安全にアクセスするには何らかの同期機構 (クリティカル セクションなど) を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="84eb7-131">Both threads must use the same [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) to create and manage the resource objects (the textures, meshes, shaders, and other assets), though, which is single-threaded, and which requires that you implement some sort of synchronization mechanism (such as critical sections) to access it safely.</span></span> <span data-ttu-id="84eb7-132">また、異なるスレッドのデバイス コンテキストに対し、(遅延レンダリング用の) 別々のコマンド リストを作成している間、これらのコマンド リストを同じ **ID3D11DeviceContext** インスタンスで同時に再生することはできません。</span><span class="sxs-lookup"><span data-stu-id="84eb7-132">And, while you can create separate command lists for the device context on different threads (for deferred rendering), you cannot play those command lists back simultaneously on the same **ID3D11DeviceContext** instance.</span></span>

<span data-ttu-id="84eb7-133">現在では、スレッド セーフな [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) を使ってリソース オブジェクトを作成することもできるようになりました。</span><span class="sxs-lookup"><span data-stu-id="84eb7-133">Now, your app can also use [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379), which is safe for multithreading, to create resource objects.</span></span> <span data-ttu-id="84eb7-134">このような状況であれば、**ID3D11DeviceContext** は使わず、常に [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476385) を使えばよいのではないでしょうか。</span><span class="sxs-lookup"><span data-stu-id="84eb7-134">So, why not always use **ID3D11Device** instead of [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)?</span></span> <span data-ttu-id="84eb7-135">現時点では、一部のグラフィックス インターフェイスで、ドライバーがマルチスレッドをサポートしていない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="84eb7-135">Well, currently, driver support for multithreading might not be available for some graphics interfaces.</span></span> <span data-ttu-id="84eb7-136">デバイスに対して問い合わせを行い、マルチスレッドをサポートしているかどうかを調べることもできますが、幅広いユーザーを対象とするために、あえてシングル スレッドの **ID3D11DeviceContext** を使って、リソース オブジェクトを管理する場合があります。</span><span class="sxs-lookup"><span data-stu-id="84eb7-136">You can query the device and find out if it does support multithreading, but if you are looking to reach the broadest audience, you might stick with single-threaded **ID3D11DeviceContext** for resource object management.</span></span> <span data-ttu-id="84eb7-137">もっとも、グラフィックス デバイス ドライバーがマルチスレッドやコマンド リストをサポートしていない場合、Direct3D 11 は、デバイス コンテキストへの同期アクセスを内部的に処理することを試み、コマンド リストがサポートされていなかった場合は、ソフトウェアによって実装された同等の機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="84eb7-137">That said, when the graphics device driver doesn't support multithreading or command lists, Direct3D 11 attempts to handle synchronized access to the device context internally; and if command lists are not supported, it provides a software implementation.</span></span> <span data-ttu-id="84eb7-138">結果として、プラットフォームのグラフィックス インターフェイスについて、デバイス コンテキストへのマルチスレッド アクセスをドライバーがサポートしていない場合でもきちんと動作するマルチスレッド対応のコードを作成することが可能です。</span><span class="sxs-lookup"><span data-stu-id="84eb7-138">As a result, you can write multithreaded code that will run on platforms with graphics interfaces that lack driver support for multithreaded device context access.</span></span>

<span data-ttu-id="84eb7-139">開発しているアプリが、コマンド リストの処理用とフレームの表示用に別々のスレッドをサポートする場合、GPU はアクティブにしておきましょう。体感的な引っかかりや遅延を生じることなく適切なタイミングでフレームを表示すると共に、コマンド リストを処理することができます。</span><span class="sxs-lookup"><span data-stu-id="84eb7-139">If your app supports separate threads for processing command lists and for displaying frames, you probably want to keep the GPU active, processing the command lists while displaying frames in a timely fashion without perceptible stutter or lag.</span></span> <span data-ttu-id="84eb7-140">この場合、スレッドごとに別個の [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) を使い、D3D11\_RESOURCE\_MISC\_SHARED フラグを使ってリソース作成することによって、リソース (テクスチャなど) を共有します。</span><span class="sxs-lookup"><span data-stu-id="84eb7-140">In this case, you could use a separate [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) for each thread, and to share resources (like textures) by creating them with the D3D11\_RESOURCE\_MISC\_SHARED flag.</span></span> <span data-ttu-id="84eb7-141">このシナリオでは、処理用のスレッドで [**ID3D11DeviceContext::Flush**](https://msdn.microsoft.com/library/windows/desktop/ff476425) を呼び出し、コマンド リストの実行を完了してから、表示用のスレッドで、リソース オブジェクトの処理結果を表示する必要があります。</span><span class="sxs-lookup"><span data-stu-id="84eb7-141">In this scenario, [**ID3D11DeviceContext::Flush**](https://msdn.microsoft.com/library/windows/desktop/ff476425) must be called on the processing thread to complete the execution of the command list prior to displaying the results of processing the resource object in the display thread.</span></span>

## <a name="deferred-rendering"></a><span data-ttu-id="84eb7-142">遅延レンダリング</span><span class="sxs-lookup"><span data-stu-id="84eb7-142">Deferred rendering</span></span>


<span data-ttu-id="84eb7-143">遅延レンダリングは、グラフィックス コマンドを後から再生できるようにコマンド リストに記録するもので、一方のスレッドでレンダリングを行いながら、別のスレッドで、レンダリングに使うコマンドを記録するしくみになっています。</span><span class="sxs-lookup"><span data-stu-id="84eb7-143">Deferred rendering records graphics commands in a command list so that they can be played back at some other time, and is designed to support rendering on one thread while recording commands for rendering on additional threads.</span></span> <span data-ttu-id="84eb7-144">必要なコマンドがすべて揃った後、最終的な表示オブジェクト (フレーム バッファー、テクスチャなどのグラフィックス出力) を生成したスレッド上で、それらのコマンドを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="84eb7-144">After these commands are completed, they can be executed on the thread that generates the final display object (frame buffer, texture, or other graphics output).</span></span>

<span data-ttu-id="84eb7-145">遅延コンテキストは、(イミディエイト コンテキストを作成する) [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) や [**D3D11CreateDeviceAndSwapChain**](https://msdn.microsoft.com/library/windows/desktop/ff476083) ではなく、[**ID3D11Device::CreateDeferredContext**](https://msdn.microsoft.com/library/windows/desktop/ff476505) を使って作成します。</span><span class="sxs-lookup"><span data-stu-id="84eb7-145">Create a deferred context using [**ID3D11Device::CreateDeferredContext**](https://msdn.microsoft.com/library/windows/desktop/ff476505) (instead of [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) or [**D3D11CreateDeviceAndSwapChain**](https://msdn.microsoft.com/library/windows/desktop/ff476083), which create an immediate context).</span></span> <span data-ttu-id="84eb7-146">詳しくは、「[イミディエイト レンダリングおよびディファード レンダリング](https://msdn.microsoft.com/library/windows/desktop/ff476892)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="84eb7-146">For more info, see [Immediate and Deferred Rendering](https://msdn.microsoft.com/library/windows/desktop/ff476892).</span></span>

## <a name="related-topics"></a><span data-ttu-id="84eb7-147">関連トピック</span><span class="sxs-lookup"><span data-stu-id="84eb7-147">Related topics</span></span>


* [<span data-ttu-id="84eb7-148">Direct3D 11 でのマルチスレッドの概要</span><span class="sxs-lookup"><span data-stu-id="84eb7-148">Introduction to Multithreading in Direct3D 11</span></span>](https://msdn.microsoft.com/library/windows/desktop/ff476891)

 

 




