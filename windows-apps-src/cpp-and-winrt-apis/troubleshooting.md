---
description: このトピックにある現象のトラブルシューティングおよび対処法に関する表は、新しいコードを作成しているか既存のアプリを移植しているかにはかかわらず役立つ可能性があります。
title: C++/WinRT に関する問題のトラブルシューティング
ms.date: 05/07/2018
ms.topic: article
keywords: Windows 10、uwp、標準、c++、cpp、winrt、プロジェクション、トラブルシューティング、HRESULT、エラー
ms.localizationpriority: medium
ms.openlocfilehash: 3158c257738e68d74feefda99a9171d25a63fdde
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2019
ms.locfileid: "57606327"
---
# <a name="troubleshooting-cwinrt-issues"></a><span data-ttu-id="2bad2-104">C++/WinRT に関する問題のトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="2bad2-104">Troubleshooting C++/WinRT issues</span></span>

> [!NOTE]
> <span data-ttu-id="2bad2-105">インストールと使用について、 [C +/cli WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) Visual Studio Extension (VSIX) (プロジェクト テンプレートのサポートを提供します) を参照してください[Visual Studio のサポートを c++/cli WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)。</span><span class="sxs-lookup"><span data-stu-id="2bad2-105">For info about installing and using the [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) Visual Studio Extension (VSIX) (which provides project template support) see [Visual Studio support for C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).</span></span>

<span data-ttu-id="2bad2-106">このトピックは、すぐに認識していただくための先行情報です。まだ必要としていない場合も同様です。</span><span class="sxs-lookup"><span data-stu-id="2bad2-106">This topic is up front so that you're aware of it right away; even if you don't need it yet.</span></span> <span data-ttu-id="2bad2-107">以下の症状のトラブルシューティングおよび対処法に関する表は、新しいコードを作成しているか既存のアプリを移植しているかにはかかわらず役立つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-107">The table of troubleshooting symptoms and remedies below may be helpful to you whether you're cutting new code or porting an existing app.</span></span> <span data-ttu-id="2bad2-108">移植中であり、進展させてプロジェクトのビルドおよび実行の段階に達することを急いでいる場合は、問題を引き起こしている重要でないコードにコメントアウトまたはスタブ挿入を適用して、一時的に進展させることができます。その後、元に戻ってその借りを解消することになります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-108">If you're porting, and you're eager to forge ahead and get to the stage where your project builds and runs, then you can make temporary progress by commenting or stubbing out any non-essential code that's causing issues, and then returning to pay off that debt later.</span></span>

<span data-ttu-id="2bad2-109">よく寄せられる質問の一覧は、次を参照してください。[よく寄せられる質問](faq.md)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-109">For a list of frequently-asked questions, see [Frequently-asked questions](faq.md).</span></span>

## <a name="tracking-down-xaml-issues"></a><span data-ttu-id="2bad2-110">XAML に関する問題の検出</span><span class="sxs-lookup"><span data-stu-id="2bad2-110">Tracking down XAML issues</span></span>
<span data-ttu-id="2bad2-111">XAML 解析例外は診断が難しい場合があります。特に、わかりやすいエラー メッセージが例外に含まれていない場合は、診断が難しくなります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-111">XAML parse exceptions can be difficult to diagnose&mdash;particularly if there are no meaningful error messages within the exception.</span></span> <span data-ttu-id="2bad2-112">デバッガーが初回例外をキャッチするように構成されていることを確してください (早い段階で解析例外のキャッチを試行するため)。</span><span class="sxs-lookup"><span data-stu-id="2bad2-112">Make sure that the debugger is configured to catch first-chance exceptions (to try and catch the parsing exception early on).</span></span> <span data-ttu-id="2bad2-113">デバッガーで例外変数を調べて、HRESULT やメッセージ内に役立つ情報が含まれているかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="2bad2-113">You may be able to inspect the exception variable in the debugger to determine whether the HRESULT or message has any useful information.</span></span> <span data-ttu-id="2bad2-114">また、XAML パーサーを使って、Visual Studio の出力ウィンドウを調べ、エラー メッセージの出力を確認することもできます。</span><span class="sxs-lookup"><span data-stu-id="2bad2-114">Also, check Visual Studio's output window for error messages output by the XAML parser.</span></span>

<span data-ttu-id="2bad2-115">アプリが終了し、XAML マークアップの解析中に処理不能な例外がスローされたことのみがわかっている場合、存在しないリソースへの (キーによる) 参照の結果である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-115">If your app terminates and all you know is that an unhandled exception was thrown during XAML markup parsing, then that could be the result of a reference (by key) to a missing resource.</span></span> <span data-ttu-id="2bad2-116">または、UserControl、カスタム コントロール、カスタム レイアウト パネルの内部で例外がスローされたことも考えられます。</span><span class="sxs-lookup"><span data-stu-id="2bad2-116">Or, it could be an exception thrown inside a UserControl, a custom control, or a custom layout panel.</span></span> <span data-ttu-id="2bad2-117">最終手段として、バイナリ分割を使うことができます。</span><span class="sxs-lookup"><span data-stu-id="2bad2-117">A last resort is a binary split.</span></span> <span data-ttu-id="2bad2-118">XAML ページからマークアップのおよそ半分を削除し、アプリを再実行します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-118">Remove about half of the markup from a XAML Page and re-run the app.</span></span> <span data-ttu-id="2bad2-119">これによって、エラーが削除した半分で発生しているか (いずれの場合でも、削除した部分はここで元に戻す必要があります)、または削除しなかった半分で発生しているかがわかります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-119">You will then know whether the error is somewhere inside the half you removed (which you should now restore in any case) or in the half you did not remove.</span></span> <span data-ttu-id="2bad2-120">問題が特定されるまで、エラーを含む半分をさらに分割するプロセスを繰り返します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-120">Repeat the process by splitting the half that contains the error, and so on, until you've zeroed in on the issue.</span></span>

## <a name="symptoms-and-remedies"></a><span data-ttu-id="2bad2-121">現象と対処法</span><span class="sxs-lookup"><span data-stu-id="2bad2-121">Symptoms and remedies</span></span>
| <span data-ttu-id="2bad2-122">現象</span><span class="sxs-lookup"><span data-stu-id="2bad2-122">Symptom</span></span> | <span data-ttu-id="2bad2-123">対処法</span><span class="sxs-lookup"><span data-stu-id="2bad2-123">Remedy</span></span> |
|---------|--------|
| <span data-ttu-id="2bad2-124">実行時に REGDB_E_CLASSNOTREGISTERED の HRESULT 値で例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="2bad2-124">An exception is thrown at runtime with a HRESULT value of REGDB_E_CLASSNOTREGISTERED.</span></span> | <span data-ttu-id="2bad2-125">このエラーの原因の 1 つは、Windows ランタイム コンポーネントを読み込むことができないことです。</span><span class="sxs-lookup"><span data-stu-id="2bad2-125">One cause of this error is that your Windows Runtime Component can't be loaded.</span></span> <span data-ttu-id="2bad2-126">コンポーネントの Windows ランタイム メタデータ ファイル (`.winmd`) の名前がコンポーネント バイナリ (`.dll`) の名前と同じであることを確認してください。この名前は、プロジェクトの名前、およびルート名前空間の名前でもあります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-126">Make sure that the component's Windows Runtime metadata file (`.winmd`) has the same name as the component binary (the `.dll`), which is also the name of the project and the name of the root namespace.</span></span> <span data-ttu-id="2bad2-127">また、Windows ランタイム メタデータとバイナリが、ビルド プロセスによって使用中のアプリの `Appx` フォルダに正しくコピーされていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-127">Also make sure that the Windows Runtime metadata and the binary have been corectly copied by the build process to the consuming app's `Appx` folder.</span></span> <span data-ttu-id="2bad2-128">さらに、使用中のアプリの `AppxManifest.xml` (および `Appx` フォルダ内) に、アクティブ化可能なクラスとバイナリ名を正しく宣言している **&lt;InProcessServer&gt;** 要素が含まれていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-128">And confirm that the consuming app's `AppxManifest.xml` (also in the `Appx` folder) contains an **&lt;InProcessServer&gt;** element correctly declaring the activatable class and the binary name.</span></span> <span data-ttu-id="2bad2-129">このエラーは、ローカルに実装されたランタイム クラスが、プロジェクションされた型の既定のコンストラクターによって誤ってインスタンス化された場合にも発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-129">This error can also happen if you make the mistake of instantiating a locally-implemented runtime class via the projected type's default constructor.</span></span> <span data-ttu-id="2bad2-130">その場合にプロジェクションされた型を正しく使用する方法の詳細については、「[XAML コントロール、C++/WinRT プロパティへのバインド](binding-property.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-130">See [XAML controls; bind to a C++/WinRT property](binding-property.md) for more information about how to correctly use the projected type in that case.</span></span> |
| <span data-ttu-id="2bad2-131">C++ コンパイラーは、"*'implements_type': は、'&lt;プロジェクションされた型&gt;'* の直接的または間接的な基底クラスのメンバーではありません" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-131">The C++ compiler produces the error "*'implements_type': is not a member of any direct or indirect base class of '&lt;projected type&gt;'*".</span></span> | <span data-ttu-id="2bad2-132">これは、実装型 (たとえば **MyRuntimeClass**) の未修飾名前空間名を使用して、その型のヘッダーを含めずに **make** を呼び出すと発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-132">This can happen when you call **make** with the namespace-unqualified name of your implementation type (**MyRuntimeClass**, for example), and you haven't included that type's header.</span></span> <span data-ttu-id="2bad2-133">コンパイラーは、**MyRuntimeClass** をプロジェクションされた型として解釈します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-133">The compiler interprets **MyRuntimeClass** as the projected type.</span></span> <span data-ttu-id="2bad2-134">解決策は、実装型のヘッダーを含めることです (たとえば `MyRuntimeClass.h`)。</span><span class="sxs-lookup"><span data-stu-id="2bad2-134">The solution is to include the header for your implementation type (`MyRuntimeClass.h`, for example).</span></span> |
| <span data-ttu-id="2bad2-135">C++ コンパイラーが、"*削除された関数を参照しようとしています*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-135">The C++ compiler produces the error "*attempting to reference a deleted function*".</span></span> | <span data-ttu-id="2bad2-136">これは、**make** を呼び出し、テンプレート パラメーターとして渡す実装型の既定のコンストラクターが `= delete` である場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-136">This can happen when you call **make** and the implementation type that you pass as the template parameter has an `= delete` default constructor.</span></span> <span data-ttu-id="2bad2-137">実装型のヘッダー ファイルを編集し、`= delete` を `= default` に変更してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-137">Edit the implementation type's header file and change `= delete` to `= default`.</span></span> <span data-ttu-id="2bad2-138">ランタイム クラスの IDL にコンストラクターを追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="2bad2-138">You can also add a constructor into the IDL for the runtime class.</span></span> |
| <span data-ttu-id="2bad2-139">[  **INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged) を実装しましたが、XAML バインドが更新されません (そのため、UI が [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged) にサブスクライブしません)。</span><span class="sxs-lookup"><span data-stu-id="2bad2-139">You've implemented [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), but your XAML bindings are not updating (and the UI is not subscribing to [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)).</span></span> | <span data-ttu-id="2bad2-140">XAML マークアップのバインド式で必ず `Mode=OneWay` (または TwoWay) を設定してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-140">Remember to set `Mode=OneWay` (or TwoWay) on your binding expression in XAML markup.</span></span> <span data-ttu-id="2bad2-141">「[XAML コントロール: C++/WinRT プロパティへのバインド](binding-property.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-141">See [XAML controls; bind to a C++/WinRT property](binding-property.md).</span></span> |
| <span data-ttu-id="2bad2-142">XAML アイテム コントロールを監視可能なコレクションにバインドしていますが、実行時に "パラメーターが正しくありません" というメッセージで例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="2bad2-142">You're binding a XAML items control to an observable collection, and an exception is thrown at runtime with the message "The parameter is incorrect".</span></span> | <span data-ttu-id="2bad2-143">IDL および実装で、監視可能なコレクションを型 **Windows.Foundation.Collections.IVector<IInspectable>** として宣言します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-143">In your IDL and your implementation, declare any observable collection as the type **Windows.Foundation.Collections.IVector<IInspectable>**.</span></span> <span data-ttu-id="2bad2-144">ただし、**Windows.Foundation.Collections.IObservableVector<T>** を実装するオブジェクトを返します。T は要素型です。</span><span class="sxs-lookup"><span data-stu-id="2bad2-144">But return an object that implements **Windows.Foundation.Collections.IObservableVector<T>**, where T is your element type.</span></span> <span data-ttu-id="2bad2-145">「[XAML アイテム コントロール: C++/WinRT コレクションへのバインド](binding-collection.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-145">See [XAML items controls; bind to a C++/WinRT collection](binding-collection.md).</span></span>  |
| <span data-ttu-id="2bad2-146">C++ コンパイラーが、"*'MyImplementationType_base&lt;MyImplementationType&gt;': 使用可能な適切な既定コンストラクターがありません*" という形式のエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-146">The C++ compiler produces an error of the form "*'MyImplementationType_base&lt;MyImplementationType&gt;': no appropriate default constructor available*".</span></span>|<span data-ttu-id="2bad2-147">これは、非自明なコンストラクターを持つ型から派生させた場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-147">This can happen when you have derived from a type that has a non-trivial constructor.</span></span> <span data-ttu-id="2bad2-148">派生型のコンストラクターは、基本型のコンストラクターが必要とするパラメーターを渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-148">Your derived type's constructor needs to pass along the parameters that the base type's constructor needs.</span></span> <span data-ttu-id="2bad2-149">実証済みの例については、「[非自明なコンストラクタを持つ型からの派生](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-149">For a worked example, see [Deriving from a type that has a non-trivial constructor](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).</span></span>|
| <span data-ttu-id="2bad2-150">C++ コンパイラーが、"*'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' から 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* に変換できません" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-150">The C++ compiler produces the error "*cannot convert from 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".</span></span>|<span data-ttu-id="2bad2-151">これは、コレクションを予期している Windows ランタイム API に std::wstring の std::vector を渡すときに発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-151">This can happen when you pass a std::vector of std::wstring to a Windows Runtime API that expects a collection.</span></span> <span data-ttu-id="2bad2-152">詳細については、「[標準的な C++ のデータ型と C++/WinRT](std-cpp-data-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-152">For more info, see [Standard C++ data types and C++/WinRT](std-cpp-data-types.md).</span></span>|
| <span data-ttu-id="2bad2-153">C++ コンパイラーが、"*'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' から 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* に変換できません" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-153">The C++ compiler produces the error "*cannot convert from 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".</span></span>|<span data-ttu-id="2bad2-154">これは、コレクションを予期している非同期 Windows ランタイム API に winrt::hstring の std::vector を渡すときに、非同期呼び出し先へのベクトルのコピーも移動も行っていない場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-154">This can happen when you pass a std::vector of winrt::hstring to an asynchronous Windows Runtime API that expects a collection, and you've neither copied nor moved the vector to the async callee.</span></span> <span data-ttu-id="2bad2-155">詳細については、「[標準的な C++ のデータ型と C++/WinRT](std-cpp-data-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-155">For more info, see [Standard C++ data types and C++/WinRT](std-cpp-data-types.md).</span></span>|
| <span data-ttu-id="2bad2-156">プロジェクトを開くときに、Visual Studio が "*プロジェクトのアプリケーションはインストールされていません*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-156">When opening a project, Visual Studio produces the error "*The application for the project is not installed*".</span></span>|<span data-ttu-id="2bad2-157">まだ行っていない場合は、Visual Studio の **[新しいプロジェクト]** ダイアログから **C++ での開発用の Windows ユニバーサル ツール**をインストールする必要があります。</span><span class="sxs-lookup"><span data-stu-id="2bad2-157">If you haven't already, you need to install **Windows Universal tools for C++ development** from within Visual Studio's **New Project** dialog.</span></span> <span data-ttu-id="2bad2-158">問題が解決されないかどうかは、c++ に依存プロジェクト/cli WinRT Visual Studio Extension (VSIX) (を参照してください[Visual Studio のサポートの C +/cli WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-158">If that doesn't resolve the issue, then the project may depend on the C++/WinRT Visual Studio Extension (VSIX) (see [Visual Studio support for C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).</span></span>|
| <span data-ttu-id="2bad2-159">Windows アプリ認定キット テストは、いずれかのランタイム クラスのエラーを生成"*Windows の基本クラスから派生していません。すべての構成可能なクラスは、最終的に Windows 名前空間内の型から派生する必要があります*"。</span><span class="sxs-lookup"><span data-stu-id="2bad2-159">The Windows App Certification Kit tests produce an error that one of your runtime classes "*does not derive from a Windows base class. All composable classes must ultimately derive from a type in the Windows namespace*".</span></span>|<span data-ttu-id="2bad2-160">呼ばれます (つまり、アプリケーション内で宣言した) ランタイムのクラスで、基底クラスから派生した、*コンポーザブル*クラス。</span><span class="sxs-lookup"><span data-stu-id="2bad2-160">Any runtime class (that you declare in your application) that derives from a base class is known as a *composable* class.</span></span> <span data-ttu-id="2bad2-161">コンポーザブルなクラスの基本クラスは、Windows.\* 名前空間で生成された型である必要があります。たとえば、 [ **Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-161">The ultimate base class of a composable class must be a type originating in a Windows.\* namespace; for example, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject).</span></span> <span data-ttu-id="2bad2-162">参照してください[XAML コントロール; バインド C +/cli WinRT プロパティ](binding-property.md)の詳細。</span><span class="sxs-lookup"><span data-stu-id="2bad2-162">See [XAML controls; bind to a C++/WinRT property](binding-property.md) for more details.</span></span>|
| <span data-ttu-id="2bad2-163">C++ コンパイラーが、EventHandler または TypedEventHandler のデリゲート特殊化に関して "*WinRT 型である必要があります*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-163">The C++ compiler produces a "*must be WinRT type*" error for an EventHandler or TypedEventHandler delegate specialization.</span></span>|<span data-ttu-id="2bad2-164">代わりに **winrt::delegate&lt;...T&gt;** を使用することを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-164">Consider using **winrt::delegate&lt;...T&gt;** instead.</span></span> <span data-ttu-id="2bad2-165">「[C++/WinRT でのイベントの作成](author-events.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-165">See [Author events in C++/WinRT](author-events.md).</span></span>|
| <span data-ttu-id="2bad2-166">C++ コンパイラーが、Windows ランタイムの非同期操作の特殊化に関して "*WinRT 型である必要があります*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-166">The C++ compiler produces a "*must be WinRT type*" error for a Windows Runtime asynchronous operation specialization.</span></span>|<span data-ttu-id="2bad2-167">代わりに並列パターン ライブラリ (PPL) の [**task**](https://msdn.microsoft.com/library/hh750113) を返すことを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-167">Consider returning a Parallel Patterns Library (PPL) [**task**](https://msdn.microsoft.com/library/hh750113) instead.</span></span> <span data-ttu-id="2bad2-168">「[同時実行操作と非同期操作](concurrency.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-168">See [Concurrency and asynchronous operations](concurrency.md).</span></span>|
| <span data-ttu-id="2bad2-169">C++ コンパイラーが、"*エラー C2220: 警告がエラーとして扱われました - 'オブジェクト' ファイルは生成されませんでした*" を生成します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-169">The C++ compiler produces "*error C2220: warning treated as error - no 'object' file generated*".</span></span>|<span data-ttu-id="2bad2-170">警告を修正するか、設定**C/C++** > **全般** > **警告をエラーとして扱う**に**いいえ (/WX-)** します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-170">Either correct the warning, or set **C/C++** > **General** > **Treat Warnings As Errors** to **No (/WX-)**.</span></span>|
| <span data-ttu-id="2bad2-171">オブジェクトが破棄された後で C++/WinRT オブジェクトのイベント ハンドラーが呼び出されるため、アプリがクラッシュします。</span><span class="sxs-lookup"><span data-stu-id="2bad2-171">Your app crashes because an event handler in your C++/WinRT object is called after the object has been destroyed.</span></span>|<span data-ttu-id="2bad2-172">参照してください[安全にアクセスする、*この*イベント処理デリゲートを使用してポインター](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-172">See [Safely accessing the *this* pointer with an event-handling delegate](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).</span></span>|
| <span data-ttu-id="2bad2-173">C++ コンパイラは"*エラー C2338:これは、弱い参照のサポートにのみ*"。</span><span class="sxs-lookup"><span data-stu-id="2bad2-173">The C++ compiler produces "*error C2338: This is only for weak ref support*".</span></span>|<span data-ttu-id="2bad2-174">**テンプレート引数として winrt::no_weak_ref** マーカー構造体を基底クラスに渡した型の、弱参照を要求しています。</span><span class="sxs-lookup"><span data-stu-id="2bad2-174">You're requesting a weak reference for a type that passed the **winrt::no_weak_ref** marker struct as a template argument to its base class.</span></span> <span data-ttu-id="2bad2-175">参照してください[弱い参照のサポートを無効にする](weak-references.md#opting-out-of-weak-reference-support)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-175">See [Opting out of weak reference support](weak-references.md#opting-out-of-weak-reference-support).</span></span>|
| <span data-ttu-id="2bad2-176">C++ リンカーの生成"*エラー lnk2019 が発生します。未解決の外部シンボル*"</span><span class="sxs-lookup"><span data-stu-id="2bad2-176">The C++ linker produces "*error LNK2019: Unresolved external symbol*"</span></span>|<span data-ttu-id="2bad2-177">参照してください[理由は、リンカーを与えてくれた、"LNK2019:未解決の外部シンボル"エラーでしょうか](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).</span><span class="sxs-lookup"><span data-stu-id="2bad2-177">See [Why is the linker giving me a "LNK2019: Unresolved external symbol" error?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).</span></span>|
| <span data-ttu-id="2bad2-178">LLVM と Clang ツール チェーン C + を使用すると、エラーが発生する/cli WinRT します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-178">The LLVM and Clang toolchain produces errors when used with C++/WinRT.</span></span>|<span data-ttu-id="2bad2-179">C++ LLVM と Clang ツール チェーンはサポートされていません/cli の使用方法、内部的には、エミュレートする場合に、WinRT して試して実験で説明されているものなど[C + を使用してコンパイルする LLVM/Clang を使用できます/cli WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-179">We don't support the LLVM and Clang toolchain for C++/WinRT, but if you wanted to emulate how we use it internally, then you could try an experiment such as the one described in [Can I use LLVM/Clang to compile with C++/WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).</span></span>|
| <span data-ttu-id="2bad2-180">C++ コンパイラが生成されます"*いない利用可能な適切な既定コンストラクター*"射影された型。</span><span class="sxs-lookup"><span data-stu-id="2bad2-180">The C++ compiler produces "*no appropriate default constructor available*" for a projected type.</span></span> | <span data-ttu-id="2bad2-181">ランタイム クラスのオブジェクトの初期化を遅延またはを使用し、同じプロジェクト内のランタイム クラスを実装しているかどうかを呼び出す必要があります、`nullptr_t`コンストラクター。</span><span class="sxs-lookup"><span data-stu-id="2bad2-181">If you're trying to delay the initialization of a runtime class object, or to consume and implement a runtime class in the same project, then you'll need to call the `nullptr_t` constructor.</span></span> <span data-ttu-id="2bad2-182">詳細については、「[C++/WinRT での API の使用](consume-apis.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2bad2-182">For more info, see [Consume APIs with C++/WinRT](consume-apis.md).</span></span> |
| <span data-ttu-id="2bad2-183">C++ コンパイラは"*エラー C3861: 'from_abi': 識別子が見つかりません*"、およびその他のエラーから発信される*base.h*します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-183">The C++ compiler produces "*error C3861: 'from_abi': identifier not found*", and other errors originating in *base.h*.</span></span> <span data-ttu-id="2bad2-184">Visual Studio 2017 を使用している場合は、このエラーを表示可能性があります (バージョン 15.8.0 またはそれ以降)、Windows SDK バージョン 10.0.17134.0 (Windows 10、バージョン 1803) を対象とするとします。</span><span class="sxs-lookup"><span data-stu-id="2bad2-184">You may see this error if you are using Visual Studio 2017 (version 15.8.0 or higher), and targeting the Windows SDK version 10.0.17134.0 (Windows 10, version 1803).</span></span> | <span data-ttu-id="2bad2-185">いずれかのターゲット以降 (詳細について準拠) のバージョンの Windows SDK、またはプロジェクトのプロパティを設定**C/C++** > **言語** > **準拠モード。いいえ**(また場合、 **/permissive -** プロジェクト プロパティに表示されます**C/C++** > **言語** > **コマンドライン** **追加オプション**から削除します)。</span><span class="sxs-lookup"><span data-stu-id="2bad2-185">Either target a later (more conformant) version of the Windows SDK, or set project property **C/C++** > **Language** > **Conformance mode: No** (also, if **/permissive-** appears in project property **C/C++** > **Language** > **Command Line** under **Additional Options**, then delete it).</span></span> |
| <span data-ttu-id="2bad2-186">C++ コンパイラは"*エラー C2039:'IUnknown': のメンバーではない '\`グローバル名前空間'*"。</span><span class="sxs-lookup"><span data-stu-id="2bad2-186">The C++ compiler produces "*error C2039: 'IUnknown': is not a member of '\`global namespace''*".</span></span> | <span data-ttu-id="2bad2-187">参照してください[方法の再ターゲットすると、C +/cli WinRT プロジェクトは、以降のバージョンの Windows SDK を](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-187">See [How to retarget your C++/WinRT project to a later version of the Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).</span></span> |
| <span data-ttu-id="2bad2-188">C++ リンカーの生成"*エラー LNK2019: 未解決の外部シンボル_WINRT_CanUnloadNow@0関数で参照されている_VSDesignerCanUnloadNow@0* "</span><span class="sxs-lookup"><span data-stu-id="2bad2-188">The C++ linker produces "*error LNK2019: unresolved external symbol _WINRT_CanUnloadNow@0 referenced in function _VSDesignerCanUnloadNow@0*"</span></span> | <span data-ttu-id="2bad2-189">参照してください[方法の再ターゲットすると、C +/cli WinRT プロジェクトは、以降のバージョンの Windows SDK を](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-189">See [How to retarget your C++/WinRT project to a later version of the Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).</span></span> |
| <span data-ttu-id="2bad2-190">ビルド プロセスには、エラー メッセージが生成される*C+/cli WinRT VSIX プロジェクトのビルドのサポートは提供されなくなりました。Microsoft.Windows.CppWinRT Nuget パッケージへの参照をプロジェクトに追加してください*します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-190">The build process produces the error message *The C++/WinRT VSIX no longer provides project build support.  Please add a project reference to the Microsoft.Windows.CppWinRT Nuget package*.</span></span> | <span data-ttu-id="2bad2-191">インストール、 **Microsoft.Windows.CppWinRT**をプロジェクトに NuGet パッケージ。</span><span class="sxs-lookup"><span data-stu-id="2bad2-191">Install the **Microsoft.Windows.CppWinRT** NuGet package into your project.</span></span> <span data-ttu-id="2bad2-192">詳細については、次を参照してください。 [VSIX 拡張機能の以前のバージョン](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-192">For details, see [Earlier versions of the VSIX extension](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension).</span></span> |

> [!NOTE]
> <span data-ttu-id="2bad2-193">このトピックでは、質問に答えしていないかどうかを参照してくださいヘルプを見つけることがあります、[開発者コミュニティの Visual Studio C](https://developercommunity.visualstudio.com/spaces/62/index.html)、またはを使用して、 [ `c++-winrt` Stack Overflow でタグ付け](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt)します。</span><span class="sxs-lookup"><span data-stu-id="2bad2-193">If this topic didn't answer your question, then you might find help by visiting the [Visual Studio C++ developer community](https://developercommunity.visualstudio.com/spaces/62/index.html), or by using the [`c++-winrt` tag on Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).</span></span>
