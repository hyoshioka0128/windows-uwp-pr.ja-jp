---
author: stevewhims
description: このトピックにある現象のトラブルシューティングおよび対処法に関する表は、新しいコードを作成しているか既存のアプリを移植しているかにはかかわらず役立つ可能性があります。
title: C++/WinRT に関する問題のトラブルシューティング
ms.author: stwhi
ms.date: 05/07/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10、uwp、標準、c++、cpp、winrt、プロジェクション、トラブルシューティング、HRESULT、エラー
ms.localizationpriority: medium
ms.openlocfilehash: 4129c50a2273c8ac425f6ea972898aa09fe0fcf3
ms.sourcegitcommit: 4f6dc806229a8226894c55ceb6d6eab391ec8ab6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2018
ms.locfileid: "4085729"
---
# <a name="troubleshooting-cwinrtwindowsuwpcpp-and-winrt-apisintro-to-using-cpp-with-winrt-issues"></a><span data-ttu-id="38590-104">[C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) に関する問題のトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="38590-104">Troubleshooting [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) issues</span></span>
> [!NOTE]
> <span data-ttu-id="38590-105">C++/WinRT Visual Studio Extension (VSIX) (プロジェクト テンプレート サポートおよび C++/WinRT MSBuild プロパティとターゲットを提供) のインストールと使用については、「[C++/WinRT の Visual Studio サポートと VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-105">For info about installing and using the C++/WinRT Visual Studio Extension (VSIX) (which provides project template support, as well as C++/WinRT MSBuild properties and targets) see [Visual Studio support for C++/WinRT, and the VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span></span>

<span data-ttu-id="38590-106">このトピックは、すぐに認識していただくための先行情報です。まだ必要としていない場合も同様です。</span><span class="sxs-lookup"><span data-stu-id="38590-106">This topic is up front so that you're aware of it right away; even if you don't need it yet.</span></span> <span data-ttu-id="38590-107">以下の症状のトラブルシューティングおよび対処法に関する表は、新しいコードを作成しているか既存のアプリを移植しているかにはかかわらず役立つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="38590-107">The table of troubleshooting symptoms and remedies below may be helpful to you whether you're cutting new code or porting an existing app.</span></span> <span data-ttu-id="38590-108">移植中であり、進展させてプロジェクトのビルドおよび実行の段階に達することを急いでいる場合は、問題を引き起こしている重要でないコードにコメントアウトまたはスタブ挿入を適用して、一時的に進展させることができます。その後、元に戻ってその借りを解消することになります。</span><span class="sxs-lookup"><span data-stu-id="38590-108">If you're porting, and you're eager to forge ahead and get to the stage where your project builds and runs, then you can make temporary progress by commenting or stubbing out any non-essential code that's causing issues, and then returning to pay off that debt later.</span></span>

<span data-ttu-id="38590-109">よく寄せられる質問の一覧では、[よく寄せられる質問](faq.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-109">For a list of frequently-asked questions, see [Frequently-asked questions](faq.md).</span></span>

## <a name="tracking-down-xaml-issues"></a><span data-ttu-id="38590-110">XAML に関する問題の検出</span><span class="sxs-lookup"><span data-stu-id="38590-110">Tracking down XAML issues</span></span>
<span data-ttu-id="38590-111">XAML 解析例外は診断が難しい場合があります。特に、わかりやすいエラー メッセージが例外に含まれていない場合は、診断が難しくなります。</span><span class="sxs-lookup"><span data-stu-id="38590-111">XAML parse exceptions can be difficult to diagnose&mdash;particularly if there are no meaningful error messages within the exception.</span></span> <span data-ttu-id="38590-112">デバッガーが初回例外をキャッチするように構成されていることを確してください (早い段階で解析例外のキャッチを試行するため)。</span><span class="sxs-lookup"><span data-stu-id="38590-112">Make sure that the debugger is configured to catch first-chance exceptions (to try and catch the parsing exception early on).</span></span> <span data-ttu-id="38590-113">デバッガーで例外変数を調べて、HRESULT やメッセージ内に役立つ情報が含まれているかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="38590-113">You may be able to inspect the exception variable in the debugger to determine whether the HRESULT or message has any useful information.</span></span> <span data-ttu-id="38590-114">また、XAML パーサーを使って、Visual Studio の出力ウィンドウを調べ、エラー メッセージの出力を確認することもできます。</span><span class="sxs-lookup"><span data-stu-id="38590-114">Also, check Visual Studio's output window for error messages output by the XAML parser.</span></span>

<span data-ttu-id="38590-115">アプリが終了し、XAML マークアップの解析中に処理不能な例外がスローされたことのみがわかっている場合、存在しないリソースへの (キーによる) 参照の結果である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="38590-115">If your app terminates and all you know is that an unhandled exception was thrown during XAML markup parsing, then that could be the result of a reference (by key) to a missing resource.</span></span> <span data-ttu-id="38590-116">または、UserControl、カスタム コントロール、カスタム レイアウト パネルの内部で例外がスローされたことも考えられます。</span><span class="sxs-lookup"><span data-stu-id="38590-116">Or, it could be an exception thrown inside a UserControl, a custom control, or a custom layout panel.</span></span> <span data-ttu-id="38590-117">最終手段として、バイナリ分割を使うことができます。</span><span class="sxs-lookup"><span data-stu-id="38590-117">A last resort is a binary split.</span></span> <span data-ttu-id="38590-118">XAML ページからマークアップのおよそ半分を削除し、アプリを再実行します。</span><span class="sxs-lookup"><span data-stu-id="38590-118">Remove about half of the markup from a XAML Page and re-run the app.</span></span> <span data-ttu-id="38590-119">これによって、エラーが削除した半分で発生しているか (いずれの場合でも、削除した部分はここで元に戻す必要があります)、または削除しなかった半分で発生しているかがわかります。</span><span class="sxs-lookup"><span data-stu-id="38590-119">You will then know whether the error is somewhere inside the half you removed (which you should now restore in any case) or in the half you did not remove.</span></span> <span data-ttu-id="38590-120">問題が特定されるまで、エラーを含む半分をさらに分割するプロセスを繰り返します。</span><span class="sxs-lookup"><span data-stu-id="38590-120">Repeat the process by splitting the half that contains the error, and so on, until you've zeroed in on the issue.</span></span>

## <a name="symptoms-and-remedies"></a><span data-ttu-id="38590-121">現象と対処法</span><span class="sxs-lookup"><span data-stu-id="38590-121">Symptoms and remedies</span></span>
| <span data-ttu-id="38590-122">現象</span><span class="sxs-lookup"><span data-stu-id="38590-122">Symptom</span></span> | <span data-ttu-id="38590-123">対処法</span><span class="sxs-lookup"><span data-stu-id="38590-123">Remedy</span></span> |
|---------|--------|
| <span data-ttu-id="38590-124">実行時に REGDB_E_CLASSNOTREGISTERED の HRESULT 値で例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="38590-124">An exception is thrown at runtime with a HRESULT value of REGDB_E_CLASSNOTREGISTERED.</span></span> | <span data-ttu-id="38590-125">このエラーの原因の 1 つは、Windows ランタイム コンポーネントを読み込むことができないことです。</span><span class="sxs-lookup"><span data-stu-id="38590-125">One cause of this error is that your Windows Runtime Component can't be loaded.</span></span> <span data-ttu-id="38590-126">コンポーネントの Windows ランタイム メタデータ ファイル (`.winmd`) の名前がコンポーネント バイナリ (`.dll`) の名前と同じであることを確認してください。この名前は、プロジェクトの名前、およびルート名前空間の名前でもあります。</span><span class="sxs-lookup"><span data-stu-id="38590-126">Make sure that the component's Windows Runtime metadata file (`.winmd`) has the same name as the component binary (the `.dll`), which is also the name of the project and the name of the root namespace.</span></span> <span data-ttu-id="38590-127">また、Windows ランタイム メタデータとバイナリが、ビルド プロセスによって使用中のアプリの `Appx` フォルダに正しくコピーされていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="38590-127">Also make sure that the Windows Runtime metadata and the binary have been corectly copied by the build process to the consuming app's `Appx` folder.</span></span> <span data-ttu-id="38590-128">さらに、使用中のアプリの `AppxManifest.xml` (および `Appx` フォルダ内) に、アクティブ化可能なクラスとバイナリ名を正しく宣言している **&lt;InProcessServer&gt;** 要素が含まれていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="38590-128">And confirm that the consuming app's `AppxManifest.xml` (also in the `Appx` folder) contains an **&lt;InProcessServer&gt;** element correctly declaring the activatable class and the binary name.</span></span> <span data-ttu-id="38590-129">このエラーは、ローカルに実装されたランタイム クラスが、プロジェクションされた型の既定のコンストラクターによって誤ってインスタンス化された場合にも発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="38590-129">This error can also happen if you make the mistake of instantiating a locally-implemented runtime class via the projected type's default constructor.</span></span> <span data-ttu-id="38590-130">その場合にプロジェクションされた型を正しく使用する方法の詳細については、「[XAML コントロール、C++/WinRT プロパティへのバインド](binding-property.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-130">See [XAML controls; bind to a C++/WinRT property](binding-property.md) for more information about how to correctly use the projected type in that case.</span></span> |
| <span data-ttu-id="38590-131">C++ コンパイラーは、"*'implements_type': は、'&lt;プロジェクションされた型&gt;'* の直接的または間接的な基底クラスのメンバーではありません" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-131">The C++ compiler produces the error "*'implements_type': is not a member of any direct or indirect base class of '&lt;projected type&gt;'*".</span></span> | <span data-ttu-id="38590-132">これは、実装型 (たとえば **MyRuntimeClass**) の未修飾名前空間名を使用して、その型のヘッダーを含めずに **make** を呼び出すと発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="38590-132">This can happen when you call **make** with the namespace-unqualified name of your implementation type (**MyRuntimeClass**, for example), and you haven't included that type's header.</span></span> <span data-ttu-id="38590-133">コンパイラーは、**MyRuntimeClass** をプロジェクションされた型として解釈します。</span><span class="sxs-lookup"><span data-stu-id="38590-133">The compiler interprets **MyRuntimeClass** as the projected type.</span></span> <span data-ttu-id="38590-134">解決策は、実装型のヘッダーを含めることです (たとえば `MyRuntimeClass.h`)。</span><span class="sxs-lookup"><span data-stu-id="38590-134">The solution is to include the header for your implementation type (`MyRuntimeClass.h`, for example).</span></span> |
| <span data-ttu-id="38590-135">C++ コンパイラーが、"*削除された関数を参照しようとしています*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-135">The C++ compiler produces the error "*attempting to reference a deleted function*".</span></span> | <span data-ttu-id="38590-136">これは、**make** を呼び出し、テンプレート パラメーターとして渡す実装型の既定のコンストラクターが `= delete` である場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="38590-136">This can happen when you call **make** and the implementation type that you pass as the template parameter has an `= delete` default constructor.</span></span> <span data-ttu-id="38590-137">実装型のヘッダー ファイルを編集し、`= delete` を `= default` に変更してください。</span><span class="sxs-lookup"><span data-stu-id="38590-137">Edit the implementation type's header file and change `= delete` to `= default`.</span></span> <span data-ttu-id="38590-138">ランタイム クラスの IDL にコンストラクターを追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="38590-138">You can also add a constructor into the IDL for the runtime class.</span></span> |
| <span data-ttu-id="38590-139">[**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged) を実装しましたが、XAML バインドが更新されません (そのため、UI が [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged) にサブスクライブしません)。</span><span class="sxs-lookup"><span data-stu-id="38590-139">You've implemented [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), but your XAML bindings are not updating (and the UI is not subscribing to [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)).</span></span> | <span data-ttu-id="38590-140">XAML マークアップのバインド式で必ず `Mode=OneWay` (または TwoWay) を設定してください。</span><span class="sxs-lookup"><span data-stu-id="38590-140">Remember to set `Mode=OneWay` (or TwoWay) on your binding expression in XAML markup.</span></span> <span data-ttu-id="38590-141">「[XAML コントロール: C++/WinRT プロパティへのバインド](binding-property.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-141">See [XAML controls; bind to a C++/WinRT property](binding-property.md).</span></span> |
| <span data-ttu-id="38590-142">XAML アイテム コントロールを監視可能なコレクションにバインドしていますが、実行時に "パラメーターが正しくありません" というメッセージで例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="38590-142">You're binding a XAML items control to an observable collection, and an exception is thrown at runtime with the message "The parameter is incorrect".</span></span> | <span data-ttu-id="38590-143">IDL および実装で、監視可能なコレクションを型 **Windows.Foundation.Collections.IVector<IInspectable>** として宣言します。</span><span class="sxs-lookup"><span data-stu-id="38590-143">In your IDL and your implementation, declare any observable collection as the type **Windows.Foundation.Collections.IVector<IInspectable>**.</span></span> <span data-ttu-id="38590-144">ただし、**Windows.Foundation.Collections.IObservableVector<T>** を実装するオブジェクトを返します。T は要素型です。</span><span class="sxs-lookup"><span data-stu-id="38590-144">But return an object that implements **Windows.Foundation.Collections.IObservableVector<T>**, where T is your element type.</span></span> <span data-ttu-id="38590-145">「[XAML アイテム コントロール: C++/WinRT コレクションへのバインド](binding-collection.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-145">See [XAML items controls; bind to a C++/WinRT collection](binding-collection.md).</span></span>  |
| <span data-ttu-id="38590-146">C++ コンパイラーが、"*'MyImplementationType_base&lt;MyImplementationType&gt;': 使用可能な適切な既定コンストラクターがありません*" という形式のエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-146">The C++ compiler produces an error of the form "*'MyImplementationType_base&lt;MyImplementationType&gt;': no appropriate default constructor available*".</span></span>|<span data-ttu-id="38590-147">これは、非自明なコンストラクターを持つ型から派生させた場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="38590-147">This can happen when you have derived from a type that has a non-trivial constructor.</span></span> <span data-ttu-id="38590-148">派生型のコンストラクターは、基本型のコンストラクターが必要とするパラメーターを渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="38590-148">Your derived type's constructor needs to pass along the parameters that the base type's constructor needs.</span></span> <span data-ttu-id="38590-149">実証済みの例については、「[非自明なコンストラクタを持つ型からの派生](author-apis.md#deriving-from-a-type-that-has-a-non-trivial-constructor)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-149">For a worked example, see [Deriving from a type that has a non-trivial constructor](author-apis.md#deriving-from-a-type-that-has-a-non-trivial-constructor).</span></span>|
| <span data-ttu-id="38590-150">C++ コンパイラーが、"*'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' から 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* に変換できません" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-150">The C++ compiler produces the error "*cannot convert from 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".</span></span>|<span data-ttu-id="38590-151">これは、コレクションを予期している Windows ランタイム API に std::wstring の std::vector を渡すときに発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="38590-151">This can happen when you pass a std::vector of std::wstring to a Windows Runtime API that expects a collection.</span></span> <span data-ttu-id="38590-152">詳細については、「[標準的な C++ のデータ型と C++/WinRT](std-cpp-data-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-152">For more info, see [Standard C++ data types and C++/WinRT](std-cpp-data-types.md).</span></span>|
| <span data-ttu-id="38590-153">C++ コンパイラーが、"*'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' から 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* に変換できません" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-153">The C++ compiler produces the error "*cannot convert from 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".</span></span>|<span data-ttu-id="38590-154">これは、コレクションを予期している非同期 Windows ランタイム API に winrt::hstring の std::vector を渡すときに、非同期呼び出し先へのベクトルのコピーも移動も行っていない場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="38590-154">This can happen when you pass a std::vector of winrt::hstring to an asynchronous Windows Runtime API that expects a collection, and you've neither copied nor moved the vector to the async callee.</span></span> <span data-ttu-id="38590-155">詳細については、「[標準的な C++ のデータ型と C++/WinRT](std-cpp-data-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-155">For more info, see [Standard C++ data types and C++/WinRT](std-cpp-data-types.md).</span></span>|
| <span data-ttu-id="38590-156">プロジェクトを開くときに、Visual Studio が "*プロジェクトのアプリケーションはインストールされていません*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-156">When opening a project, Visual Studio produces the error "*The application for the project is not installed*".</span></span>|<span data-ttu-id="38590-157">まだ行っていない場合は、Visual Studio の **[新しいプロジェクト]** ダイアログから **C++ での開発用の Windows ユニバーサル ツール**をインストールする必要があります。</span><span class="sxs-lookup"><span data-stu-id="38590-157">If you haven't already, you need to install **Windows Universal tools for C++ development** from within Visual Studio's **New Project** dialog.</span></span> <span data-ttu-id="38590-158">それでも問題が解決しない場合は、プロジェクトが C++/WinRT Visual Studio Extension (VSIX) に依存している可能性があります (「[C++/WinRT の Visual Studio サポートと VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)」を参照)。</span><span class="sxs-lookup"><span data-stu-id="38590-158">If that doesn't resolve the issue, then the project may depend on the C++/WinRT Visual Studio Extension (VSIX) (see [Visual Studio support for C++/WinRT, and the VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).</span></span>|
| <span data-ttu-id="38590-159">Windows アプリ認定キットのテストが、ランタイム クラスの 1 つについて、"*Windows 基底クラスから派生しません。すべての構成可能クラスは最終的に、Windows 名前空間内の型から派生する必要があります*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-159">The Windows App Certification Kit tests produce an error that one of your runtime classes "*does not derive from a Windows base class. All composable classes must ultimately derive from a type in the Windows namespace*".</span></span>|<span data-ttu-id="38590-160">(つまり、アプリケーション内で宣言した) 実行時のクラスで、基底クラスから派生したと呼ばれる、*構成可能な*クラスです。</span><span class="sxs-lookup"><span data-stu-id="38590-160">Any runtime class (that you declare in your application) that derives from a base class is known as a *composable* class.</span></span> <span data-ttu-id="38590-161">構成可能なクラスの最終的な基底クラスは、Windows.\* 名前空間の型である必要があります。たとえば、 [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject)です。</span><span class="sxs-lookup"><span data-stu-id="38590-161">The ultimate base class of a composable class must be a type originating in a Windows.\* namespace; for example, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject).</span></span> <span data-ttu-id="38590-162">参照してください[XAML コントロール、バインドを C++/WinRT プロパティ](binding-property.md)の詳細はします。</span><span class="sxs-lookup"><span data-stu-id="38590-162">See [XAML controls; bind to a C++/WinRT property](binding-property.md) for more details.</span></span>|
| <span data-ttu-id="38590-163">C++ コンパイラーが、EventHandler または TypedEventHandler のデリゲート特殊化に関して "*WinRT 型である必要があります*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-163">The C++ compiler produces a "*must be WinRT type*" error for an EventHandler or TypedEventHandler delegate specialization.</span></span>|<span data-ttu-id="38590-164">代わりに **winrt::delegate&lt;...T&gt;** を使用することを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="38590-164">Consider using **winrt::delegate&lt;...T&gt;** instead.</span></span> <span data-ttu-id="38590-165">「[C++/WinRT でのイベントの作成](author-events.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-165">See [Author events in C++/WinRT](author-events.md).</span></span>|
| <span data-ttu-id="38590-166">C++ コンパイラーが、Windows ランタイムの非同期操作の特殊化に関して "*WinRT 型である必要があります*" というエラーを生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-166">The C++ compiler produces a "*must be WinRT type*" error for a Windows Runtime asynchronous operation specialization.</span></span>|<span data-ttu-id="38590-167">代わりに並列パターン ライブラリ (PPL) の [**task**](https://msdn.microsoft.com/library/hh750113) を返すことを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="38590-167">Consider returning a Parallel Patterns Library (PPL) [**task**](https://msdn.microsoft.com/library/hh750113) instead.</span></span> <span data-ttu-id="38590-168">「[同時実行操作と非同期操作](concurrency.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-168">See [Concurrency and asynchronous operations](concurrency.md).</span></span>|
| <span data-ttu-id="38590-169">C++ コンパイラーが、"*エラー C2220: 警告がエラーとして扱われました - 'オブジェクト' ファイルは生成されませんでした*" を生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-169">The C++ compiler produces "*error C2220: warning treated as error - no 'object' file generated*".</span></span>|<span data-ttu-id="38590-170">警告を解決するか、または **[C/C++]** > **[全般]** > **[警告をエラーとして扱う]** を **[いいえ (/WX-)]** に設定します。</span><span class="sxs-lookup"><span data-stu-id="38590-170">Either correct the warning, or set **C/C++** > **General** > **Treat Warnings As Errors** to **No (/WX-)**.</span></span>|
| <span data-ttu-id="38590-171">オブジェクトが破棄された後で C++/WinRT オブジェクトのイベント ハンドラーが呼び出されるため、アプリがクラッシュします。</span><span class="sxs-lookup"><span data-stu-id="38590-171">Your app crashes because an event handler in your C++/WinRT object is called after the object has been destroyed.</span></span>|<span data-ttu-id="38590-172">「[イベント ハンドラーでの *this* オブジェクトの使用](handle-events.md#using-the-this-object-in-an-event-handler)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-172">See [Using the *this* object in an event handler](handle-events.md#using-the-this-object-in-an-event-handler).</span></span>|
| <span data-ttu-id="38590-173">C++ コンパイラーが "*エラー C2338: これは弱参照サポート専用です*" を生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-173">The C++ compiler produces "*error C2338: This is only for weak ref support*".</span></span>|<span data-ttu-id="38590-174">**テンプレート引数として winrt::no_weak_ref** マーカー構造体を基底クラスに渡した型の、弱参照を要求しています。</span><span class="sxs-lookup"><span data-stu-id="38590-174">You're requesting a weak reference for a type that passed the **winrt::no_weak_ref** marker struct as a template argument to its base class.</span></span> <span data-ttu-id="38590-175">「[弱参照サポートの除外](weak-references.md#opting-out-of-weak-reference-support)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-175">See [Opting out of weak reference support](weak-references.md#opting-out-of-weak-reference-support)</span></span>|
| <span data-ttu-id="38590-176">C++ リンカー生成"*エラー lnk 2019: 外部シンボルは未解決*"</span><span class="sxs-lookup"><span data-stu-id="38590-176">The C++ linker produces "*error LNK2019: Unresolved external symbol*"</span></span>|<span data-ttu-id="38590-177">表示[理由は、リンカー入力すると、"lnk 2019: 外部シンボルは未解決です"エラーかどうか](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error)。</span><span class="sxs-lookup"><span data-stu-id="38590-177">See [Why is the linker giving me a "LNK2019: Unresolved external symbol" error?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error)</span></span>|
| <span data-ttu-id="38590-178">LLVM および Clang ツール チェーンは、C++ を使用するとエラーを生成/WinRT します。</span><span class="sxs-lookup"><span data-stu-id="38590-178">The LLVM and Clang toolchain produces errors when used with C++/WinRT.</span></span>|<span data-ttu-id="38590-179">LLVM および Clang ツール チェーンは、C++ サポートしていません/WinRT の使用方法が内部をエミュレートする場合に後、は、いずれかで説明されているように、実験に試すことができます[において、C++ をコンパイルする Llvm/clang を使用できる/WinRT かどうか。](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt)します。</span><span class="sxs-lookup"><span data-stu-id="38590-179">We don't support the LLVM and Clang toolchain for C++/WinRT, but if you wanted to emulate how we use it internally, then you could try an experiment such as the one described in [Can I use LLVM/Clang to compile with C++/WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).</span></span>|
| <span data-ttu-id="38590-180">C++ コンパイラーは、投影された型の「*適切な既定コンス トラクターがありません利用可能な*」を生成します。</span><span class="sxs-lookup"><span data-stu-id="38590-180">The C++ compiler produces "*no appropriate default constructor available*" for a projected type.</span></span> | <span data-ttu-id="38590-181">ランタイム クラスのオブジェクトの初期化を遅延するまたはを消費し、同じプロジェクトにランタイム クラスを実装する場合に呼び出す必要があります、`nullptr_t`コンス トラクター。</span><span class="sxs-lookup"><span data-stu-id="38590-181">If you're trying to delay the initialization of a runtime class object, or to consume and implement a runtime class in the same project, then you'll need to call the `nullptr_t` constructor.</span></span> <span data-ttu-id="38590-182">詳細については、「[C++/WinRT での API の使用](consume-apis.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="38590-182">For more info, see [Consume APIs with C++/WinRT](consume-apis.md).</span></span> |
| <span data-ttu-id="38590-183">C++ コンパイラーが"*エラー C3861: 'from_abi': 識別子が見つかりません*"、および*base.h*でその他のエラー。</span><span class="sxs-lookup"><span data-stu-id="38590-183">The C++ compiler produces "*error C3861: 'from_abi': identifier not found*", and other errors originating in *base.h*.</span></span> <span data-ttu-id="38590-184">Visual Studio 2017 を使用している場合にこのエラーが表示することがあります (バージョン 15.8.0 以上)、Windows SDK バージョン 10.0.17134.0 (Windows 10、バージョン 1803) をターゲットとします。</span><span class="sxs-lookup"><span data-stu-id="38590-184">You may see this error if you are using Visual Studio 2017 (version 15.8.0 or higher), and targeting the Windows SDK version 10.0.17134.0 (Windows 10, version 1803).</span></span> | <span data-ttu-id="38590-185">以降 (詳しく準拠) をターゲットにするかのバージョンの Windows SDK、またはプロジェクトのプロパティを設定する**C/C++** > **言語** > **Conformance mode: いいえ**(また場合、 **/制限解除-** **C/C++**  > **言語** > **コマンド ライン**[**その他のオプション**を削除します)。</span><span class="sxs-lookup"><span data-stu-id="38590-185">Either target a later (more conformant) version of the Windows SDK, or set project property **C/C++** > **Language** > **Conformance mode: No** (also, if **/permissive-** appears in project property **C/C++** > **Language** > **Command Line** under **Additional Options**, then delete it).</span></span> |

> [!NOTE]
> <span data-ttu-id="38590-186">このトピックで質問の回答が得られない場合は、[Stack Overflow で `c++-winrt` タグ](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt)を使用してヘルプ情報を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="38590-186">If this topic didn't answer your question, you might find help by using the [`c++-winrt` tag on Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).</span></span>
