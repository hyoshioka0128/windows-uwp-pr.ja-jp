---
description: C++/WinRT に関するニュースと変更内容です。
title: 新しい c++/cli WinRT
ms.date: 01/29/2019
ms.topic: article
keywords: windows 10、uwp、standard、c++、cpp、winrt、プロジェクション、ニュース、ものの新しい
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: cb624a93a010dfe9784cf8c26beed12c6cf2f77d
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2019
ms.locfileid: "57639957"
---
# <a name="whats-new-in-cwinrt"></a><span data-ttu-id="16a16-104">新しい c++/cli WinRT</span><span class="sxs-lookup"><span data-stu-id="16a16-104">What's new in C++/WinRT</span></span>

<span data-ttu-id="16a16-105">次の表は、ニュースを含むし、への変更[C +/cli WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) 10.0.17763.0 (Windows 10、バージョンは 1809) で一般公開バージョンの最新の Windows SDK であります。</span><span class="sxs-lookup"><span data-stu-id="16a16-105">The table below contains news and changes to [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) in the latest generally-available version of the Windows SDK, which is 10.0.17763.0 (Windows 10, version 1809).</span></span> <span data-ttu-id="16a16-106">これらの変更も SDK Insider Preview 以降のバージョンに存在する場合があります。</span><span class="sxs-lookup"><span data-stu-id="16a16-106">These changes may also be present in later SDK Insider Preview versions.</span></span>

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a><span data-ttu-id="16a16-107">ニュース、および変更 で、Windows SDK バージョン 10.0.17763.0 (Windows 10、バージョンは 1809)</span><span class="sxs-lookup"><span data-stu-id="16a16-107">News, and changes, in Windows SDK version 10.0.17763.0 (Windows 10, version 1809)</span></span>

| <span data-ttu-id="16a16-108">新規または変更された機能</span><span class="sxs-lookup"><span data-stu-id="16a16-108">New or changed feature</span></span> | <span data-ttu-id="16a16-109">詳細情報</span><span class="sxs-lookup"><span data-stu-id="16a16-109">More info</span></span> |
| - | - |
| <span data-ttu-id="16a16-110">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-110">**Breaking change**.</span></span> <span data-ttu-id="16a16-111">コンパイル、C +/cli WinRT は、Windows SDK からのヘッダーに依存しません。</span><span class="sxs-lookup"><span data-stu-id="16a16-111">For it to compile, C++/WinRT doesn't depend on headers from the Windows SDK.</span></span> | <span data-ttu-id="16a16-112">参照してください[Windows SDK ヘッダー ファイルから分離](#isolation-from-windows-sdk-header-files)、後述します。</span><span class="sxs-lookup"><span data-stu-id="16a16-112">See [Isolation from Windows SDK header files](#isolation-from-windows-sdk-header-files), below.</span></span> |
| <span data-ttu-id="16a16-113">Visual Studio プロジェクト システムの形式が変更されました。</span><span class="sxs-lookup"><span data-stu-id="16a16-113">The Visual Studio project system format has changed.</span></span> | <span data-ttu-id="16a16-114">参照してください[、C + の再ターゲットする方法/cli WinRT プロジェクトは、以降のバージョンの Windows SDK を](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)、後述します。</span><span class="sxs-lookup"><span data-stu-id="16a16-114">See [How to retarget your C++/WinRT project to a later version of the Windows SDK](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk), below.</span></span> |
| <span data-ttu-id="16a16-115">新しい機能と Windows ランタイム関数の場合にコレクション オブジェクトを渡すため、または独自のコレクションのプロパティとコレクション型を実装する基底クラスがあります。</span><span class="sxs-lookup"><span data-stu-id="16a16-115">There are new functions and base classes to help you pass a collection object to a Windows Runtime function, or to implement your own collection properties and collection types.</span></span> | <span data-ttu-id="16a16-116">参照してください[コレクション c++/cli WinRT](collections.md)します。</span><span class="sxs-lookup"><span data-stu-id="16a16-116">See [Collections with C++/WinRT](collections.md).</span></span> |
| <span data-ttu-id="16a16-117">使用することができます、 [{binding}](/windows/uwp/xaml-platform/binding-markup-extension)マークアップ拡張では、C +/cli WinRT ランタイム クラスです。</span><span class="sxs-lookup"><span data-stu-id="16a16-117">You can use the [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) markup extension with your C++/WinRT runtime classes.</span></span> | <span data-ttu-id="16a16-118">詳細については、およびコード例は、次を参照してください。[データ バインディングの概要](/windows/uwp/data-binding/data-binding-quickstart)します。</span><span class="sxs-lookup"><span data-stu-id="16a16-118">For more info, and code examples, see [Data binding overview](/windows/uwp/data-binding/data-binding-quickstart).</span></span> |
| <span data-ttu-id="16a16-119">コルーチンのキャンセルのサポートを使用すると、取り消しのコールバックを登録できます。</span><span class="sxs-lookup"><span data-stu-id="16a16-119">Support for canceling a coroutine allows you to register a cancellation callback.</span></span> | <span data-ttu-id="16a16-120">詳細については、およびコード例は、次を参照してください。[非同期操作、および取り消しのコールバックをキャンセル](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks)します。</span><span class="sxs-lookup"><span data-stu-id="16a16-120">For more info, and code examples, see [Canceling an asychronous operation, and cancellation callbacks](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks).</span></span> |
| <span data-ttu-id="16a16-121">メンバー関数を指すデリゲートを作成するときに、強力なまたは現在のオブジェクトへの弱い参照を確立することができます (未加工ではなく*この*ポインター)、ハンドラーが登録されている時点。</span><span class="sxs-lookup"><span data-stu-id="16a16-121">When creating a delegate pointing to a member function, you can establish a strong or a weak reference to the current object (instead of a raw *this* pointer) at the point where the handler is registered.</span></span> | <span data-ttu-id="16a16-122">詳細については、およびコード例は、次を参照してください、**デリゲートとしてメンバー関数を使用する場合**サブセクションに記載[安全にアクセスする、*これ*イベント処理デリゲートとポインター](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).</span><span class="sxs-lookup"><span data-stu-id="16a16-122">For more info, and code examples, see the **If you use a member function as a delegate** sub-section in the section [Safely accessing the *this* pointer with an event-handling delegate](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).</span></span> |
| <span data-ttu-id="16a16-123">C++ 標準に Visual Studio の適合性を向上によって発見されたバグが修正されます。</span><span class="sxs-lookup"><span data-stu-id="16a16-123">Bugs are fixed that were uncovered by Visual Studio's improved conformance to the C++ standard.</span></span> <span data-ttu-id="16a16-124">LLVM と Clang ツール チェーンを活用すると、C + 検証よりも/cli WinRT の標準への準拠。</span><span class="sxs-lookup"><span data-stu-id="16a16-124">The LLVM and Clang toolchain is also better leveraged to validate C++/WinRT's standards conformance.</span></span> | <span data-ttu-id="16a16-125">説明されている問題が発生するが不要になった[自分の新しいプロジェクトがコンパイルされない理由でしょうか。Visual Studio 2017 を使用している (15.8.0 バージョンまたはそれ以降)、および SDK version 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134)</span><span class="sxs-lookup"><span data-stu-id="16a16-125">You'll no longer encounter the issue described in [Why won't my new project compile? I'm using Visual Studio 2017 (version 15.8.0 or higher), and SDK version 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134)</span></span> |

<span data-ttu-id="16a16-126">その他の変更。</span><span class="sxs-lookup"><span data-stu-id="16a16-126">Other changes.</span></span>

- <span data-ttu-id="16a16-127">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-127">**Breaking change**.</span></span> <span data-ttu-id="16a16-128">[**winrt::get_abi(winrt::hstring const&)** ](/uwp/cpp-ref-for-winrt/get-abi)返すようになりました`void*`の代わりに`HSTRING`します。</span><span class="sxs-lookup"><span data-stu-id="16a16-128">[**winrt::get_abi(winrt::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi) now returns `void*` instead of `HSTRING`.</span></span> <span data-ttu-id="16a16-129">使用することができます`static_cast<HSTRING>(get_abi(my_hstring));`HSTRING を取得します。</span><span class="sxs-lookup"><span data-stu-id="16a16-129">You can use `static_cast<HSTRING>(get_abi(my_hstring));` to get an HSTRING.</span></span>
- <span data-ttu-id="16a16-130">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-130">**Breaking change**.</span></span> <span data-ttu-id="16a16-131">[**winrt::put_abi(winrt::hstring&)** ](/uwp/cpp-ref-for-winrt/put-abi)返すようになりました`void**`の代わりに`HSTRING*`します。</span><span class="sxs-lookup"><span data-stu-id="16a16-131">[**winrt::put_abi(winrt::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi) now returns `void**` instead of `HSTRING*`.</span></span> <span data-ttu-id="16a16-132">使用することができます`reinterpret_cast<HSTRING*>(put_abi(my_hstring));`HSTRING \* を取得します。</span><span class="sxs-lookup"><span data-stu-id="16a16-132">You can use `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` to get an HSTRING\*.</span></span>
- <span data-ttu-id="16a16-133">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-133">**Breaking change**.</span></span> <span data-ttu-id="16a16-134">HRESULT として投影今すぐ**winrt::hresult**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-134">HRESULT is now projected as **winrt::hresult**.</span></span> <span data-ttu-id="16a16-135">HRESULT (に型チェック、または型の特徴をサポートするために)、する必要があるかどうかはその後、 `static_cast` 、 **winrt::hresult**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-135">If you need an HRESULT (to do type checking, or to support type traits), then you can `static_cast` a **winrt::hresult**.</span></span> <span data-ttu-id="16a16-136">それ以外の場合、 **winrt::hresult** HRESULT に変換します含める限り`unknwn.h`すべて C + インクルードする前に/cli WinRT ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="16a16-136">Otherwise, **winrt::hresult** converts to HRESULT, as long as you include `unknwn.h` before you include any C++/WinRT headers.</span></span>
- <span data-ttu-id="16a16-137">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-137">**Breaking change**.</span></span> <span data-ttu-id="16a16-138">GUID として投影今すぐ**winrt::guid**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-138">GUID is now projected as **winrt::guid**.</span></span> <span data-ttu-id="16a16-139">実装する api を使用する必要があります**winrt::guid** GUID パラメーター。</span><span class="sxs-lookup"><span data-stu-id="16a16-139">For APIs that you implement, you must use **winrt::guid** for GUID parameters.</span></span> <span data-ttu-id="16a16-140">それ以外の場合、 **winrt::hresult** GUID に変換する限り`unknwn.h`すべて C + インクルードする前に/cli WinRT ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="16a16-140">Otherwise, **winrt::hresult** converts to GUID, as long as you include `unknwn.h` before you include any C++/WinRT headers.</span></span>
- <span data-ttu-id="16a16-141">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-141">**Breaking change**.</span></span> <span data-ttu-id="16a16-142">[ **Winrt::handle_type コンス トラクター** ](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) (これは今すぐ困難と不適切なコードを記述する) を明示的にすることで書き込まれています。</span><span class="sxs-lookup"><span data-stu-id="16a16-142">The [**winrt::handle_type constructor**](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) has been hardened by making it explicit (it's now harder to write incorrect code with it).</span></span> <span data-ttu-id="16a16-143">未処理のハンドル値を割り当てる必要がある場合は、呼び出し、 [ **handle_type::attach 関数**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function)代わりにします。</span><span class="sxs-lookup"><span data-stu-id="16a16-143">If you need to assign a raw handle value, call the [**handle_type::attach function**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function) instead.</span></span>
- <span data-ttu-id="16a16-144">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-144">**Breaking change**.</span></span> <span data-ttu-id="16a16-145">シグネチャ**WINRT_CanUnloadNow**と**WINRT_GetActivationFactory**が変更されました。</span><span class="sxs-lookup"><span data-stu-id="16a16-145">The signatures of **WINRT_CanUnloadNow** and **WINRT_GetActivationFactory** have changed.</span></span> <span data-ttu-id="16a16-146">これらの関数は、まったく宣言しないでください。</span><span class="sxs-lookup"><span data-stu-id="16a16-146">You mustn't declare these functions at all.</span></span> <span data-ttu-id="16a16-147">代わりに、含める`winrt/base.h`(C + 任意を含める場合に自動的に含まれている/cli WinRT Windows 名前空間のヘッダー ファイル) これらの関数の宣言を含めます。</span><span class="sxs-lookup"><span data-stu-id="16a16-147">Instead, include `winrt/base.h` (which is automatically included if you include any C++/WinRT Windows namespace header files) to include the declarations of these functions.</span></span>
- <span data-ttu-id="16a16-148">[ **Winrt::clock 構造体**](/uwp/cpp-ref-for-winrt/clock)、 **from_FILETIME/to_FILETIME**好評だったは非推奨と**from_file_time/to_file_time**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-148">For the [**winrt::clock struct**](/uwp/cpp-ref-for-winrt/clock), **from_FILETIME/to_FILETIME** are deprecated in favor of **from_file_time/to_file_time**.</span></span>
- <span data-ttu-id="16a16-149">期待する Api **IBuffer**パラメーターが簡素化されます。</span><span class="sxs-lookup"><span data-stu-id="16a16-149">APIs that expect **IBuffer** parameters are simplified.</span></span> <span data-ttu-id="16a16-150">十分な Api が依存するが、ほとんどの Api には、コレクションまたは配列が必要に応じて、 **IBuffer** C++ からこのような Api を使用して容易になる必要があります。</span><span class="sxs-lookup"><span data-stu-id="16a16-150">Although most APIs prefer collections or arrays, enough APIs rely on **IBuffer** that it needed to be easier to use such APIs from C++.</span></span> <span data-ttu-id="16a16-151">この更新プログラムの背後にあるデータに直接アクセスを提供する、 **IBuffer** C++ 標準ライブラリ コンテナーで使用される同じデータ名前付け規則を使用して実装します。</span><span class="sxs-lookup"><span data-stu-id="16a16-151">This update provides direct access to the data behind an **IBuffer** implementation, using the same data naming convention used by the C++ Standard Library containers.</span></span> <span data-ttu-id="16a16-152">これには、競合するメタデータの名前が大文字で始まる規約も回避できます。</span><span class="sxs-lookup"><span data-stu-id="16a16-152">This also avoids colliding with metadata names that conventionally begin with an uppercase letter.</span></span>
- <span data-ttu-id="16a16-153">コード生成の向上: コードのサイズを小さくさまざまな機能強化は、インライン展開を向上させるし、工場出荷時のキャッシュを最適化します。</span><span class="sxs-lookup"><span data-stu-id="16a16-153">Improved code generation: various improvements to reduce code size, improve inlining, and optimize factory caching.</span></span>
- <span data-ttu-id="16a16-154">不要な再帰を削除します。</span><span class="sxs-lookup"><span data-stu-id="16a16-154">Removed unnecessary recursion.</span></span> <span data-ttu-id="16a16-155">ときに、コマンド ラインは、特定ではなく、フォルダーに`.winmd`、`cppwinrt.exe`に対して再帰的に不要になった検索`.winmd`ファイル。</span><span class="sxs-lookup"><span data-stu-id="16a16-155">When the command-line refers to a folder, rather than to a specific `.winmd`, the `cppwinrt.exe` tool no longer searches recursively for `.winmd` files.</span></span> <span data-ttu-id="16a16-156">`cppwinrt.exe`ツールも現在処理重複よりインテリジェントに適切な形式は、ユーザー エラー、回復力のある`.winmd`ファイル。</span><span class="sxs-lookup"><span data-stu-id="16a16-156">The `cppwinrt.exe` tool also now handles duplicates more intelligently, making it more resilient to user error, and to poorly-formed `.winmd` files.</span></span>
- <span data-ttu-id="16a16-157">セキュリティを強化したスマート ポインター。</span><span class="sxs-lookup"><span data-stu-id="16a16-157">Hardened smart pointers.</span></span> <span data-ttu-id="16a16-158">以前は、ときに失効に失敗したイベント revokers 移動によって割り当てられた新しい値。</span><span class="sxs-lookup"><span data-stu-id="16a16-158">Formerly, the event revokers failed to revoke when move-assigned a new value.</span></span> <span data-ttu-id="16a16-159">これにより、スマート ポインター クラス自己代入; の処理をでした。 確実に問題を発見基盤として、 [ **winrt::com_ptr 構造体のテンプレート**](/uwp/cpp-ref-for-winrt/com-ptr)します。</span><span class="sxs-lookup"><span data-stu-id="16a16-159">This helped uncover an issue where smart pointer classes weren't reliably handling self-assignment; rooted in the [**winrt::com_ptr struct template**](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="16a16-160">**winrt::com_ptr**が修正され、し、処理する固定イベント revokers 移動セマンティクスを正しく割り当て時に失効できるようにします。</span><span class="sxs-lookup"><span data-stu-id="16a16-160">**winrt::com_ptr** has been fixed, and the event revokers fixed to handle move semantics correctly so that they revoke upon assignment.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="16a16-161">重要な変更を加えました、 [C +/cli WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)1.0.181002.2 のバージョンでどちらもバージョン 1.0.190128.4 で後で。</span><span class="sxs-lookup"><span data-stu-id="16a16-161">Important changes were made to the [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix), both in version 1.0.181002.2, and then later in version 1.0.190128.4.</span></span> <span data-ttu-id="16a16-162">これらの変更と、既存のプロジェクトへの影響についての詳細については[Visual Studio のサポートを c++/cli WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)と[VSIX 拡張機能の以前のバージョン](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension)。</span><span class="sxs-lookup"><span data-stu-id="16a16-162">For details of these changes, and how they affect your existing projects, [Visual Studio support for C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package) and  [Earlier versions of the VSIX extension](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension).</span></span>

## <a name="isolation-from-windows-sdk-header-files"></a><span data-ttu-id="16a16-163">Windows SDK ヘッダー ファイルからの分離</span><span class="sxs-lookup"><span data-stu-id="16a16-163">Isolation from Windows SDK header files</span></span>

<span data-ttu-id="16a16-164">これは、可能性のあるコードの互換性に影響する変更です。</span><span class="sxs-lookup"><span data-stu-id="16a16-164">This is potentially a breaking change for your code.</span></span>

<span data-ttu-id="16a16-165">コンパイル、C +/cli WinRT が不要になった Windows SDK からのヘッダー ファイルに依存します。</span><span class="sxs-lookup"><span data-stu-id="16a16-165">For it to compile, C++/WinRT no longer depends on header files from the Windows SDK.</span></span> <span data-ttu-id="16a16-166">C ランタイム ライブラリ (CRT) および C++ 標準テンプレート ライブラリ (STL) のヘッダー ファイルは、すべての Windows SDK ヘッダーも含めないでください。</span><span class="sxs-lookup"><span data-stu-id="16a16-166">Header files in the C run-time library (CRT) and the C++ Standard Template Library (STL) also don't include any Windows SDK headers.</span></span> <span data-ttu-id="16a16-167">およびを標準への準拠を向上、不慮の依存関係を回避およびを防ぐために必要のあるマクロの数を大幅に短縮します。</span><span class="sxs-lookup"><span data-stu-id="16a16-167">And that improves standards compliance, avoids inadvertent dependencies, and greatly reduces the number of macros that you have to guard against.</span></span>

<span data-ttu-id="16a16-168">この独立性は c++/cli WinRT が移植性に優れてなり標準に準拠して、およびクロス コンパイラとクロス プラットフォーム ライブラリになる可能性を推進します。</span><span class="sxs-lookup"><span data-stu-id="16a16-168">This independence means that C++/WinRT is now more portable and standards compliant, and it furthers the possibility of it becoming a cross-compiler and cross-platform library.</span></span> <span data-ttu-id="16a16-169">意味 c++/cli WinRT ヘッダーが悪影響を及ぼす影響を受けるマクロはありません。</span><span class="sxs-lookup"><span data-stu-id="16a16-169">It also means that the C++/WinRT headers aren't adversely affected macros.</span></span>

<span data-ttu-id="16a16-170">C++ 以前ままの場合/cli WinRT を今すぐそれらを含める必要がありますし、プロジェクトで、任意の Windows ヘッダーを含めます。</span><span class="sxs-lookup"><span data-stu-id="16a16-170">If you previously left it to C++/WinRT to include any Windows headers in your project, then you'll now need to include them yourself.</span></span> <span data-ttu-id="16a16-171">いずれの場合も、常のベスト プラクティスを明示的に依存するヘッダーを含めるし、しない別のライブラリに含めることのままにします。</span><span class="sxs-lookup"><span data-stu-id="16a16-171">It is, in any case, always best practice to explicitly include the headers that you depend on, and not leave it to another library to include them for you.</span></span>

<span data-ttu-id="16a16-172">現時点では、Windows SDK ヘッダー ファイルの分離の唯一の例外は組み込み関数、および数値です。</span><span class="sxs-lookup"><span data-stu-id="16a16-172">Currently, the only exceptions to Windows SDK header file isolation are for intrinsics, and numerics.</span></span> <span data-ttu-id="16a16-173">この最後の残りの依存関係に関する既知の問題はありません。</span><span class="sxs-lookup"><span data-stu-id="16a16-173">There are no known issues with these last remaining dependencies.</span></span>

<span data-ttu-id="16a16-174">必要がある場合は、プロジェクトの Windows SDK のヘッダーとの相互運用を有効にできます再。</span><span class="sxs-lookup"><span data-stu-id="16a16-174">In your project, you can re-enable interop with the Windows SDK headers if you need to.</span></span> <span data-ttu-id="16a16-175">COM インターフェイスを実装する可能性があります、たとえば、(ルートと[ **IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509))。</span><span class="sxs-lookup"><span data-stu-id="16a16-175">You might, for example, want to implement a COM interface (rooted in [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)).</span></span> <span data-ttu-id="16a16-176">例では、含める`unknwn.h`すべて C + インクルードする前に/cli WinRT ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="16a16-176">For that example, include `unknwn.h` before you include any C++/WinRT headers.</span></span> <span data-ttu-id="16a16-177">そのため、C +/cli WinRT ベースのライブラリにクラシック COM インターフェイスをサポートするためにさまざまなフックを有効にします。</span><span class="sxs-lookup"><span data-stu-id="16a16-177">Doing so causes the C++/WinRT base library to enable various hooks to support classic COM interfaces.</span></span> <span data-ttu-id="16a16-178">コード例では、次を参照してください。 [C + での作成者の COM コンポーネント/cli WinRT](author-coclasses.md)します。</span><span class="sxs-lookup"><span data-stu-id="16a16-178">For a code example, see [Author COM components with C++/WinRT](author-coclasses.md).</span></span> <span data-ttu-id="16a16-179">同様に、宣言型や関数を呼び出そうとするその他の Windows SDK ヘッダーに明示的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="16a16-179">Similarly, explicitly include any other Windows SDK headers that declare types and/or functions that you want to call.</span></span>

## <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a><span data-ttu-id="16a16-180">C++ の再ターゲットする方法/cli 以降のバージョンの Windows SDK に WinRT プロジェクト</span><span class="sxs-lookup"><span data-stu-id="16a16-180">How to retarget your C++/WinRT project to a later version of the Windows SDK</span></span>

<span data-ttu-id="16a16-181">最小限のコンパイラとリンカーの問題が発生する可能性があるプロジェクトの再ターゲットのメソッドは、最も手間もあります。</span><span class="sxs-lookup"><span data-stu-id="16a16-181">The method for retargeting your project that's likely to result in the fewest compiler and linker issue is also the most labor-intensive.</span></span> <span data-ttu-id="16a16-182">(任意の Windows SDK のバージョンを対象とする) 新しいプロジェクトを作成し、古いからは経由で新しいプロジェクトのファイルをコピーし、そのメソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="16a16-182">That method involves creating a new project (targeting the Windows SDK version of your choice), and then copying files over to your new project from your old.</span></span> <span data-ttu-id="16a16-183">古いのセクションがあります`.vcxproj`と`.vcxproj.filters`できますファイルをコピー以上節約 Visual Studio でファイルを追加します。</span><span class="sxs-lookup"><span data-stu-id="16a16-183">There will be sections of your old `.vcxproj` and `.vcxproj.filters` files that you can just copy over to save you adding files in Visual Studio.</span></span>

<span data-ttu-id="16a16-184">ただし、Visual Studio でプロジェクトを再ターゲットするその他の 2 つの方法はあります。</span><span class="sxs-lookup"><span data-stu-id="16a16-184">However, there are two other ways to retarget your project in Visual Studio.</span></span>

- <span data-ttu-id="16a16-185">プロジェクトのプロパティに移動して**全般** \> **Windows SDK バージョン**を選択し、**すべての構成**と**すべてのプラットフォーム**します。</span><span class="sxs-lookup"><span data-stu-id="16a16-185">Go to project property **General** \> **Windows SDK Version**, and select **All Configurations** and **All Platforms**.</span></span> <span data-ttu-id="16a16-186">設定**Windows SDK バージョン**を対象とバージョン。</span><span class="sxs-lookup"><span data-stu-id="16a16-186">Set **Windows SDK Version** to the version that you want to target.</span></span>
- <span data-ttu-id="16a16-187">**ソリューション エクスプ ローラー**は、プロジェクト ノードを右クリックし、**プロジェクトの再ターゲット**をクリックして、ターゲット バージョンを選択**OK**。</span><span class="sxs-lookup"><span data-stu-id="16a16-187">In **Solution Explorer**, right-click the project node, click **Retarget Projects**, choose the version(s) you wish to target, and then click **OK**.</span></span>

<span data-ttu-id="16a16-188">これら 2 つのメソッドのいずれかを使用した後、コンパイラやリンカー エラーが発生するかどうかは、ソリューションをクリーニングを再試行してください (**ビルド** > **ソリューションのクリーン**またはすべてを手動で削除一時フォルダーおよびファイル) をもう一度ビルドを試みる前にします。</span><span class="sxs-lookup"><span data-stu-id="16a16-188">If you encounter any compiler or linker errors after using either of these two methods, then you can try cleaning the solution (**Build** > **Clean Solution** and/or manually delete all temporary folders and files) before trying to build again.</span></span>

<span data-ttu-id="16a16-189">C++ コンパイラが生成した場合"*エラー C2039:'IUnknown': のメンバーではない '\`グローバル名前空間'*"、追加し、`#include <unknwn.h>`の先頭に、`pch.h`ファイル (C +、インクルードする前に/cli WinRT ヘッダー)。</span><span class="sxs-lookup"><span data-stu-id="16a16-189">If the C++ compiler produces "*error C2039: 'IUnknown': is not a member of '\`global namespace''*", then add `#include <unknwn.h>` to the top of your `pch.h` file (before you include any C++/WinRT headers).</span></span>

<span data-ttu-id="16a16-190">追加する必要がありますも`#include <hstring.h>`にします。</span><span class="sxs-lookup"><span data-stu-id="16a16-190">You may also need to add `#include <hstring.h>` after that.</span></span>

<span data-ttu-id="16a16-191">C++ リンカーが生成した場合"*エラー LNK2019: 未解決の外部シンボル_WINRT_CanUnloadNow@0関数で参照されている_VSDesignerCanUnloadNow@0* "を追加することで解決できます`#define _VSDESIGNER_DONT_LOAD_AS_DLL`を`pch.h`ファイル。</span><span class="sxs-lookup"><span data-stu-id="16a16-191">If the C++ linker produces "*error LNK2019: unresolved external symbol _WINRT_CanUnloadNow@0 referenced in function _VSDesignerCanUnloadNow@0*", then you can resolve that by adding `#define _VSDESIGNER_DONT_LOAD_AS_DLL` to your `pch.h` file.</span></span>
