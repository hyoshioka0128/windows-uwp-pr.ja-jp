---
author: stevewhims
description: ニュースや変更を C++/WinRT します。
title: 新機能、C++/WinRT
ms.author: stwhi
ms.date: 10/03/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10、uwp、標準、c++、cpp、winrt、プロジェクション、ニュース、ものの新機能
ms.localizationpriority: medium
ms.openlocfilehash: bc6be28e112dfdd14b3585bd88ba066fbeae382d
ms.sourcegitcommit: 5c9a47b135c5f587214675e39c1ac058c0380f4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/04/2018
ms.locfileid: "4357774"
---
# <a name="whats-new-in-cwinrt"></a><span data-ttu-id="a2603-104">新機能、C++/WinRT</span><span class="sxs-lookup"><span data-stu-id="a2603-104">What's new in C++/WinRT</span></span>

<span data-ttu-id="a2603-105">次の表のニュースを含むし、への変更[、C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt)一般公開バージョンの最新の Windows SDK では 10.0.17763.0 (Windows 10、バージョン 1809)。</span><span class="sxs-lookup"><span data-stu-id="a2603-105">The table below contains news and changes to [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) in the latest generally-available version of the Windows SDK, which is 10.0.17763.0 (Windows 10, version 1809).</span></span> <span data-ttu-id="a2603-106">これらの変更は、それ以降の SDK Insider Preview バージョンに存在する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="a2603-106">These changes may also be present in later SDK Insider Preview versions.</span></span>

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a><span data-ttu-id="a2603-107">ニュース、変化と、Windows SDK バージョン 10.0.17763.0 (Windows 10、バージョン 1809)</span><span class="sxs-lookup"><span data-stu-id="a2603-107">News, and changes, in Windows SDK version 10.0.17763.0 (Windows 10, version 1809)</span></span>

| <span data-ttu-id="a2603-108">新規または変更された機能</span><span class="sxs-lookup"><span data-stu-id="a2603-108">New or changed feature</span></span> | <span data-ttu-id="a2603-109">詳細</span><span class="sxs-lookup"><span data-stu-id="a2603-109">More info</span></span> |
| - | - |
| <span data-ttu-id="a2603-110">**変更を中断**します。</span><span class="sxs-lookup"><span data-stu-id="a2603-110">**Breaking change**.</span></span> <span data-ttu-id="a2603-111">コンパイル、C + + WinRT は、Windows SDK からのヘッダーに依存しません。</span><span class="sxs-lookup"><span data-stu-id="a2603-111">For it to compile, C++/WinRT doesn't depend on headers from the Windows SDK.</span></span> | <span data-ttu-id="a2603-112">[Windows SDK ヘッダー ファイルから分離](#isolation-from-windows-sdk-header-files)、以下をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="a2603-112">See [Isolation from Windows SDK header files](#isolation-from-windows-sdk-header-files), below.</span></span> |
| <span data-ttu-id="a2603-113">Visual Studio のプロジェクト システム形式が変更されました。</span><span class="sxs-lookup"><span data-stu-id="a2603-113">The Visual Studio project system format has changed.</span></span> | <span data-ttu-id="a2603-114">参照してください[c++ ターゲットを変更する方法/以降のバージョンの Windows SDK に WinRT プロジェクト](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)ください。</span><span class="sxs-lookup"><span data-stu-id="a2603-114">See [How to retarget your C++/WinRT project to a later version of the Windows SDK](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk), below.</span></span> |
| <span data-ttu-id="a2603-115">新しい機能と、Windows ランタイム関数に渡すと、コレクション オブジェクトまたは独自のコレクションのプロパティとコレクション型を実装する基底クラスがあります。</span><span class="sxs-lookup"><span data-stu-id="a2603-115">There are new functions and base classes to help you pass a collection object to a Windows Runtime function, or to implement your own collection properties and collection types.</span></span> | <span data-ttu-id="a2603-116">参照してください[コレクション、C++/WinRT](collections.md)します。</span><span class="sxs-lookup"><span data-stu-id="a2603-116">See [Collections with C++/WinRT](collections.md).</span></span> |
| <span data-ttu-id="a2603-117">[{Binding}](/windows/uwp/xaml-platform/binding-markup-extension)マークアップ拡張機能を使用するには、C + + WinRT ランタイム クラスです。</span><span class="sxs-lookup"><span data-stu-id="a2603-117">You can use the [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) markup extension with your C++/WinRT runtime classes.</span></span> | <span data-ttu-id="a2603-118">詳しくとコード例については、[データ バインディングの概要](/windows/uwp/data-binding/data-binding-quickstart)をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="a2603-118">For more info, and code examples, see [Data binding overview](/windows/uwp/data-binding/data-binding-quickstart).</span></span> |
| <span data-ttu-id="a2603-119">コルーチンをキャンセルするサポートでは、取り消しコールバックを登録することができます。</span><span class="sxs-lookup"><span data-stu-id="a2603-119">Support for canceling a coroutine allows you to register a cancellation callback.</span></span> | <span data-ttu-id="a2603-120">詳しくとコード例については、[キャンセル非同期操作と取り消しコールバック](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks)をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="a2603-120">For more info, and code examples, see [Canceling an asychronous operation, and cancellation callbacks](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks).</span></span> |
| <span data-ttu-id="a2603-121">メンバー関数を指すデリゲートを作成するときは、強参照または弱参照を (raw*この*ポインター) ではなく、ハンドラーが登録されている時点での現在のオブジェクトを確立できます。</span><span class="sxs-lookup"><span data-stu-id="a2603-121">When creating a delegate pointing to a member function, you can establish a strong or a weak reference to the current object (instead of a raw *this* pointer) at the point where the handler is registered.</span></span> | <span data-ttu-id="a2603-122">詳しくとコード例については、[イベント処理デリゲートを使用して*この*ポインターを安全にアクセスする](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate)セクションで **、デリゲートとしてメンバー関数を使用する場合**のサブ セクションをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="a2603-122">For more info, and code examples, see the **If you use a member function as a delegate** sub-section in the section [Safely accessing the *this* pointer with an event-handling delegate](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).</span></span> |
| <span data-ttu-id="a2603-123">標準的な C++ に Visual Studio の適合性を向上を発見されたバグを修正します。</span><span class="sxs-lookup"><span data-stu-id="a2603-123">Bugs are fixed that were uncovered by Visual Studio's improved conformance to the C++ standard.</span></span> <span data-ttu-id="a2603-124">LLVM および Clang ツール チェーンがよりも活用すると、検証するには、C++/WinRT の標準への準拠します。</span><span class="sxs-lookup"><span data-stu-id="a2603-124">The LLVM and Clang toolchain is also better leveraged to validate C++/WinRT's standards conformance.</span></span> | <span data-ttu-id="a2603-125">しなくなった流通している問題[で説明されている理由されない [新しいプロジェクトのコンパイルかどうか。Visual Studio 2017 を使用している (バージョン 15.8.0 以上)、および SDK バージョン 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134)</span><span class="sxs-lookup"><span data-stu-id="a2603-125">You'll no longer encounter the issue described in [Why won't my new project compile? I'm using Visual Studio 2017 (version 15.8.0 or higher), and SDK version 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134)</span></span> |

<span data-ttu-id="a2603-126">その他の変更。</span><span class="sxs-lookup"><span data-stu-id="a2603-126">Other changes.</span></span>

- <span data-ttu-id="a2603-127">**変更を中断**します。</span><span class="sxs-lookup"><span data-stu-id="a2603-127">**Breaking change**.</span></span> <span data-ttu-id="a2603-128">[**winrt::get_abi(winrt::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi)返すようになりました`void*`の代わりに`HSTRING`します。</span><span class="sxs-lookup"><span data-stu-id="a2603-128">[**winrt::get_abi(winrt::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi) now returns `void*` instead of `HSTRING`.</span></span> <span data-ttu-id="a2603-129">使用することができます`static_cast<HSTRING>(get_abi(my_hstring));`、HSTRING を取得します。</span><span class="sxs-lookup"><span data-stu-id="a2603-129">You can use `static_cast<HSTRING>(get_abi(my_hstring));` to get an HSTRING.</span></span>
- <span data-ttu-id="a2603-130">**変更を中断**します。</span><span class="sxs-lookup"><span data-stu-id="a2603-130">**Breaking change**.</span></span> <span data-ttu-id="a2603-131">[**winrt::put_abi(winrt::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi)返すようになりました`void**`の代わりに`HSTRING*`します。</span><span class="sxs-lookup"><span data-stu-id="a2603-131">[**winrt::put_abi(winrt::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi) now returns `void**` instead of `HSTRING*`.</span></span> <span data-ttu-id="a2603-132">使用できる`reinterpret_cast<HSTRING*>(put_abi(my_hstring));`HSTRING \* を取得します。</span><span class="sxs-lookup"><span data-stu-id="a2603-132">You can use `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` to get an HSTRING\*.</span></span>
- <span data-ttu-id="a2603-133">**変更を中断**します。</span><span class="sxs-lookup"><span data-stu-id="a2603-133">**Breaking change**.</span></span> <span data-ttu-id="a2603-134">HRESULT は**winrt::hresult**として投影されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="a2603-134">HRESULT is now projected as **winrt::hresult**.</span></span> <span data-ttu-id="a2603-135">HRESULT (型の確認、または型の特性をサポートするためにに)、必要なかどうかは、できます`static_cast` **winrt::hresult**します。</span><span class="sxs-lookup"><span data-stu-id="a2603-135">If you need an HRESULT (to do type checking, or to support type traits), then you can `static_cast` a **winrt::hresult**.</span></span> <span data-ttu-id="a2603-136">それ以外の場合、 **winrt::hresult**に変換 HRESULT、含める限り`unknwn.h`c++ インクルードする前に +/winrt ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="a2603-136">Otherwise, **winrt::hresult** converts to HRESULT, as long as you include `unknwn.h` before you include any C++/WinRT headers.</span></span>
- <span data-ttu-id="a2603-137">**変更を中断**します。</span><span class="sxs-lookup"><span data-stu-id="a2603-137">**Breaking change**.</span></span> <span data-ttu-id="a2603-138">GUID は**winrt::guid**として投影されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="a2603-138">GUID is now projected as **winrt::guid**.</span></span> <span data-ttu-id="a2603-139">実装する Api では、GUID パラメーターの**winrt::guid**を使う必要があります。</span><span class="sxs-lookup"><span data-stu-id="a2603-139">For APIs that you implement, you must use **winrt::guid** for GUID parameters.</span></span> <span data-ttu-id="a2603-140">それ以外の場合、 **winrt::hresult**に変換、GUID を含める場合に限り`unknwn.h`c++ インクルードする前に +/winrt ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="a2603-140">Otherwise, **winrt::hresult** converts to GUID, as long as you include `unknwn.h` before you include any C++/WinRT headers.</span></span>
- <span data-ttu-id="a2603-141">**変更を中断**します。</span><span class="sxs-lookup"><span data-stu-id="a2603-141">**Breaking change**.</span></span> <span data-ttu-id="a2603-142">[**Winrt::handle_type コンス トラクター**](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor)が (は今すぐにくくを正しくないコードを記述する) を明示的にすることで強化されています。</span><span class="sxs-lookup"><span data-stu-id="a2603-142">The [**winrt::handle_type constructor**](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) has been hardened by making it explicit (it's now harder to write incorrect code with it).</span></span> <span data-ttu-id="a2603-143">ハンドルの生の値を割り当てる必要がある場合は、代わりに、 [**handle_type::attach 関数**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function)を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="a2603-143">If you need to assign a raw handle value, call the [**handle_type::attach function**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function) instead.</span></span>
- <span data-ttu-id="a2603-144">**変更を中断**します。</span><span class="sxs-lookup"><span data-stu-id="a2603-144">**Breaking change**.</span></span> <span data-ttu-id="a2603-145">**WINRT_CanUnloadNow**および**WINRT_GetActivationFactory**のシグネチャが変更されました。</span><span class="sxs-lookup"><span data-stu-id="a2603-145">The signatures of **WINRT_CanUnloadNow** and **WINRT_GetActivationFactory** have changed.</span></span> <span data-ttu-id="a2603-146">これらの関数はまったく宣言照準します。</span><span class="sxs-lookup"><span data-stu-id="a2603-146">You mustn't declare these functions at all.</span></span> <span data-ttu-id="a2603-147">含める代わりに、 `winrt/base.h` (c++ を含める場合に自動的に含まれる//winrt Windows 名前空間のヘッダー ファイル) に、これらの機能の宣言が含まれます。</span><span class="sxs-lookup"><span data-stu-id="a2603-147">Instead, include `winrt/base.h` (which is automatically included if you include any C++/WinRT Windows namespace header files) to include the declarations of these functions.</span></span>
- <span data-ttu-id="a2603-148">[**Winrt::clock 構造体**](/uwp/cpp-ref-for-winrt/clock) **from_FILETIME/to_FILETIME**は廃止**from_file_time/to_file_time**推奨されなくなりました。</span><span class="sxs-lookup"><span data-stu-id="a2603-148">For the [**winrt::clock struct**](/uwp/cpp-ref-for-winrt/clock), **from_FILETIME/to_FILETIME** are deprecated in favor of **from_file_time/to_file_time**.</span></span>
- <span data-ttu-id="a2603-149">**IBuffer**パラメーターを期待する Api が簡略化します。</span><span class="sxs-lookup"><span data-stu-id="a2603-149">APIs that expect **IBuffer** parameters are simplified.</span></span> <span data-ttu-id="a2603-150">ただし、ほとんどの Api は、コレクションまたは配列を必要に応じて、十分な Api は C++ からこのような Api を使用する方が簡単に必要な**IBuffer**に依存します。</span><span class="sxs-lookup"><span data-stu-id="a2603-150">Although most APIs prefer collections or arrays, enough APIs rely on **IBuffer** that it needed to be easier to use such APIs from C++.</span></span> <span data-ttu-id="a2603-151">この更新プログラムは、C++ 標準ライブラリのコンテナーで使用される同じデータ名前付け規則を使用して、 **IBuffer**実装の背後にあるデータへの直接アクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="a2603-151">This update provides direct access to the data behind an **IBuffer** implementation, using the same data naming convention used by the C++ Standard Library containers.</span></span> <span data-ttu-id="a2603-152">これは、従来どおり大文字で始まるメタデータ名との衝突もなくなります。</span><span class="sxs-lookup"><span data-stu-id="a2603-152">This also avoids colliding with metadata names that conventionally begin with an uppercase letter.</span></span>
- <span data-ttu-id="a2603-153">コード生成の向上: コードのサイズを小さくさまざまな機能強化の向上、インラインと工場出荷時のキャッシュを最適化します。</span><span class="sxs-lookup"><span data-stu-id="a2603-153">Improved code generation: various improvements to reduce code size, improve inlining, and optimize factory caching.</span></span>
- <span data-ttu-id="a2603-154">不要な再帰を削除します。</span><span class="sxs-lookup"><span data-stu-id="a2603-154">Removed unnecessary recursion.</span></span> <span data-ttu-id="a2603-155">とき、コマンド ラインは特定のではなく、フォルダーに`.winmd`、`cppwinrt.exe`ツールを再帰的を検索されなくなった`.winmd`ファイル。</span><span class="sxs-lookup"><span data-stu-id="a2603-155">When the command-line refers to a folder, rather than to a specific `.winmd`, the `cppwinrt.exe` tool no longer searches recursively for `.winmd` files.</span></span> <span data-ttu-id="a2603-156">`cppwinrt.exe`ツールも処理重複よりインテリジェントなに適切な形式は、ユーザーのエラーを回復力の強化`.winmd`ファイル。</span><span class="sxs-lookup"><span data-stu-id="a2603-156">The `cppwinrt.exe` tool also now handles duplicates more intelligently, making it more resilient to user error, and to poorly-formed `.winmd` files.</span></span>
- <span data-ttu-id="a2603-157">スマート ポインターを強化します。</span><span class="sxs-lookup"><span data-stu-id="a2603-157">Hardened smart pointers.</span></span> <span data-ttu-id="a2603-158">以前は、取り消すときに失敗したイベント revokers 移動に割り当てられた新しい値。</span><span class="sxs-lookup"><span data-stu-id="a2603-158">Formerly, the event revokers failed to revoke when move-assigned a new value.</span></span> <span data-ttu-id="a2603-159">これスマート ポインター クラス自動割り当ての処理を減少が生じない確実に問題が明らかになりました[**winrt::com_ptr 構造体のテンプレート**](/uwp/cpp-ref-for-winrt/com-ptr)が発行されます。</span><span class="sxs-lookup"><span data-stu-id="a2603-159">This helped uncover an issue where smart pointer classes weren't reliably handling self-assignment; rooted in the [**winrt::com_ptr struct template**](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="a2603-160">**winrt::com_ptr**が修正されましたし、処理する固定イベント revokers 移動セマンティクス正しく割り当て時に取り消すことができるようにします。</span><span class="sxs-lookup"><span data-stu-id="a2603-160">**winrt::com_ptr** has been fixed, and the event revokers fixed to handle move semantics correctly so that they revoke upon assignment.</span></span>

> [!NOTE]
> <span data-ttu-id="a2603-161">バージョン 1.0.181002.2 (またはそれ以降) の[、C++/WinRT Visual Studio Extension (VSIX)](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)インストールされると、作成するには、新しい C + + WinRT プロジェクトは、そのプロジェクトの[Microsoft.Windows.CppWinRT NuGet パッケージ](https://www.nuget.org/packages/Microsoft.Windows.CppWinRT/)を自動的にインストールします。</span><span class="sxs-lookup"><span data-stu-id="a2603-161">With version 1.0.181002.2 (or later) of the [C++/WinRT Visual Studio Extension (VSIX)](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix) installed, creating a new C++/WinRT project automatically installs the [Microsoft.Windows.CppWinRT NuGet package](https://www.nuget.org/packages/Microsoft.Windows.CppWinRT/) for that project.</span></span> <span data-ttu-id="a2603-162">Microsoft.Windows.CppWinRT NuGet パッケージを提供強化 C + + WinRT プロジェクト ビルドのサポート、開発コンピューターと (NuGet パッケージと、VSIX ではないがインストールされている)、ビルド エージェントの間で移植プロジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="a2603-162">The Microsoft.Windows.CppWinRT NuGet package provides improved C++/WinRT project build support, making your project portable between a development machine and a build agent (on which only the NuGet package, and not the VSIX, is installed).</span></span>
>
> <span data-ttu-id="a2603-163">既存のプロジェクトの&mdash;1.0.181002.2 のバージョンをインストールした後 (またはそれ以降) VSIX の&mdash;Visual Studio でプロジェクトを開く場合は、**プロジェクト**をクリックすることをお勧めします \> **NuGet パッケージの管理]** \> **参照**を、入力または**Microsoft.Windows.CppWinRT**検索ボックスに、検索結果、項目を選択し、貼り付け**インストール**をそのプロジェクトのパッケージをインストールする] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="a2603-163">For an existing project&mdash;after you've installed version 1.0.181002.2 (or later) of the VSIX&mdash;we recommend that you open the project in Visual Studio, click **Project** \> **Manage NuGet Packages...** \> **Browse**, type or paste **Microsoft.Windows.CppWinRT** in the search box, select the item in search results, and then click **Install** to install the package for that project.</span></span>


## <a name="isolation-from-windows-sdk-header-files"></a><span data-ttu-id="a2603-164">Windows SDK ヘッダー ファイルから分離</span><span class="sxs-lookup"><span data-stu-id="a2603-164">Isolation from Windows SDK header files</span></span>

<span data-ttu-id="a2603-165">これは、可能性のあるコードの変更点です。</span><span class="sxs-lookup"><span data-stu-id="a2603-165">This is potentially a breaking change for your code.</span></span>

<span data-ttu-id="a2603-166">コンパイル、C + + WinRT がしなくなったから Windows SDK ヘッダー ファイルに依存します。</span><span class="sxs-lookup"><span data-stu-id="a2603-166">For it to compile, C++/WinRT no longer depends on header files from the Windows SDK.</span></span> <span data-ttu-id="a2603-167">また、C ランタイム ライブラリ (CRT) と C++ 標準テンプレート ライブラリ (STL) のヘッダー ファイルは、Windows SDK ヘッダーを含めないでください。</span><span class="sxs-lookup"><span data-stu-id="a2603-167">Header files in the C run-time library (CRT) and the C++ Standard Template Library (STL) also don't include any Windows SDK headers.</span></span> <span data-ttu-id="a2603-168">ファイルとを標準への準拠を向上、不注意の依存関係を回避に備える必要があるマクロの数を大幅に減少します。</span><span class="sxs-lookup"><span data-stu-id="a2603-168">And that improves standards compliance, avoids inadvertent dependencies, and greatly reduces the number of macros that you have to guard against.</span></span>

<span data-ttu-id="a2603-169">このに依存しないことを意味する、C++/WinRT は複数の移植性と標準に準拠しないため、なり、クロス コンパイラとクロス プラットフォームのライブラリになる可能性を推進します。</span><span class="sxs-lookup"><span data-stu-id="a2603-169">This independence means that C++/WinRT is now more portable and standards compliant, and it furthers the possibility of it becoming a cross-compiler and cross-platform library.</span></span> <span data-ttu-id="a2603-170">意味を C++/cli/winrt ヘッダーいない悪影響を与える影響を受けるマクロです。</span><span class="sxs-lookup"><span data-stu-id="a2603-170">It also means that the C++/WinRT headers aren't adversely affected macros.</span></span>

<span data-ttu-id="a2603-171">C++ 以前左する場合/WinRT 今すぐそれらを含める必要がありますし、プロジェクトで、Windows ヘッダーをインクルードします。</span><span class="sxs-lookup"><span data-stu-id="a2603-171">If you previously left it to C++/WinRT to include any Windows headers in your project, then you'll now need to include them yourself.</span></span> <span data-ttu-id="a2603-172">いずれの場合でも、常のベスト プラクティスを明示的に依存するヘッダーを含めるし、別のライブラリに含めることをしないままにします。</span><span class="sxs-lookup"><span data-stu-id="a2603-172">It is, in any case, always best practice to explicitly include the headers that you depend on, and not leave it to another library to include them for you.</span></span>

<span data-ttu-id="a2603-173">現時点では、Windows SDK ヘッダー ファイルの分離の唯一の例外は、組み込みと数値です。</span><span class="sxs-lookup"><span data-stu-id="a2603-173">Currently, the only exceptions to Windows SDK header file isolation are for intrinsics, and numerics.</span></span> <span data-ttu-id="a2603-174">これら最後の残りの依存関係のある既知の問題はありません。</span><span class="sxs-lookup"><span data-stu-id="a2603-174">There are no known issues with these last remaining dependencies.</span></span>

<span data-ttu-id="a2603-175">プロジェクトを再度有効にする Windows SDK ヘッダーと相互運用する必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="a2603-175">In your project, you can re-enable interop with the Windows SDK headers if you need to.</span></span> <span data-ttu-id="a2603-176">たとえば、( [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)をルートと)、COM インターフェイスを実装する、可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a2603-176">You might, for example, want to implement a COM interface (rooted in [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)).</span></span> <span data-ttu-id="a2603-177">この例では、含める`unknwn.h`c++ インクルードする前に +/winrt ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="a2603-177">For that example, include `unknwn.h` before you include any C++/WinRT headers.</span></span> <span data-ttu-id="a2603-178">その原因を行うには c++/cli 従来の COM インターフェイスをサポートするさまざまなフックを有効にする/winrt 基本ライブラリ。</span><span class="sxs-lookup"><span data-stu-id="a2603-178">Doing so causes the C++/WinRT base library to enable various hooks to support classic COM interfaces.</span></span> <span data-ttu-id="a2603-179">コード例を参照してください。[作成者 COM コンポーネントにおいて、C++/WinRT](author-coclasses.md)します。</span><span class="sxs-lookup"><span data-stu-id="a2603-179">For a code example, see [Author COM components with C++/WinRT](author-coclasses.md).</span></span> <span data-ttu-id="a2603-180">同様に、種類やを呼び出して関数を宣言する他の Windows SDK ヘッダーを明示的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="a2603-180">Similarly, explicitly include any other Windows SDK headers that declare types and/or functions that you want to call.</span></span>

## <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a><span data-ttu-id="a2603-181">C++ のターゲットに変更する方法/以降のバージョンの Windows SDK に WinRT プロジェクト</span><span class="sxs-lookup"><span data-stu-id="a2603-181">How to retarget your C++/WinRT project to a later version of the Windows SDK</span></span>

<span data-ttu-id="a2603-182">また、最小限のコンパイラとリンカーの問題が発生する可能性があるプロジェクトの再ターゲットのメソッドでは最も労力が必要です。</span><span class="sxs-lookup"><span data-stu-id="a2603-182">The method for retargeting your project that's likely to result in the fewest compiler and linker issue is also the most labor-intensive.</span></span> <span data-ttu-id="a2603-183">(任意の Windows SDK バージョンをターゲットと)、新しいプロジェクトを作成して、古いからは経由で新しいプロジェクトのファイルをコピーし、そのメソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="a2603-183">That method involves creating a new project (targeting the Windows SDK version of your choice), and then copying files over to your new project from your old.</span></span> <span data-ttu-id="a2603-184">古いのセクションがあります`.vcxproj`と`.vcxproj.filters`すればファイルのコピーで Visual Studio でファイルを追加することができます。</span><span class="sxs-lookup"><span data-stu-id="a2603-184">There will be sections of your old `.vcxproj` and `.vcxproj.filters` files that you can just copy over to save you adding files in Visual Studio.</span></span>

<span data-ttu-id="a2603-185">ただし、Visual Studio でプロジェクトのターゲットを変更するその他の 2 つの方法はあります。</span><span class="sxs-lookup"><span data-stu-id="a2603-185">However, there are two other ways to retarget your project in Visual Studio.</span></span>

- <span data-ttu-id="a2603-186">**一般的な**プロパティをプロジェクトに移動する \> **Windows SDK バージョン**、および選択の**すべての構成**と**すべてのプラットフォーム**です。</span><span class="sxs-lookup"><span data-stu-id="a2603-186">Go to project property **General** \> **Windows SDK Version**, and select **All Configurations** and **All Platforms**.</span></span> <span data-ttu-id="a2603-187">バージョンをターゲットにするには、 **Windows SDK バージョン**を設定します。</span><span class="sxs-lookup"><span data-stu-id="a2603-187">Set **Windows SDK Version** to the version that you want to target.</span></span>
- <span data-ttu-id="a2603-188">**ソリューション エクスプ ローラー**でプロジェクト ノードを右クリックして、**プロジェクトの再ターゲット**] をクリックを対象とするバージョンを選択し、 **[ok]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="a2603-188">In **Solution Explorer**, right-click the project node, click **Retarget Projects**, choose the version(s) you wish to target, and then click **OK**.</span></span>

<span data-ttu-id="a2603-189">これら 2 つのメソッドのいずれかを使用した後、コンパイラやリンカーのエラーが発生するかどうかは、ソリューションをクリーンアップしてみてください (**ビルド** > **クリーンなソリューション**や、すべての一時フォルダーとファイルを手動で削除) もう一度ビルドを試みる前にします。</span><span class="sxs-lookup"><span data-stu-id="a2603-189">If you encounter any compiler or linker errors after using either of these two methods, then you can try cleaning the solution (**Build** > **Clean Solution** and/or manually delete all temporary folders and files) before trying to build again.</span></span>

<span data-ttu-id="a2603-190">C++ コンパイラーが場合"*エラー C2039: 'IUnknown': のメンバーでない '\'global 名前空間'*"、追加し、`#include <unknwn.h>`の先頭に、`pch.h`ファイル (c++ インクルードする前に +/winrt ヘッダー)。</span><span class="sxs-lookup"><span data-stu-id="a2603-190">If the C++ compiler produces "*error C2039: 'IUnknown': is not a member of '\`global namespace''*", then add `#include <unknwn.h>` to the top of your `pch.h` file (before you include any C++/WinRT headers).</span></span>

<span data-ttu-id="a2603-191">You may also need to add `#include <hstring.h>` after that.</span><span class="sxs-lookup"><span data-stu-id="a2603-191">You may also need to add `#include <hstring.h>` after that.</span></span>

<span data-ttu-id="a2603-192">C++ リンカーを生成する場合"*エラー lnk 2019: 外部シンボルは未解決です_WINRT_CanUnloadNow@0関数で参照されている_VSDesignerCanUnloadNow@0*"を追加することで解決できます`#define _VSDESIGNER_DONT_LOAD_AS_DLL`を`pch.h`ファイル。</span><span class="sxs-lookup"><span data-stu-id="a2603-192">If the C++ linker produces "*error LNK2019: unresolved external symbol _WINRT_CanUnloadNow@0 referenced in function _VSDesignerCanUnloadNow@0*", then you can resolve that by adding `#define _VSDESIGNER_DONT_LOAD_AS_DLL` to your `pch.h` file.</span></span>
