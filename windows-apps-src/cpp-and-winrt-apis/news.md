---
description: C++/WinRT に関するニュースと変更内容です。
title: 新しい c++/cli WinRT
ms.date: 04/02/2019
ms.topic: article
keywords: windows 10、uwp、standard、c++、cpp、winrt、プロジェクション、ニュース、ものの新しい
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: 8ee10450a7a346c1ae032240aaecc65e7f87822d
ms.sourcegitcommit: 940645c705865ba9635ccae2da9d917420faf608
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/02/2019
ms.locfileid: "58812611"
---
# <a name="whats-new-in-cwinrt"></a><span data-ttu-id="58b89-104">新しい c++/cli WinRT</span><span class="sxs-lookup"><span data-stu-id="58b89-104">What's new in C++/WinRT</span></span>

## <a name="news-and-changes-in-cwinrt-20"></a><span data-ttu-id="58b89-105">ニュース、および変更でC++WinRT 2.0</span><span class="sxs-lookup"><span data-stu-id="58b89-105">News, and changes, in C++/WinRT 2.0</span></span>

<span data-ttu-id="58b89-106">詳細について、 [ C++WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)、 [Microsoft.Windows.CppWinRT NuGet パッケージ](https://www.nuget.org/packages/Microsoft.Windows.CppWinRT/)、および、`cppwinrt.exe`ツール&mdash;する方法についても取得してインストールする&mdash;を参照してください[Visual Studio のサポートC++/WinRT、XAML、VSIX 拡張機能、および NuGet パッケージ](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-106">For more info about the [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix), the [Microsoft.Windows.CppWinRT NuGet package](https://www.nuget.org/packages/Microsoft.Windows.CppWinRT/), and the the `cppwinrt.exe` tool&mdash;including how to acquire and install them&mdash;see [Visual Studio support for C++/WinRT, XAML, the VSIX extension, and the NuGet package](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).</span></span>

### <a name="changes-to-the-cwinrt-visual-studio-extension-vsix-for-version-20"></a><span data-ttu-id="58b89-107">変更、 C++WinRT Visual Studio Extension (VSIX) バージョン 2.0</span><span class="sxs-lookup"><span data-stu-id="58b89-107">Changes to the C++/WinRT Visual Studio Extension (VSIX) for version 2.0</span></span>

- <span data-ttu-id="58b89-108">ビジュアライザーのデバッグを Visual Studio 2019; サポートします。Visual Studio 2017 をサポートするために続行します。</span><span class="sxs-lookup"><span data-stu-id="58b89-108">The debug visualizer now supports Visual Studio 2019; as well as continuing to support Visual Studio 2017.</span></span>
- <span data-ttu-id="58b89-109">多くのバグ修正が加えられました。</span><span class="sxs-lookup"><span data-stu-id="58b89-109">Numerous bug fixes have been made.</span></span>

### <a name="changes-to-the-microsoftwindowscppwinrt-nuget-package-for-version-20"></a><span data-ttu-id="58b89-110">バージョン 2.0 の Microsoft.Windows.CppWinRT NuGet パッケージへの変更</span><span class="sxs-lookup"><span data-stu-id="58b89-110">Changes to the Microsoft.Windows.CppWinRT NuGet package for version 2.0</span></span>

- <span data-ttu-id="58b89-111">`cppwinrt.exe` Microsoft.Windows.CppWinRT NuGet パッケージでツールが含まれるようになりましたし、ツールは、必要に応じてプロジェクトごとにトラステッド プラットフォーム プロジェクション ヘッダーを生成します。</span><span class="sxs-lookup"><span data-stu-id="58b89-111">The `cppwinrt.exe` tool is now included in the Microsoft.Windows.CppWinRT NuGet package, and the tool generates platfom projection headers for each project on demand.</span></span> <span data-ttu-id="58b89-112">その結果、 `cppwinrt.exe` (ただし、引き続き、ツールは、互換性の理由から、SDK が付属しています)、このツールは、不要になった Windows sdk によって異なります。</span><span class="sxs-lookup"><span data-stu-id="58b89-112">Consequently, the `cppwinrt.exe` tool no longer depends on the Windows SDK (although, the tool still ships with the SDK for compatibility reasons).</span></span>
- <span data-ttu-id="58b89-113">`cppwinrt.exe` これで各プラットフォーム/構成固有中間フォルダー ($IntDir) 並行ビルドを有効にするプロジェクション ヘッダーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="58b89-113">`cppwinrt.exe` now generates projection headers under each platform/configuration-specific intermediate folder ($IntDir) to enable parallel builds.</span></span>
- <span data-ttu-id="58b89-114">C++/WinRT ビルドのサポート (プロパティ/ターゲット) が完全に記述されました、プロジェクト ファイルを手動でカスタマイズする場合。</span><span class="sxs-lookup"><span data-stu-id="58b89-114">The C++/WinRT build support (props/targets) is now fully documented, in case you want to manually customize your project files.</span></span> <span data-ttu-id="58b89-115">参照してください[Microsoft.Windows.CppWinRT NuGet パッケージ](https://github.com/Microsoft/xlang/tree/user/sjones/cppwinrt_nuget/src/package/nuget)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-115">See [Microsoft.Windows.CppWinRT NuGet Package](https://github.com/Microsoft/xlang/tree/user/sjones/cppwinrt_nuget/src/package/nuget).</span></span>
- <span data-ttu-id="58b89-116">多くのバグ修正が加えられました。</span><span class="sxs-lookup"><span data-stu-id="58b89-116">Numerous bug fixes have been made.</span></span>

### <a name="changes-to-cwinrt-for-version-20"></a><span data-ttu-id="58b89-117">変更C++/WinRT バージョン 2.0</span><span class="sxs-lookup"><span data-stu-id="58b89-117">Changes to C++/WinRT for version 2.0</span></span>

#### <a name="open-source"></a><span data-ttu-id="58b89-118">オープン ソース</span><span class="sxs-lookup"><span data-stu-id="58b89-118">Open source</span></span>

<span data-ttu-id="58b89-119">`cppwinrt.exe`ツールは Windows ランタイム メタデータ (`.winmd`) ファイルを開き、そこからヘッダー ファイル ベースの標準が生成されますC++ライブラリを*プロジェクト*メタデータで説明する Api。</span><span class="sxs-lookup"><span data-stu-id="58b89-119">The `cppwinrt.exe` tool takes a Windows Runtime metadata (`.winmd`) file, and generates from it a header-file-based standard C++ library that *projects* the APIs described in the metadata.</span></span> <span data-ttu-id="58b89-120">そうすることから、それらの Api を使用することができます、 C++/WinRT コード。</span><span class="sxs-lookup"><span data-stu-id="58b89-120">That way, you can consume those APIs from your C++/WinRT code.</span></span>

<span data-ttu-id="58b89-121">このツールは、完全オープン ソース プロジェクト、GitHub で入手できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="58b89-121">This tool is now an entirely open source project, available on GitHub.</span></span> <span data-ttu-id="58b89-122">参照してください[Microsoft\/xlang](https://github.com/Microsoft/xlang)をクリック**src** > **ツール** > **cppwinrt**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-122">Visit [Microsoft\/xlang](https://github.com/Microsoft/xlang), and then click in to **src** > **tool** > **cppwinrt**.</span></span>

#### <a name="xlang-libraries"></a><span data-ttu-id="58b89-123">xlang ライブラリ</span><span class="sxs-lookup"><span data-stu-id="58b89-123">xlang libraries</span></span>

<span data-ttu-id="58b89-124">(Windows ランタイムで使用される ECMA 335 メタデータ形式を解析) を完全に移植のヘッダーのみのライブラリは、すべての Windows ランタイムおよびツールの今後 xlang の基礎を形成します。</span><span class="sxs-lookup"><span data-stu-id="58b89-124">A completely portable header-only library (for parsing the ECMA-335 metadata format used by the Windows Runtime) forms the basis of all the Windows Runtime and xlang tooling going forward.</span></span> <span data-ttu-id="58b89-125">またを書き直して特に、`cppwinrt.exe`ツール地表から xlang ライブラリを使用します。</span><span class="sxs-lookup"><span data-stu-id="58b89-125">Notably, we also rewrote the `cppwinrt.exe` tool from the ground up using the xlang libraries.</span></span> <span data-ttu-id="58b89-126">これにより、長期にわたる、いくつかの問題を解決、メタデータのより正確なクエリ、 C++/WinRT 言語プロジェクションです。</span><span class="sxs-lookup"><span data-stu-id="58b89-126">This provides far more accurate metadata queries, solving a few long-standing issues with the C++/WinRT language projection.</span></span>

#### <a name="fewer-dependencies"></a><span data-ttu-id="58b89-127">依存関係</span><span class="sxs-lookup"><span data-stu-id="58b89-127">Fewer dependencies</span></span>

<span data-ttu-id="58b89-128">により、xlang メタデータ リーダー、`cppwinrt.exe`ツール自体は少ない依存しています。</span><span class="sxs-lookup"><span data-stu-id="58b89-128">Due to the xlang metadata reader, the `cppwinrt.exe` tool itself has fewer dependencies.</span></span> <span data-ttu-id="58b89-129">これによりより柔軟なより多くのシナリオで使用できるのと同様&mdash;特にで制約付きの環境を構築します。</span><span class="sxs-lookup"><span data-stu-id="58b89-129">This makes it far more flexible, as well as being usable in more scenarios&mdash;especially in constrained build environments.</span></span> <span data-ttu-id="58b89-130">特に、不要になった依存`RoMetadata.dll`します。</span><span class="sxs-lookup"><span data-stu-id="58b89-130">Notably, it no longer relies on `RoMetadata.dll`.</span></span>
 
<span data-ttu-id="58b89-131">これらの依存関係は、 `cppwinrt.exe` 2.0。</span><span class="sxs-lookup"><span data-stu-id="58b89-131">These are the dependencies for `cppwinrt.exe` 2.0.</span></span>
 
- <span data-ttu-id="58b89-132">api-ms-win-core-processenvironment-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-132">api-ms-win-core-processenvironment-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-133">api-ms-win-core-libraryloader-l1-2-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-133">api-ms-win-core-libraryloader-l1-2-0.dll</span></span>
- <span data-ttu-id="58b89-134">XmlLite.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-134">XmlLite.dll</span></span>
- <span data-ttu-id="58b89-135">api-ms-win-core-memory-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-135">api-ms-win-core-memory-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-136">api-ms-win-core-handle-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-136">api-ms-win-core-handle-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-137">api-ms-win-core-file-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-137">api-ms-win-core-file-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-138">SHLWAPI.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-138">SHLWAPI.dll</span></span>
- <span data-ttu-id="58b89-139">ADVAPI32.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-139">ADVAPI32.dll</span></span>
- <span data-ttu-id="58b89-140">KERNEL32.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-140">KERNEL32.dll</span></span>
- <span data-ttu-id="58b89-141">api-ms-win-core-rtlsupport-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-141">api-ms-win-core-rtlsupport-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-142">api-ms-win-core-processthreads-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-142">api-ms-win-core-processthreads-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-143">api-ms-win-core-heap-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-143">api-ms-win-core-heap-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-144">api-ms-win-core-console-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-144">api-ms-win-core-console-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-145">api-ms-win-core-localization-l1-2-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-145">api-ms-win-core-localization-l1-2-0.dll</span></span>

<span data-ttu-id="58b89-146">これらの依存関係とは対照的が`cppwinrt.exe`1.0 には。</span><span class="sxs-lookup"><span data-stu-id="58b89-146">Contrasting with these dependencies, which `cppwinrt.exe` 1.0 has.</span></span>

- <span data-ttu-id="58b89-147">ADVAPI32.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-147">ADVAPI32.dll</span></span>
- <span data-ttu-id="58b89-148">SHELL32.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-148">SHELL32.dll</span></span>
- <span data-ttu-id="58b89-149">api-ms-win-core-file-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-149">api-ms-win-core-file-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-150">XmlLite.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-150">XmlLite.dll</span></span>
- <span data-ttu-id="58b89-151">api-ms-win-core-libraryloader-l1-2-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-151">api-ms-win-core-libraryloader-l1-2-0.dll</span></span>
- <span data-ttu-id="58b89-152">api-ms-win-core-processenvironment-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-152">api-ms-win-core-processenvironment-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-153">RoMetadata.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-153">RoMetadata.dll</span></span>
- <span data-ttu-id="58b89-154">SHLWAPI.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-154">SHLWAPI.dll</span></span>
- <span data-ttu-id="58b89-155">KERNEL32.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-155">KERNEL32.dll</span></span>
- <span data-ttu-id="58b89-156">api-ms-win-core-rtlsupport-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-156">api-ms-win-core-rtlsupport-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-157">api-ms-win-core-heap-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-157">api-ms-win-core-heap-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-158">api-ms-win-core-timezone-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-158">api-ms-win-core-timezone-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-159">api-ms-win-core-console-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-159">api-ms-win-core-console-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-160">api-ms-win-core-localization-l1-2-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-160">api-ms-win-core-localization-l1-2-0.dll</span></span>
- <span data-ttu-id="58b89-161">OLEAUT32.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-161">OLEAUT32.dll</span></span>
- <span data-ttu-id="58b89-162">api-ms-win-core-winrt-error-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-162">api-ms-win-core-winrt-error-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-163">api-ms-win-core-winrt-error-l1-1-1.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-163">api-ms-win-core-winrt-error-l1-1-1.dll</span></span>
- <span data-ttu-id="58b89-164">api-ms-win-core-winrt-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-164">api-ms-win-core-winrt-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-165">api-ms-win-core-winrt-string-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-165">api-ms-win-core-winrt-string-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-166">api-ms-win-core-synch-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-166">api-ms-win-core-synch-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-167">api-ms-win-core-threadpool-l1-2-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-167">api-ms-win-core-threadpool-l1-2-0.dll</span></span>
- <span data-ttu-id="58b89-168">api-ms-win-core-com-l1-1-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-168">api-ms-win-core-com-l1-1-0.dll</span></span>
- <span data-ttu-id="58b89-169">api-ms-win-core-com-l1-1-1.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-169">api-ms-win-core-com-l1-1-1.dll</span></span>
- <span data-ttu-id="58b89-170">api-ms-win-core-synch-l1-2-0.dll</span><span class="sxs-lookup"><span data-stu-id="58b89-170">api-ms-win-core-synch-l1-2-0.dll</span></span> 

#### <a name="the-windows-runtime-noexcept-attribute"></a><span data-ttu-id="58b89-171">Windows ランタイム`noexcept`属性</span><span class="sxs-lookup"><span data-stu-id="58b89-171">The Windows Runtime `noexcept` attribute</span></span>

<span data-ttu-id="58b89-172">Windows ランタイムは新しい`[noexcept]`、属性、メソッドとプロパティを修飾するために使用することが[MIDL 3.0](/uwp/midl-3/predefined-attributes)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-172">The Windows Runtime has a new `[noexcept]` attribute, which you may use to decorate your methods and properties in [MIDL 3.0](/uwp/midl-3/predefined-attributes).</span></span> <span data-ttu-id="58b89-173">属性の有無は、実装が例外をスローしないツールのサポートすることを示します (障害のあるを返すも HRESULT)。</span><span class="sxs-lookup"><span data-stu-id="58b89-173">The presence of the attribute indicates to supporting tools that your implementation doesn't throw an exception (nor return a failing HRESULT).</span></span> <span data-ttu-id="58b89-174">これにより、言語プロジェクションが失敗する可能性のあるアプリケーション バイナリ インターフェイス (ABI) の呼び出しをサポートするために必要な例外処理のオーバーヘッドを回避することでコード生成を最適化することができます。</span><span class="sxs-lookup"><span data-stu-id="58b89-174">This allows language projections to optimize code-generation by avoiding the exception-handling overhead that's required to support application binary interface (ABI) calls that can potentially fail.</span></span>

<span data-ttu-id="58b89-175">C++/WinRT を生成するこの方法の利点は、 C++ `noexcept`実装、消費し、コードを作成します。</span><span class="sxs-lookup"><span data-stu-id="58b89-175">C++/WinRT takes advantage of this by producing C++ `noexcept` implementations of both the consuming and authoring code.</span></span> <span data-ttu-id="58b89-176">API のメソッドまたは、失敗のないとしているプロパティは、コードのサイズに関する懸念している場合は、この属性を調査できます。</span><span class="sxs-lookup"><span data-stu-id="58b89-176">If you have API methods or properties that are fail-free, and you're concerned about code size, then you can investigate this attribute.</span></span>

#### <a name="optimized-code-generation"></a><span data-ttu-id="58b89-177">最適化されたコード生成</span><span class="sxs-lookup"><span data-stu-id="58b89-177">Optimized code-generation</span></span>

<span data-ttu-id="58b89-178">C++/WinRT を今すぐ生成効率がいっそう高まりますC++ソース コード (バック グラウンドで) ので、C++コンパイラは、最小値と最も効率的なバイナリ コード可能性を生成できます。</span><span class="sxs-lookup"><span data-stu-id="58b89-178">C++/WinRT now generates even more efficient C++ source code (behind the scenes) so that the C++ compiler can produce the smallest and most efficient binary code possible.</span></span> <span data-ttu-id="58b89-179">例外処理のコストを削減向けと機能強化の多くが不要なを回避することでアンワインド情報。</span><span class="sxs-lookup"><span data-stu-id="58b89-179">Many of the improvements are geared toward reducing the cost of exception-handling by avoiding unnecessary unwind information.</span></span> <span data-ttu-id="58b89-180">使用して、大量のバイナリC++WinRT コードが約 4% 削減コードのサイズで表示されます。</span><span class="sxs-lookup"><span data-stu-id="58b89-180">Binaries that use large amounts of C++/WinRT code will see roughly a 4% reduction in code size.</span></span> <span data-ttu-id="58b89-181">コードがより効率的な (より速く実行されます) も、縮小命令数が原因です。</span><span class="sxs-lookup"><span data-stu-id="58b89-181">The code is also more efficient (it runs faster) due to the reduced instruction count.</span></span>

<span data-ttu-id="58b89-182">これらの機能強化もが、使用可能な新しい相互運用機能に依存します。</span><span class="sxs-lookup"><span data-stu-id="58b89-182">These improvements rely on a new interop feature that's available to you, as well.</span></span> <span data-ttu-id="58b89-183">すべてのC++]、[リソースの所有者となっている WinRT 型には、前の 2 段階のアプローチを回避の所有権を直接コンストラクターにはが含まれます。</span><span class="sxs-lookup"><span data-stu-id="58b89-183">All of the C++/WinRT types that are resource owners now include a constructor for taking ownership directly, avoiding the previous two-step approach.</span></span>

```cppwinrt
ABI::Windows::Foundation::IStringable* raw = ...

IStringable projected(raw, take_ownership_from_abi);

printf("%ls\n", projected.ToString().c_str());
```

#### <a name="optimized-exception-handling-eh-code-generation"></a><span data-ttu-id="58b89-184">最適化された例外処理 (EH) のコード生成</span><span class="sxs-lookup"><span data-stu-id="58b89-184">Optimized exception-handling (EH) code-generation</span></span>

<span data-ttu-id="58b89-185">この変更は、マイクロソフトが行った作業を補完C++オプティマイザー チーム例外処理のコストを削減できます。</span><span class="sxs-lookup"><span data-stu-id="58b89-185">This change complements work that has been done by the Microsoft C++ optimizer team to reduce the cost of exception-handling.</span></span> <span data-ttu-id="58b89-186">コードで大きく (COM) などのアプリケーション バイナリ インターフェイス (Abi) を使用する場合、多くのこのパターンに従うコードを確認します。</span><span class="sxs-lookup"><span data-stu-id="58b89-186">If you use application binary interfaces (ABIs) (such as COM) heavily in your code, then you'll observe a lot of code following this pattern.</span></span>

```cpp
int32_t Function() noexcept
{
    try
    {
        // code here constitutes unique value.
    }
    catch (...)
    {
        // code here is always duplicated.
    }
}
```

<span data-ttu-id="58b89-187">C++/WinRT 自体は、実装されているすべての API をこのパターンを生成します。</span><span class="sxs-lookup"><span data-stu-id="58b89-187">C++/WinRT itself generates this pattern for every API that's implemented.</span></span> <span data-ttu-id="58b89-188">何千もの API 関数のここで最適化を重要なことがあります。</span><span class="sxs-lookup"><span data-stu-id="58b89-188">With thousands of API functions, any optimization here can be significant.</span></span> <span data-ttu-id="58b89-189">オプティマイザー以前は、その catch ブロックであることを検出はありませんは、多くの (さらにシステム コードで例外を使用して大きなバイナリを生成するという確信に提供) を各 ABI の周囲のコードを複製することがあるために、すべて同じです。</span><span class="sxs-lookup"><span data-stu-id="58b89-189">In the past, the optimizer wouldn't detect that those catch blocks are all identical, so it was duplicating a lot of code around each ABI (which in turn contributed to the belief that using exceptions in system code produces large binaries).</span></span> <span data-ttu-id="58b89-190">ただしで、Visual Studio 2019 から、C++コンパイラがそれらのすべての圧縮 funclets をキャッチし、固有のものを格納するだけです。</span><span class="sxs-lookup"><span data-stu-id="58b89-190">However, from Visual Studio 2019 on, the C++ compiler folds all of those catch funclets, and only stores those that are unique.</span></span> <span data-ttu-id="58b89-191">結果は、このパターンに大きく依存するバイナリ コードのサイズの詳細と全体的な 18% 減少します。</span><span class="sxs-lookup"><span data-stu-id="58b89-191">The result is a further and overall 18% reduction in code size for binaries that rely heavily on this pattern.</span></span> <span data-ttu-id="58b89-192">だけでなく EH コードようになりましたリターン コードを使用するよりも効率がも大きいバイナリ ファイルに関する問題ようになりました、過去のものです。</span><span class="sxs-lookup"><span data-stu-id="58b89-192">Not only is EH code now more efficient than using return codes, but also the concern about larger binaries is now a thing of the past.</span></span>

#### <a name="incremental-build-improvements"></a><span data-ttu-id="58b89-193">インクリメンタル ビルドの機能強化</span><span class="sxs-lookup"><span data-stu-id="58b89-193">Incremental build improvements</span></span>

<span data-ttu-id="58b89-194">`cppwinrt.exe`ツールでは、ディスク上で既存のファイルの内容に対して生成されたヘッダー/ソース ファイルの出力を比較し、ファイルが実際に変更された場合は、ファイルにのみ書き込みます。</span><span class="sxs-lookup"><span data-stu-id="58b89-194">The `cppwinrt.exe` tool now compares the output of a generated header/source file against the contents of any existing file on disk, and it only writes out the file if the file has in fact changed.</span></span> <span data-ttu-id="58b89-195">ディスク I/O、かなりの時間を短縮し、これにより、ファイルが、「ダーティ」考慮されませんが、C++コンパイラ。</span><span class="sxs-lookup"><span data-stu-id="58b89-195">This saves considerable time with disk I/O, and it ensures that the files are not considered "dirty" by the C++ compiler.</span></span> <span data-ttu-id="58b89-196">結果は、その再コンパイルを回避、または縮小、多くの場合は。</span><span class="sxs-lookup"><span data-stu-id="58b89-196">The result is that recompilation is avoided, or reduced, in many cases.</span></span>

#### <a name="generic-interfaces-are-now-all-generated"></a><span data-ttu-id="58b89-197">ジェネリック インターフェイスは、生成されたものではようになりました</span><span class="sxs-lookup"><span data-stu-id="58b89-197">Generic interfaces are now all generated</span></span>

<span data-ttu-id="58b89-198">により、xlang メタデータ リーダー C++/WinRT は、メタデータからすべてのパラメーター化された、または、ジェネリック インターフェイスを生成するようになりました。</span><span class="sxs-lookup"><span data-stu-id="58b89-198">Due to the xlang metadata reader, C++/WinRT now generates all parameterized, or generic, interfaces from metadata.</span></span> <span data-ttu-id="58b89-199">ようなインターフェイス[:ivector\<T\> ](/uwp/api/windows.foundation.collections.ivector_t_)は今すぐメタデータから生成されたではなく手作業で記述された`winrt/base.h`します。</span><span class="sxs-lookup"><span data-stu-id="58b89-199">Interfaces such as [Windows::Foundation::Collections::IVector\<T\>](/uwp/api/windows.foundation.collections.ivector_t_) are now generated from metadata rather than hand-written in `winrt/base.h`.</span></span> <span data-ttu-id="58b89-200">その結果、サイズの`winrt/base.h`、半分にカットされた最適化が生成されると、(このアプローチでは手ロールバックを行うは大変でした) コードに右します。</span><span class="sxs-lookup"><span data-stu-id="58b89-200">The result is that the size of `winrt/base.h` has been cut in half, and that optimizations are generated right into the code (which was tricky to do with the hand-rolled approach).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="58b89-201">指定の例などのインターフェイスは、それぞれの名前空間のヘッダーではなくでを表示`winrt/base.h`します。</span><span class="sxs-lookup"><span data-stu-id="58b89-201">Interfaces such as the example given now appear in their respective namespace headers, rather than in `winrt/base.h`.</span></span> <span data-ttu-id="58b89-202">そのため、されていない場合は、インターフェイスを使用するには、適切な名前空間のヘッダーを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="58b89-202">So, if you have not already done so, you'll have to include the appropriate namespace header in order to use the interface.</span></span>

#### <a name="component-optimizations"></a><span data-ttu-id="58b89-203">コンポーネントの最適化</span><span class="sxs-lookup"><span data-stu-id="58b89-203">Component optimizations</span></span>

<span data-ttu-id="58b89-204">この更新プログラムには、いくつか追加のオプトインの最適化のサポートが追加されます。 C++/WinRT、以下のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="58b89-204">This update adds support for several additional opt-in optimizations for C++/WinRT, described in the sections below.</span></span> <span data-ttu-id="58b89-205">有効にするを明示的に使用する必要がありますので、これらの最適化は中断中の変更 (をサポートするために小さな変更を加える必要があります)、`cppwinrt.exe`ツールの`-opt`フラグ。</span><span class="sxs-lookup"><span data-stu-id="58b89-205">Because these optimizations are breaking changes (which you may need to make minor changes to support), you'll need to turn them on explicitly using the `cppwinrt.exe` tool's `-opt` flag.</span></span>

<span data-ttu-id="58b89-206">(プロジェクト テンプレート) から新しいプロジェクトを使用して`-opt`既定。</span><span class="sxs-lookup"><span data-stu-id="58b89-206">A new project (from a project template) will use `-opt` by default.</span></span>

##### <a name="uniform-construction-and-direct-implementation-access"></a><span data-ttu-id="58b89-207">Uniform の構築、および直接実装へのアクセス</span><span class="sxs-lookup"><span data-stu-id="58b89-207">Uniform construction, and direct implementation access</span></span>

<span data-ttu-id="58b89-208">これら 2 つの最適化は、射影された型のみを使用している場合でも、独自の実装の型に、コンポーネントの直接アクセスを許可します。</span><span class="sxs-lookup"><span data-stu-id="58b89-208">These two optimizations allow your component direct access to its own implementation types, even when it's only using the projected types.</span></span> <span data-ttu-id="58b89-209">使用する必要はありません[**ように**](/uwp/cpp-ref-for-winrt/make)、 [ **make_self**](/uwp/cpp-ref-for-winrt/make-self)も[ **get_self** ](/uwp/cpp-ref-for-winrt/get-self)場合は、パブリック API サーフェイスを使用するだけです。</span><span class="sxs-lookup"><span data-stu-id="58b89-209">There's no need to use [**make**](/uwp/cpp-ref-for-winrt/make), [**make_self**](/uwp/cpp-ref-for-winrt/make-self), nor [**get_self**](/uwp/cpp-ref-for-winrt/get-self) if you simply want to use the public API surface.</span></span> <span data-ttu-id="58b89-210">呼び出しは、実装への直接呼び出しにコンパイルされ、それらできない可能性がありますも完全にインライン化します。</span><span class="sxs-lookup"><span data-stu-id="58b89-210">Your calls will compile down to direct calls into the implementation, and those might even be entirely inlined.</span></span>

##### <a name="type-erased-factories"></a><span data-ttu-id="58b89-211">ファクトリの型消去</span><span class="sxs-lookup"><span data-stu-id="58b89-211">Type-erased factories</span></span>

<span data-ttu-id="58b89-212">この最適化を回避、# で依存関係を include`module.g.cpp`に必要な再コンパイルされません任意の 1 つの実装クラスの動作を変更するたびにできるようにします。</span><span class="sxs-lookup"><span data-stu-id="58b89-212">This optimization avoids the #include dependencies in `module.g.cpp` so that it need not be recompiled every time any single implementation class happens to change.</span></span> <span data-ttu-id="58b89-213">強化されたビルドのパフォーマンスになります。</span><span class="sxs-lookup"><span data-stu-id="58b89-213">The result is improved build performance.</span></span>

#### <a name="smarter-and-more-efficient-modulegcpp-for-large-projects-with-multiple-libs"></a><span data-ttu-id="58b89-214">スマートかつ効率的`module.g.cpp`大規模なプロジェクトに複数のライブラリ</span><span class="sxs-lookup"><span data-stu-id="58b89-214">Smarter and more efficient `module.g.cpp` for large projects with multiple libs</span></span>

<span data-ttu-id="58b89-215">`module.g.cpp`今すぐファイルも、という名前の 2 つの追加構成可能なヘルパーを含む**winrt_can_unload_now**、および**winrt_get_activation_factory**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-215">The `module.g.cpp` file now also contains two additional composable helpers, named **winrt_can_unload_now**, and **winrt_get_activation_factory**.</span></span> <span data-ttu-id="58b89-216">これらは、それぞれに独自のランタイム クラス ライブラリ、多数の DLL がここで構成されますが、大規模なプロジェクトの設計されています。</span><span class="sxs-lookup"><span data-stu-id="58b89-216">These have been designed for larger projects where a DLL is composed of a number of libs, each with its own runtime classes.</span></span> <span data-ttu-id="58b89-217">そのような状況で、DLL を手動で合成する必要があります。 **DllGetActivationFactory**と**DllCanUnloadNow**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-217">In that situation, you need to manually stitch together the DLL's **DllGetActivationFactory** and **DllCanUnloadNow**.</span></span> <span data-ttu-id="58b89-218">これらのヘルパーを作成すると、見かけ上の実行元のエラーを回避することでは、はるかに簡単です。</span><span class="sxs-lookup"><span data-stu-id="58b89-218">These helpers make it much easier for you to do that, by avoiding spurious origination errors.</span></span> <span data-ttu-id="58b89-219">`cppwinrt.exe`ツールの`-lib`フラグが、独自のプリアンブルごとの個々 の lib を提供することも可能性があります (なく`winrt_xxx`) できるように、各ライブラリの関数で個別に名前付きの場合、明確に組み合わせてしたがって可能性があります。</span><span class="sxs-lookup"><span data-stu-id="58b89-219">The `cppwinrt.exe` tool's `-lib` flag may also be used to give each individual lib its own preamble (rather than `winrt_xxx`) so that each lib's functions may be individually named, and thus combined unambiguously.</span></span>

#### <a name="new-winrtcoroutineh-header"></a><span data-ttu-id="58b89-220">新しい`winrt/coroutine.h`ヘッダー</span><span class="sxs-lookup"><span data-stu-id="58b89-220">New `winrt/coroutine.h` header</span></span>

<span data-ttu-id="58b89-221">`winrt/coroutine.h`ヘッダーがすべての新しいホームC++/WinRT のコルーチンのサポート。</span><span class="sxs-lookup"><span data-stu-id="58b89-221">The `winrt/coroutine.h` header is the new home for all of C++/WinRT's coroutine support.</span></span> <span data-ttu-id="58b89-222">このサポート、いくつかの場所に存在していた以前とこれが限定的すぎます。</span><span class="sxs-lookup"><span data-stu-id="58b89-222">Previously, this support resided in a few places, which we felt was too limiting.</span></span> <span data-ttu-id="58b89-223">現在ある手作業で記述されたのではなく、Windows ランタイムの非同期インターフェイスが生成されるようになりましたので`winrt/Windows.Foundation.h`します。</span><span class="sxs-lookup"><span data-stu-id="58b89-223">Since the Windows Runtime async interfaces are now generated, rather than hand-written, they now reside in `winrt/Windows.Foundation.h`.</span></span> <span data-ttu-id="58b89-224">サポート可能と保守が容易なであるとは別に意味するコルーチンなどのヘルパー [ **resume_foreground** ](/uwp/cpp-ref-for-winrt/resume-foreground)に数行の特定の名前空間のヘッダーの末尾が不要になった。</span><span class="sxs-lookup"><span data-stu-id="58b89-224">Apart from being more maintainable and supportable, it means that coroutine helpers such as [**resume_foreground**](/uwp/cpp-ref-for-winrt/resume-foreground) no longer have to be tacked on to the end of a specific namespace header.</span></span> <span data-ttu-id="58b89-225">代わりに、その依存関係より自然含めることができます。</span><span class="sxs-lookup"><span data-stu-id="58b89-225">Instead, they can more naturally include their dependencies.</span></span> <span data-ttu-id="58b89-226">これにより、さらに**resume_foreground**だけでなくの再開をサポートするために、指定された[ **Windows::UI::Core::CoreDispatcher**](/uwp/api/windows.ui.core.coredispatcher)ができるようになりましたもサポートの再開を指定[ **Windows::System::DispatcherQueue**](/uwp/api/windows.system.dispatcherqueue)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-226">This further allows **resume_foreground** to support not only resuming on a given [**Windows::UI::Core::CoreDispatcher**](/uwp/api/windows.ui.core.coredispatcher), but it can now also support resuming on a given [**Windows::System::DispatcherQueue**](/uwp/api/windows.system.dispatcherqueue).</span></span> <span data-ttu-id="58b89-227">以前は、1 つのみをサポートできます。両方ではなく、定義は、1 つの名前空間にのみ存在でしたので。</span><span class="sxs-lookup"><span data-stu-id="58b89-227">Previously, only one could be supported; but not both, since the definition could only reside in one namespace.</span></span>

<span data-ttu-id="58b89-228">次の例に示します、 **DispatcherQueue**をサポートします。</span><span class="sxs-lookup"><span data-stu-id="58b89-228">Here's an example of the **DispatcherQueue** support.</span></span>

```cppwinrt
fire_and_forget Async(DispatcherQueueController controller)
{
    bool queued = co_await resume_foreground(controller.DispatcherQueue());
    assert(queued);

    // This is just to simulate queue failure...
    co_await controller.ShutdownQueueAsync();

    queued = co_await resume_foreground(controller.DispatcherQueue());
    assert(!queued);
}
```

<span data-ttu-id="58b89-229">コルーチンのヘルパーもで修飾されたようになりました`[[nodiscard]]`のため、その使いやすさを向上します。</span><span class="sxs-lookup"><span data-stu-id="58b89-229">The coroutine helpers are now also decorated with `[[nodiscard]]`, thereby improving their usability.</span></span> <span data-ttu-id="58b89-230">かどうかにもご活用ください (またはする必要があることに気付かず)`co_await`使用するには次に、理由のために`[[nodiscard]]`、このような誤りは、コンパイラの警告を生成します。</span><span class="sxs-lookup"><span data-stu-id="58b89-230">If you forget to (or don't realize you have to) `co_await` them for them to work then, due to `[[nodiscard]]`, such mistakes now produce a compiler warning.</span></span>

#### <a name="help-with-diagnosing-stack-allocations"></a><span data-ttu-id="58b89-231">スタック割り当ての診断に役立ちます</span><span class="sxs-lookup"><span data-stu-id="58b89-231">Help with diagnosing stack allocations</span></span>

<span data-ttu-id="58b89-232">使用してではなく、その他の 1 つはよく間違わを誤って、スタックの実装を作成することが予測と実装のクラス名が (既定) では、同じ名前空間のみが異なるため、 [ **ように**](/uwp/cpp-ref-for-winrt/make)ヘルパーのファミリです。</span><span class="sxs-lookup"><span data-stu-id="58b89-232">Since the projected and implementation class names are (by default) the same, and only differ by namespace, it's possible to mistake the one for the other, and to accidentally create an implementation on the stack, rather than using the [**make**](/uwp/cpp-ref-for-winrt/make) family of helpers.</span></span> <span data-ttu-id="58b89-233">これは、未解決の参照は引き続きフライト中に、オブジェクトが破棄される可能性がありますので、場合によっては、診断が困難です。</span><span class="sxs-lookup"><span data-stu-id="58b89-233">This can be hard to diagnose in some cases, because the object may be destroyed while outstanding references are still in flight.</span></span> <span data-ttu-id="58b89-234">今すぐアサーション ピックアップこれ、デバッグ ビルドの場合。</span><span class="sxs-lookup"><span data-stu-id="58b89-234">An assertion now picks this up, for debug builds.</span></span> <span data-ttu-id="58b89-235">アサーションは、コルーチン内部でのスタック割り当てを検出は、このような誤りはほとんどの把握に役立つがそれでもです。</span><span class="sxs-lookup"><span data-stu-id="58b89-235">While the assertion doesn't detect stack allocation inside a coroutine, it's nevertheless helpful in catching most such mistakes.</span></span>

#### <a name="improved-capture-helpers-and-variadic-delegates"></a><span data-ttu-id="58b89-236">強化されたキャプチャのヘルパーと可変個引数のデリゲート</span><span class="sxs-lookup"><span data-stu-id="58b89-236">Improved capture helpers, and variadic delegates</span></span>

<span data-ttu-id="58b89-237">この更新プログラムは、射影された型もサポートすることによってキャプチャ ヘルパーの制限を修正します。</span><span class="sxs-lookup"><span data-stu-id="58b89-237">This update fixes the limitation with the capture helpers by supporting projected types as well.</span></span> <span data-ttu-id="58b89-238">これと Windows ランタイムの相互運用 Api では、射影の型が戻るときにされます。</span><span class="sxs-lookup"><span data-stu-id="58b89-238">This comes up now and then with the Windows Runtime interop APIs, when they return a projected type.</span></span>

<span data-ttu-id="58b89-239">この更新はサポートも追加[ **get_strong** ](/uwp/cpp-ref-for-winrt/implements#implementsget_strong-function)と[ **get_weak** ](/uwp/cpp-ref-for-winrt/implements#implementsget_weak-function)可変個引数 (非 Windows ランタイム) のデリゲートを作成するときにします。</span><span class="sxs-lookup"><span data-stu-id="58b89-239">This update also adds support for [**get_strong**](/uwp/cpp-ref-for-winrt/implements#implementsget_strong-function) and [**get_weak**](/uwp/cpp-ref-for-winrt/implements#implementsget_weak-function) when creating a variadic (non-Windows Runtime) delegate.</span></span>

#### <a name="support-for-deferred-destruction-and-safe-qi-during-destruction"></a><span data-ttu-id="58b89-240">遅延の破棄と破棄中に安全な QI のサポート</span><span class="sxs-lookup"><span data-stu-id="58b89-240">Support for deferred destruction and safe QI during destruction</span></span>

<span data-ttu-id="58b89-241">XAML アプリケーションは難易度を実行する必要があったためにそれ自体を取得できます、 [ **QueryInterface** ](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q_)) (QI) 階層を上下するいくつかのクリーンアップの実装を呼び出すために、デストラクターでします。</span><span class="sxs-lookup"><span data-stu-id="58b89-241">A XAML application can get itself into difficulty due to its need to perform a [**QueryInterface**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q_)) (QI) in a destructor, in order to call some cleanup implementation up or down the hierarchy.</span></span> <span data-ttu-id="58b89-242">ただし、0 に達した後、オブジェクトの参照カウントが既に、呼び出しにはで、QI が含まれています。</span><span class="sxs-lookup"><span data-stu-id="58b89-242">But, that call involves a QI after the object's reference count has already reached zero.</span></span> <span data-ttu-id="58b89-243">この更新プログラムは再生されません。 0 に達したことを確認する、参照カウントを debouncing サポートを追加します。破棄中に必要な一時の QI ができます。</span><span class="sxs-lookup"><span data-stu-id="58b89-243">This update adds support for debouncing the reference count, ensuring that once it reaches zero it can never be resurrected; while still allowing QI for any temporary that's required during destruction.</span></span> <span data-ttu-id="58b89-244">この手順が特定の XAML アプリケーション/コントロール、避けられないとC++/WinRT に回復力のあるようになりました。</span><span class="sxs-lookup"><span data-stu-id="58b89-244">This procedure is unavoidable in certain XAML applications/controls, and C++/WinRT is now resilient to it.</span></span>

<span data-ttu-id="58b89-245">静的なを提供することで破壊を延期できる**final_release**関数、およびの所有権を移動、 **unique_ptr**の他のコンテキストにします。</span><span class="sxs-lookup"><span data-stu-id="58b89-245">Destruction can be deferred by providing a static **final_release** function, and moving ownership of the **unique_ptr** to some other context.</span></span>

```cppwinrt
struct Sample : implements<Sample, IStringable>
{
    hstring ToString()
    {
        return L"Sample";
    }

    ~Sample()
    {
        // Called when the unique_ptr below is reset.
    }

    static void final_release(std::unique_ptr<Sample> ptr) noexcept
    {
        // Move 'ptr' as needed to delay destruction.
    }
};
```

<span data-ttu-id="58b89-246">1 回次の例で、 **MainPage** (の最終的な時間) がリリースされる**final_release**が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="58b89-246">In the example below, once the **MainPage** is released (for the final time), **final_release** is called.</span></span> <span data-ttu-id="58b89-247">関数が待機している (スレッド プールにある)、5 秒を費やすことし、ページを使用して、再開**ディスパッチャー** (QI/Addref/release 作業が必要する)。</span><span class="sxs-lookup"><span data-stu-id="58b89-247">That function spends five seconds waiting (on the thread pool), and then it resumes using the page's **Dispatcher** (which requires QI/AddRef/Release to work).</span></span> <span data-ttu-id="58b89-248">クリアします、 **unique_ptr**、原因となる、 **MainPage**を実際に呼び出されるデストラクター。</span><span class="sxs-lookup"><span data-stu-id="58b89-248">It then clears the **unique_ptr**, which causes the **MainPage** destructor to actually get called.</span></span> <span data-ttu-id="58b89-249">ここでも、 **DataContext**を呼び出すの QI を必要とする**IFrameworkElement**。</span><span class="sxs-lookup"><span data-stu-id="58b89-249">Even here, **DataContext** is called, which requires a QI for **IFrameworkElement**.</span></span> <span data-ttu-id="58b89-250">当然ながら、実装することも、 **final_release**がコルーチンとして。</span><span class="sxs-lookup"><span data-stu-id="58b89-250">Obviously, you don't have to implement your **final_release** as a coroutine.</span></span> <span data-ttu-id="58b89-251">機能し、破棄を別のスレッドに移動する非常に単純な使用します。</span><span class="sxs-lookup"><span data-stu-id="58b89-251">But that does work, and it makes it very simple to move destruction to a different thread.</span></span>

```cppwinrt
struct MainPage : PageT<MainPage>
{
    MainPage()
    {
    }

    ~MainPage()
    {
        DataContext(nullptr);
    }

    static IAsyncAction final_release(std::unique_ptr<MainPage> ptr)
    {
        co_await 5s;

        co_await resume_foreground(ptr->Dispatcher());

        ptr = nullptr;
    }
};
```

#### <a name="improved-support-for-com-style-single-interface-inheritance"></a><span data-ttu-id="58b89-252">COM スタイルの単一のインターフェイスの継承に対するサポートの向上</span><span class="sxs-lookup"><span data-stu-id="58b89-252">Improved support for COM-style single interface inheritance</span></span>

<span data-ttu-id="58b89-253">Windows ランタイム プログラミング用としてもC++/WinRT は作成および COM 専用の Api を使用することも使用されます。</span><span class="sxs-lookup"><span data-stu-id="58b89-253">As well as for Windows Runtime programming, C++/WinRT is also used to author and consume COM-only APIs.</span></span> <span data-ttu-id="58b89-254">この更新プログラムでは、あるインターフェイスの階層構造が存在する COM サーバーを実装できます。</span><span class="sxs-lookup"><span data-stu-id="58b89-254">This update makes it possible to implement a COM server where there exists an interface hierarchy.</span></span> <span data-ttu-id="58b89-255">これには Windows ランタイムは必要ありません。COM 実装の必要があります。</span><span class="sxs-lookup"><span data-stu-id="58b89-255">This isn't required for the Windows Runtime; but it is required for some COM implementations.</span></span>

#### <a name="correct-handling-of-out-params"></a><span data-ttu-id="58b89-256">処理の適切な`out`params</span><span class="sxs-lookup"><span data-stu-id="58b89-256">Correct handling of `out` params</span></span>

<span data-ttu-id="58b89-257">使用することはたいへん`out`params。 特に Windows ランタイムの配列。</span><span class="sxs-lookup"><span data-stu-id="58b89-257">It can be tricky to work with `out` params; particularly Windows Runtime arrays.</span></span> <span data-ttu-id="58b89-258">この更新で、 C++/に関しては WinRT はかなりより堅牢で耐障害性を間違い`out`params と配列は、言語プロジェクションを使用して、または生の ABI を使用しているユーザーと、担当するユーザーは、COM 開発者から、これらのパラメーターが到着したかどうか一貫していない変数の初期化の間違いです。</span><span class="sxs-lookup"><span data-stu-id="58b89-258">With this update, C++/WinRT is considerably more robust and resilient to mistakes when it comes to `out` params and arrays; whether those parameters arrive via a language projection, or from a COM developer who's using the raw ABI, and who's making the mistake of not initializing variables consistently.</span></span> <span data-ttu-id="58b89-259">いずれの場合も、 C++WinRT は適切な処理をようになりましたが (記憶してリソースを解放する)、ABI に射影された型を渡す際と領域の解放または ABI 間で到着するパラメーターを消去するのにあたって/。</span><span class="sxs-lookup"><span data-stu-id="58b89-259">In either case, C++/WinRT now does the right thing when it comes to handing off projected types to the ABI (by remembering to release any resources), and when it comes to zeroing out or clearing out parameters that arrive across the ABI.</span></span>

#### <a name="events-now-handle-invalid-tokens-reliably"></a><span data-ttu-id="58b89-260">イベントで無効なトークンを確実に処理ようになりました</span><span class="sxs-lookup"><span data-stu-id="58b89-260">Events now handle invalid tokens reliably</span></span>

<span data-ttu-id="58b89-261">[ **Winrt::event** ](/uwp/cpp-ref-for-winrt/event)現在の実装は、大文字と小文字を適切に処理をその**削除**トークン値が無効なメソッドが呼び出されます (にない値、配列の場合)。</span><span class="sxs-lookup"><span data-stu-id="58b89-261">The [**winrt::event**](/uwp/cpp-ref-for-winrt/event) implementation now gracefully handles the case where its **remove** method is called with an invalid token value (a value that's not present in the array).</span></span>

#### <a name="coroutine-locals-are-now-destroyed-before-the-coroutine-returns"></a><span data-ttu-id="58b89-262">コルーチンが戻る前に、コルーチンのローカル変数が破棄ようになりました</span><span class="sxs-lookup"><span data-stu-id="58b89-262">Coroutine locals are now destroyed before the coroutine returns</span></span>

<span data-ttu-id="58b89-263">コルーチンの型を実装するは、従来の方法は、コルーチン内部ローカル変数を破棄することを許可*後*コルーチン返します/が完了すると (前の最後の中断) ではありません。</span><span class="sxs-lookup"><span data-stu-id="58b89-263">The traditional way of implementing a coroutine type may allow locals within the coroutine to be destroyed *after* the coroutine returns/completes (rather than prior to final suspension).</span></span> <span data-ttu-id="58b89-264">この問題を回避するには、その他の特典の課金、任意の待機処理の再開は最後の中断まで延期ようになりました。</span><span class="sxs-lookup"><span data-stu-id="58b89-264">The resumption of any waiter is now deferred until final suspension, in order to avoid this problem and to accrue other benefits.</span></span>

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a><span data-ttu-id="58b89-265">ニュース、および変更 で、Windows SDK バージョン 10.0.17763.0 (Windows 10、バージョンは 1809)</span><span class="sxs-lookup"><span data-stu-id="58b89-265">News, and changes, in Windows SDK version 10.0.17763.0 (Windows 10, version 1809)</span></span>

<span data-ttu-id="58b89-266">次の表は、ニュースを含むし、への変更[C +/cli WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) 10.0.17763.0 (Windows 10、バージョンは 1809) で一般公開バージョンの最新の Windows SDK であります。</span><span class="sxs-lookup"><span data-stu-id="58b89-266">The table below contains news and changes to [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) in the latest generally-available version of the Windows SDK, which is 10.0.17763.0 (Windows 10, version 1809).</span></span> <span data-ttu-id="58b89-267">これらの変更も SDK Insider Preview 以降のバージョンに存在する場合があります。</span><span class="sxs-lookup"><span data-stu-id="58b89-267">These changes may also be present in later SDK Insider Preview versions.</span></span>

| <span data-ttu-id="58b89-268">新規または変更された機能</span><span class="sxs-lookup"><span data-stu-id="58b89-268">New or changed feature</span></span> | <span data-ttu-id="58b89-269">詳細情報</span><span class="sxs-lookup"><span data-stu-id="58b89-269">More info</span></span> |
| - | - |
| <span data-ttu-id="58b89-270">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-270">**Breaking change**.</span></span> <span data-ttu-id="58b89-271">コンパイル、C +/cli WinRT は、Windows SDK からのヘッダーに依存しません。</span><span class="sxs-lookup"><span data-stu-id="58b89-271">For it to compile, C++/WinRT doesn't depend on headers from the Windows SDK.</span></span> | <span data-ttu-id="58b89-272">参照してください[Windows SDK ヘッダー ファイルから分離](#isolation-from-windows-sdk-header-files)、後述します。</span><span class="sxs-lookup"><span data-stu-id="58b89-272">See [Isolation from Windows SDK header files](#isolation-from-windows-sdk-header-files), below.</span></span> |
| <span data-ttu-id="58b89-273">Visual Studio プロジェクト システムの形式が変更されました。</span><span class="sxs-lookup"><span data-stu-id="58b89-273">The Visual Studio project system format has changed.</span></span> | <span data-ttu-id="58b89-274">参照してください[、C + の再ターゲットする方法/cli WinRT プロジェクトは、以降のバージョンの Windows SDK を](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)、後述します。</span><span class="sxs-lookup"><span data-stu-id="58b89-274">See [How to retarget your C++/WinRT project to a later version of the Windows SDK](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk), below.</span></span> |
| <span data-ttu-id="58b89-275">新しい機能と Windows ランタイム関数の場合にコレクション オブジェクトを渡すため、または独自のコレクションのプロパティとコレクション型を実装する基底クラスがあります。</span><span class="sxs-lookup"><span data-stu-id="58b89-275">There are new functions and base classes to help you pass a collection object to a Windows Runtime function, or to implement your own collection properties and collection types.</span></span> | <span data-ttu-id="58b89-276">参照してください[コレクション c++/cli WinRT](collections.md)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-276">See [Collections with C++/WinRT](collections.md).</span></span> |
| <span data-ttu-id="58b89-277">使用することができます、 [{binding}](/windows/uwp/xaml-platform/binding-markup-extension)マークアップ拡張では、C +/cli WinRT ランタイム クラスです。</span><span class="sxs-lookup"><span data-stu-id="58b89-277">You can use the [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) markup extension with your C++/WinRT runtime classes.</span></span> | <span data-ttu-id="58b89-278">詳細については、およびコード例は、次を参照してください。[データ バインディングの概要](/windows/uwp/data-binding/data-binding-quickstart)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-278">For more info, and code examples, see [Data binding overview](/windows/uwp/data-binding/data-binding-quickstart).</span></span> |
| <span data-ttu-id="58b89-279">コルーチンのキャンセルのサポートを使用すると、取り消しのコールバックを登録できます。</span><span class="sxs-lookup"><span data-stu-id="58b89-279">Support for canceling a coroutine allows you to register a cancellation callback.</span></span> | <span data-ttu-id="58b89-280">詳細については、およびコード例は、次を参照してください。[非同期操作、および取り消しのコールバックをキャンセル](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-280">For more info, and code examples, see [Canceling an asychronous operation, and cancellation callbacks](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks).</span></span> |
| <span data-ttu-id="58b89-281">メンバー関数を指すデリゲートを作成するときに、強力なまたは現在のオブジェクトへの弱い参照を確立することができます (未加工ではなく*この*ポインター)、ハンドラーが登録されている時点。</span><span class="sxs-lookup"><span data-stu-id="58b89-281">When creating a delegate pointing to a member function, you can establish a strong or a weak reference to the current object (instead of a raw *this* pointer) at the point where the handler is registered.</span></span> | <span data-ttu-id="58b89-282">詳細については、およびコード例は、次を参照してください、**デリゲートとしてメンバー関数を使用する場合**サブセクションに記載[安全にアクセスする、*これ*イベント処理デリゲートとポインター](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).</span><span class="sxs-lookup"><span data-stu-id="58b89-282">For more info, and code examples, see the **If you use a member function as a delegate** sub-section in the section [Safely accessing the *this* pointer with an event-handling delegate](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).</span></span> |
| <span data-ttu-id="58b89-283">C++ 標準に Visual Studio の適合性を向上によって発見されたバグが修正されます。</span><span class="sxs-lookup"><span data-stu-id="58b89-283">Bugs are fixed that were uncovered by Visual Studio's improved conformance to the C++ standard.</span></span> <span data-ttu-id="58b89-284">LLVM と Clang ツール チェーンを活用すると、C + 検証よりも/cli WinRT の標準への準拠。</span><span class="sxs-lookup"><span data-stu-id="58b89-284">The LLVM and Clang toolchain is also better leveraged to validate C++/WinRT's standards conformance.</span></span> | <span data-ttu-id="58b89-285">説明されている問題が発生するが不要になった[自分の新しいプロジェクトがコンパイルされない理由でしょうか。Visual Studio 2017 を使用している (15.8.0 バージョンまたはそれ以降)、および SDK version 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134)</span><span class="sxs-lookup"><span data-stu-id="58b89-285">You'll no longer encounter the issue described in [Why won't my new project compile? I'm using Visual Studio 2017 (version 15.8.0 or higher), and SDK version 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134)</span></span> |

<span data-ttu-id="58b89-286">その他の変更。</span><span class="sxs-lookup"><span data-stu-id="58b89-286">Other changes.</span></span>

- <span data-ttu-id="58b89-287">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-287">**Breaking change**.</span></span> <span data-ttu-id="58b89-288">[**winrt::get_abi(winrt::hstring const&)** ](/uwp/cpp-ref-for-winrt/get-abi)返すようになりました`void*`の代わりに`HSTRING`します。</span><span class="sxs-lookup"><span data-stu-id="58b89-288">[**winrt::get_abi(winrt::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi) now returns `void*` instead of `HSTRING`.</span></span> <span data-ttu-id="58b89-289">使用することができます`static_cast<HSTRING>(get_abi(my_hstring));`HSTRING を取得します。</span><span class="sxs-lookup"><span data-stu-id="58b89-289">You can use `static_cast<HSTRING>(get_abi(my_hstring));` to get an HSTRING.</span></span>
- <span data-ttu-id="58b89-290">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-290">**Breaking change**.</span></span> <span data-ttu-id="58b89-291">[**winrt::put_abi(winrt::hstring&)** ](/uwp/cpp-ref-for-winrt/put-abi)返すようになりました`void**`の代わりに`HSTRING*`します。</span><span class="sxs-lookup"><span data-stu-id="58b89-291">[**winrt::put_abi(winrt::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi) now returns `void**` instead of `HSTRING*`.</span></span> <span data-ttu-id="58b89-292">使用することができます`reinterpret_cast<HSTRING*>(put_abi(my_hstring));`HSTRING \* を取得します。</span><span class="sxs-lookup"><span data-stu-id="58b89-292">You can use `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` to get an HSTRING\*.</span></span>
- <span data-ttu-id="58b89-293">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-293">**Breaking change**.</span></span> <span data-ttu-id="58b89-294">HRESULT として投影今すぐ**winrt::hresult**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-294">HRESULT is now projected as **winrt::hresult**.</span></span> <span data-ttu-id="58b89-295">HRESULT (に型チェック、または型の特徴をサポートするために)、する必要があるかどうかはその後、 `static_cast` 、 **winrt::hresult**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-295">If you need an HRESULT (to do type checking, or to support type traits), then you can `static_cast` a **winrt::hresult**.</span></span> <span data-ttu-id="58b89-296">それ以外の場合、 **winrt::hresult** HRESULT に変換します含める限り`unknwn.h`すべて C + インクルードする前に/cli WinRT ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="58b89-296">Otherwise, **winrt::hresult** converts to HRESULT, as long as you include `unknwn.h` before you include any C++/WinRT headers.</span></span>
- <span data-ttu-id="58b89-297">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-297">**Breaking change**.</span></span> <span data-ttu-id="58b89-298">GUID として投影今すぐ**winrt::guid**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-298">GUID is now projected as **winrt::guid**.</span></span> <span data-ttu-id="58b89-299">実装する api を使用する必要があります**winrt::guid** GUID パラメーター。</span><span class="sxs-lookup"><span data-stu-id="58b89-299">For APIs that you implement, you must use **winrt::guid** for GUID parameters.</span></span> <span data-ttu-id="58b89-300">それ以外の場合、 **winrt::guid** GUID に変換する限り`unknwn.h`いずれかをインクルードする前にC++/WinRT ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="58b89-300">Otherwise, **winrt::guid** converts to GUID, as long as you include `unknwn.h` before you include any C++/WinRT headers.</span></span>
- <span data-ttu-id="58b89-301">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-301">**Breaking change**.</span></span> <span data-ttu-id="58b89-302">[ **Winrt::handle_type コンストラクター** ](/uwp/cpp-ref-for-winrt/handle-type#handle_typehandle_type-constructor) (これは今すぐ困難と不適切なコードを記述する) を明示的にすることで書き込まれています。</span><span class="sxs-lookup"><span data-stu-id="58b89-302">The [**winrt::handle_type constructor**](/uwp/cpp-ref-for-winrt/handle-type#handle_typehandle_type-constructor) has been hardened by making it explicit (it's now harder to write incorrect code with it).</span></span> <span data-ttu-id="58b89-303">未処理のハンドル値を割り当てる必要がある場合は、呼び出し、 [ **handle_type::attach 関数**](/uwp/cpp-ref-for-winrt/handle-type#handle_typeattach-function)代わりにします。</span><span class="sxs-lookup"><span data-stu-id="58b89-303">If you need to assign a raw handle value, call the [**handle_type::attach function**](/uwp/cpp-ref-for-winrt/handle-type#handle_typeattach-function) instead.</span></span>
- <span data-ttu-id="58b89-304">**互換性に影響する変更**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-304">**Breaking change**.</span></span> <span data-ttu-id="58b89-305">シグネチャ**WINRT_CanUnloadNow**と**WINRT_GetActivationFactory**が変更されました。</span><span class="sxs-lookup"><span data-stu-id="58b89-305">The signatures of **WINRT_CanUnloadNow** and **WINRT_GetActivationFactory** have changed.</span></span> <span data-ttu-id="58b89-306">これらの関数は、まったく宣言しないでください。</span><span class="sxs-lookup"><span data-stu-id="58b89-306">You mustn't declare these functions at all.</span></span> <span data-ttu-id="58b89-307">代わりに、含める`winrt/base.h`(C + 任意を含める場合に自動的に含まれている/cli WinRT Windows 名前空間のヘッダー ファイル) これらの関数の宣言を含めます。</span><span class="sxs-lookup"><span data-stu-id="58b89-307">Instead, include `winrt/base.h` (which is automatically included if you include any C++/WinRT Windows namespace header files) to include the declarations of these functions.</span></span>
- <span data-ttu-id="58b89-308">[ **Winrt::clock 構造体**](/uwp/cpp-ref-for-winrt/clock)、 **from_FILETIME/to_FILETIME**好評だったは非推奨と**from_file_time/to_file_time**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-308">For the [**winrt::clock struct**](/uwp/cpp-ref-for-winrt/clock), **from_FILETIME/to_FILETIME** are deprecated in favor of **from_file_time/to_file_time**.</span></span>
- <span data-ttu-id="58b89-309">期待する Api **IBuffer**パラメーターが簡素化されます。</span><span class="sxs-lookup"><span data-stu-id="58b89-309">APIs that expect **IBuffer** parameters are simplified.</span></span> <span data-ttu-id="58b89-310">十分な Api が依存するが、ほとんどの Api には、コレクションまたは配列が必要に応じて、 **IBuffer** C++ からこのような Api を使用して容易になる必要があります。</span><span class="sxs-lookup"><span data-stu-id="58b89-310">Although most APIs prefer collections or arrays, enough APIs rely on **IBuffer** that it needed to be easier to use such APIs from C++.</span></span> <span data-ttu-id="58b89-311">この更新プログラムの背後にあるデータに直接アクセスを提供する、 **IBuffer** C++ 標準ライブラリ コンテナーで使用される同じデータ名前付け規則を使用して実装します。</span><span class="sxs-lookup"><span data-stu-id="58b89-311">This update provides direct access to the data behind an **IBuffer** implementation, using the same data naming convention used by the C++ Standard Library containers.</span></span> <span data-ttu-id="58b89-312">これには、競合するメタデータの名前が大文字で始まる規約も回避できます。</span><span class="sxs-lookup"><span data-stu-id="58b89-312">This also avoids colliding with metadata names that conventionally begin with an uppercase letter.</span></span>
- <span data-ttu-id="58b89-313">コード生成の向上: コードのサイズを小さくさまざまな機能強化は、インライン展開を向上させるし、工場出荷時のキャッシュを最適化します。</span><span class="sxs-lookup"><span data-stu-id="58b89-313">Improved code generation: various improvements to reduce code size, improve inlining, and optimize factory caching.</span></span>
- <span data-ttu-id="58b89-314">不要な再帰を削除します。</span><span class="sxs-lookup"><span data-stu-id="58b89-314">Removed unnecessary recursion.</span></span> <span data-ttu-id="58b89-315">ときに、コマンド ラインは、特定ではなく、フォルダーに`.winmd`、`cppwinrt.exe`に対して再帰的に不要になった検索`.winmd`ファイル。</span><span class="sxs-lookup"><span data-stu-id="58b89-315">When the command-line refers to a folder, rather than to a specific `.winmd`, the `cppwinrt.exe` tool no longer searches recursively for `.winmd` files.</span></span> <span data-ttu-id="58b89-316">`cppwinrt.exe`ツールも現在処理重複よりインテリジェントに適切な形式は、ユーザー エラー、回復力のある`.winmd`ファイル。</span><span class="sxs-lookup"><span data-stu-id="58b89-316">The `cppwinrt.exe` tool also now handles duplicates more intelligently, making it more resilient to user error, and to poorly-formed `.winmd` files.</span></span>
- <span data-ttu-id="58b89-317">セキュリティを強化したスマート ポインター。</span><span class="sxs-lookup"><span data-stu-id="58b89-317">Hardened smart pointers.</span></span> <span data-ttu-id="58b89-318">以前は、ときに失効に失敗したイベント revokers 移動によって割り当てられた新しい値。</span><span class="sxs-lookup"><span data-stu-id="58b89-318">Formerly, the event revokers failed to revoke when move-assigned a new value.</span></span> <span data-ttu-id="58b89-319">これにより、スマート ポインター クラス自己代入; の処理をでした。 確実に問題を発見基盤として、 [ **winrt::com_ptr 構造体のテンプレート**](/uwp/cpp-ref-for-winrt/com-ptr)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-319">This helped uncover an issue where smart pointer classes weren't reliably handling self-assignment; rooted in the [**winrt::com_ptr struct template**](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="58b89-320">**winrt::com_ptr**が修正され、し、処理する固定イベント revokers 移動セマンティクスを正しく割り当て時に失効できるようにします。</span><span class="sxs-lookup"><span data-stu-id="58b89-320">**winrt::com_ptr** has been fixed, and the event revokers fixed to handle move semantics correctly so that they revoke upon assignment.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="58b89-321">重要な変更を加えました、 [C +/cli WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)1.0.181002.2 のバージョンでどちらもバージョン 1.0.190128.4 で後で。</span><span class="sxs-lookup"><span data-stu-id="58b89-321">Important changes were made to the [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix), both in version 1.0.181002.2, and then later in version 1.0.190128.4.</span></span> <span data-ttu-id="58b89-322">これらの変更と、既存のプロジェクトへの影響についての詳細については[Visual Studio のサポートを c++/cli WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)と[VSIX 拡張機能の以前のバージョン](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension)。</span><span class="sxs-lookup"><span data-stu-id="58b89-322">For details of these changes, and how they affect your existing projects, [Visual Studio support for C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package) and  [Earlier versions of the VSIX extension](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension).</span></span>

### <a name="isolation-from-windows-sdk-header-files"></a><span data-ttu-id="58b89-323">Windows SDK ヘッダー ファイルからの分離</span><span class="sxs-lookup"><span data-stu-id="58b89-323">Isolation from Windows SDK header files</span></span>

<span data-ttu-id="58b89-324">これは、可能性のあるコードの互換性に影響する変更です。</span><span class="sxs-lookup"><span data-stu-id="58b89-324">This is potentially a breaking change for your code.</span></span>

<span data-ttu-id="58b89-325">コンパイル、C +/cli WinRT が不要になった Windows SDK からのヘッダー ファイルに依存します。</span><span class="sxs-lookup"><span data-stu-id="58b89-325">For it to compile, C++/WinRT no longer depends on header files from the Windows SDK.</span></span> <span data-ttu-id="58b89-326">C ランタイム ライブラリ (CRT) および C++ 標準テンプレート ライブラリ (STL) のヘッダー ファイルは、すべての Windows SDK ヘッダーも含めないでください。</span><span class="sxs-lookup"><span data-stu-id="58b89-326">Header files in the C run-time library (CRT) and the C++ Standard Template Library (STL) also don't include any Windows SDK headers.</span></span> <span data-ttu-id="58b89-327">およびを標準への準拠を向上、不慮の依存関係を回避およびを防ぐために必要のあるマクロの数を大幅に短縮します。</span><span class="sxs-lookup"><span data-stu-id="58b89-327">And that improves standards compliance, avoids inadvertent dependencies, and greatly reduces the number of macros that you have to guard against.</span></span>

<span data-ttu-id="58b89-328">この独立性は c++/cli WinRT が移植性に優れてなり標準に準拠して、およびクロス コンパイラとクロス プラットフォーム ライブラリになる可能性を推進します。</span><span class="sxs-lookup"><span data-stu-id="58b89-328">This independence means that C++/WinRT is now more portable and standards compliant, and it furthers the possibility of it becoming a cross-compiler and cross-platform library.</span></span> <span data-ttu-id="58b89-329">意味 c++/cli WinRT ヘッダーが悪影響を及ぼす影響を受けるマクロはありません。</span><span class="sxs-lookup"><span data-stu-id="58b89-329">It also means that the C++/WinRT headers aren't adversely affected macros.</span></span>

<span data-ttu-id="58b89-330">C++ 以前ままの場合/cli WinRT を今すぐそれらを含める必要がありますし、プロジェクトで、任意の Windows ヘッダーを含めます。</span><span class="sxs-lookup"><span data-stu-id="58b89-330">If you previously left it to C++/WinRT to include any Windows headers in your project, then you'll now need to include them yourself.</span></span> <span data-ttu-id="58b89-331">いずれの場合も、常のベスト プラクティスを明示的に依存するヘッダーを含めるし、しない別のライブラリに含めることのままにします。</span><span class="sxs-lookup"><span data-stu-id="58b89-331">It is, in any case, always best practice to explicitly include the headers that you depend on, and not leave it to another library to include them for you.</span></span>

<span data-ttu-id="58b89-332">現時点では、Windows SDK ヘッダー ファイルの分離の唯一の例外は組み込み関数、および数値です。</span><span class="sxs-lookup"><span data-stu-id="58b89-332">Currently, the only exceptions to Windows SDK header file isolation are for intrinsics, and numerics.</span></span> <span data-ttu-id="58b89-333">この最後の残りの依存関係に関する既知の問題はありません。</span><span class="sxs-lookup"><span data-stu-id="58b89-333">There are no known issues with these last remaining dependencies.</span></span>

<span data-ttu-id="58b89-334">必要がある場合は、プロジェクトの Windows SDK のヘッダーとの相互運用を有効にできます再。</span><span class="sxs-lookup"><span data-stu-id="58b89-334">In your project, you can re-enable interop with the Windows SDK headers if you need to.</span></span> <span data-ttu-id="58b89-335">COM インターフェイスを実装する可能性があります、たとえば、(ルートと[ **IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509))。</span><span class="sxs-lookup"><span data-stu-id="58b89-335">You might, for example, want to implement a COM interface (rooted in [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)).</span></span> <span data-ttu-id="58b89-336">例では、含める`unknwn.h`すべて C + インクルードする前に/cli WinRT ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="58b89-336">For that example, include `unknwn.h` before you include any C++/WinRT headers.</span></span> <span data-ttu-id="58b89-337">そのため、C +/cli WinRT ベースのライブラリにクラシック COM インターフェイスをサポートするためにさまざまなフックを有効にします。</span><span class="sxs-lookup"><span data-stu-id="58b89-337">Doing so causes the C++/WinRT base library to enable various hooks to support classic COM interfaces.</span></span> <span data-ttu-id="58b89-338">コード例では、次を参照してください。 [C + での作成者の COM コンポーネント/cli WinRT](author-coclasses.md)します。</span><span class="sxs-lookup"><span data-stu-id="58b89-338">For a code example, see [Author COM components with C++/WinRT](author-coclasses.md).</span></span> <span data-ttu-id="58b89-339">同様に、宣言型や関数を呼び出そうとするその他の Windows SDK ヘッダーに明示的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="58b89-339">Similarly, explicitly include any other Windows SDK headers that declare types and/or functions that you want to call.</span></span>

### <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a><span data-ttu-id="58b89-340">C++ の再ターゲットする方法/cli 以降のバージョンの Windows SDK に WinRT プロジェクト</span><span class="sxs-lookup"><span data-stu-id="58b89-340">How to retarget your C++/WinRT project to a later version of the Windows SDK</span></span>

<span data-ttu-id="58b89-341">最小限のコンパイラとリンカーの問題が発生する可能性があるプロジェクトの再ターゲットのメソッドは、最も手間もあります。</span><span class="sxs-lookup"><span data-stu-id="58b89-341">The method for retargeting your project that's likely to result in the fewest compiler and linker issue is also the most labor-intensive.</span></span> <span data-ttu-id="58b89-342">(任意の Windows SDK のバージョンを対象とする) 新しいプロジェクトを作成し、古いからは経由で新しいプロジェクトのファイルをコピーし、そのメソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="58b89-342">That method involves creating a new project (targeting the Windows SDK version of your choice), and then copying files over to your new project from your old.</span></span> <span data-ttu-id="58b89-343">古いのセクションがあります`.vcxproj`と`.vcxproj.filters`できますファイルをコピー以上節約 Visual Studio でファイルを追加します。</span><span class="sxs-lookup"><span data-stu-id="58b89-343">There will be sections of your old `.vcxproj` and `.vcxproj.filters` files that you can just copy over to save you adding files in Visual Studio.</span></span>

<span data-ttu-id="58b89-344">ただし、Visual Studio でプロジェクトを再ターゲットするその他の 2 つの方法はあります。</span><span class="sxs-lookup"><span data-stu-id="58b89-344">However, there are two other ways to retarget your project in Visual Studio.</span></span>

- <span data-ttu-id="58b89-345">プロジェクトのプロパティに移動して**全般** \> **Windows SDK バージョン**を選択し、**すべての構成**と**すべてのプラットフォーム**します。</span><span class="sxs-lookup"><span data-stu-id="58b89-345">Go to project property **General** \> **Windows SDK Version**, and select **All Configurations** and **All Platforms**.</span></span> <span data-ttu-id="58b89-346">設定**Windows SDK バージョン**を対象とバージョン。</span><span class="sxs-lookup"><span data-stu-id="58b89-346">Set **Windows SDK Version** to the version that you want to target.</span></span>
- <span data-ttu-id="58b89-347">**ソリューション エクスプ ローラー**は、プロジェクト ノードを右クリックし、**プロジェクトの再ターゲット**をクリックして、ターゲット バージョンを選択**OK**。</span><span class="sxs-lookup"><span data-stu-id="58b89-347">In **Solution Explorer**, right-click the project node, click **Retarget Projects**, choose the version(s) you wish to target, and then click **OK**.</span></span>

<span data-ttu-id="58b89-348">これら 2 つのメソッドのいずれかを使用した後、コンパイラやリンカー エラーが発生するかどうかは、ソリューションをクリーニングを再試行してください (**ビルド** > **ソリューションのクリーン**またはすべてを手動で削除一時フォルダーおよびファイル) をもう一度ビルドを試みる前にします。</span><span class="sxs-lookup"><span data-stu-id="58b89-348">If you encounter any compiler or linker errors after using either of these two methods, then you can try cleaning the solution (**Build** > **Clean Solution** and/or manually delete all temporary folders and files) before trying to build again.</span></span>

<span data-ttu-id="58b89-349">C++ コンパイラが生成した場合"*エラー C2039:'IUnknown': のメンバーではない '\`グローバル名前空間'*"、追加し、`#include <unknwn.h>`の先頭に、`pch.h`ファイル (C +、インクルードする前に/cli WinRT ヘッダー)。</span><span class="sxs-lookup"><span data-stu-id="58b89-349">If the C++ compiler produces "*error C2039: 'IUnknown': is not a member of '\`global namespace''*", then add `#include <unknwn.h>` to the top of your `pch.h` file (before you include any C++/WinRT headers).</span></span>

<span data-ttu-id="58b89-350">追加する必要がありますも`#include <hstring.h>`にします。</span><span class="sxs-lookup"><span data-stu-id="58b89-350">You may also need to add `#include <hstring.h>` after that.</span></span>

<span data-ttu-id="58b89-351">C++ リンカーが生成した場合"*エラー LNK2019: 未解決の外部シンボル_WINRT_CanUnloadNow@0関数で参照されている_VSDesignerCanUnloadNow@0* "を追加することで解決できます`#define _VSDESIGNER_DONT_LOAD_AS_DLL`を`pch.h`ファイル。</span><span class="sxs-lookup"><span data-stu-id="58b89-351">If the C++ linker produces "*error LNK2019: unresolved external symbol _WINRT_CanUnloadNow@0 referenced in function _VSDesignerCanUnloadNow@0*", then you can resolve that by adding `#define _VSDESIGNER_DONT_LOAD_AS_DLL` to your `pch.h` file.</span></span>
