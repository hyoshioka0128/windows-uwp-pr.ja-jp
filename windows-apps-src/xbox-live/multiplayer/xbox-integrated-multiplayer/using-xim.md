---
title: Using XIM
author: KevinAsgari
description: Learn how to implement Xbox Integrated Multiplayer (XIM) into your game.
ms.assetid: f5a2c68b-b1f9-4533-9282-41c31eab2487
ms.author: kevinasg
ms.date: 04-04-2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: xbox live, xbox, games, xbox one, xbox integrated multiplayer
ms.openlocfilehash: 9c1f5dff04024fb82a02df78d1964b3ca86c9eff
ms.sourcegitcommit: b73a57142b9847b09ebb00e81396f2655bbc26ec
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/12/2017
---
# <a name="using-xim"></a><span data-ttu-id="f46d9-104">Using XIM</span><span class="sxs-lookup"><span data-stu-id="f46d9-104">Using XIM</span></span>

<span data-ttu-id="f46d9-105">This is a brief walkthrough on using XIM, containing the following topics:</span><span class="sxs-lookup"><span data-stu-id="f46d9-105">This is a brief walkthrough on using XIM, containing the following topics:</span></span>

1. [<span data-ttu-id="f46d9-106">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="f46d9-106">Prerequisites</span></span>](#prereq)
2. [<span data-ttu-id="f46d9-107">Initialization and startup</span><span class="sxs-lookup"><span data-stu-id="f46d9-107">Initialization and startup</span></span>](#init)
3. [<span data-ttu-id="f46d9-108">Asynchronous operations and processing state changes</span><span class="sxs-lookup"><span data-stu-id="f46d9-108">Asynchronous operations and processing state changes</span></span>](#async)
4. [<span data-ttu-id="f46d9-109">Basic xim_player handling</span><span class="sxs-lookup"><span data-stu-id="f46d9-109">Basic xim_player handling</span></span>](#player)
5. [<span data-ttu-id="f46d9-110">Enabling friends to join and inviting them</span><span class="sxs-lookup"><span data-stu-id="f46d9-110">Enabling friends to join and inviting them</span></span>](#invites)
6. [<span data-ttu-id="f46d9-111">Sending and receiving messages</span><span class="sxs-lookup"><span data-stu-id="f46d9-111">Sending and receiving messages</span></span>](#send)
7. [<span data-ttu-id="f46d9-112">Basic matchmaking and moving to another XIM network with others</span><span class="sxs-lookup"><span data-stu-id="f46d9-112">Basic matchmaking and moving to another XIM network with others</span></span>](#basicmatch)
8. [<span data-ttu-id="f46d9-113">Leaving a XIM network and cleaning up</span><span class="sxs-lookup"><span data-stu-id="f46d9-113">Leaving a XIM network and cleaning up</span></span>](#leave)
9. [<span data-ttu-id="f46d9-114">Working with chat</span><span class="sxs-lookup"><span data-stu-id="f46d9-114">Working with chat</span></span>](#chat)
10. [<span data-ttu-id="f46d9-115">Configuring custom player and network properties</span><span class="sxs-lookup"><span data-stu-id="f46d9-115">Configuring custom player and network properties</span></span>](#properties)
11. [<span data-ttu-id="f46d9-116">Matchmaking using per-player skill or role</span><span class="sxs-lookup"><span data-stu-id="f46d9-116">Matchmaking using per-player skill or role</span></span>](#roles)
12. [<span data-ttu-id="f46d9-117">Player teams and configuring chat targets</span><span class="sxs-lookup"><span data-stu-id="f46d9-117">Player teams and configuring chat targets</span></span>](#teams)
13. [<span data-ttu-id="f46d9-118">Automatic background filling of player slots ("backfill" matchmaking)</span><span class="sxs-lookup"><span data-stu-id="f46d9-118">Automatic background filling of player slots ("backfill" matchmaking)</span></span>](#backfill)
14. [<span data-ttu-id="f46d9-119">The role of servers, "host migration", and XIM authorities</span><span class="sxs-lookup"><span data-stu-id="f46d9-119">The role of servers, "host migration", and XIM authorities</span></span>](#authority)

## <a name="prerequisites-a-nameprereq"></a><span data-ttu-id="f46d9-120">Prerequisites <a name="prereq"></span><span class="sxs-lookup"><span data-stu-id="f46d9-120">Prerequisites <a name="prereq"></span></span>

<span data-ttu-id="f46d9-121">Before you get started coding with XIM, there are two prerequisites.</span><span class="sxs-lookup"><span data-stu-id="f46d9-121">Before you get started coding with XIM, there are two prerequisites.</span></span> <span data-ttu-id="f46d9-122">First, you must have configured your app's AppXManifest with standard multiplayer networking capabilities and you must have configured its "network manifest" to declare the necessary traffic pattern templates used by XIM.</span><span class="sxs-lookup"><span data-stu-id="f46d9-122">First, you must have configured your app's AppXManifest with standard multiplayer networking capabilities and you must have configured its "network manifest" to declare the necessary traffic pattern templates used by XIM.</span></span>

> <span data-ttu-id="f46d9-123">AppXManifest capabilities and network manifests are described in more detail in their respective sections of the platform documentation; the typical XIM-specific XML to paste is provided at [XIM Project Configuration](xim-manifest.md).</span><span class="sxs-lookup"><span data-stu-id="f46d9-123">AppXManifest capabilities and network manifests are described in more detail in their respective sections of the platform documentation; the typical XIM-specific XML to paste is provided at [XIM Project Configuration](xim-manifest.md).</span></span>

<span data-ttu-id="f46d9-124">Second, you'll need to have two pieces of application identity information available: the assigned Xbox Live title ID and service configuration ID provided as part of provisioning your application for access to the Xbox Live service.</span><span class="sxs-lookup"><span data-stu-id="f46d9-124">Second, you'll need to have two pieces of application identity information available: the assigned Xbox Live title ID and service configuration ID provided as part of provisioning your application for access to the Xbox Live service.</span></span> <span data-ttu-id="f46d9-125">See your Microsoft representative for more information on acquiring these.</span><span class="sxs-lookup"><span data-stu-id="f46d9-125">See your Microsoft representative for more information on acquiring these.</span></span> <span data-ttu-id="f46d9-126">These pieces of information will be used during initialization.</span><span class="sxs-lookup"><span data-stu-id="f46d9-126">These pieces of information will be used during initialization.</span></span>

<span data-ttu-id="f46d9-127">Compiling XIM requires including the primary XboxIntegratedMultiplayer.h header.</span><span class="sxs-lookup"><span data-stu-id="f46d9-127">Compiling XIM requires including the primary XboxIntegratedMultiplayer.h header.</span></span> <span data-ttu-id="f46d9-128">In order to link properly, your project must also include XboxIntegratedMultiplayerImpl.h in at least one compilation unit (a common precompiled header is recommended since these stub function implementations are small and easy for the compiler to generate as "inline").</span><span class="sxs-lookup"><span data-stu-id="f46d9-128">In order to link properly, your project must also include XboxIntegratedMultiplayerImpl.h in at least one compilation unit (a common precompiled header is recommended since these stub function implementations are small and easy for the compiler to generate as "inline").</span></span>

<span data-ttu-id="f46d9-129">The XIM interface does not require a project to choose between compiling with C++/CX versus traditional C++; it can be used with either.</span><span class="sxs-lookup"><span data-stu-id="f46d9-129">The XIM interface does not require a project to choose between compiling with C++/CX versus traditional C++; it can be used with either.</span></span> <span data-ttu-id="f46d9-130">The implementation also doesn't throw exceptions as a means of non-fatal error reporting so you can consume it easily from exception-free projects if preferred.</span><span class="sxs-lookup"><span data-stu-id="f46d9-130">The implementation also doesn't throw exceptions as a means of non-fatal error reporting so you can consume it easily from exception-free projects if preferred.</span></span>

## <a name="initialization-and-startup-a-nameinit"></a><span data-ttu-id="f46d9-131">Initialization and startup <a name="init"></span><span class="sxs-lookup"><span data-stu-id="f46d9-131">Initialization and startup <a name="init"></span></span>

<span data-ttu-id="f46d9-132">You begin interacting with the library by initializing the XIM object singleton with your Xbox Live service configuration ID string and title ID number.</span><span class="sxs-lookup"><span data-stu-id="f46d9-132">You begin interacting with the library by initializing the XIM object singleton with your Xbox Live service configuration ID string and title ID number.</span></span> <span data-ttu-id="f46d9-133">If you're also using the Xbox Services API, you may find it convenient to retrieve these from `xbox::services::xbox_live_app_config`).</span><span class="sxs-lookup"><span data-stu-id="f46d9-133">If you're also using the Xbox Services API, you may find it convenient to retrieve these from `xbox::services::xbox_live_app_config`).</span></span> <span data-ttu-id="f46d9-134">The following example assumes the values already reside in 'myServiceConfigurationId' and 'myTitleId' variables respectively:</span><span class="sxs-lookup"><span data-stu-id="f46d9-134">The following example assumes the values already reside in 'myServiceConfigurationId' and 'myTitleId' variables respectively:</span></span>

```cpp
xim::singleton_instance().initialize(myServiceConfigurationId, myTitleId);
```

<span data-ttu-id="f46d9-135">Once initialized, the app should retrieve the Xbox User ID strings for all users currently on the local device that will participate, and pass them to a `xim::set_intended_local_xbox_user_ids()` call.</span><span class="sxs-lookup"><span data-stu-id="f46d9-135">Once initialized, the app should retrieve the Xbox User ID strings for all users currently on the local device that will participate, and pass them to a `xim::set_intended_local_xbox_user_ids()` call.</span></span> <span data-ttu-id="f46d9-136">The following sample code assumes a single user has pressed a controller button expressing intent to play and the Xbox User ID string associated with the user has already been retrieved into a 'myXuid' variable:</span><span class="sxs-lookup"><span data-stu-id="f46d9-136">The following sample code assumes a single user has pressed a controller button expressing intent to play and the Xbox User ID string associated with the user has already been retrieved into a 'myXuid' variable:</span></span>

```cpp
xim::singleton_instance().set_intended_local_xbox_user_ids(1, &myXuid);
```

<span data-ttu-id="f46d9-137">A call to `xim::set_intended_local_xbox_user_ids()` immediately sets the Xbox User IDs associated with the local users that should be added to the XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-137">A call to `xim::set_intended_local_xbox_user_ids()` immediately sets the Xbox User IDs associated with the local users that should be added to the XIM network.</span></span> <span data-ttu-id="f46d9-138">This list of Xbox User IDs will be used in all future network operations until the list changes through another call to `xim::set_intended_local_xbox_user_ids()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-138">This list of Xbox User IDs will be used in all future network operations until the list changes through another call to `xim::set_intended_local_xbox_user_ids()`.</span></span>

<span data-ttu-id="f46d9-139">In this case there is no XIM network at all yet, so you must begin moving to a XIM network to get that process started.</span><span class="sxs-lookup"><span data-stu-id="f46d9-139">In this case there is no XIM network at all yet, so you must begin moving to a XIM network to get that process started.</span></span> <span data-ttu-id="f46d9-140">The best practice if the user doesn't already have a specific XIM network in mind is to simply move to a new, empty one that you allow the user's friends to join, as a sort of "lobby" from which they can collaborate to select their next multiplayer activity (such as entering matchmaking together).</span><span class="sxs-lookup"><span data-stu-id="f46d9-140">The best practice if the user doesn't already have a specific XIM network in mind is to simply move to a new, empty one that you allow the user's friends to join, as a sort of "lobby" from which they can collaborate to select their next multiplayer activity (such as entering matchmaking together).</span></span> <span data-ttu-id="f46d9-141">An example starting to move just the local users previously added to such an empty XIM network with room for up to 8 total players would be:</span><span class="sxs-lookup"><span data-stu-id="f46d9-141">An example starting to move just the local users previously added to such an empty XIM network with room for up to 8 total players would be:</span></span>

```cpp
xim::singleton_instance().move_to_new_network(8, xim_players_to_move::bring_only_local_players);
```
<span data-ttu-id="f46d9-142">Now the asynchronous move operation will begin, and you can learn of its eventual results by regularly processing state changes.</span><span class="sxs-lookup"><span data-stu-id="f46d9-142">Now the asynchronous move operation will begin, and you can learn of its eventual results by regularly processing state changes.</span></span>

## <a name="asynchronous-operations-and-processing-state-changes-a-nameasync"></a><span data-ttu-id="f46d9-143">Asynchronous operations and processing state changes <a name="async"></span><span class="sxs-lookup"><span data-stu-id="f46d9-143">Asynchronous operations and processing state changes <a name="async"></span></span>

<span data-ttu-id="f46d9-144">The heart of XIM is the app's regular, frequent calls to the `xim::start_processing_state_changes()` and `xim::finish_processing_state_changes()` pair of methods.</span><span class="sxs-lookup"><span data-stu-id="f46d9-144">The heart of XIM is the app's regular, frequent calls to the `xim::start_processing_state_changes()` and `xim::finish_processing_state_changes()` pair of methods.</span></span> <span data-ttu-id="f46d9-145">These methods are how XIM is informed that the app is ready to handle updates to multiplayer state, and how XIM provides those updates.</span><span class="sxs-lookup"><span data-stu-id="f46d9-145">These methods are how XIM is informed that the app is ready to handle updates to multiplayer state, and how XIM provides those updates.</span></span> <span data-ttu-id="f46d9-146">They're designed to operate quickly such that they can be called every graphics frame in your UI rendering loop.</span><span class="sxs-lookup"><span data-stu-id="f46d9-146">They're designed to operate quickly such that they can be called every graphics frame in your UI rendering loop.</span></span> <span data-ttu-id="f46d9-147">This provides a convenient place to retrieve all queued changes without worrying about the unpredictability of network timing or multi-threaded callback complexity.</span><span class="sxs-lookup"><span data-stu-id="f46d9-147">This provides a convenient place to retrieve all queued changes without worrying about the unpredictability of network timing or multi-threaded callback complexity.</span></span> <span data-ttu-id="f46d9-148">The XIM API is actually optimized for this single-threaded pattern.</span><span class="sxs-lookup"><span data-stu-id="f46d9-148">The XIM API is actually optimized for this single-threaded pattern.</span></span> <span data-ttu-id="f46d9-149">It guarantees its state will remain unchanged outside of these two functions, so you can use it directly and efficiently.</span><span class="sxs-lookup"><span data-stu-id="f46d9-149">It guarantees its state will remain unchanged outside of these two functions, so you can use it directly and efficiently.</span></span>

<span data-ttu-id="f46d9-150">For the same reason, all objects returned by the XIM API should *not* be considered thread-safe.</span><span class="sxs-lookup"><span data-stu-id="f46d9-150">For the same reason, all objects returned by the XIM API should *not* be considered thread-safe.</span></span> <span data-ttu-id="f46d9-151">The library has internal multithreading protection, but you will still need to implement your own locking if you require one thread to access any values-- for example, walking the `xim::players()` list-- while another thread might be invoking either `xim::start_processing_state_changes()` or `xim::finish_processing_state_changes()` and altering the memory associated with that player list.</span><span class="sxs-lookup"><span data-stu-id="f46d9-151">The library has internal multithreading protection, but you will still need to implement your own locking if you require one thread to access any values-- for example, walking the `xim::players()` list-- while another thread might be invoking either `xim::start_processing_state_changes()` or `xim::finish_processing_state_changes()` and altering the memory associated with that player list.</span></span>

<span data-ttu-id="f46d9-152">When `xim::start_processing_state_changes()` is called, all queued updates are reported in an array of `xim_state_change` structure pointers.</span><span class="sxs-lookup"><span data-stu-id="f46d9-152">When `xim::start_processing_state_changes()` is called, all queued updates are reported in an array of `xim_state_change` structure pointers.</span></span> <span data-ttu-id="f46d9-153">Apps should iterate over the array, inspect the base structure for its more specific type, cast the base structure type to the corresponding more detailed type, and then handle that update as appropriate.</span><span class="sxs-lookup"><span data-stu-id="f46d9-153">Apps should iterate over the array, inspect the base structure for its more specific type, cast the base structure type to the corresponding more detailed type, and then handle that update as appropriate.</span></span> <span data-ttu-id="f46d9-154">Once finished with all the `xim_state_change` structures currently available, that array should be passed back to XIM to release the resources by calling `xim::finish_processing_state_changes()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-154">Once finished with all the `xim_state_change` structures currently available, that array should be passed back to XIM to release the resources by calling `xim::finish_processing_state_changes()`.</span></span> <span data-ttu-id="f46d9-155">For example:</span><span class="sxs-lookup"><span data-stu-id="f46d9-155">For example:</span></span>

```cpp
uint32_t stateChangeCount;
xim_state_change_array stateChanges;
xim::singleton_instance().start_processing_state_changes(&stateChangeCount, &stateChanges);
for (uint32_t stateChangeIndex = 0; stateChangeIndex < stateChangeCount; stateChangeIndex++)
{
   const xim_state_change * stateChange = stateChanges[stateChangeIndex];
   switch (stateChange->state_change_type)
   {
       case xim_state_change_type::player_joined:
       {
           MyHandlePlayerJoined(static_cast<const xim_player_joined_state_change*>(stateChange));
           break;
        }

       case xim_state_change_type::player_left:
       {
           MyHandlePlayerLeft(static_cast<const xim_player_left_state_change*>(stateChange));
           break;
       }

       ...
    }
 }
 xim::singleton_instance().finish_processing_state_changes(stateChanges);
```

<span data-ttu-id="f46d9-156">Now that you have your basic processing loop, you can handle the state changes associated with the initial `xim::move_to_new_network()` operation.</span><span class="sxs-lookup"><span data-stu-id="f46d9-156">Now that you have your basic processing loop, you can handle the state changes associated with the initial `xim::move_to_new_network()` operation.</span></span> <span data-ttu-id="f46d9-157">Every XIM network move operation will begin with a `xim_move_to_network_starting_state_change`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-157">Every XIM network move operation will begin with a `xim_move_to_network_starting_state_change`.</span></span> <span data-ttu-id="f46d9-158">If the move fails for any reason, then your app will be provided a `xim_network_exited_state_change`, which is the common failure handling mechanism for any asynchronous fatal error that prevents you from moving to a XIM network or disconnects you from the current XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-158">If the move fails for any reason, then your app will be provided a `xim_network_exited_state_change`, which is the common failure handling mechanism for any asynchronous fatal error that prevents you from moving to a XIM network or disconnects you from the current XIM network.</span></span> <span data-ttu-id="f46d9-159">Otherwise, the move will complete with a `xim_move_to_network_succeeded_state_change` after all the state has been finalized and all the players have been successfully added to the XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-159">Otherwise, the move will complete with a `xim_move_to_network_succeeded_state_change` after all the state has been finalized and all the players have been successfully added to the XIM network.</span></span>

## <a name="basic-ximplayer-handling-a-nameplayer"></a><span data-ttu-id="f46d9-160">Basic xim_player handling <a name="player"></span><span class="sxs-lookup"><span data-stu-id="f46d9-160">Basic xim_player handling <a name="player"></span></span>

<span data-ttu-id="f46d9-161">Assuming the example of moving a single local user to a new XIM network succeeded, your app has also been provided a `xim_player_joined_state_change` for a local `xim_player` object.</span><span class="sxs-lookup"><span data-stu-id="f46d9-161">Assuming the example of moving a single local user to a new XIM network succeeded, your app has also been provided a `xim_player_joined_state_change` for a local `xim_player` object.</span></span> <span data-ttu-id="f46d9-162">This object pointer will remain valid for as long as the player instance itself is valid, which is up until the corresponding `xim_player_left_state_change` for it has been provided and returned via `xim::finish_processing_state_changes()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-162">This object pointer will remain valid for as long as the player instance itself is valid, which is up until the corresponding `xim_player_left_state_change` for it has been provided and returned via `xim::finish_processing_state_changes()`.</span></span> <span data-ttu-id="f46d9-163">Your app will always be provided a `xim_player_left_state_change` for every `xim_player_joined_state_change`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-163">Your app will always be provided a `xim_player_left_state_change` for every `xim_player_joined_state_change`.</span></span> <span data-ttu-id="f46d9-164">You can also retrieve an array of all `xim_player` objects in the XIM network at any time by using `xim::get_players()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-164">You can also retrieve an array of all `xim_player` objects in the XIM network at any time by using `xim::get_players()`.</span></span>

<span data-ttu-id="f46d9-165">The `xim_player` object has many helpful methods, such as `xim_player::gamertag()` for retrieving the current Xbox Live Gamertag string associated with the player for display purposes.</span><span class="sxs-lookup"><span data-stu-id="f46d9-165">The `xim_player` object has many helpful methods, such as `xim_player::gamertag()` for retrieving the current Xbox Live Gamertag string associated with the player for display purposes.</span></span> <span data-ttu-id="f46d9-166">If the `xim_player` is local to the device, then it will also report a non-null `xim_player::xim_local` object pointer from `xim_player::local()`, which has additional methods only available to local players.</span><span class="sxs-lookup"><span data-stu-id="f46d9-166">If the `xim_player` is local to the device, then it will also report a non-null `xim_player::xim_local` object pointer from `xim_player::local()`, which has additional methods only available to local players.</span></span>

<span data-ttu-id="f46d9-167">Of course, the most important state for players is not the common information that XIM knows, but what your specific app wants to track, and since you likely have your own object for that, you'll want to link the `xim_player` object to yours so that any time XIM reports a `xim_player` you can quickly get to your state without having to perform a lookup by setting a custom player context pointer.</span><span class="sxs-lookup"><span data-stu-id="f46d9-167">Of course, the most important state for players is not the common information that XIM knows, but what your specific app wants to track, and since you likely have your own object for that, you'll want to link the `xim_player` object to yours so that any time XIM reports a `xim_player` you can quickly get to your state without having to perform a lookup by setting a custom player context pointer.</span></span> <span data-ttu-id="f46d9-168">The following example assumes a pointer to your private state is in the variable 'myPlayerStateObject' and the newly added `xim_player` object is in the variable 'newXimPlayer':</span><span class="sxs-lookup"><span data-stu-id="f46d9-168">The following example assumes a pointer to your private state is in the variable 'myPlayerStateObject' and the newly added `xim_player` object is in the variable 'newXimPlayer':</span></span>

```cpp
newXimPlayer->set_custom_player_context(myPlayerStateObject);
```

<span data-ttu-id="f46d9-169">This saves the specified pointer value with the player object locally (it is never transferred over the network to remote devices where the memory would not be valid).</span><span class="sxs-lookup"><span data-stu-id="f46d9-169">This saves the specified pointer value with the player object locally (it is never transferred over the network to remote devices where the memory would not be valid).</span></span> <span data-ttu-id="f46d9-170">You'll then be able to always get back to your object by retrieving the custom context and casting it back to your object like the following example:</span><span class="sxs-lookup"><span data-stu-id="f46d9-170">You'll then be able to always get back to your object by retrieving the custom context and casting it back to your object like the following example:</span></span>

```cpp
myPlayerStateObject = reinterpret_cast<MyPlayerState *>(newXimPlayer->custom_player_context());
```

<span data-ttu-id="f46d9-171">You can change this custom player context pointer at any time.</span><span class="sxs-lookup"><span data-stu-id="f46d9-171">You can change this custom player context pointer at any time.</span></span>

<span data-ttu-id="f46d9-172">With this basic player handling, you're now ready to enable remote users to join this XIM network through existing social relationships with the local users.</span><span class="sxs-lookup"><span data-stu-id="f46d9-172">With this basic player handling, you're now ready to enable remote users to join this XIM network through existing social relationships with the local users.</span></span>

## <a name="enabling-friends-to-join-and-inviting-thema-nameinvites"></a><span data-ttu-id="f46d9-173">Enabling friends to join and inviting them<a name="invites"></span><span class="sxs-lookup"><span data-stu-id="f46d9-173">Enabling friends to join and inviting them<a name="invites"></span></span>

<span data-ttu-id="f46d9-174">For privacy and security, all new XIM networks are automatically configured by default to not be joinable by any additional players, and it's up to the app to explicitly allow them once it is ready.</span><span class="sxs-lookup"><span data-stu-id="f46d9-174">For privacy and security, all new XIM networks are automatically configured by default to not be joinable by any additional players, and it's up to the app to explicitly allow them once it is ready.</span></span> <span data-ttu-id="f46d9-175">The following example shows how to use xim::set_allowed_player_joins() to begin allowing new local users to join as players, as well other users that have been invited or that are being "followed" (an Xbox Live social relationship):</span><span class="sxs-lookup"><span data-stu-id="f46d9-175">The following example shows how to use xim::set_allowed_player_joins() to begin allowing new local users to join as players, as well other users that have been invited or that are being "followed" (an Xbox Live social relationship):</span></span>

```cpp
xim::singleton_instance().set_allowed_player_joins(xim_allowed_player_joins::local_invited_or_followed);
```

<span data-ttu-id="f46d9-176">This happens asynchronously.</span><span class="sxs-lookup"><span data-stu-id="f46d9-176">This happens asynchronously.</span></span> <span data-ttu-id="f46d9-177">Once complete, a `xim_allowed_player_joins_changed_state_change` is provided to notify you that its value has changed from its default of `xim_allowed_player_joins::none`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-177">Once complete, a `xim_allowed_player_joins_changed_state_change` is provided to notify you that its value has changed from its default of `xim_allowed_player_joins::none`.</span></span> <span data-ttu-id="f46d9-178">You can query the new value then or at any by using `xim::allowed_player_joins()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-178">You can query the new value then or at any by using `xim::allowed_player_joins()`.</span></span>

<span data-ttu-id="f46d9-179">Now the local player may want to send out invitations to remote users to join this XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-179">Now the local player may want to send out invitations to remote users to join this XIM network.</span></span> <span data-ttu-id="f46d9-180">This is trivially accomplished by calling `xim_player::xim_local::show_invite_ui()` to launch the system invitation UI where the local user can select people and send invitations.</span><span class="sxs-lookup"><span data-stu-id="f46d9-180">This is trivially accomplished by calling `xim_player::xim_local::show_invite_ui()` to launch the system invitation UI where the local user can select people and send invitations.</span></span> <span data-ttu-id="f46d9-181">The following example demonstrates this, assuming the variable 'ximPlayer' points to a valid local `xim_player`:</span><span class="sxs-lookup"><span data-stu-id="f46d9-181">The following example demonstrates this, assuming the variable 'ximPlayer' points to a valid local `xim_player`:</span></span>

```cpp
ximPlayer->local()->show_invite_ui();
```

<span data-ttu-id="f46d9-182">The system invitation UI will now display, and once the user has sent the invitations (or otherwise dismissed the UI), a `xim_show_invite_ui_completed_state_change` will be provided.</span><span class="sxs-lookup"><span data-stu-id="f46d9-182">The system invitation UI will now display, and once the user has sent the invitations (or otherwise dismissed the UI), a `xim_show_invite_ui_completed_state_change` will be provided.</span></span> <span data-ttu-id="f46d9-183">Alternatively, your app can send the invitations directly using `xim_player::xim_local::invite_users()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-183">Alternatively, your app can send the invitations directly using `xim_player::xim_local::invite_users()`.</span></span> <span data-ttu-id="f46d9-184">Either way, the remote users will receive an Xbox Live invitation message wherever they are signed in, and can choose to accept.</span><span class="sxs-lookup"><span data-stu-id="f46d9-184">Either way, the remote users will receive an Xbox Live invitation message wherever they are signed in, and can choose to accept.</span></span> <span data-ttu-id="f46d9-185">This will launch your app on those devices if it isn't already running, and "protocol activate" it with the event arguments that can be used to move to this same XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-185">This will launch your app on those devices if it isn't already running, and "protocol activate" it with the event arguments that can be used to move to this same XIM network.</span></span> <span data-ttu-id="f46d9-186">See the platform documentation for more information on activation itself.</span><span class="sxs-lookup"><span data-stu-id="f46d9-186">See the platform documentation for more information on activation itself.</span></span> <span data-ttu-id="f46d9-187">The following example shows how to take the event arguments and call `xim::extract_protocol_activation_information()` to determine if they're applicable to XIM, assuming you've already retrieved the raw URI string from `Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs` to a variable 'uriString':</span><span class="sxs-lookup"><span data-stu-id="f46d9-187">The following example shows how to take the event arguments and call `xim::extract_protocol_activation_information()` to determine if they're applicable to XIM, assuming you've already retrieved the raw URI string from `Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs` to a variable 'uriString':</span></span>

```cpp
xim_protocol_activation_information activationInfo;
bool isXimActivation;
isXimActivation = xim::singleton_instance().extract_protocol_activation_information(uriString, &activationInfo);

```

<span data-ttu-id="f46d9-188">If it is a XIM activation, then you will want to ensure the local user identified in the 'local_xbox_user_id' field of the filled-in `xim_protocol_activation_information` structure is signed in and is among the users specified to `xim::set_intended_local_xbox_user_ids()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-188">If it is a XIM activation, then you will want to ensure the local user identified in the 'local_xbox_user_id' field of the filled-in `xim_protocol_activation_information` structure is signed in and is among the users specified to `xim::set_intended_local_xbox_user_ids()`.</span></span> <span data-ttu-id="f46d9-189">Then you can initiate moving to the specified XIM network with a call to `xim::move_to_network_using_protocol_activated_event_args()` using the same URI string.</span><span class="sxs-lookup"><span data-stu-id="f46d9-189">Then you can initiate moving to the specified XIM network with a call to `xim::move_to_network_using_protocol_activated_event_args()` using the same URI string.</span></span> <span data-ttu-id="f46d9-190">For example:</span><span class="sxs-lookup"><span data-stu-id="f46d9-190">For example:</span></span>

```cpp
xim::singleton_instance().move_to_network_using_protocol_activated_event_args(uriString);
```

<span data-ttu-id="f46d9-191">Also note that "followed" remote users can navigate to the local user's player card in the system UI and initiate a join attempt themselves without an invitation (assuming you've allowed such player joins as shown above).</span><span class="sxs-lookup"><span data-stu-id="f46d9-191">Also note that "followed" remote users can navigate to the local user's player card in the system UI and initiate a join attempt themselves without an invitation (assuming you've allowed such player joins as shown above).</span></span> <span data-ttu-id="f46d9-192">These will protocol activate your app just like invites and don't need to be handled any differently.</span><span class="sxs-lookup"><span data-stu-id="f46d9-192">These will protocol activate your app just like invites and don't need to be handled any differently.</span></span>

<span data-ttu-id="f46d9-193">Moving to a XIM network using protocol activation is identical to moving to a new XIM network like was done earlier.</span><span class="sxs-lookup"><span data-stu-id="f46d9-193">Moving to a XIM network using protocol activation is identical to moving to a new XIM network like was done earlier.</span></span> <span data-ttu-id="f46d9-194">The only difference is that when the move succeeds, the moving device will have been provided both local and remote player `xim_player_joined_state_change` structures representing the applicable players.</span><span class="sxs-lookup"><span data-stu-id="f46d9-194">The only difference is that when the move succeeds, the moving device will have been provided both local and remote player `xim_player_joined_state_change` structures representing the applicable players.</span></span> <span data-ttu-id="f46d9-195">And naturally, the device that was already in the XIM network won't be moving, but will see the new device's users be added as players with additional `xim_player_joined_state_change` structures.</span><span class="sxs-lookup"><span data-stu-id="f46d9-195">And naturally, the device that was already in the XIM network won't be moving, but will see the new device's users be added as players with additional `xim_player_joined_state_change` structures.</span></span>


<span data-ttu-id="f46d9-196">At this point, voice and text chat communication is automatically enabled among the players on these different devices in this XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-196">At this point, voice and text chat communication is automatically enabled among the players on these different devices in this XIM network.</span></span> <span data-ttu-id="f46d9-197">You're now fully ready for multiplayer and any app-specific messages you want to send.</span><span class="sxs-lookup"><span data-stu-id="f46d9-197">You're now fully ready for multiplayer and any app-specific messages you want to send.</span></span>

## <a name="sending-and-receiving-messages-a-namesend"></a><span data-ttu-id="f46d9-198">Sending and receiving messages <a name="send"></span><span class="sxs-lookup"><span data-stu-id="f46d9-198">Sending and receiving messages <a name="send"></span></span>

<span data-ttu-id="f46d9-199">XIM and its underlying components do all the tedious work of establishing secure communication channels over the Internet so you don't have to worry about connectivity problems or being able to reach some but not all players.</span><span class="sxs-lookup"><span data-stu-id="f46d9-199">XIM and its underlying components do all the tedious work of establishing secure communication channels over the Internet so you don't have to worry about connectivity problems or being able to reach some but not all players.</span></span> <span data-ttu-id="f46d9-200">If there are any fundamental peer-to-peer connectivity issues, moving to a XIM network will not succeed.</span><span class="sxs-lookup"><span data-stu-id="f46d9-200">If there are any fundamental peer-to-peer connectivity issues, moving to a XIM network will not succeed.</span></span> <span data-ttu-id="f46d9-201">Otherwise you can be sure that all instances of your app any all the devices will be informed of every `xim_player`, and can send messages to any of them.</span><span class="sxs-lookup"><span data-stu-id="f46d9-201">Otherwise you can be sure that all instances of your app any all the devices will be informed of every `xim_player`, and can send messages to any of them.</span></span> <span data-ttu-id="f46d9-202">The following example assumes a 'sendingPlayer' variable is a pointer to a valid local player object, and sends a message structure 'msgData' to all players (local or remote) in the XIM network (by not passing an array of specific players), with guaranteed, sequential delivery:</span><span class="sxs-lookup"><span data-stu-id="f46d9-202">The following example assumes a 'sendingPlayer' variable is a pointer to a valid local player object, and sends a message structure 'msgData' to all players (local or remote) in the XIM network (by not passing an array of specific players), with guaranteed, sequential delivery:</span></span>

```cpp
sendingPlayer->local()->send_data_to_other_players(sizeof(msgData), &msgData, 0, nullptr, xim_send_type::guaranteed_and_sequential);
```

<span data-ttu-id="f46d9-203">All recipients of the message will be provided a xim_player_to_player_data_received_state_change that includes a pointer to a copy of the data, as well as pointers to the corresponding xim_player object that sent it and are locally receiving it.</span><span class="sxs-lookup"><span data-stu-id="f46d9-203">All recipients of the message will be provided a xim_player_to_player_data_received_state_change that includes a pointer to a copy of the data, as well as pointers to the corresponding xim_player object that sent it and are locally receiving it.</span></span>

<span data-ttu-id="f46d9-204">Of course, guaranteed, sequential delivery is convenient, but it can also be an inefficient send type, since XIM needs to retransmit or delay it if packets are dropped/misordered by the Internet.</span><span class="sxs-lookup"><span data-stu-id="f46d9-204">Of course, guaranteed, sequential delivery is convenient, but it can also be an inefficient send type, since XIM needs to retransmit or delay it if packets are dropped/misordered by the Internet.</span></span> <span data-ttu-id="f46d9-205">Be sure to consider using the other send types for messages that your app can tolerate losing or having arrive out of order.</span><span class="sxs-lookup"><span data-stu-id="f46d9-205">Be sure to consider using the other send types for messages that your app can tolerate losing or having arrive out of order.</span></span>

<span data-ttu-id="f46d9-206">Since message data comes from a remote machine, the best practice is to clearly defined the data formats, such as packing multi-byte values in a particular byte order ("endianness"), and to validate the data before acting on it.</span><span class="sxs-lookup"><span data-stu-id="f46d9-206">Since message data comes from a remote machine, the best practice is to clearly defined the data formats, such as packing multi-byte values in a particular byte order ("endianness"), and to validate the data before acting on it.</span></span> <span data-ttu-id="f46d9-207">XIM provides network-level security so you should not implement any additional encryption or signature scheme, but it is always wise to be robust for "defense-in-depth", to protect against accidental application bugs, or to handle different versions of your application protocol coexisting gracefully (during development, content updates, etc.).</span><span class="sxs-lookup"><span data-stu-id="f46d9-207">XIM provides network-level security so you should not implement any additional encryption or signature scheme, but it is always wise to be robust for "defense-in-depth", to protect against accidental application bugs, or to handle different versions of your application protocol coexisting gracefully (during development, content updates, etc.).</span></span>

<span data-ttu-id="f46d9-208">The user's Internet connection is also a limited, ever-changing resource.</span><span class="sxs-lookup"><span data-stu-id="f46d9-208">The user's Internet connection is also a limited, ever-changing resource.</span></span> <span data-ttu-id="f46d9-209">Be sure to use efficient message data formats and avoid designs that send every UI frame.</span><span class="sxs-lookup"><span data-stu-id="f46d9-209">Be sure to use efficient message data formats and avoid designs that send every UI frame.</span></span> <span data-ttu-id="f46d9-210">You can learn more about the current quality of the path between two players by calling the `xim_player::network_path_information()` method.</span><span class="sxs-lookup"><span data-stu-id="f46d9-210">You can learn more about the current quality of the path between two players by calling the `xim_player::network_path_information()` method.</span></span> <span data-ttu-id="f46d9-211">The following example retrieves a pointer to the `xim_network_path_information` structure for a `xim_player` pointer contained in the 'remotePlayer' variable:</span><span class="sxs-lookup"><span data-stu-id="f46d9-211">The following example retrieves a pointer to the `xim_network_path_information` structure for a `xim_player` pointer contained in the 'remotePlayer' variable:</span></span>

```cpp
 const xim_network_path_information * networkPathInfo = remotePlayer->network_path_information();
```

<span data-ttu-id="f46d9-212">The returned structure includes the estimated round trip latency and how many messages are still queued locally because the connection can't support transmitting more data at the moment.</span><span class="sxs-lookup"><span data-stu-id="f46d9-212">The returned structure includes the estimated round trip latency and how many messages are still queued locally because the connection can't support transmitting more data at the moment.</span></span>

<span data-ttu-id="f46d9-213">`xim_network_path_information::round_trip_latency_in_milliseconds` フィールドは、基盤のネットワークの待機時間と、キューを経由しない場合の XIM の推定待機時間を表します。</span><span class="sxs-lookup"><span data-stu-id="f46d9-213">The `xim_network_path_information::round_trip_latency_in_milliseconds` field represents the latency of the underlying network and XIM's estimated latency without queuing.</span></span> <span data-ttu-id="f46d9-214">実際の遅延時間は、`xim_network_path_information::send_queue_size_in_messages` が大きくなり、XIM がキュー経由で動作するようになるにつれて増加します。</span><span class="sxs-lookup"><span data-stu-id="f46d9-214">Effective latency increases as `xim_network_path_information::send_queue_size_in_messages` grows and XIM works through the queue.</span></span>

<span data-ttu-id="f46d9-215">ゲームの使用状況と要件に基づいて、`send_data_to_other_players` の呼び出しの調整を開始する適切なポイントを選択してください。</span><span class="sxs-lookup"><span data-stu-id="f46d9-215">Choose a reasonable point to start throttling calls to `send_data_to_other_players` based on the game's usage and requirements.</span></span> <span data-ttu-id="f46d9-216">送信キューにメッセージがあるということは、実際のネットワーク待機時間が増えることを意味します。</span><span class="sxs-lookup"><span data-stu-id="f46d9-216">Every message in the send queue represents an increase in the effective network latency.</span></span>

<span data-ttu-id="f46d9-217">XIM の上限 (現在は 3,500 件のメッセージ) に近い値は、ほとんどのゲームにとっては大きすぎ、`send_data_to_other_players` の呼び出し頻度と各データ ペイロードの大きさに応じて、データが送信されるまでに数秒の待機時間が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f46d9-217">A value close to XIM’s max limit (currently 3500 messages) is far too high for most games and  likely represents several seconds of data waiting to be sent depending on the rate of calling `send_data_to_other_players` and how big each data payload is.</span></span> <span data-ttu-id="f46d9-218">代わりに、ゲームの待機時間の要件と、ゲームでの `send_data_to_other_players` の呼び出しパターンの頻度を合わせて考慮して、適切な数値を選択してください。</span><span class="sxs-lookup"><span data-stu-id="f46d9-218">Instead, choose a number that takes into account the game's latency requirements along with how jittery the game's `send_data_to_other_players` calling pattern is.</span></span>


## <a name="basic-matchmaking-and-moving-to-another-xim-network-with-others-a-namebasicmatch"></a><span data-ttu-id="f46d9-219">マッチメイキングの概要および別の XIM ネットワークへの移動 <a name="basicmatch"></span><span class="sxs-lookup"><span data-stu-id="f46d9-219">Basic matchmaking and moving to another XIM network with others <a name="basicmatch"></span></span>

<span data-ttu-id="f46d9-220">You can further expand the experience for a group of friends by moving the players to a XIM network that also has strangers-- opponents from around the world who are brought together using the Xbox Live matchmaking service based on similar interests.</span><span class="sxs-lookup"><span data-stu-id="f46d9-220">You can further expand the experience for a group of friends by moving the players to a XIM network that also has strangers-- opponents from around the world who are brought together using the Xbox Live matchmaking service based on similar interests.</span></span> <span data-ttu-id="f46d9-221">The most basic form is calling `xim::move_to_network_using_matchmaking()` on one of the devices with a populated `xim_matchmaking_configuration` structure, taking players from the current XIM network along with it.</span><span class="sxs-lookup"><span data-stu-id="f46d9-221">The most basic form is calling `xim::move_to_network_using_matchmaking()` on one of the devices with a populated `xim_matchmaking_configuration` structure, taking players from the current XIM network along with it.</span></span> <span data-ttu-id="f46d9-222">The following example initiates a move using matchmaking configured to find a total of 8 players for a no-teams free-for- all (although if 8 aren't found, 2-7 players are also acceptable), using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_DEATHMATCH that will only match with other players specifying that same value, and bringing all socially-joined players from the current XIM network:</span><span class="sxs-lookup"><span data-stu-id="f46d9-222">The following example initiates a move using matchmaking configured to find a total of 8 players for a no-teams free-for- all (although if 8 aren't found, 2-7 players are also acceptable), using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_DEATHMATCH that will only match with other players specifying that same value, and bringing all socially-joined players from the current XIM network:</span></span>

```cpp
xim_matchmaking_configuration matchmakingConfiguration = { 0 };
matchmakingConfiguration.team_matchmaking_mode = xim_team_matchmaking_mode::no_teams_8_players_minimum_2;
matchmakingConfiguration.custom_game_mode = MYGAMEMODE_DEATHMATCH;

xim::singleton_instance().move_to_network_using_matchmaking(matchmakingConfiguration, xim_players_to_move::bring_existing_social_players);
```

<span data-ttu-id="f46d9-223">Like earlier moves, this will provide an initial `xim_move_to_network_starting_state_change` on all devices, and a `xim_move_to_network_succeeded_state_change` once the move completes successfully.</span><span class="sxs-lookup"><span data-stu-id="f46d9-223">Like earlier moves, this will provide an initial `xim_move_to_network_starting_state_change` on all devices, and a `xim_move_to_network_succeeded_state_change` once the move completes successfully.</span></span> <span data-ttu-id="f46d9-224">Since this is a move from one XIM network to another, one difference is that there are already existing `xim_player` objects added for local and remote users, and these will remain for all players that are moving together to the new XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-224">Since this is a move from one XIM network to another, one difference is that there are already existing `xim_player` objects added for local and remote users, and these will remain for all players that are moving together to the new XIM network.</span></span> <span data-ttu-id="f46d9-225">Chat and data communication among them will continue to work uninterrupted while matchmaking is in progress (which can be a lengthy process, depending on the number of potential players in the matchmaking pool that have called `xim::move_to_network_using_matchmaking()` as well).</span><span class="sxs-lookup"><span data-stu-id="f46d9-225">Chat and data communication among them will continue to work uninterrupted while matchmaking is in progress (which can be a lengthy process, depending on the number of potential players in the matchmaking pool that have called `xim::move_to_network_using_matchmaking()` as well).</span></span> <span data-ttu-id="f46d9-226">A `xim_matchmaking_progress_updated_state_change` will be provided periodically throughout the operation to keep you and your users informed of the current status.</span><span class="sxs-lookup"><span data-stu-id="f46d9-226">A `xim_matchmaking_progress_updated_state_change` will be provided periodically throughout the operation to keep you and your users informed of the current status.</span></span> <span data-ttu-id="f46d9-227">When the match has been found, the additional players are added to the XIM network with the typical `xim_player_joined_state_change` and the move completes.</span><span class="sxs-lookup"><span data-stu-id="f46d9-227">When the match has been found, the additional players are added to the XIM network with the typical `xim_player_joined_state_change` and the move completes.</span></span>

<span data-ttu-id="f46d9-228">Once you've finished the multiplayer experience with this set of "matchmade" players, you can repeat the process to move to a different XIM network with another round of matchmaking.</span><span class="sxs-lookup"><span data-stu-id="f46d9-228">Once you've finished the multiplayer experience with this set of "matchmade" players, you can repeat the process to move to a different XIM network with another round of matchmaking.</span></span> <span data-ttu-id="f46d9-229">You'll see each player that joined via the prior `xim::move_to_network_using_matchmaking()` operation provide a `xim_player_left_state_change` to indicate that their `xim_player` objects are no longer in the same XIM network, and only the players that had joined via social means, `xim::move_to_network_using_protocol_activated_event_args()` or `xim::move_to_network_using_joinable_xbox_user_id()`, will remain while the new matchmaking takes place (assuming you specify `xim_players_to_move::bring_existing_social_players` again; specifying `xim_players_to_move::bring_only_local_players` will disconnect from even those remote players, and just the local players will remain).</span><span class="sxs-lookup"><span data-stu-id="f46d9-229">You'll see each player that joined via the prior `xim::move_to_network_using_matchmaking()` operation provide a `xim_player_left_state_change` to indicate that their `xim_player` objects are no longer in the same XIM network, and only the players that had joined via social means, `xim::move_to_network_using_protocol_activated_event_args()` or `xim::move_to_network_using_joinable_xbox_user_id()`, will remain while the new matchmaking takes place (assuming you specify `xim_players_to_move::bring_existing_social_players` again; specifying `xim_players_to_move::bring_only_local_players` will disconnect from even those remote players, and just the local players will remain).</span></span> <span data-ttu-id="f46d9-230">A different set of strangers will be added when the second move operation completes.</span><span class="sxs-lookup"><span data-stu-id="f46d9-230">A different set of strangers will be added when the second move operation completes.</span></span>

<span data-ttu-id="f46d9-231">Alternatively, you can move to a completely new XIM network with just the non-matchmade players (or just local players) before deciding the next matchmaking configuration/multiplayer activity.</span><span class="sxs-lookup"><span data-stu-id="f46d9-231">Alternatively, you can move to a completely new XIM network with just the non-matchmade players (or just local players) before deciding the next matchmaking configuration/multiplayer activity.</span></span> <span data-ttu-id="f46d9-232">The following example demonstrates having a device call `xim::move_to_new_network()` for a XIM network with a maximum of 8 players again, but this time taking the existing socially-joined players as well:</span><span class="sxs-lookup"><span data-stu-id="f46d9-232">The following example demonstrates having a device call `xim::move_to_new_network()` for a XIM network with a maximum of 8 players again, but this time taking the existing socially-joined players as well:</span></span>

```cpp
xim::singleton_instance().move_to_new_network(8, xim_players_to_move::bring_existing_social_players);
```

<span data-ttu-id="f46d9-233">A `xim_move_to_network_starting_state_change` and `xim_move_to_network_succeeded_state_change` will be provided to all participating devices, along with a `xim_player_left_state_change` for the matchmade players staying behind (those devices similarly see a `xim_player_left_state_change` for each player that is moving).</span><span class="sxs-lookup"><span data-stu-id="f46d9-233">A `xim_move_to_network_starting_state_change` and `xim_move_to_network_succeeded_state_change` will be provided to all participating devices, along with a `xim_player_left_state_change` for the matchmade players staying behind (those devices similarly see a `xim_player_left_state_change` for each player that is moving).</span></span>

<span data-ttu-id="f46d9-234">You can continue moving from XIM network to XIM network using matchmaking (or not) in this manner as many times as desired.</span><span class="sxs-lookup"><span data-stu-id="f46d9-234">You can continue moving from XIM network to XIM network using matchmaking (or not) in this manner as many times as desired.</span></span>

<span data-ttu-id="f46d9-235">For performance, the Xbox Live service will not try to match groups of players on devices that are unlikely to be able to establish any direct peer-to-peer connections.</span><span class="sxs-lookup"><span data-stu-id="f46d9-235">For performance, the Xbox Live service will not try to match groups of players on devices that are unlikely to be able to establish any direct peer-to-peer connections.</span></span> <span data-ttu-id="f46d9-236">If you're developing in a network environment that's not properly configured to support standard Xbox Live multiplayer, the `xim::move_to_network_using_matchmaking()` operation might continue indefinitely without matching even when you're certain you have sufficient players meeting the matchmaking criteria who are all moving and all using devices in the same local environment.</span><span class="sxs-lookup"><span data-stu-id="f46d9-236">If you're developing in a network environment that's not properly configured to support standard Xbox Live multiplayer, the `xim::move_to_network_using_matchmaking()` operation might continue indefinitely without matching even when you're certain you have sufficient players meeting the matchmaking criteria who are all moving and all using devices in the same local environment.</span></span> <span data-ttu-id="f46d9-237">Be sure to run the multiplayer connectivity test in the network settings area/Xbox application and follow its recommendations if it reports trouble, particularly regarding a "Strict NAT".</span><span class="sxs-lookup"><span data-stu-id="f46d9-237">Be sure to run the multiplayer connectivity test in the network settings area/Xbox application and follow its recommendations if it reports trouble, particularly regarding a "Strict NAT".</span></span> <span data-ttu-id="f46d9-238">However, if your network administrator is unable to make the necessary environment changes, you can unblock your matchmaking testing on Xbox One development kits by configuring XIM to allow matching "Strict NAT" devices without at least one "Open NAT" device.</span><span class="sxs-lookup"><span data-stu-id="f46d9-238">However, if your network administrator is unable to make the necessary environment changes, you can unblock your matchmaking testing on Xbox One development kits by configuring XIM to allow matching "Strict NAT" devices without at least one "Open NAT" device.</span></span> <span data-ttu-id="f46d9-239">This is done by placing a file called "xim_disable_matchmaking_nat_rule" (contents don't matter) at the root of the "title scratch" drive on all Xbox One consoles.</span><span class="sxs-lookup"><span data-stu-id="f46d9-239">This is done by placing a file called "xim_disable_matchmaking_nat_rule" (contents don't matter) at the root of the "title scratch" drive on all Xbox One consoles.</span></span> <span data-ttu-id="f46d9-240">One example way to do that is by executing the following from an XDK command prompt before launching your app, replacing the placeholder "{console_name_or_ip_address}" for each console as appropriate:</span><span class="sxs-lookup"><span data-stu-id="f46d9-240">One example way to do that is by executing the following from an XDK command prompt before launching your app, replacing the placeholder "{console_name_or_ip_address}" for each console as appropriate:</span></span>

```bat

echo.>%TEMP%\emptyfile.txt
copy %TEMP%\emptyfile.txt \\{console_name_or_ip_address}\TitleScratch\xim_disable_matchmaking_nat_rule
del %TEMP%\emptyfile.txt

```

<span data-ttu-id="f46d9-241">This development workaround is currently only available for Xbox One exclusive resource applications and not for universal Windows applications.</span><span class="sxs-lookup"><span data-stu-id="f46d9-241">This development workaround is currently only available for Xbox One exclusive resource applications and not for universal Windows applications.</span></span> <span data-ttu-id="f46d9-242">Also note that consoles that are using this setting will never match with devices that don't have the file present, regardless of network environment, so be sure to add or remove the file everywhere.</span><span class="sxs-lookup"><span data-stu-id="f46d9-242">Also note that consoles that are using this setting will never match with devices that don't have the file present, regardless of network environment, so be sure to add or remove the file everywhere.</span></span>

## <a name="leaving-a-xim-network-and-cleaning-up-a-nameleave"></a><span data-ttu-id="f46d9-243">Leaving a XIM network and cleaning up <a name="leave"></span><span class="sxs-lookup"><span data-stu-id="f46d9-243">Leaving a XIM network and cleaning up <a name="leave"></span></span>

<span data-ttu-id="f46d9-244">When the local users are done participating in a XIM network, often they will simply move back to a new XIM network that allows local users, invites, and "followed" users to join it so they can continue coordinating with their friends to find the next activity.</span><span class="sxs-lookup"><span data-stu-id="f46d9-244">When the local users are done participating in a XIM network, often they will simply move back to a new XIM network that allows local users, invites, and "followed" users to join it so they can continue coordinating with their friends to find the next activity.</span></span> <span data-ttu-id="f46d9-245">But if the user is completely done with all multiplayer experiences, then your app may want to begin leaving the XIM network altogether and return to the state as if only `xim::initialize()` and `xim::set_intended_local_xbox_user_ids()` had been called.</span><span class="sxs-lookup"><span data-stu-id="f46d9-245">But if the user is completely done with all multiplayer experiences, then your app may want to begin leaving the XIM network altogether and return to the state as if only `xim::initialize()` and `xim::set_intended_local_xbox_user_ids()` had been called.</span></span> <span data-ttu-id="f46d9-246">This is done using the `xim::leave_network()` method:</span><span class="sxs-lookup"><span data-stu-id="f46d9-246">This is done using the `xim::leave_network()` method:</span></span>

```cpp
xim::singleton_instance().leave_network();
```

<span data-ttu-id="f46d9-247">This method begins the process of asynchronously disconnecting from the other participants gracefully.</span><span class="sxs-lookup"><span data-stu-id="f46d9-247">This method begins the process of asynchronously disconnecting from the other participants gracefully.</span></span> <span data-ttu-id="f46d9-248">This will cause the remote devices to be provided a `xim_player_left_state_change` for the local player(s), and the local device will be provided a `xim_player_left_state_change` for each player, local or remote.</span><span class="sxs-lookup"><span data-stu-id="f46d9-248">This will cause the remote devices to be provided a `xim_player_left_state_change` for the local player(s), and the local device will be provided a `xim_player_left_state_change` for each player, local or remote.</span></span> <span data-ttu-id="f46d9-249">When all disconnect operations have finished, a final `xim_network_exited_state_change` will be provided.</span><span class="sxs-lookup"><span data-stu-id="f46d9-249">When all disconnect operations have finished, a final `xim_network_exited_state_change` will be provided.</span></span> <span data-ttu-id="f46d9-250">The app can then call `xim::cleanup()`\` to free all resources and return to the uninitialized state:</span><span class="sxs-lookup"><span data-stu-id="f46d9-250">The app can then call `xim::cleanup()`\` to free all resources and return to the uninitialized state:</span></span>

```cpp
xim::singleton_instance().cleanup();
```

<span data-ttu-id="f46d9-251">Invoking `xim::leave_network()` and waiting for the `xim_network_exited_state_change` in order to exit a XIM network gracefully is always highly recommended when a `xim_network_exited_state_change` has not already been provided.</span><span class="sxs-lookup"><span data-stu-id="f46d9-251">Invoking `xim::leave_network()` and waiting for the `xim_network_exited_state_change` in order to exit a XIM network gracefully is always highly recommended when a `xim_network_exited_state_change` has not already been provided.</span></span> <span data-ttu-id="f46d9-252">Calling `xim::cleanup()` directly may cause communication performance problems for the remaining participants while they're forced to time out messages to the device that simply "disappeared".</span><span class="sxs-lookup"><span data-stu-id="f46d9-252">Calling `xim::cleanup()` directly may cause communication performance problems for the remaining participants while they're forced to time out messages to the device that simply "disappeared".</span></span>

## <a name="working-with-chat-a-namechat"></a><span data-ttu-id="f46d9-253">Working with chat <a name="chat"></span><span class="sxs-lookup"><span data-stu-id="f46d9-253">Working with chat <a name="chat"></span></span>

<span data-ttu-id="f46d9-254">Voice and text chat communication are automatically enabled among players in a XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-254">Voice and text chat communication are automatically enabled among players in a XIM network.</span></span> <span data-ttu-id="f46d9-255">XIM handles interacting with all voice headset and microphone hardware for you.</span><span class="sxs-lookup"><span data-stu-id="f46d9-255">XIM handles interacting with all voice headset and microphone hardware for you.</span></span> <span data-ttu-id="f46d9-256">Your app doesn't need to do much for chat, but it does have one requirement regarding text chat: supporting input and display.</span><span class="sxs-lookup"><span data-stu-id="f46d9-256">Your app doesn't need to do much for chat, but it does have one requirement regarding text chat: supporting input and display.</span></span> <span data-ttu-id="f46d9-257">Text input is required because, even on platforms or game genres that historically haven't had widespread physical keyboard use, players may configure the system to use text-to-speech assistive technologies.</span><span class="sxs-lookup"><span data-stu-id="f46d9-257">Text input is required because, even on platforms or game genres that historically haven't had widespread physical keyboard use, players may configure the system to use text-to-speech assistive technologies.</span></span> <span data-ttu-id="f46d9-258">Similarly, text display is required because players may configure the system to use speech-to-text.</span><span class="sxs-lookup"><span data-stu-id="f46d9-258">Similarly, text display is required because players may configure the system to use speech-to-text.</span></span> <span data-ttu-id="f46d9-259">These preferences can be detected on local players by calling the `xim_player::xim_local::chat_text_to_speech_conversion_preference_enabled()` and `xim_player::xim_local::chat_speech_to_text_conversion_preference_enabled()` methods respectively, and you may wish to conditionally enable text mechanisms.</span><span class="sxs-lookup"><span data-stu-id="f46d9-259">These preferences can be detected on local players by calling the `xim_player::xim_local::chat_text_to_speech_conversion_preference_enabled()` and `xim_player::xim_local::chat_speech_to_text_conversion_preference_enabled()` methods respectively, and you may wish to conditionally enable text mechanisms.</span></span> <span data-ttu-id="f46d9-260">But consider making text input and display options that are always available.</span><span class="sxs-lookup"><span data-stu-id="f46d9-260">But consider making text input and display options that are always available.</span></span>


> `Windows::Xbox::UI::Accessability` <span data-ttu-id="f46d9-261">is an Xbox One class specifically designed to provide simple rendering of in-game text chat with a focus on speech-to-text assistive technologies.</span><span class="sxs-lookup"><span data-stu-id="f46d9-261">is an Xbox One class specifically designed to provide simple rendering of in-game text chat with a focus on speech-to-text assistive technologies.</span></span>

<span data-ttu-id="f46d9-262">Once you have text input provided by a real or virtual keyboard, pass the string to the `xim_player::xim_local::send_chat_text()` method.</span><span class="sxs-lookup"><span data-stu-id="f46d9-262">Once you have text input provided by a real or virtual keyboard, pass the string to the `xim_player::xim_local::send_chat_text()` method.</span></span> <span data-ttu-id="f46d9-263">The following code shows sending an example hard-coded string from a local `xim_player` object pointed to by the variable 'localPlayer':</span><span class="sxs-lookup"><span data-stu-id="f46d9-263">The following code shows sending an example hard-coded string from a local `xim_player` object pointed to by the variable 'localPlayer':</span></span>

```cpp
localPlayer->local()->send_chat_text(L"Example chat text");
```

<span data-ttu-id="f46d9-264">This chat text is delivered to all players in the XIM network that can receive chat communication from the originating local player.</span><span class="sxs-lookup"><span data-stu-id="f46d9-264">This chat text is delivered to all players in the XIM network that can receive chat communication from the originating local player.</span></span> <span data-ttu-id="f46d9-265">It might be synthesized to speech audio and it might be provided as a `xim_chat_text_received_state_change`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-265">It might be synthesized to speech audio and it might be provided as a `xim_chat_text_received_state_change`.</span></span> <span data-ttu-id="f46d9-266">Your app should make a copy of any text string received and display it along with some identification of the originating player for an appropriate amount of time (or in a scrollable window).</span><span class="sxs-lookup"><span data-stu-id="f46d9-266">Your app should make a copy of any text string received and display it along with some identification of the originating player for an appropriate amount of time (or in a scrollable window).</span></span>

<span data-ttu-id="f46d9-267">There are also some best practices regarding chat.</span><span class="sxs-lookup"><span data-stu-id="f46d9-267">There are also some best practices regarding chat.</span></span> <span data-ttu-id="f46d9-268">It's recommended that anywhere players are shown, particularly in a list of gamertags such as a scoreboard, that you also display muted/speaking icons as feedback for the user.</span><span class="sxs-lookup"><span data-stu-id="f46d9-268">It's recommended that anywhere players are shown, particularly in a list of gamertags such as a scoreboard, that you also display muted/speaking icons as feedback for the user.</span></span> <span data-ttu-id="f46d9-269">This is done by calling `xim_player::chat_indicator()` to retrieve a `xim_player_chat_indicator` representing the current, instantaneous status of chat for that player.</span><span class="sxs-lookup"><span data-stu-id="f46d9-269">This is done by calling `xim_player::chat_indicator()` to retrieve a `xim_player_chat_indicator` representing the current, instantaneous status of chat for that player.</span></span> <span data-ttu-id="f46d9-270">The following example demonstrates retrieving the indicator value for a `xim_player` object pointed to by the variable 'ximPlayer' to determine a particular icon constant value to assign to an 'iconToShow' variable:</span><span class="sxs-lookup"><span data-stu-id="f46d9-270">The following example demonstrates retrieving the indicator value for a `xim_player` object pointed to by the variable 'ximPlayer' to determine a particular icon constant value to assign to an 'iconToShow' variable:</span></span>

```cpp
switch (ximPlayer->chat_indicator())
{
   case xim_player_chat_indicator::silent:
   {
       iconToShow = Icon_InactiveSpeaker;
       break;
   }

   case xim_player_chat_indicator::talking:
   {
       iconToShow = Icon_ActiveSpeaker;
       break;
   }

   case xim_player_chat_indicator::muted:
   {
       iconToShow = Icon_MutedSpeaker;
       break;
   }
   ...
}
```

<span data-ttu-id="f46d9-271">The value reported by `xim_player::chat_indicator()` is expected to change frequently as players start and stop talking, for example.</span><span class="sxs-lookup"><span data-stu-id="f46d9-271">The value reported by `xim_player::chat_indicator()` is expected to change frequently as players start and stop talking, for example.</span></span> <span data-ttu-id="f46d9-272">It is designed to support apps polling it every UI frame as a result.</span><span class="sxs-lookup"><span data-stu-id="f46d9-272">It is designed to support apps polling it every UI frame as a result.</span></span>

<span data-ttu-id="f46d9-273">Another best practice is to support muting players.</span><span class="sxs-lookup"><span data-stu-id="f46d9-273">Another best practice is to support muting players.</span></span> <span data-ttu-id="f46d9-274">XIM automatically handles system muting initiated by users through player cards, but apps should support game-specific transient muting that can be performed within the game UI via the `xim_player::set_chat_muted()` method.</span><span class="sxs-lookup"><span data-stu-id="f46d9-274">XIM automatically handles system muting initiated by users through player cards, but apps should support game-specific transient muting that can be performed within the game UI via the `xim_player::set_chat_muted()` method.</span></span> <span data-ttu-id="f46d9-275">The following example begins muting a remote `xim_player` object pointed to by the variable 'remotePlayer' so that no voice chat is heard and no text chat is received from it:</span><span class="sxs-lookup"><span data-stu-id="f46d9-275">The following example begins muting a remote `xim_player` object pointed to by the variable 'remotePlayer' so that no voice chat is heard and no text chat is received from it:</span></span>

```cpp
remotePlayer->set_chat_muted(true);
```

<span data-ttu-id="f46d9-276">The muting takes effect immediately and there is no `xim_state_change` associated with it.</span><span class="sxs-lookup"><span data-stu-id="f46d9-276">The muting takes effect immediately and there is no `xim_state_change` associated with it.</span></span> <span data-ttu-id="f46d9-277">It can be undone by calling `xim_player::set_chat_muted()` again with the false value.</span><span class="sxs-lookup"><span data-stu-id="f46d9-277">It can be undone by calling `xim_player::set_chat_muted()` again with the false value.</span></span> <span data-ttu-id="f46d9-278">The following example unmutes a remote `xim_player` object pointed to by the variable 'remotePlayer':</span><span class="sxs-lookup"><span data-stu-id="f46d9-278">The following example unmutes a remote `xim_player` object pointed to by the variable 'remotePlayer':</span></span>

```cpp
remotePlayer->set_chat_muted(false);
```

<span data-ttu-id="f46d9-279">Mutes remain in effect for as long as the `xim_player` exists, including when moving to a new XIM network with the player.</span><span class="sxs-lookup"><span data-stu-id="f46d9-279">Mutes remain in effect for as long as the `xim_player` exists, including when moving to a new XIM network with the player.</span></span> <span data-ttu-id="f46d9-280">It is not persisted if the player leaves and the same user rejoins (as a new `xim_player` instance).</span><span class="sxs-lookup"><span data-stu-id="f46d9-280">It is not persisted if the player leaves and the same user rejoins (as a new `xim_player` instance).</span></span>

<span data-ttu-id="f46d9-281">Players typically start in the unmuted state.</span><span class="sxs-lookup"><span data-stu-id="f46d9-281">Players typically start in the unmuted state.</span></span> <span data-ttu-id="f46d9-282">If your app wants to start a player in the muted state for gameplay reasons, it can call `xim_player::set_chat_muted()` on the `xim_player` object before finishing processing the associated `xim_player_joined_state_change`, and XIM will guarantee there will be no period of time where voice audio from the player can be heard.</span><span class="sxs-lookup"><span data-stu-id="f46d9-282">If your app wants to start a player in the muted state for gameplay reasons, it can call `xim_player::set_chat_muted()` on the `xim_player` object before finishing processing the associated `xim_player_joined_state_change`, and XIM will guarantee there will be no period of time where voice audio from the player can be heard.</span></span>

<span data-ttu-id="f46d9-283">An automatic mute check based on player reputation occurs when a remote player joins the XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-283">An automatic mute check based on player reputation occurs when a remote player joins the XIM network.</span></span> <span data-ttu-id="f46d9-284">If the player has a bad reputation flag, the player is automatically muted.</span><span class="sxs-lookup"><span data-stu-id="f46d9-284">If the player has a bad reputation flag, the player is automatically muted.</span></span> <span data-ttu-id="f46d9-285">Muting only affects local state and therefore persists if a player moves across networks.</span><span class="sxs-lookup"><span data-stu-id="f46d9-285">Muting only affects local state and therefore persists if a player moves across networks.</span></span> <span data-ttu-id="f46d9-286">The automatic reputation-based mute check is performed once and not re-evaluated again for as long as the `xim_player` remains valid.</span><span class="sxs-lookup"><span data-stu-id="f46d9-286">The automatic reputation-based mute check is performed once and not re-evaluated again for as long as the `xim_player` remains valid.</span></span>


## <a name="configuring-custom-player-and-network-properties-a-nameproperties"></a><span data-ttu-id="f46d9-287">Configuring custom player and network properties <a name="properties"></span><span class="sxs-lookup"><span data-stu-id="f46d9-287">Configuring custom player and network properties <a name="properties"></span></span>

<span data-ttu-id="f46d9-288">Most app data exchanges happen with the `xim_player::xim_local::send_data_to_other_players()` method since it allows the most control over who receives it and when, how it should deal with packet loss, and so on.</span><span class="sxs-lookup"><span data-stu-id="f46d9-288">Most app data exchanges happen with the `xim_player::xim_local::send_data_to_other_players()` method since it allows the most control over who receives it and when, how it should deal with packet loss, and so on.</span></span> <span data-ttu-id="f46d9-289">However there are times where it would be nice for players to share basic, rarely changing state about themselves with others with minimal fuss.</span><span class="sxs-lookup"><span data-stu-id="f46d9-289">However there are times where it would be nice for players to share basic, rarely changing state about themselves with others with minimal fuss.</span></span> <span data-ttu-id="f46d9-290">For example, each player might have a fixed string representing the character model selected before entering multiplayer that all players use to render their in-game representation.</span><span class="sxs-lookup"><span data-stu-id="f46d9-290">For example, each player might have a fixed string representing the character model selected before entering multiplayer that all players use to render their in-game representation.</span></span> <span data-ttu-id="f46d9-291">XIM provides a "custom player properties" convenience feature for app-defined name and value null terminated string pairs that can be applied to the local player and automatically propagated to all devices whenever they are changed.</span><span class="sxs-lookup"><span data-stu-id="f46d9-291">XIM provides a "custom player properties" convenience feature for app-defined name and value null terminated string pairs that can be applied to the local player and automatically propagated to all devices whenever they are changed.</span></span> <span data-ttu-id="f46d9-292">Their current values are also automatically provided to new participating devices when they join a XIM network and see the player added.</span><span class="sxs-lookup"><span data-stu-id="f46d9-292">Their current values are also automatically provided to new participating devices when they join a XIM network and see the player added.</span></span> <span data-ttu-id="f46d9-293">These can be configured by calling `xim_player::xim_local::set_player_custom_property()` with the name and value strings, like in the following example that sets a property named "model" to have the value "brute" on a local `xim_player` object pointed to by the variable 'localPlayer':</span><span class="sxs-lookup"><span data-stu-id="f46d9-293">These can be configured by calling `xim_player::xim_local::set_player_custom_property()` with the name and value strings, like in the following example that sets a property named "model" to have the value "brute" on a local `xim_player` object pointed to by the variable 'localPlayer':</span></span>

```cpp
localPlayer->local()->set_player_custom_property(L"model", L"brute");
```

<span data-ttu-id="f46d9-294">Changes to player properties will cause a `xim_player_custom_properties_changed_state_change` to be provided to all devices, alerting them to the names of properties that have changed.</span><span class="sxs-lookup"><span data-stu-id="f46d9-294">Changes to player properties will cause a `xim_player_custom_properties_changed_state_change` to be provided to all devices, alerting them to the names of properties that have changed.</span></span> <span data-ttu-id="f46d9-295">The value for a given name can be retrieved on any player, local or remote, with `xim_player::get_player_custom_property()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-295">The value for a given name can be retrieved on any player, local or remote, with `xim_player::get_player_custom_property()`.</span></span> <span data-ttu-id="f46d9-296">The following example retrieves the value for a property named "model" from a `xim_player` pointed to by the variable 'ximPlayer':</span><span class="sxs-lookup"><span data-stu-id="f46d9-296">The following example retrieves the value for a property named "model" from a `xim_player` pointed to by the variable 'ximPlayer':</span></span>

```cpp
PCWSTR modelName = ximPlayer->get_player_custom_property(L"model");
```

<span data-ttu-id="f46d9-297">Setting a new value for a given property name will replace any existing value, and a null value string pointer is treated the same as an empty value string, which is the same as the property not having been specified yet.</span><span class="sxs-lookup"><span data-stu-id="f46d9-297">Setting a new value for a given property name will replace any existing value, and a null value string pointer is treated the same as an empty value string, which is the same as the property not having been specified yet.</span></span> <span data-ttu-id="f46d9-298">Otherwise the names and values aren't interpreted by XIM; it's up to the app to validate the string contents as needed.</span><span class="sxs-lookup"><span data-stu-id="f46d9-298">Otherwise the names and values aren't interpreted by XIM; it's up to the app to validate the string contents as needed.</span></span>

<span data-ttu-id="f46d9-299">This convenience feature is also available for the XIM network as a whole via "custom network properties".</span><span class="sxs-lookup"><span data-stu-id="f46d9-299">This convenience feature is also available for the XIM network as a whole via "custom network properties".</span></span> <span data-ttu-id="f46d9-300">These work identically to custom player properties, except they're set on the XIM singleton object with `xim::set_network_custom_property()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-300">These work identically to custom player properties, except they're set on the XIM singleton object with `xim::set_network_custom_property()`.</span></span> <span data-ttu-id="f46d9-301">The following example sets a "map" property to have the value "stronghold":</span><span class="sxs-lookup"><span data-stu-id="f46d9-301">The following example sets a "map" property to have the value "stronghold":</span></span>

```cpp
xim::singleton_instance().set_network_custom_property(L"map", L"stronghold");
```

<span data-ttu-id="f46d9-302">Changes to network properties will cause a `xim_network_custom_properties_changed_state_change` to be provided to all devices, alerting them to the names of properties that have changed.</span><span class="sxs-lookup"><span data-stu-id="f46d9-302">Changes to network properties will cause a `xim_network_custom_properties_changed_state_change` to be provided to all devices, alerting them to the names of properties that have changed.</span></span> <span data-ttu-id="f46d9-303">The value for a given name can be retrieved with `xim::get_network_custom_property()`, like in the following example that retrieves the value for a property named "map":</span><span class="sxs-lookup"><span data-stu-id="f46d9-303">The value for a given name can be retrieved with `xim::get_network_custom_property()`, like in the following example that retrieves the value for a property named "map":</span></span>

```cpp
PCWSTR mapName = xim::singleton_instance().get_network_custom_property(L"map");
```
<span data-ttu-id="f46d9-304">Just like custom player properties, setting a value for a given custom network property name will replace the existing value, and null, unset, or cleared values are always treated the same: as non-null empty strings.</span><span class="sxs-lookup"><span data-stu-id="f46d9-304">Just like custom player properties, setting a value for a given custom network property name will replace the existing value, and null, unset, or cleared values are always treated the same: as non-null empty strings.</span></span>

<span data-ttu-id="f46d9-305">Custom player properties are always reset when moving from one XIM network to another, and newly created XIM networks always start with no properties set.</span><span class="sxs-lookup"><span data-stu-id="f46d9-305">Custom player properties are always reset when moving from one XIM network to another, and newly created XIM networks always start with no properties set.</span></span> <span data-ttu-id="f46d9-306">However, new players joining an existing XIM network will see the custom properties set on existing players and on the XIM network itself.</span><span class="sxs-lookup"><span data-stu-id="f46d9-306">However, new players joining an existing XIM network will see the custom properties set on existing players and on the XIM network itself.</span></span>

<span data-ttu-id="f46d9-307">Custom player and network properties are intended as a convenience for state that doesn't change frequently.</span><span class="sxs-lookup"><span data-stu-id="f46d9-307">Custom player and network properties are intended as a convenience for state that doesn't change frequently.</span></span> <span data-ttu-id="f46d9-308">They have more internal synchronization overhead than the `xim_player::xim_local::send_data_to_other_players()` method, so you should still use direct sends instead for state like player positions that are rapidly replaced.</span><span class="sxs-lookup"><span data-stu-id="f46d9-308">They have more internal synchronization overhead than the `xim_player::xim_local::send_data_to_other_players()` method, so you should still use direct sends instead for state like player positions that are rapidly replaced.</span></span>

## <a name="matchmaking-using-per-player-skill-or-role-a-nameroles"></a><span data-ttu-id="f46d9-309">Matchmaking using per-player skill or role <a name="roles"></span><span class="sxs-lookup"><span data-stu-id="f46d9-309">Matchmaking using per-player skill or role <a name="roles"></span></span>

<span data-ttu-id="f46d9-310">Matching players by common interest in a particular app-specified game mode is a good base strategy.</span><span class="sxs-lookup"><span data-stu-id="f46d9-310">Matching players by common interest in a particular app-specified game mode is a good base strategy.</span></span> <span data-ttu-id="f46d9-311">As the pool of available players grows, you should consider also matching players based on their personal skill or experience with your game so that veteran players can enjoy the challenge of healthy competition with other veterans, while newer players can grow by competing against others with similar abilities.</span><span class="sxs-lookup"><span data-stu-id="f46d9-311">As the pool of available players grows, you should consider also matching players based on their personal skill or experience with your game so that veteran players can enjoy the challenge of healthy competition with other veterans, while newer players can grow by competing against others with similar abilities.</span></span> <span data-ttu-id="f46d9-312">To do this, start by providing the skill level for all local players in their per-player matchmaking configuration structure specified in calls to `xim_player::xim_local::set_matchmaking_configuration()` prior to starting to move to a XIM network using matchmaking.</span><span class="sxs-lookup"><span data-stu-id="f46d9-312">To do this, start by providing the skill level for all local players in their per-player matchmaking configuration structure specified in calls to `xim_player::xim_local::set_matchmaking_configuration()` prior to starting to move to a XIM network using matchmaking.</span></span> <span data-ttu-id="f46d9-313">Skill level is an app-specific concept and the number is not interpreted by XIM, except that matchmaking will first try to find players with the same skill value, and then periodically widen its search in increments of +/- 10 to try to find other players declaring skill values within a range around that skill.</span><span class="sxs-lookup"><span data-stu-id="f46d9-313">Skill level is an app-specific concept and the number is not interpreted by XIM, except that matchmaking will first try to find players with the same skill value, and then periodically widen its search in increments of +/- 10 to try to find other players declaring skill values within a range around that skill.</span></span> <span data-ttu-id="f46d9-314">The following example assumes that the local `xim_player` object, whose pointer is 'localPlayer', has an associated app-specific uint32_t skill value retrieved from local or Xbox Live storage into a variable called 'playerSkillValue':</span><span class="sxs-lookup"><span data-stu-id="f46d9-314">The following example assumes that the local `xim_player` object, whose pointer is 'localPlayer', has an associated app-specific uint32_t skill value retrieved from local or Xbox Live storage into a variable called 'playerSkillValue':</span></span>

```cpp

 xim_player_matchmaking_configuration playerMatchmakingConfiguration = { 0 };
 playerMatchmakingConfiguration.skill = playerSkillValue;

 localPlayer->local()->set_matchmaking_configuration(&playerMatchmakingConfiguration);
```

<span data-ttu-id="f46d9-315">When this completes, all participants will be provided a `xim_player_matchmaking_configuration_changed_state_change` indicating this `xim_player` has changed its per-player matchmaking configuration.</span><span class="sxs-lookup"><span data-stu-id="f46d9-315">When this completes, all participants will be provided a `xim_player_matchmaking_configuration_changed_state_change` indicating this `xim_player` has changed its per-player matchmaking configuration.</span></span> <span data-ttu-id="f46d9-316">The new value can be retrieved by calling `xim_player::matchmaking_configuration()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-316">The new value can be retrieved by calling `xim_player::matchmaking_configuration()`.</span></span>

<span data-ttu-id="f46d9-317">When all players have non-null matchmaking configuration applied, you can move to a XIM network using matchmaking with a value of true for the require_player_matchmaking_configuration field of the `xim_matchmaking_configuration` structure specified to `xim::move_to_network_using_matchmaking()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-317">When all players have non-null matchmaking configuration applied, you can move to a XIM network using matchmaking with a value of true for the require_player_matchmaking_configuration field of the `xim_matchmaking_configuration` structure specified to `xim::move_to_network_using_matchmaking()`.</span></span> <span data-ttu-id="f46d9-318">The following example populates a matchmaking configuration that will find a total of 2-8 players for a no-teams free-for-all, using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_DEATHMATCH that will only match with other players specifying that same value, and that requires per-player matchmaking configuration:</span><span class="sxs-lookup"><span data-stu-id="f46d9-318">The following example populates a matchmaking configuration that will find a total of 2-8 players for a no-teams free-for-all, using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_DEATHMATCH that will only match with other players specifying that same value, and that requires per-player matchmaking configuration:</span></span>

```cpp
xim_matchmaking_configuration matchmakingConfiguration = { 0 };
matchmakingConfiguration.team_matchmaking_mode = xim_team_matchmaking_mode::no_teams_8_players_minimum_2;
matchmakingConfiguration.custom_game_mode = MYGAMEMODE_DEATHMATCH;
matchmakingConfiguration.require_player_matchmaking_configuration = true;
```

<span data-ttu-id="f46d9-319">When this structure is provided to `xim::move_to_network_using_matchmaking()`, the move operation will start normally as long as players moving have called `xim_player::xim_local::set_matchmaking_configuration()` with a non-null `xim_player_matchmaking_configuration` pointer.</span><span class="sxs-lookup"><span data-stu-id="f46d9-319">When this structure is provided to `xim::move_to_network_using_matchmaking()`, the move operation will start normally as long as players moving have called `xim_player::xim_local::set_matchmaking_configuration()` with a non-null `xim_player_matchmaking_configuration` pointer.</span></span> <span data-ttu-id="f46d9-320">If any player hasn't, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_matchmaking_configuration` value.</span><span class="sxs-lookup"><span data-stu-id="f46d9-320">If any player hasn't, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_matchmaking_configuration` value.</span></span> <span data-ttu-id="f46d9-321">This includes players that subsequently join the XIM network through a previously sent invitation or through other social means (e.g., a call to `xim::move_to_network_using_joinable_xbox_user_id`) before matchmaking has completed.</span><span class="sxs-lookup"><span data-stu-id="f46d9-321">This includes players that subsequently join the XIM network through a previously sent invitation or through other social means (e.g., a call to `xim::move_to_network_using_joinable_xbox_user_id`) before matchmaking has completed.</span></span> <span data-ttu-id="f46d9-322">Once all players have supplied their `xim_player_matchmaking_configuration` structures, matchmaking will resume.</span><span class="sxs-lookup"><span data-stu-id="f46d9-322">Once all players have supplied their `xim_player_matchmaking_configuration` structures, matchmaking will resume.</span></span>

<span data-ttu-id="f46d9-323">Another method of using per-player matchmaking configuration to improve users' matchmaking experience is through the use of required player roles.</span><span class="sxs-lookup"><span data-stu-id="f46d9-323">Another method of using per-player matchmaking configuration to improve users' matchmaking experience is through the use of required player roles.</span></span> <span data-ttu-id="f46d9-324">This is best suited to games that provide selectable character types that encourage different cooperative play styles; that is, types that don't simply alter in-game graphical representation, but control complementary, impactful attributes such as defensive "healers" vs. close-in "melee" offense vs. distant "range" attack support.</span><span class="sxs-lookup"><span data-stu-id="f46d9-324">This is best suited to games that provide selectable character types that encourage different cooperative play styles; that is, types that don't simply alter in-game graphical representation, but control complementary, impactful attributes such as defensive "healers" vs. close-in "melee" offense vs. distant "range" attack support.</span></span> <span data-ttu-id="f46d9-325">Users' personalities mean they may prefer to play as a particular specialization.</span><span class="sxs-lookup"><span data-stu-id="f46d9-325">Users' personalities mean they may prefer to play as a particular specialization.</span></span> <span data-ttu-id="f46d9-326">But if your game is designed such that it's functionally not possible to complete objectives without at least one person fulfilling each role, sometimes it's better to match such players together first than to match any players together then require them to negotiate play styles among themselves once gathered.</span><span class="sxs-lookup"><span data-stu-id="f46d9-326">But if your game is designed such that it's functionally not possible to complete objectives without at least one person fulfilling each role, sometimes it's better to match such players together first than to match any players together then require them to negotiate play styles among themselves once gathered.</span></span> <span data-ttu-id="f46d9-327">You can do this by first defining a unique bit flag representing each role to be specified in a given player's `xim_player_matchmaking_configuration` structure.</span><span class="sxs-lookup"><span data-stu-id="f46d9-327">You can do this by first defining a unique bit flag representing each role to be specified in a given player's `xim_player_matchmaking_configuration` structure.</span></span> <span data-ttu-id="f46d9-328">The following example sets an app-specific MYROLEBITFLAG_HEALER uint8_t role value for the local `xim_player` object, whose pointer is 'localPlayer':</span><span class="sxs-lookup"><span data-stu-id="f46d9-328">The following example sets an app-specific MYROLEBITFLAG_HEALER uint8_t role value for the local `xim_player` object, whose pointer is 'localPlayer':</span></span>

```cpp

xim_player_matchmaking_configuration playerMatchmakingConfiguration = { 0 };
playerMatchmakingConfiguration.roles = MYROLEBITFLAG_HEALER;

localPlayer->local()->set_matchmaking_configuration(&playerMatchmakingConfiguration);

```

<span data-ttu-id="f46d9-329">All participants will be provided a `xim_player_matchmaking_configuration_changed_state_change` for this player as described for skill above.</span><span class="sxs-lookup"><span data-stu-id="f46d9-329">All participants will be provided a `xim_player_matchmaking_configuration_changed_state_change` for this player as described for skill above.</span></span> <span data-ttu-id="f46d9-330">The global `xim_matchmaking_configuration` structure specified to `xim::move_to_network_using_matchmaking()` should then have all the required roles flags combined using bitwise-OR, and a value of true for the require_player_matchmaking_configuration field.</span><span class="sxs-lookup"><span data-stu-id="f46d9-330">The global `xim_matchmaking_configuration` structure specified to `xim::move_to_network_using_matchmaking()` should then have all the required roles flags combined using bitwise-OR, and a value of true for the require_player_matchmaking_configuration field.</span></span> <span data-ttu-id="f46d9-331">The following example populates a matchmaking configuration that will find a total of 3 players for a no-teams free-for-all, using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_COOPERATIVE that will only match with other players specifying that same value, and that requires per-player matchmaking configuration where at least one player that fulfills each of three app-specific uint8_t role bit flags-- MYROLEBITFLAG_HEALER, MYROLEBITFLAG_MELEE, and MYROLEBITFLAG_RANGE-- are required:</span><span class="sxs-lookup"><span data-stu-id="f46d9-331">The following example populates a matchmaking configuration that will find a total of 3 players for a no-teams free-for-all, using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_COOPERATIVE that will only match with other players specifying that same value, and that requires per-player matchmaking configuration where at least one player that fulfills each of three app-specific uint8_t role bit flags-- MYROLEBITFLAG_HEALER, MYROLEBITFLAG_MELEE, and MYROLEBITFLAG_RANGE-- are required:</span></span>

```cpp
xim_matchmaking_configuration matchmakingConfiguration = { 0 };
matchmakingConfiguration.team_matchmaking_mode = xim_team_matchmaking_mode::no_teams_3_players_minimum_3;
matchmakingConfiguration.custom_game_mode = MYGAMEMODE_COOPERATIVE;
matchmakingConfiguration.required_roles = MYROLEBITFLAG_HEALER | MYROLEBITFLAG_MELEE | MYROLEBITFLAG_RANGE;
matchmakingConfiguration.require_player_matchmaking_configuration = true;
```

<span data-ttu-id="f46d9-332">When this structure is provided to `xim::move_to_network_using_matchmaking()`, the move operation will start as described above.</span><span class="sxs-lookup"><span data-stu-id="f46d9-332">When this structure is provided to `xim::move_to_network_using_matchmaking()`, the move operation will start as described above.</span></span>

<span data-ttu-id="f46d9-333">Skill and role can be used together.</span><span class="sxs-lookup"><span data-stu-id="f46d9-333">Skill and role can be used together.</span></span> <span data-ttu-id="f46d9-334">If only one is desired, specify a value of 0 for the other.</span><span class="sxs-lookup"><span data-stu-id="f46d9-334">If only one is desired, specify a value of 0 for the other.</span></span> <span data-ttu-id="f46d9-335">This is because all players declaring they have a `xim_player_matchmaking_configuration` skill value of 0 will always match each other, and if no bits are non-zero in the `xim_matchmaking_configuration` required_roles field, then no role bits are needed in order to match.</span><span class="sxs-lookup"><span data-stu-id="f46d9-335">This is because all players declaring they have a `xim_player_matchmaking_configuration` skill value of 0 will always match each other, and if no bits are non-zero in the `xim_matchmaking_configuration` required_roles field, then no role bits are needed in order to match.</span></span>

<span data-ttu-id="f46d9-336">Once the `xim::move_to_network_using_matchmaking()` or any other XIM network move operation has completed, all players' `xim_player_matchmaking_configuration` structures will automatically be cleared to a null pointer (with an accompanying `xim_player_matchmaking_configuration_changed_state_change` notification).</span><span class="sxs-lookup"><span data-stu-id="f46d9-336">Once the `xim::move_to_network_using_matchmaking()` or any other XIM network move operation has completed, all players' `xim_player_matchmaking_configuration` structures will automatically be cleared to a null pointer (with an accompanying `xim_player_matchmaking_configuration_changed_state_change` notification).</span></span> <span data-ttu-id="f46d9-337">If you plan to move to another XIM network using matchmaking that requires per-player configuration, you'll need to call `xim_player::xim_local::set_matchmaking_configuration()` again with a new structure pointer containing the most up-to-date information.</span><span class="sxs-lookup"><span data-stu-id="f46d9-337">If you plan to move to another XIM network using matchmaking that requires per-player configuration, you'll need to call `xim_player::xim_local::set_matchmaking_configuration()` again with a new structure pointer containing the most up-to-date information.</span></span>


## <a name="player-teams-and-configuring-chat-targets-a-nameteams"></a><span data-ttu-id="f46d9-338">Player teams and configuring chat targets <a name="teams"></span><span class="sxs-lookup"><span data-stu-id="f46d9-338">Player teams and configuring chat targets <a name="teams"></span></span>

<span data-ttu-id="f46d9-339">Multiplayer gaming often involves players organized onto opposing teams.</span><span class="sxs-lookup"><span data-stu-id="f46d9-339">Multiplayer gaming often involves players organized onto opposing teams.</span></span> <span data-ttu-id="f46d9-340">XIM makes it easy to assign teams when matchmaking by using a `xim_team_matchmaking_mode` value requesting two or more teams in the specified configuration.</span><span class="sxs-lookup"><span data-stu-id="f46d9-340">XIM makes it easy to assign teams when matchmaking by using a `xim_team_matchmaking_mode` value requesting two or more teams in the specified configuration.</span></span> <span data-ttu-id="f46d9-341">The following example initiates a move using matchmaking configured to find a total of 8 players to place on two teams of 4 (although if 4 aren't found, 1-3 players are also acceptable), using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_CAPTURETHEFLAG that will only match with other players specifying that same value, and bringing all socially-joined players from the current XIM network:</span><span class="sxs-lookup"><span data-stu-id="f46d9-341">The following example initiates a move using matchmaking configured to find a total of 8 players to place on two teams of 4 (although if 4 aren't found, 1-3 players are also acceptable), using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_CAPTURETHEFLAG that will only match with other players specifying that same value, and bringing all socially-joined players from the current XIM network:</span></span>

```cpp
xim_matchmaking_configuration matchmakingConfiguration = { 0 };
matchmakingConfiguration.team_matchmaking_mode = two_teams_4v4_minimum_1_per_team;
matchmakingConfiguration.custom_game_mode = MYGAMEMODE_CAPTURETHEFLAG;

xim::singleton_instance().move_to_network_using_matchmaking(matchmakingConfiguration, xim_players_to_move::bring_existing_social_players);
```

<span data-ttu-id="f46d9-342">When such a XIM network move operation completes, the players will be assigned a team index value 1 through {n} corresponding to the {n} teams requested.</span><span class="sxs-lookup"><span data-stu-id="f46d9-342">When such a XIM network move operation completes, the players will be assigned a team index value 1 through {n} corresponding to the {n} teams requested.</span></span> <span data-ttu-id="f46d9-343">A player's team index value is retrieved via `xim_player::team_index()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-343">A player's team index value is retrieved via `xim_player::team_index()`.</span></span> <span data-ttu-id="f46d9-344">The following example retrieves the team index for a xim_player object whose pointer is in the 'ximPlayer' variable:</span><span class="sxs-lookup"><span data-stu-id="f46d9-344">The following example retrieves the team index for a xim_player object whose pointer is in the 'ximPlayer' variable:</span></span>

```cpp
uint8_t playerTeamIndex = ximPlayer->team_index();
```

<span data-ttu-id="f46d9-345">For the preferred user experience (not to mention reduced opportunity for negative player behavior), the Xbox Live matchmaking service will never split players who are moving to a XIM network together onto different teams.</span><span class="sxs-lookup"><span data-stu-id="f46d9-345">For the preferred user experience (not to mention reduced opportunity for negative player behavior), the Xbox Live matchmaking service will never split players who are moving to a XIM network together onto different teams.</span></span>

<span data-ttu-id="f46d9-346">The team index value assigned initially by matchmaking is only a recommendation and the app can change it for local players at any time using `xim_player::xim_local::set_team_index()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-346">The team index value assigned initially by matchmaking is only a recommendation and the app can change it for local players at any time using `xim_player::xim_local::set_team_index()`.</span></span> <span data-ttu-id="f46d9-347">This can also be called in XIM networks that don't use matchmaking at all.</span><span class="sxs-lookup"><span data-stu-id="f46d9-347">This can also be called in XIM networks that don't use matchmaking at all.</span></span> <span data-ttu-id="f46d9-348">The following example configures a player pointer 'localPlayer' to have a new team index value of one:</span><span class="sxs-lookup"><span data-stu-id="f46d9-348">The following example configures a player pointer 'localPlayer' to have a new team index value of one:</span></span>

```cpp
localPlayer->local()->set_team_index(1);
```

<span data-ttu-id="f46d9-349">All devices are informed that the player has a new team index value in effect when they're provided a `xim_player_team_index_changed_state_change` for that player.</span><span class="sxs-lookup"><span data-stu-id="f46d9-349">All devices are informed that the player has a new team index value in effect when they're provided a `xim_player_team_index_changed_state_change` for that player.</span></span>

<span data-ttu-id="f46d9-350">When using a `xim_team_matchmaking_mode` with two or more teams, players will never be assigned a team index value of zero by the call to `xim::move_to_network_using_matchmaking()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-350">When using a `xim_team_matchmaking_mode` with two or more teams, players will never be assigned a team index value of zero by the call to `xim::move_to_network_using_matchmaking()`.</span></span> <span data-ttu-id="f46d9-351">This is in contrast to players that are added to the XIM network with any other configuration or type of move operation (such as through a protocol activation resulting from accepting an invitation), who will always have a zero team index.</span><span class="sxs-lookup"><span data-stu-id="f46d9-351">This is in contrast to players that are added to the XIM network with any other configuration or type of move operation (such as through a protocol activation resulting from accepting an invitation), who will always have a zero team index.</span></span> <span data-ttu-id="f46d9-352">It may be helpful to treat team index 0 as a special "unassigned" team.</span><span class="sxs-lookup"><span data-stu-id="f46d9-352">It may be helpful to treat team index 0 as a special "unassigned" team.</span></span>

<span data-ttu-id="f46d9-353">The true meaning of any particular team index value is up to the app.</span><span class="sxs-lookup"><span data-stu-id="f46d9-353">The true meaning of any particular team index value is up to the app.</span></span> <span data-ttu-id="f46d9-354">XIM doesn't interpret them except for equality comparisons with respect to chat target configuration.</span><span class="sxs-lookup"><span data-stu-id="f46d9-354">XIM doesn't interpret them except for equality comparisons with respect to chat target configuration.</span></span> <span data-ttu-id="f46d9-355">If the chat target configuration reported by `xim::chat_targets()` is currently `xim_chat_targets::same_team_index_only`, then any given player will only exchange chat communication with another if the two have the same value reported by `xim_player::team_index()` (and privacy/ policy also permit it).</span><span class="sxs-lookup"><span data-stu-id="f46d9-355">If the chat target configuration reported by `xim::chat_targets()` is currently `xim_chat_targets::same_team_index_only`, then any given player will only exchange chat communication with another if the two have the same value reported by `xim_player::team_index()` (and privacy/ policy also permit it).</span></span>

<span data-ttu-id="f46d9-356">To be conservative and support competitive scenarios, newly created XIM networks are automatically configured to default to `xim_chat_targets::same_team_index_only`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-356">To be conservative and support competitive scenarios, newly created XIM networks are automatically configured to default to `xim_chat_targets::same_team_index_only`.</span></span> <span data-ttu-id="f46d9-357">However, chatting with vanquished opponents on the other team may be desirable, for example, in a post-game "lobby".</span><span class="sxs-lookup"><span data-stu-id="f46d9-357">However, chatting with vanquished opponents on the other team may be desirable, for example, in a post-game "lobby".</span></span> <span data-ttu-id="f46d9-358">You can instruct XIM to allow everyone to talk to everyone else where privacy and policy permit) by calling `xim::set_chat_targets()`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-358">You can instruct XIM to allow everyone to talk to everyone else where privacy and policy permit) by calling `xim::set_chat_targets()`.</span></span> <span data-ttu-id="f46d9-359">The following sample begins configuring all participants in the XIM network to use a `xim_chat_targets::all_players` value:</span><span class="sxs-lookup"><span data-stu-id="f46d9-359">The following sample begins configuring all participants in the XIM network to use a `xim_chat_targets::all_players` value:</span></span>

```cpp
xim::singleton_instance().set_chat_targets(xim_chat_targets::all_players);
```

<span data-ttu-id="f46d9-360">All participants are informed that a new target setting is in effect when they're provided a `xim_chat_targets_changed_state_change`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-360">All participants are informed that a new target setting is in effect when they're provided a `xim_chat_targets_changed_state_change`.</span></span>

<span data-ttu-id="f46d9-361">As noted earlier, most XIM network move types will initially assign all players the team index value of zero.</span><span class="sxs-lookup"><span data-stu-id="f46d9-361">As noted earlier, most XIM network move types will initially assign all players the team index value of zero.</span></span> <span data-ttu-id="f46d9-362">This means a configuration of `xim_chat_targets::same_team_index_only` is likely indistinguishable from `xim_chat_targets::all_players` by default.</span><span class="sxs-lookup"><span data-stu-id="f46d9-362">This means a configuration of `xim_chat_targets::same_team_index_only` is likely indistinguishable from `xim_chat_targets::all_players` by default.</span></span> <span data-ttu-id="f46d9-363">However, players that move to a XIM network using matchmaking will have differing team index values if the matchmaking configuration's `xim_team_matchmaking_mode` value declared two or more teams.</span><span class="sxs-lookup"><span data-stu-id="f46d9-363">However, players that move to a XIM network using matchmaking will have differing team index values if the matchmaking configuration's `xim_team_matchmaking_mode` value declared two or more teams.</span></span> <span data-ttu-id="f46d9-364">You can also call `xim_player::xim_local::set_team_index()` at any time as shown above.</span><span class="sxs-lookup"><span data-stu-id="f46d9-364">You can also call `xim_player::xim_local::set_team_index()` at any time as shown above.</span></span> <span data-ttu-id="f46d9-365">If your app is using non-zero team index values through either of these methods, don't forget to manage the current chat targets setting appropriately.</span><span class="sxs-lookup"><span data-stu-id="f46d9-365">If your app is using non-zero team index values through either of these methods, don't forget to manage the current chat targets setting appropriately.</span></span>

<span data-ttu-id="f46d9-366">Matchmaking evaluates required per-player roles independently from teams.</span><span class="sxs-lookup"><span data-stu-id="f46d9-366">Matchmaking evaluates required per-player roles independently from teams.</span></span> <span data-ttu-id="f46d9-367">Therefore it's not recommended to use both teams and required roles as simultaneous matchmaking configuration criteria because the teams will be balanced by player count, not by fulfilled player roles.</span><span class="sxs-lookup"><span data-stu-id="f46d9-367">Therefore it's not recommended to use both teams and required roles as simultaneous matchmaking configuration criteria because the teams will be balanced by player count, not by fulfilled player roles.</span></span>

## <a name="automatic-background-filling-of-player-slots-backfill-matchmaking-a-namebackfill"></a><span data-ttu-id="f46d9-368">Automatic background filling of player slots ("backfill" matchmaking) <a name="backfill"></span><span class="sxs-lookup"><span data-stu-id="f46d9-368">Automatic background filling of player slots ("backfill" matchmaking) <a name="backfill"></span></span>

<span data-ttu-id="f46d9-369">Disparate groups of players calling `xim::move_to_network_using_matchmaking()` at the same time gives the Xbox Live matchmaking service the greatest flexibility to organize them into new, optimal XIM networks quickly.</span><span class="sxs-lookup"><span data-stu-id="f46d9-369">Disparate groups of players calling `xim::move_to_network_using_matchmaking()` at the same time gives the Xbox Live matchmaking service the greatest flexibility to organize them into new, optimal XIM networks quickly.</span></span> <span data-ttu-id="f46d9-370">However, some gameplay scenarios would like to keep a particular XIM network intact, and only matchmake additional players just to fill vacant player slots.</span><span class="sxs-lookup"><span data-stu-id="f46d9-370">However, some gameplay scenarios would like to keep a particular XIM network intact, and only matchmake additional players just to fill vacant player slots.</span></span> <span data-ttu-id="f46d9-371">XIM supports configuring matchmaking to operate in an automatic background filling mode, or "backfilling", by using the `xim::set_backfill_matchmaking_configuration()` method.</span><span class="sxs-lookup"><span data-stu-id="f46d9-371">XIM supports configuring matchmaking to operate in an automatic background filling mode, or "backfilling", by using the `xim::set_backfill_matchmaking_configuration()` method.</span></span> <span data-ttu-id="f46d9-372">The following example configures backfill matchmaking to try to find a total of 8 players for a no-teams free-for-all (although if 8 aren't found, 2-7 players are also acceptable), using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_DEATHMATCH that will only match with other players specifying that same value:</span><span class="sxs-lookup"><span data-stu-id="f46d9-372">The following example configures backfill matchmaking to try to find a total of 8 players for a no-teams free-for-all (although if 8 aren't found, 2-7 players are also acceptable), using an app-specific game mode constant uint64_t defined by the value MYGAMEMODE_DEATHMATCH that will only match with other players specifying that same value:</span></span>

```cpp
 xim_matchmaking_configuration matchmakingConfiguration = { 0 };
 matchmakingConfiguration.team_matchmaking_mode = xim_team_matchmaking_mode::no_teams_8_players_minimum_2;
 matchmakingConfiguration.custom_game_mode = MYGAMEMODE_DEATHMATCH;

 xim::singleton_instance().set_backfill_matchmaking_configuration(&matchmakingConfiguration);
```

<span data-ttu-id="f46d9-373">This makes the existing XIM network available to devices calling `xim::move_to_network_using_matchmaking()` in the normal manner.</span><span class="sxs-lookup"><span data-stu-id="f46d9-373">This makes the existing XIM network available to devices calling `xim::move_to_network_using_matchmaking()` in the normal manner.</span></span> <span data-ttu-id="f46d9-374">Those devices see no behavior change.</span><span class="sxs-lookup"><span data-stu-id="f46d9-374">Those devices see no behavior change.</span></span> <span data-ttu-id="f46d9-375">The participants in the backfilling XIM network will not move, but will be provided a `xim_backfill_matchmaking_configuration_changed_state_change` signifying backfill turning on, as well as multiple `xim_matchmaking_progress_updated_state_change` notifications when applicable.</span><span class="sxs-lookup"><span data-stu-id="f46d9-375">The participants in the backfilling XIM network will not move, but will be provided a `xim_backfill_matchmaking_configuration_changed_state_change` signifying backfill turning on, as well as multiple `xim_matchmaking_progress_updated_state_change` notifications when applicable.</span></span> <span data-ttu-id="f46d9-376">Any matchmade player will be added to the XIM network using the normal `xim_player_joined_state_change`.</span><span class="sxs-lookup"><span data-stu-id="f46d9-376">Any matchmade player will be added to the XIM network using the normal `xim_player_joined_state_change`.</span></span>

<span data-ttu-id="f46d9-377">Backfill matchmaking remains in progress indefinitely, although it won't try to add players if the XIM network already has the maximum number of players specified by the `xim_team_matchmaking_mode` value.</span><span class="sxs-lookup"><span data-stu-id="f46d9-377">Backfill matchmaking remains in progress indefinitely, although it won't try to add players if the XIM network already has the maximum number of players specified by the `xim_team_matchmaking_mode` value.</span></span> <span data-ttu-id="f46d9-378">Backfilling can be disabled by calling `xim::set_backfill_matchmaking_configuration()` again with a null pointer:</span><span class="sxs-lookup"><span data-stu-id="f46d9-378">Backfilling can be disabled by calling `xim::set_backfill_matchmaking_configuration()` again with a null pointer:</span></span>

```cpp
 xim::singleton_instance().set_backfill_matchmaking_configuration(nullptr);
```

<span data-ttu-id="f46d9-379">A corresponding `xim_backfill_matchmaking_configuration_changed_state_change` will be provided to all devices, and once this asynchronous process has completed, a final `xim_matchmaking_progress_updated_state_change` will be provided with `xim_matchmaking_status::none` to signify that no further matchmade players will be added to the XIM network.</span><span class="sxs-lookup"><span data-stu-id="f46d9-379">A corresponding `xim_backfill_matchmaking_configuration_changed_state_change` will be provided to all devices, and once this asynchronous process has completed, a final `xim_matchmaking_progress_updated_state_change` will be provided with `xim_matchmaking_status::none` to signify that no further matchmade players will be added to the XIM network.</span></span>

<span data-ttu-id="f46d9-380">When enabling backfill matchmaking with a `xim_team_matchmaking_mode` value that declares two or more teams, all existing players must have a valid team index that is between 1 and the number of teams.</span><span class="sxs-lookup"><span data-stu-id="f46d9-380">When enabling backfill matchmaking with a `xim_team_matchmaking_mode` value that declares two or more teams, all existing players must have a valid team index that is between 1 and the number of teams.</span></span> <span data-ttu-id="f46d9-381">This includes players who have called `xim_player::xim_local::set_team_index()` to specify a custom value or who have joined using an invitation or through other social means (e.g., a call to `xim::move_to_network_using_joinable_xbox_user_id`) and have been added with a default team index value of 0.</span><span class="sxs-lookup"><span data-stu-id="f46d9-381">This includes players who have called `xim_player::xim_local::set_team_index()` to specify a custom value or who have joined using an invitation or through other social means (e.g., a call to `xim::move_to_network_using_joinable_xbox_user_id`) and have been added with a default team index value of 0.</span></span> <span data-ttu-id="f46d9-382">If any player doesn't have a valid team index, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_team_index` value.</span><span class="sxs-lookup"><span data-stu-id="f46d9-382">If any player doesn't have a valid team index, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_team_index` value.</span></span> <span data-ttu-id="f46d9-383">Once all players have supplied or corrected their team index values with `xim_player::xim_local::set_team_index()`, backfill matchmaking will resume.</span><span class="sxs-lookup"><span data-stu-id="f46d9-383">Once all players have supplied or corrected their team index values with `xim_player::xim_local::set_team_index()`, backfill matchmaking will resume.</span></span>

<span data-ttu-id="f46d9-384">Similarly, when enabling backfill matchmaking with a `xim_matchmaking_configuration` structure with the require_player_matchmaking_configuration field set to true for roles or skill, then all players must have specified a non-null per-player matchmaking configuration.</span><span class="sxs-lookup"><span data-stu-id="f46d9-384">Similarly, when enabling backfill matchmaking with a `xim_matchmaking_configuration` structure with the require_player_matchmaking_configuration field set to true for roles or skill, then all players must have specified a non-null per-player matchmaking configuration.</span></span> <span data-ttu-id="f46d9-385">If any player hasn't, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_matchmaking_configuration` value.</span><span class="sxs-lookup"><span data-stu-id="f46d9-385">If any player hasn't, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_matchmaking_configuration` value.</span></span> <span data-ttu-id="f46d9-386">Once all players have supplied their `xim_player_matchmaking_configuration` structures, backfill matchmaking will resume.</span><span class="sxs-lookup"><span data-stu-id="f46d9-386">Once all players have supplied their `xim_player_matchmaking_configuration` structures, backfill matchmaking will resume.</span></span>

## <a name="the-role-of-servers-host-migration-and-xim-authorities-a-nameauthority"></a><span data-ttu-id="f46d9-387">The role of servers, "host migration", and XIM authorities <a name="authority"></span><span class="sxs-lookup"><span data-stu-id="f46d9-387">The role of servers, "host migration", and XIM authorities <a name="authority"></span></span>

<span data-ttu-id="f46d9-388">A XIM network is logically a fully-connected mesh of peer devices-- as opposed to a client/server model, for example.</span><span class="sxs-lookup"><span data-stu-id="f46d9-388">A XIM network is logically a fully-connected mesh of peer devices-- as opposed to a client/server model, for example.</span></span> <span data-ttu-id="f46d9-389">Any player can send directly to any other through the API, and all methods that affect the state of the XIM network as a whole, such as xim::set_network_custom_property(), xim::set_allowed_player_joins(), and xim::set_chat_targets(), can be invoked by any participating device.</span><span class="sxs-lookup"><span data-stu-id="f46d9-389">Any player can send directly to any other through the API, and all methods that affect the state of the XIM network as a whole, such as xim::set_network_custom_property(), xim::set_allowed_player_joins(), and xim::set_chat_targets(), can be invoked by any participating device.</span></span> <span data-ttu-id="f46d9-390">XIM uses simple last-write-wins conflict resolution if the app doesn't otherwise prevent more than one participant modifying the same XIM network state at effectively the same time.</span><span class="sxs-lookup"><span data-stu-id="f46d9-390">XIM uses simple last-write-wins conflict resolution if the app doesn't otherwise prevent more than one participant modifying the same XIM network state at effectively the same time.</span></span> <span data-ttu-id="f46d9-391">This means that XIM doesn't impose any "server" or "host" role concept.</span><span class="sxs-lookup"><span data-stu-id="f46d9-391">This means that XIM doesn't impose any "server" or "host" role concept.</span></span> <span data-ttu-id="f46d9-392">It also doesn't constrain apps that still wish to define their own concepts (and accompanying process for migrating that role to another participant when leaving the XIM network, also known as "host migration").</span><span class="sxs-lookup"><span data-stu-id="f46d9-392">It also doesn't constrain apps that still wish to define their own concepts (and accompanying process for migrating that role to another participant when leaving the XIM network, also known as "host migration").</span></span>

<span data-ttu-id="f46d9-393">For some apps, a game host is purely a simple, social construct.</span><span class="sxs-lookup"><span data-stu-id="f46d9-393">For some apps, a game host is purely a simple, social construct.</span></span> <span data-ttu-id="f46d9-394">A user decides to initiate a multiplayer experience for friends to join, and that user will manage the current gameplay rules, map, and other settings on behalf of the group as a whole.</span><span class="sxs-lookup"><span data-stu-id="f46d9-394">A user decides to initiate a multiplayer experience for friends to join, and that user will manage the current gameplay rules, map, and other settings on behalf of the group as a whole.</span></span> <span data-ttu-id="f46d9-395">For other apps, it's a more fundamental communication role.</span><span class="sxs-lookup"><span data-stu-id="f46d9-395">For other apps, it's a more fundamental communication role.</span></span> <span data-ttu-id="f46d9-396">It can simplify arbitrating conflicts in game state generated by separate players, such as whose real-time input takes precedent and therefore who defeated whom.</span><span class="sxs-lookup"><span data-stu-id="f46d9-396">It can simplify arbitrating conflicts in game state generated by separate players, such as whose real-time input takes precedent and therefore who defeated whom.</span></span> <span data-ttu-id="f46d9-397">It can be a challenge to maintain an uninterrupted user experience and reliably agree on a single device to manage such authoritative game state in spite of players joining and leaving (perhaps ungracefully) at arbitrary  times, so XIM is designed with an optional `xim_authority` object to assist apps.</span><span class="sxs-lookup"><span data-stu-id="f46d9-397">It can be a challenge to maintain an uninterrupted user experience and reliably agree on a single device to manage such authoritative game state in spite of players joining and leaving (perhaps ungracefully) at arbitrary  times, so XIM is designed with an optional `xim_authority` object to assist apps.</span></span>

<span data-ttu-id="f46d9-398">A XIM authority represents a single device in the XIM network that has been automatically selected based on best network quality, stability, player reputation and other dynamic factors.</span><span class="sxs-lookup"><span data-stu-id="f46d9-398">A XIM authority represents a single device in the XIM network that has been automatically selected based on best network quality, stability, player reputation and other dynamic factors.</span></span> <span data-ttu-id="f46d9-399">All participants in the XIM network can determine if their local device is currently assigned this responsibility by querying `xim_authority::is_local()`, as in the following example:</span><span class="sxs-lookup"><span data-stu-id="f46d9-399">All participants in the XIM network can determine if their local device is currently assigned this responsibility by querying `xim_authority::is_local()`, as in the following example:</span></span>

```cpp
 bool authorityIsLocal = xim::singleton_instance().authority()->is_local();
```

<span data-ttu-id="f46d9-400">Only one device in the XIM network will report that the xim_authority is local for any given set of players.</span><span class="sxs-lookup"><span data-stu-id="f46d9-400">Only one device in the XIM network will report that the xim_authority is local for any given set of players.</span></span> <span data-ttu-id="f46d9-401">Apps shouldn't make assumptions about which device that will be and are encouraged not to visibly identify such devices to users to reduce the potential for taking unfair advantage of authority-specific behavior in the app (e.g., lower latency, or always deferring to local simulation when movement packets from others are maliciously blocked).</span><span class="sxs-lookup"><span data-stu-id="f46d9-401">Apps shouldn't make assumptions about which device that will be and are encouraged not to visibly identify such devices to users to reduce the potential for taking unfair advantage of authority-specific behavior in the app (e.g., lower latency, or always deferring to local simulation when movement packets from others are maliciously blocked).</span></span>

<span data-ttu-id="f46d9-402">In a future software release, apps will be able to send messages directly targeting the `xim_authority` using the `xim_player::xim_local::send_data_to_authority()` method and receive messages directly originating from it.</span><span class="sxs-lookup"><span data-stu-id="f46d9-402">In a future software release, apps will be able to send messages directly targeting the `xim_authority` using the `xim_player::xim_local::send_data_to_authority()` method and receive messages directly originating from it.</span></span> <span data-ttu-id="f46d9-403">XIM will also provide `xim_state_change` notifications and data buffer exchanges during the migration process.</span><span class="sxs-lookup"><span data-stu-id="f46d9-403">XIM will also provide `xim_state_change` notifications and data buffer exchanges during the migration process.</span></span> <span data-ttu-id="f46d9-404">However, these are not available in this software release.</span><span class="sxs-lookup"><span data-stu-id="f46d9-404">However, these are not available in this software release.</span></span> <span data-ttu-id="f46d9-405">All `xim_authority` methods other than `xim_authority::is_local()`, and the `xim_player::xim_local::send_data_to_authority()` method are not implemented and will throw an exception if called.</span><span class="sxs-lookup"><span data-stu-id="f46d9-405">All `xim_authority` methods other than `xim_authority::is_local()`, and the `xim_player::xim_local::send_data_to_authority()` method are not implemented and will throw an exception if called.</span></span> <span data-ttu-id="f46d9-406">Contact your Microsoft representative if you have questions about xim_authority.\`</span><span class="sxs-lookup"><span data-stu-id="f46d9-406">Contact your Microsoft representative if you have questions about xim_authority.\`</span></span>
