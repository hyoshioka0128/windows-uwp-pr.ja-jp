---
title: XIM (C++) の使用
author: KevinAsgari
description: C++ で Xbox Integrated Multiplayer (XIM) を使用する方法について説明します。
ms.author: kevinasg
ms.date: 01/24/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Xbox Live, Xbox, ゲーム, Xbox One, Xbox Integrated Multiplayer
ms.localizationpriority: low
ms.openlocfilehash: a2768fb34e2552af4699b106380591e584ec9977
ms.sourcegitcommit: 01760b73fa8cdb423a9aa1f63e72e70647d8f6ab
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/24/2018
---
# <a name="using-xim-c"></a><span data-ttu-id="e661a-104">XIM (C++) の使用</span><span class="sxs-lookup"><span data-stu-id="e661a-104">Using XIM (C++)</span></span>

> [!div class="op_single_selector" title1="Language"]
> - [C++](using-xim.md)
> - [C#](using-xim-cs.md)

<span data-ttu-id="e661a-107">ここでは、XIM の C++ API の使用方法について概要を紹介します。</span><span class="sxs-lookup"><span data-stu-id="e661a-107">This is a brief walkthrough on using XIM's C++ API.</span></span> <span data-ttu-id="e661a-108">ゲーム開発者が C# 経由で XIM にアクセスする場合は、「[XIM (C#) の使用](using-xim-cs.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="e661a-108">Game developers wanting to access XIM through C# should see [Using XIM (C#)](using-xim-cs.md).</span></span>

- [<span data-ttu-id="e661a-109">XIM (C++) の使用</span><span class="sxs-lookup"><span data-stu-id="e661a-109">Using XIM (C++)</span></span>](#using-xim-c)
    - [<span data-ttu-id="e661a-110">前提条件</span><span class="sxs-lookup"><span data-stu-id="e661a-110">Prerequisites</span></span>](#prerequisites)
    - [<span data-ttu-id="e661a-111">初期化および起動</span><span class="sxs-lookup"><span data-stu-id="e661a-111">Initialization and startup</span></span>](#initialization-and-startup)
    - [<span data-ttu-id="e661a-112">非同期操作および状態変更の処理</span><span class="sxs-lookup"><span data-stu-id="e661a-112">Asynchronous operations and processing state changes</span></span>](#asynchronous-operations-and-processing-state-changes)
    - [<span data-ttu-id="e661a-113">XIM プレイヤー オブジェクトの処理</span><span class="sxs-lookup"><span data-stu-id="e661a-113">Handling XIM player objects</span></span>](#handling-xim-player-objects)
    - [<span data-ttu-id="e661a-114">フレンド参加の有効化とフレンドの招待</span><span class="sxs-lookup"><span data-stu-id="e661a-114">Enabling friends to join and inviting them</span></span>](#enabling-friends-to-join-and-inviting-them)
    - [<span data-ttu-id="e661a-115">マッチメイキングの概要および別の XIM ネットワークへの移動</span><span class="sxs-lookup"><span data-stu-id="e661a-115">Basic matchmaking and moving to another XIM network with others</span></span>](#basic-matchmaking-and-moving-to-another-xim-network-with-others)
    - [<span data-ttu-id="e661a-116">デバッグ目的でのマッチメイキング NAT 規則の無効化</span><span class="sxs-lookup"><span data-stu-id="e661a-116">Disabling matchmaking NAT rule for debugging purposes</span></span>](#disabling-matchmaking-nat-rule-for-debugging-purposes)
    - [<span data-ttu-id="e661a-117">XIM ネットワークの退出およびクリーンアップ</span><span class="sxs-lookup"><span data-stu-id="e661a-117">Leaving a XIM network and cleaning up</span></span>](#leaving-a-xim-network-and-cleaning-up)
    - [<span data-ttu-id="e661a-118">メッセージの送信と受信</span><span class="sxs-lookup"><span data-stu-id="e661a-118">Sending and receiving messages</span></span>](#sending-and-receiving-messages)
    - [<span data-ttu-id="e661a-119">データ経路の品質の評価</span><span class="sxs-lookup"><span data-stu-id="e661a-119">Assessing data pathway quality</span></span>](#assessing-data-pathway-quality)
    - [<span data-ttu-id="e661a-120">プレイヤーのカスタム プロパティを使ったデータの共有</span><span class="sxs-lookup"><span data-stu-id="e661a-120">Sharing data using player custom properties</span></span>](#sharing-data-using-player-custom-properties)
    - [<span data-ttu-id="e661a-121">ネットワークのカスタム プロパティを使ったデータの共有</span><span class="sxs-lookup"><span data-stu-id="e661a-121">Sharing data using network custom properties</span></span>](#sharing-data-using-network-custom-properties)
    - [<span data-ttu-id="e661a-122">プレイヤーごとのスキルによるマッチメイキング</span><span class="sxs-lookup"><span data-stu-id="e661a-122">Matchmaking using per-player skill</span></span>](#matchmaking-using-per-player-skill)
    - [<span data-ttu-id="e661a-123">プレイヤーごとのロールによるマッチメイキング</span><span class="sxs-lookup"><span data-stu-id="e661a-123">Matchmaking using per-player role</span></span>](#matchmaking-using-per-player-role)
    - [<span data-ttu-id="e661a-124">XIM とプレイヤー チームの連携について</span><span class="sxs-lookup"><span data-stu-id="e661a-124">How XIM works with player teams</span></span>](#how-xim-works-with-player-teams)
    - [<span data-ttu-id="e661a-125">チャットの操作</span><span class="sxs-lookup"><span data-stu-id="e661a-125">Working with chat</span></span>](#working-with-chat)
    - [<span data-ttu-id="e661a-126">プレイヤーを消音する</span><span class="sxs-lookup"><span data-stu-id="e661a-126">Muting players</span></span>](#muting-players)
    - [<span data-ttu-id="e661a-127">プレイヤーのチームを使ったチャット ターゲットの構成</span><span class="sxs-lookup"><span data-stu-id="e661a-127">Configuring chat targets using player teams</span></span>](#configuring-chat-targets-using-player-teams)
    - [<span data-ttu-id="e661a-128">プレイヤー スロットの自動バックグラウンド設定 ("バックフィル" マッチメイキング)</span><span class="sxs-lookup"><span data-stu-id="e661a-128">Automatic background filling of player slots ("backfill" matchmaking)</span></span>](#automatic-background-filling-of-player-slots-backfill-matchmaking)

## <a name="prerequisites"></a><span data-ttu-id="e661a-129">前提条件</span><span class="sxs-lookup"><span data-stu-id="e661a-129">Prerequisites</span></span>

<span data-ttu-id="e661a-130">XIM のコーディングを始めるには、2 つの前提条件があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-130">Before you get started coding with XIM, there are two prerequisites.</span></span>

1. <span data-ttu-id="e661a-131">標準のマルチプレイヤー ネットワーキング機能を使用してアプリの AppXManifest を設定し、ネットワーク マニフェスト部分を構成して、XIM で使用するのに必要なトラフィック パターン テンプレートを宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-131">You must have configured your app's AppXManifest with standard multiplayer networking capabilities and you must have configured the network manifest portion to declare the necessary traffic pattern templates used by XIM.</span></span>

    <span data-ttu-id="e661a-132">AppXManifest 機能およびネットワーク マニフェストについては、プラットフォームのドキュメントの各セクションで詳しく説明されています。また、貼り付ける XIM 固有の XML は、「[XIM プロジェクト構成](xim-manifest.md)」で確認できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-132">AppXManifest capabilities and network manifests are described in more detail in their respective sections of the platform documentation; the typical XIM-specific XML to paste is provided at [XIM Project Configuration](xim-manifest.md).</span></span>

1. <span data-ttu-id="e661a-133">2 つのアプリケーション ID 情報が必要になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-133">You'll need to have two pieces of application identity information available:</span></span>

    * <span data-ttu-id="e661a-134">割り当てられている Xbox Live タイトル ID。</span><span class="sxs-lookup"><span data-stu-id="e661a-134">The assigned Xbox Live title ID.</span></span>
    * <span data-ttu-id="e661a-135">Xbox Live サービスにアクセスするためのアプリケーションのプロビジョニングの一部として提供されるサービス構成 ID。</span><span class="sxs-lookup"><span data-stu-id="e661a-135">The service configuration ID provided as part of provisioning your application for access to the Xbox Live service.</span></span>

    <span data-ttu-id="e661a-136">これらの取得に関する詳細については、マイクロソフトの担当者にお問い合わせください。</span><span class="sxs-lookup"><span data-stu-id="e661a-136">See your Microsoft representative for more information on acquiring these.</span></span> <span data-ttu-id="e661a-137">これらの情報は、初期化時に使用されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-137">These pieces of information will be used during initialization.</span></span>

<span data-ttu-id="e661a-138">XIM をコンパイルするには、プライマリ ヘッダー `XboxIntegratedMultiplayer.h` を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-138">Compiling XIM requires including the primary `XboxIntegratedMultiplayer.h` header.</span></span> <span data-ttu-id="e661a-139">適切にリンクするには、プロジェクト内の 1 つ以上のコンパイル ユニットにも `XboxIntegratedMultiplayerImpl.h` を含める必要があります (スタブ関数実装は小さく、コンパイラーで "インライン" として生成しやすいため、一般的なプリコンパイル済みヘッダーをお勧めします)。</span><span class="sxs-lookup"><span data-stu-id="e661a-139">In order to link properly, your project must also include `XboxIntegratedMultiplayerImpl.h` in at least one compilation unit (a common precompiled header is recommended since these stub function implementations are small and easy for the compiler to generate as "inline").</span></span>

<span data-ttu-id="e661a-140">[XIM の概要に関するページ](../xbox-integrated-multiplayer.md)で説明したとおり、XIM インターフェイスでは、プロジェクトのコンパイルにおいて、C++/CX と従来の C++ のいずれかを選択する必要がなく、どちらも使用できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-140">As mentioned in the [XIM Overview](../xbox-integrated-multiplayer.md), the XIM interface does not require a project to choose between compiling with C++/CX versus traditional C++; it can be used with either.</span></span> <span data-ttu-id="e661a-141">また、この実装では、致命的ではないエラーの報告手段として例外をスローしないため、必要な場合には、例外が発生しないプロジェクトから簡単に使用できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-141">The implementation also doesn't throw exceptions as a means of non-fatal error reporting so you can consume it easily from exception-free projects, if preferred.</span></span>

## <a name="initialization-and-startup"></a><span data-ttu-id="e661a-142">初期化および起動</span><span class="sxs-lookup"><span data-stu-id="e661a-142">Initialization and startup</span></span>

<span data-ttu-id="e661a-143">ライブラリーの操作を開始するには、Xbox Live サービス構成 ID の文字列とタイトル ID 番号を使用して XIM オブジェクト シングルトンを初期化します。</span><span class="sxs-lookup"><span data-stu-id="e661a-143">You begin interacting with the library by initializing the XIM object singleton with your Xbox Live service configuration ID string and title ID number.</span></span> <span data-ttu-id="e661a-144">Xbox Services API も使用している場合は、これらを `xbox::services::xbox_live_app_config` から取得すると便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-144">If you're also using the Xbox Services API, you may find it convenient to retrieve these from `xbox::services::xbox_live_app_config`.</span></span> <span data-ttu-id="e661a-145">次の例では、これらの値はそれぞれ "myServiceConfigurationId" および "myTitleId" 変数に既に存在するものと想定しています。</span><span class="sxs-lookup"><span data-stu-id="e661a-145">The following example assumes the values already reside in 'myServiceConfigurationId' and 'myTitleId' variables respectively:</span></span>

```cpp
xim::singleton_instance().initialize(myServiceConfigurationId, myTitleId);
```

<span data-ttu-id="e661a-146">初期化した後は、参加するローカル デバイスに現在存在しているすべてのユーザーの Xbox ユーザー ID 文字列をアプリで取得し、`xim::set_intended_local_xbox_user_ids()` の呼び出しに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-146">Once initialized, the app should retrieve the Xbox User ID strings for all users currently on the local device that will participate, and pass them to a `xim::set_intended_local_xbox_user_ids()` call.</span></span> <span data-ttu-id="e661a-147">次のサンプル コードでは、1 人のユーザーがコントローラーのボタンを押してプレイする意図を示し、そのユーザーに関連付けられた Xbox ユーザー ID 文字列は "myXuid" 変数に既に取得されているものとします。</span><span class="sxs-lookup"><span data-stu-id="e661a-147">The following sample code assumes a single user has pressed a controller button expressing intent to play and the Xbox User ID string associated with the user has already been retrieved into a 'myXuid' variable:</span></span>

```cpp
xim::singleton_instance().set_intended_local_xbox_user_ids(1, &myXuid);
```

<span data-ttu-id="e661a-148">`xim::set_intended_local_xbox_user_ids()` を呼び出すとすぐに、XIM ネットワークに追加する必要のあるローカル ユーザーに関連付けられている Xbox ユーザー ID が設定されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-148">A call to `xim::set_intended_local_xbox_user_ids()` immediately sets the Xbox User IDs associated with the local users that should be added to the XIM network.</span></span> <span data-ttu-id="e661a-149">この Xbox ユーザー ID のリストは、`xim::set_intended_local_xbox_user_ids()` の別の呼び出しによってリストが変更されるまで、以降のすべてのネットワーク操作で使用されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-149">This list of Xbox User IDs will be used in all future network operations until the list changes through another call to `xim::set_intended_local_xbox_user_ids()`.</span></span>

<span data-ttu-id="e661a-150">XIM ネットワークがまだ存在していない場合、プロセスを開始するために最初の手順として XIM ネットワークに移動します。</span><span class="sxs-lookup"><span data-stu-id="e661a-150">In the case where no XIM network exists at all yet, the first step is to move to a XIM network in order to get that process started.</span></span> <span data-ttu-id="e661a-151">ユーザーが特定の XIM ネットワークをまだ想定していない場合のベスト プラクティスは、単に、新しい空のネットワークに移動することです。</span><span class="sxs-lookup"><span data-stu-id="e661a-151">If the user doesn't already have a specific XIM network in mind, the best practice is to simply move to a new, empty network.</span></span> <span data-ttu-id="e661a-152">そのネットワークは、ユーザーのフレンドの参加を許可することで、次のマルチプレイヤー アクティビティ (一緒にマッチメイキングに入る、など) を共同で選択できる一種の "ロビー" になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-152">This allows the user's friends to join the network as a sort of "lobby" from which they can collaborate together to select their next multiplayer activity (such as entering matchmaking).</span></span>

<span data-ttu-id="e661a-153">`xim::set_intended_local_xbox_user_ids()` を使って以前に追加したローカル ユーザーのみを、最大で 8 プレイヤーが参加できる空の XIM ネットワークに移動する方法の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="e661a-153">The following is an example of how to move just the local users previously added with  `xim::set_intended_local_xbox_user_ids()` to an empty XIM network with room for up to 8 total players:</span></span>

```cpp
xim::singleton_instance().move_to_new_network(8, xim_players_to_move::bring_only_local_players);
```

<span data-ttu-id="e661a-154">`xim::move_to_new_network()` を呼び出すと、非同期移動操作が開始され、最終的に開発者が定期的に処理する必要がある状態変更イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="e661a-154">The call to `xim::move_to_new_network()` initiates an asynchronous move operation that concludes with a state change event that developers should regularly process for.</span></span>

## <a name="asynchronous-operations-and-processing-state-changes"></a><span data-ttu-id="e661a-155">非同期操作および状態変更の処理</span><span class="sxs-lookup"><span data-stu-id="e661a-155">Asynchronous operations and processing state changes</span></span>

<span data-ttu-id="e661a-156">XIM の中核的な動作は、アプリによる `xim::start_processing_state_changes()` メソッドと `xim::finish_processing_state_changes()` メソッドの定期的かつ頻繁な呼び出しです。</span><span class="sxs-lookup"><span data-stu-id="e661a-156">The heart of XIM is the app's regular, frequent calls to the `xim::start_processing_state_changes()` and `xim::finish_processing_state_changes()` pair of methods.</span></span> <span data-ttu-id="e661a-157">これらのメソッドを使用して、XIM はアプリがマルチプレイヤーの状態の更新を処理する準備ができた通知を受け取り、更新を提供します。</span><span class="sxs-lookup"><span data-stu-id="e661a-157">These methods are how XIM is informed that the app is ready to handle updates to multiplayer state, and how XIM provides those updates.</span></span> <span data-ttu-id="e661a-158">これらのメソッドは、UI レンダリング ループのすべてのグラフィックス フレームで呼び出すことができるよう、素早く動作するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="e661a-158">They're designed to operate quickly such that they can be called every graphics frame in your UI rendering loop.</span></span> <span data-ttu-id="e661a-159">これを利用することで、ネットワークのタイミングの予測不可能性やマルチスレッド コールバックの複雑さを気にすることなく、キュー内のすべての変更を取得できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-159">This provides a convenient place to retrieve all queued changes without worrying about the unpredictability of network timings or multi-threaded callback complexity.</span></span> <span data-ttu-id="e661a-160">XIM API は、このシングル スレッド パターン用に実際に最適化されています。</span><span class="sxs-lookup"><span data-stu-id="e661a-160">The XIM API is actually optimized for this single-threaded pattern.</span></span> <span data-ttu-id="e661a-161">これら 2 つの関数の外部では状態が変化しないことが保証されているため、直接的かつ効率的に使用できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-161">It guarantees its state will remain unchanged outside of these two functions, so you can use it directly and efficiently.</span></span>

<span data-ttu-id="e661a-162">同じ理由から、XIM API によって返されるオブジェクトがすべてスレッドセーフであるとは見なさないでください**。</span><span class="sxs-lookup"><span data-stu-id="e661a-162">For the same reason, all objects returned by the XIM API should *not* be considered thread-safe.</span></span> <span data-ttu-id="e661a-163">ライブラリには内部的なマルチスレッド保護機能がありますが、任意のスレッドで XIM のいずれかの値にアクセスする必要がある場合は、独自のロック処理を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-163">The library has internal multithreading protection, but you will still need to implement your own locking if you require an arbitrary thread to access any of XIM's values.</span></span> <span data-ttu-id="e661a-164">たとえば、あるスレッドが `xim::players()` リストを処理すると同時に、別のスレッドが `xim::start_processing_state_changes()` または `xim::finish_processing_state_changes()` を呼び出して、プレイヤー リストに関連付けられたメモリを変更する場合などです。</span><span class="sxs-lookup"><span data-stu-id="e661a-164">For example, in the case of having one thread walk the `xim::players()` list while another thread could be invoking either `xim::start_processing_state_changes()` or `xim::finish_processing_state_changes()` and altering the memory associated with that player list.</span></span>

<span data-ttu-id="e661a-165">`xim::start_processing_state_changes()` を呼び出すと、キューに入っているすべての更新が `xim_state_change` 構造体ポインターの配列で報告されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-165">When `xim::start_processing_state_changes()` is called, all queued updates are reported in an array of `xim_state_change` structure pointers.</span></span>

<span data-ttu-id="e661a-166">アプリは次の処理を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-166">Apps should:</span></span>

1. <span data-ttu-id="e661a-167">配列を反復処理する。</span><span class="sxs-lookup"><span data-stu-id="e661a-167">Iterate over the array.</span></span>
1. <span data-ttu-id="e661a-168">具体的な型の基本構造体を検査する。</span><span class="sxs-lookup"><span data-stu-id="e661a-168">Inspect the base structure for its more specific type.</span></span>
1. <span data-ttu-id="e661a-169">基本構造体の型を対応するより詳細な型にキャストする。</span><span class="sxs-lookup"><span data-stu-id="e661a-169">Cast the base structure type to the corresponding more detailed type.</span></span>
1. <span data-ttu-id="e661a-170">必要に応じて更新を処理する。</span><span class="sxs-lookup"><span data-stu-id="e661a-170">Handle that update as appropriate.</span></span>

<span data-ttu-id="e661a-171">現在使用可能なすべての `xim_state_change` 構造体が終了した後は、`xim::finish_processing_state_changes()` を呼び出すことによってその配列を XIM に戻してリソースを解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-171">Once finished with all the `xim_state_change` structures currently available, that array should be passed back to XIM to release the resources by calling `xim::finish_processing_state_changes()`.</span></span> <span data-ttu-id="e661a-172">次に、例を示します。</span><span class="sxs-lookup"><span data-stu-id="e661a-172">For example:</span></span>

```cpp
uint32_t stateChangeCount;
xim_state_change_array stateChanges;
xim::singleton_instance().start_processing_state_changes(&stateChangeCount, &stateChanges);
for (uint32_t stateChangeIndex = 0; stateChangeIndex < stateChangeCount; stateChangeIndex++)
{
   const xim_state_change * stateChange = stateChanges[stateChangeIndex];
   switch (stateChange->state_change_type)
   {
       case xim_state_change_type::player_joined:
       {
           MyHandlePlayerJoined(static_cast<const xim_player_joined_state_change*>(stateChange));
           break;
        }

       case xim_state_change_type::player_left:
       {
           MyHandlePlayerLeft(static_cast<const xim_player_left_state_change*>(stateChange));
           break;
       }

       ...
    }
 }
 xim::singleton_instance().finish_processing_state_changes(stateChanges);
```

<span data-ttu-id="e661a-173">これで基本的な処理ループができたので、`xim::move_to_new_network()` の初期操作に関連する状態変化を処理できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-173">Now that you have your basic processing loop, you can handle the state changes associated with the initial `xim::move_to_new_network()` operation.</span></span> <span data-ttu-id="e661a-174">すべての XIM ネットワーク移動操作は、`xim_move_to_network_starting_state_change` で開始します。</span><span class="sxs-lookup"><span data-stu-id="e661a-174">Every XIM network move operation will begin with a `xim_move_to_network_starting_state_change`.</span></span> <span data-ttu-id="e661a-175">何らかの理由で移動が失敗した場合、アプリは `xim_network_exited_state_change` を受け取ります。これは、XIM ネットワークへの移動を防止する、または現在の XIM ネットワークからタイトルを切断する、非同期エラーに対する共通のエラー処理メカニズムです。</span><span class="sxs-lookup"><span data-stu-id="e661a-175">If the move fails for any reason, then your app will be provided a `xim_network_exited_state_change`, which is the common failure handling mechanism for any asynchronous error that prevents you from moving to a XIM network or disconnects you from the current XIM network.</span></span> <span data-ttu-id="e661a-176">移動が成功した場合は、すべての状態が終了され、すべてのプレイヤーが XIM ネットワークに正常に追加された後、移動は `xim_move_to_network_succeeded_state_change` で完了します。</span><span class="sxs-lookup"><span data-stu-id="e661a-176">Otherwise, the move will complete with a `xim_move_to_network_succeeded_state_change` after all the state has been finalized and all the players have been successfully added to the XIM network.</span></span>

<span data-ttu-id="e661a-177">マルチプレイヤー セッションで他のプレイヤーとプレイするプラットフォーム特権がユーザーにない場合、XIM は、XIM ネットワークを作成または参加しようとするデバイスに、理由 `xim_network_exit_reason::user_multiplayer_restricted` の `xim_network_exited_state_change` を送信します。</span><span class="sxs-lookup"><span data-stu-id="e661a-177">When a user does not have the platform privilege for playing with others in a multiplayer session, XIM will send to a device attempting to create or join a XIM network a `xim_network_exited_state_change` with the reason `xim_network_exit_reason::user_multiplayer_restricted`.</span></span> <span data-ttu-id="e661a-178">これにより、`xim::set_intended_local_xbox_user_ids()` を使って設定されたローカル ユーザーすべてに Xbox Live マルチプレイヤーの制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-178">This happens when any of the local users set with `xim::set_intended_local_xbox_user_ids()` have an Xbox Live multiplayer restriction.</span></span> <span data-ttu-id="e661a-179">XIM を使う Xbox ERA アプリは、attemptResolution を true に設定して XIM ネットワークに移動しようとする前にローカル プレイヤーで `Store::Product::CheckPrivilegeAsync` を呼び出すか、返された `xim_network_exited_state_change` の理由として `xim_network_exit_reason::user_multiplayer_restricted` を受け取ったことへの応答としてこれを行います。</span><span class="sxs-lookup"><span data-stu-id="e661a-179">Xbox ERA Apps using XIM should either call `Store::Product::CheckPrivilegeAsync` on local players before attempting to move them into a XIM network with attemptResolution set to true, or do so in response to receiving `xim_network_exit_reason::user_multiplayer_restricted` as a reason for a returned `xim_network_exited_state_change`.</span></span>

## <a name="handling-xim-player-objects"></a><span data-ttu-id="e661a-180">XIM プレイヤー オブジェクトの処理</span><span class="sxs-lookup"><span data-stu-id="e661a-180">Handling XIM player objects</span></span>

<span data-ttu-id="e661a-181">1 人のローカル ユーザーを新しい XIM ネットワークに移動する例が成功したとすると、アプリにはローカル `xim_player` オブジェクトの `xim_player_joined_state_change` も提供されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-181">Assuming the example of moving a single local user to a new XIM network succeeded, your app will be provided a `xim_player_joined_state_change` for a local `xim_player` object.</span></span> <span data-ttu-id="e661a-182">このオブジェクト ポインターは、プレイヤー インスタンス自体が有効な場合に限り有効なままです。</span><span class="sxs-lookup"><span data-stu-id="e661a-182">This object pointer will remain valid for as long as the player instance itself is valid.</span></span> <span data-ttu-id="e661a-183">プレイヤー インスタンスは、そのプレイヤー インスタンスの対応する `xim_player_left_state_change` が `xim::finish_processing_state_changes()` の呼び出しによって返されると無効になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-183">The player instance becomes invalid when the corresponding `xim_player_left_state_change` for that player instance has been returned via a call to  `xim::finish_processing_state_changes()`.</span></span> <span data-ttu-id="e661a-184">アプリはすべての `xim_player_left_state_change` に対して常に `xim_player_joined_state_change` を提供されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-184">Your app will always be provided a `xim_player_left_state_change` for every `xim_player_joined_state_change`.</span></span>

<span data-ttu-id="e661a-185">`xim::get_players()` を使用することで、いつでも XIM ネットワークのすべての `xim_player` オブジェクトの配列を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="e661a-185">You can also retrieve an array of all `xim_player` objects in the XIM network at any time by using `xim::get_players()`.</span></span>

<span data-ttu-id="e661a-186">`xim_player` オブジェクトには、多くの役に立つメソッドがあります。たとえば、`xim_player::gamertag()` は、プレイヤーに関連付けられている現在の Xbox Live ゲーマータグ文字列を表示用に取得します。</span><span class="sxs-lookup"><span data-stu-id="e661a-186">The `xim_player` object has many helpful methods, such as `xim_player::gamertag()` for retrieving the current Xbox Live Gamertag string associated with the player for display purposes.</span></span> <span data-ttu-id="e661a-187">`xim_player` がデバイスに対してローカルである場合は、ローカル プレイヤーだけが使用できるメソッドである `xim_player::local()` から null ではない `xim_player::xim_local` オブジェクトのポインターも報告します。</span><span class="sxs-lookup"><span data-stu-id="e661a-187">If the `xim_player` is local to the device, then it will also report a non-null `xim_player::xim_local` object pointer from `xim_player::local()`, which has additional methods only available to local players.</span></span>

<span data-ttu-id="e661a-188">もちろん、プレイヤーにとって最も重要な状態は XIM が知っている共通の情報ではなく、特定のアプリで追跡する必要のある情報です。その追跡情報に対しては独自のコンストラクトがある可能性があるため、`xim_player` オブジェクトを独自のプレイヤー コンストラクト オブジェクトにリンクして、XIM が `xim_player` を報告するときはいつでも、カスタム プレイヤー コンテキスト ポインターを事前設定して検索を実行することなく状態をすばやく取得できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-188">Of course, the most important state for players is not the common information that XIM knows, but what your specific app wants to track. Since you likely have your own construct for that tracking information, you'll want to link the `xim_player` object to your own player construct object so that any time XIM reports a `xim_player`, you can quickly retrieve your state without having to populate and look up a custom player context pointer.</span></span> <span data-ttu-id="e661a-189">次の例では、プライベート状態に対するポインターは変数 "myPlayerStateObject" 内にあり、新しく追加される `xim_player` オブジェクトは変数 "newXimPlayer" 内にあるものとします。</span><span class="sxs-lookup"><span data-stu-id="e661a-189">The following example assumes a pointer to your private state is in the variable 'myPlayerStateObject' and the newly added `xim_player` object is in the variable 'newXimPlayer':</span></span>

```cpp
newXimPlayer->set_custom_player_context(myPlayerStateObject);
```

<span data-ttu-id="e661a-190">これは、指定されたポインター値をプレイヤー オブジェクトでローカルに保存します (メモリーが有効でないときにリモート デバイスにネットワーク経由で転送されることはありません)。</span><span class="sxs-lookup"><span data-stu-id="e661a-190">This saves the specified pointer value with the player object locally (it is never transferred over the network to remote devices where the memory would not be valid).</span></span> <span data-ttu-id="e661a-191">その後は、カスタム コンテキストを取得して、次の例のようにオブジェクトにキャストすることによって、いつでもオブジェクトに戻ることができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-191">You'll then be able to always get back to your object by retrieving the custom context and casting it back to your object like the following example:</span></span>

```cpp
myPlayerStateObject = reinterpret_cast<MyPlayerState *>(newXimPlayer->custom_player_context());
```

<span data-ttu-id="e661a-192">`xim_player` に割り当てられたカスタム プレイヤー コンテキスト ポインターはいつでも変更できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-192">You can change the custom player context pointer assigned to a `xim_player` at any time.</span></span>

## <a name="enabling-friends-to-join-and-inviting-them"></a><span data-ttu-id="e661a-193">フレンド参加の有効化とフレンドの招待</span><span class="sxs-lookup"><span data-stu-id="e661a-193">Enabling friends to join and inviting them</span></span>

<span data-ttu-id="e661a-194">プライバシーとセキュリティのため、すべての新しい XIM ネットワークは既定では追加プレイヤーが参加できないように自動的に構成されるので、アプリ側で参加を明示的に許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-194">For privacy and security, all new XIM networks are automatically configured by default to not be joinable by any additional players, and it's up to the app to explicitly allow joinability once it is ready.</span></span> <span data-ttu-id="e661a-195">次の例では、`xim::set_allowed_player_joins()` を使用して、プレイヤーとして参加する新しいローカル ユーザー、および招待されている、または "フォロー" されている (Xbox Live ソーシャル関係) ユーザーの許可を開始する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="e661a-195">The following example shows how to use `xim::set_allowed_player_joins()` to begin allowing new local users to join as players, as well other users that have been invited or that are being "followed" (an Xbox Live social relationship):</span></span>

```cpp
xim::singleton_instance().set_allowed_player_joins(xim_allowed_player_joins::local_invited_or_followed);
```

`xim::set_allowed_player_joins()` <span data-ttu-id="e661a-196">が非同期で実行されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-196">executes asynchronoulsy.</span></span> <span data-ttu-id="e661a-197">前のコード サンプルの呼び出しが完了すると、参加可能性の値がその既定値 `xim_allowed_player_joins::none` から変更されたことを通知する `xim_allowed_player_joins_changed_state_change` が生成されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-197">Once the previous code sample call completes, a `xim_allowed_player_joins_changed_state_change` is provided to notify the app that the joinability value has changed from its default of `xim_allowed_player_joins::none`.</span></span> <span data-ttu-id="e661a-198">その後、`xim::allowed_player_joins()` を使用して新しい値を照会できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-198">You can then query for the new value using `xim::allowed_player_joins()`.</span></span>

`xim::allowed_player_joins()` <span data-ttu-id="e661a-199">はいつでも呼び出して、ネットワーク上の参加可能性の設定を確認できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-199">may be called at any time to determine the joinability setting on the network.</span></span>

<span data-ttu-id="e661a-200">いずれかのローカル プレイヤーが、この XIM ネットワークへの参加招待をリモート ユーザーに送信する場合、アプリは `xim_player::xim_local::show_invite_ui()` を呼び出してシステム招待 UI を起動できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-200">Should one of the local players want to send out invitations to remote users to join this XIM network, the app can call `xim_player::xim_local::show_invite_ui()` to launch the system invitation UI.</span></span> <span data-ttu-id="e661a-201">ここでは、ローカル ユーザーが招待するユーザーを選択して、招待を送信できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-201">Here, the local user can select people they wish to invite and send out invitations.</span></span> <span data-ttu-id="e661a-202">このしくみは、次の例で示されています。変数 'ximPlayer' は有効なローカル `xim_player` を指しているものとします。</span><span class="sxs-lookup"><span data-stu-id="e661a-202">The following example demonstrates how this works and assumes that the variable 'ximPlayer' points to a valid local `xim_player`:</span></span>

```cpp
ximPlayer->local()->show_invite_ui();
```

<span data-ttu-id="e661a-203">上記のステートメントが実行されると、システム招待 UI が表示されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-203">After the above statement executes, the system invitation UI will display.</span></span> <span data-ttu-id="e661a-204">ユーザーが招待を送信すると (またはそれ以外で UI を閉じると)、`xim::start_processing_state_changes()` の次の呼び出しで `xim_show_invite_ui_completed_state_change` が提供されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-204">Once the user has sent the invitations (or otherwise dismissed the UI), a `xim_show_invite_ui_completed_state_change` will be provided on the next call to `xim::start_processing_state_changes()`.</span></span> <span data-ttu-id="e661a-205">または、アプリはシステム招待 UI を表示せずに `xim_player::xim_local::invite_users()` を使って直接招待を送信することもできます。</span><span class="sxs-lookup"><span data-stu-id="e661a-205">Alternatively, your app can send the invitations directly using `xim_player::xim_local::invite_users()` without bringing up the system invitation UI.</span></span>

<span data-ttu-id="e661a-206">どちらの方法でも、リモート ユーザーはサインインしている場所で Xbox Live 招待メッセージを受け取り、受け入れるか拒否することができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-206">Either way, remote users will receive Xbox Live invitation messages wherever they are signed in, which they can choose to accept or reject.</span></span> <span data-ttu-id="e661a-207">受け入れた場合、プロトコルのアクティブ化によってそれらのサービスでアプリが開始されます (まだ実行されていない場合)。プロトコルのアクティブ化は、対応する XIM ネットワークへの移動に使用できるイベント引数を指定してアプリに配信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-207">If they accept, a protocol activation will initiate your app on those devices if it isn't already running, and the protocol activation will be delivered to your app with its event arguments that can be used to move to the corresponding XIM network.</span></span>

<span data-ttu-id="e661a-208">プロトコルのアクティブ化自体について詳しくは、プラットフォームのドキュメントをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="e661a-208">See platform documentation for more information on protocol activation itself.</span></span>

<span data-ttu-id="e661a-209">次の例は、`xim::extract_protocol_activation_information()` を呼び出して、イベント引数が XIM に適用されるかどうかを調べる方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="e661a-209">The following example shows how a call to `xim::extract_protocol_activation_information()` determines if the event arguments are applicable to XIM.</span></span> <span data-ttu-id="e661a-210">これは、`Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs` から変数 'uriString' まで生の URI 文字列を取得したことを想定しています。</span><span class="sxs-lookup"><span data-stu-id="e661a-210">This assumes you've retrieved the raw URI string from `Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs` to a variable 'uriString':</span></span>

```cpp
xim_protocol_activation_information activationInfo;
bool isXimActivation;
isXimActivation = xim::singleton_instance().extract_protocol_activation_information(uriString, &activationInfo);
```

<span data-ttu-id="e661a-211">XIM のアクティブ化の場合、事前設定された `xim_protocol_activation_information` 構造体の "local_xbox_user_id" フィールドで示されているローカル ユーザーがサインインしていて、`xim::set_intended_local_xbox_user_ids()` に指定されているユーザーに含まれることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-211">If it is a XIM activation, then you will want to ensure the local user identified in the 'local_xbox_user_id' field of the populated `xim_protocol_activation_information` structure is signed in and is among the users specified to `xim::set_intended_local_xbox_user_ids()`.</span></span> <span data-ttu-id="e661a-212">その後、同じ URI 文字列を使用して `xim::move_to_network_using_protocol_activated_event_args()` を呼び出すことで、指定された XIM ネットワークへの移動を開始できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-212">You can then initiate moving to the specified XIM network with a call to `xim::move_to_network_using_protocol_activated_event_args()` using the same URI string.</span></span> <span data-ttu-id="e661a-213">次に、例を示します。</span><span class="sxs-lookup"><span data-stu-id="e661a-213">For example:</span></span>

```cpp
xim::singleton_instance().move_to_network_using_protocol_activated_event_args(uriString);
```

<span data-ttu-id="e661a-214">"フォローされている" リモート ユーザーはシステム UI でローカル ユーザーのプレイヤー カードに移動し、招待なしに自分だけで参加の試みを開始できることにも注意してください (前に示したように、そのようなプレイヤーの参加を許可してあるものとします)。</span><span class="sxs-lookup"><span data-stu-id="e661a-214">Also note that "followed" remote users can navigate to the local user's player card in the system UI and initiate a join attempt themselves without an invitation (assuming you've allowed such player joins as shown above).</span></span> <span data-ttu-id="e661a-215">このアクションでも、アプリでは招待の場合と同じようにプロトコルのアクティブ化が実行され、同じように処理されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-215">This action will also protocol activate your app just like invites do and are handled in the same way.</span></span>

<span data-ttu-id="e661a-216">プロトコルのアクティブ化を使用した XIM ネットワークへの移動は、「[初期化および起動](#initialization-and-startup)」に示されているように新しい XIM ネットワークへの移動と同じです。</span><span class="sxs-lookup"><span data-stu-id="e661a-216">Moving to a XIM network using protocol activation is identical to moving to a new XIM network as shown in [Initialization and startup](#initialization-and-startup).</span></span> <span data-ttu-id="e661a-217">唯一の違いは、移動が成功すると、移動中のデバイスによって、適用可能なすべてのプレイヤーを表すローカルとリモート両方のプレイヤーに `xim_player_joined_state_change` 構造体が送信されることです。</span><span class="sxs-lookup"><span data-stu-id="e661a-217">The only difference is that when the move succeeds, the moving device will be provided both local and remote player `xim_player_joined_state_change` structures representing all applicable players.</span></span> <span data-ttu-id="e661a-218">当然、既に XIM ネットワークに存在していた元のデバイスが移動することはありませんが、`xim_player_joined_state_change` 構造体がさらに送信されると、新しいデバイスのユーザーがプレイヤーとして追加されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-218">Naturally, the original device that was already in the XIM network won't be moving, but will see the new device's users be added as players through additional `xim_player_joined_state_change` structures.</span></span>

<span data-ttu-id="e661a-219">さまざまなデバイスのプレイヤーが XIM ネットワークに一緒に参加すると、マルチプレイヤー シナリオを開始して、音声およびテキストを介して自動的に通信し、アプリ固有のメッセージを送信できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-219">Once players across different devices are joined together in a XIM network, they can initiate multiplayer scenarios, communicate over voice and text automatically, and send app-specific messages.</span></span>

## <a name="basic-matchmaking-and-moving-to-another-xim-network-with-others"></a><span data-ttu-id="e661a-220">マッチメイキングの概要および別の XIM ネットワークへの移動</span><span class="sxs-lookup"><span data-stu-id="e661a-220">Basic matchmaking and moving to another XIM network with others</span></span>

<span data-ttu-id="e661a-221">知らないユーザーも含まれる XIM ネットワークにプレイヤーを移動することにより、フレンドのグループのネットワーク エクスペリエンスをさらに拡張できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-221">You can further expand the networking experience for a group of friends by moving the players to a XIM network that also has strangers.</span></span> <span data-ttu-id="e661a-222">知らないユーザーは世界中から参戦し、同じ興味に基づき Xbox Live マッチメイキング サービスを使って一緒になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-222">Strangers are opponents from around the world who are brought together using the Xbox Live matchmaking service based on similar interests.</span></span>

<span data-ttu-id="e661a-223">XIM を使って基本的なマッチメイキングを開始するには、データの設定された `xim_matchmaking_configuration` 構造体を使用して、いずれかのデバイスで `xim::move_to_network_using_matchmaking()` を呼び出し、現在の XIM ネットワークからプレイヤーを移動するのが最も簡単です。</span><span class="sxs-lookup"><span data-stu-id="e661a-223">A simple way to initiate basic matchmaking with XIM is by calling `xim::move_to_network_using_matchmaking()` on one of the devices with a populated `xim_matchmaking_configuration` structure, taking players from the current XIM network along with it.</span></span>

<span data-ttu-id="e661a-224">次の例では、no-teams free-for-all 用に合計 8 人のプレイヤーを探すようにセットアップされたマッチメイキング構成を使って移動を開始します。</span><span class="sxs-lookup"><span data-stu-id="e661a-224">The following example initiates a move using a matchmaking configuration set up to find a total of 8 players for a no-teams free-for-all match.</span></span> <span data-ttu-id="e661a-225">プレイヤーが 8 人見つからない場合、システムにより 2 ～ 7 人のプレイヤーがマッチングされることができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-225">If 8 total players aren't found, the system might still match 2-7 players together.</span></span> <span data-ttu-id="e661a-226">この例では、フィルターで除外するゲーム モードを表す、アプリによって定義された定数 (型は uint64_t、名前は MYGAMEMODE_DEATHMATCH) を使います。</span><span class="sxs-lookup"><span data-stu-id="e661a-226">This example uses an app-defined constant, of type uint64_t, named MYGAMEMODE_DEATHMATCH, that represents the game-mode to filter off of.</span></span> <span data-ttu-id="e661a-227">XIM のマッチメイキングでは、同じ値を指定する他のプレイヤーだけがこのネットワークとマッチングされ、2 番目のパラメーター `xim_players_to_move::bring_existing_social_players` を `xim::move_to_network_using_matchmaking()` に指定すると、ソーシャル機能を使用して参加したプレイヤーがすべて現在の XIM ネットワークから移行されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-227">XIM's matchmaking will only match this network with other players specifying that same value and brings along all socially-joined players from the current XIM network when providing the second parameter `xim_players_to_move::bring_existing_social_players` to `xim::move_to_network_using_matchmaking()`:</span></span>

```cpp
xim_matchmaking_configuration matchmakingConfiguration = { 0 };
matchmakingConfiguration.team_matchmaking_mode = xim_team_matchmaking_mode::no_teams_8_players_minimum_2;
matchmakingConfiguration.custom_game_mode = MYGAMEMODE_DEATHMATCH;

xim::singleton_instance().move_to_network_using_matchmaking(matchmakingConfiguration, xim_players_to_move::bring_existing_social_players);
```

<span data-ttu-id="e661a-228">前述の移動のように、このマッチメイキング プロセスにより、すべてのデバイスに最初の `xim_move_to_network_starting_state_change` が送信され、成功すると、`xim_move_to_network_succeeded_state_change` が送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-228">Like earlier moves, this matchmaking process will provide an initial `xim_move_to_network_starting_state_change` on all devices, and a `xim_move_to_network_succeeded_state_change` once the move completes successfully.</span></span> <span data-ttu-id="e661a-229">この場合は XIM ネットワーク間で移動するため、ローカルユーザーおよびリモートユーザー向けに追加された既存の `xim_player` オブジェクトが存在している点が異なり、このオブジェクトはすべてのプレイヤーを新しい XIM ネットワークにまとめて移動するために保持されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-229">Since this is a move from one XIM network to another, one difference is that there are already existing `xim_player` objects added for local and remote users, and these will remain for all players that are moving together to the new XIM network.</span></span> <span data-ttu-id="e661a-230">プレイヤー間でのチャットとデータ通信は、マッチメイキングが進行中も中断せずに機能し続けます。</span><span class="sxs-lookup"><span data-stu-id="e661a-230">Chat and data communication among players will continue to work uninterrupted while matchmaking is in progress.</span></span>

<span data-ttu-id="e661a-231">同様に `xim::move_to_network_using_matchmaking()` を呼び出した、マッチメイキング プールに含まれる可能性があるプレイヤーの数によっては、マッチメイキング プロセスに時間がかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="e661a-231">Matchmaking can be a lengthy process depending on the number of potential players in the matchmaking pool that have also called `xim::move_to_network_using_matchmaking()`.</span></span>

<span data-ttu-id="e661a-232">ユーザーに現在のステータスを通知し続けるために、`xim_matchmaking_progress_updated_state_change` は、この操作が終わるまで定期的に送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-232">A `xim_matchmaking_progress_updated_state_change` will be provided periodically throughout the operation to keep you and your users informed of the current status.</span></span> <span data-ttu-id="e661a-233">一致すると、一般的な `xim_player_joined_state_change` を使用してユーザーが XIM ネットワークに追加され、移動は完了します。</span><span class="sxs-lookup"><span data-stu-id="e661a-233">When the match has been found, the additional players are added to the XIM network with the typical `xim_player_joined_state_change` and the move completes.</span></span>

<span data-ttu-id="e661a-234">この "マッチメイキング型" プレイヤーのセットを使用したマルチプレイヤー体験が完了すると、他のマッチメイキングのラウンドを使用して他の XIM ネットワークに移動することができるこのプロセスを繰り返せるようになります。</span><span class="sxs-lookup"><span data-stu-id="e661a-234">Once you've finished the multiplayer experience with this set of "matchmade" players, you can repeat the process to move to a different XIM network with another round of matchmaking.</span></span> <span data-ttu-id="e661a-235">以前の `xim::move_to_network_using_matchmaking()` 操作によって参加した各プレイヤーが `xim_player_left_state_change` を生成して、その `xim_player` オブジェクトが同じ XIM ネットワークに存在しなくかったことを示しているのがわかります。</span><span class="sxs-lookup"><span data-stu-id="e661a-235">You'll see each player that joined via the prior `xim::move_to_network_using_matchmaking()` operation provide a `xim_player_left_state_change` to indicate that their `xim_player` objects are no longer in the same XIM network.</span></span>

<span data-ttu-id="e661a-236">`xim::move_to_network_using_matchmaking()` を使って再度マッチメイキングを開始することを選んだときに `xim_players_to_move::bring_existing_social_players` を指定した場合、ソーシャル エントリ ポイントを通じて参加してプレイヤー (`xim::move_to_network_using_protocol_activated_event_args()` or `xim::move_to_network_using_joinable_xbox_user_id()`) は、新しいマッチメイキングが行われている間も残ります。</span><span class="sxs-lookup"><span data-stu-id="e661a-236">If when you choose to initiate matchmaking again using `xim::move_to_network_using_matchmaking()`, you specify `xim_players_to_move::bring_existing_social_players`, the players that joined via social entry points (`xim::move_to_network_using_protocol_activated_event_args()` or `xim::move_to_network_using_joinable_xbox_user_id()`) will remain while the new matchmaking takes place.</span></span> <span data-ttu-id="e661a-237">または、`xim_players_to_move::bring_only_local_players` を指定すると、ソーシャル機能を使ってつながったリモート プレイヤーが切断され、ローカル プレイヤーだけが残ります。</span><span class="sxs-lookup"><span data-stu-id="e661a-237">Alternatively, specifying `xim_players_to_move::bring_only_local_players` will disconnect socially connected remote players, leaving just the local players to remain.</span></span> <span data-ttu-id="e661a-238">どちらの場合も、2 回目の移動操作が完了すると、別の見知らぬユーザーの集合が追加されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-238">In both cases, a different set of strangers will be added when the second move operation completes.</span></span>

<span data-ttu-id="e661a-239">次のマッチメイキング構成/マルチプレイヤー アクティビティを決めると同時に、マッチメイキング型でないプレイヤー (つまり、ローカル プレイヤー) をまったく新しい XIM ネットワークに移動することも選択できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-239">You also have the choice to move the non-matchmade players (or just local players) to a completely new XIM network while deciding the next matchmaking configuration/multiplayer activity.</span></span> <span data-ttu-id="e661a-240">次の例は、XIM ネットワークに最大 8 人のプレイヤーを集めるために、デバイスが `xim::move_to_new_network()` を呼び出す方法を示してます。ただし、今回はソーシャル機能を使用して参加した既存プレイヤーも移動します。</span><span class="sxs-lookup"><span data-stu-id="e661a-240">The following example demonstrates how a device would call `xim::move_to_new_network()` for a XIM network with a maximum of 8 players, but this time taking the existing socially-joined players as well:</span></span>

```cpp
xim::singleton_instance().move_to_new_network(8, xim_players_to_move::bring_existing_social_players);
```

<span data-ttu-id="e661a-241">すべての参加デバイスに`xim_move_to_network_starting_state_change` と `xim_move_to_network_succeeded_state_change` が生成され、後に残ったマッチメイキング型のプレイヤーには `xim_player_left_state_change` が生成されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-241">A `xim_move_to_network_starting_state_change` and `xim_move_to_network_succeeded_state_change` will be provided to all participating devices, along with a `xim_player_left_state_change` for the matchmade players that were left behind.</span></span> <span data-ttu-id="e661a-242">それらのデバイスでも、ネットワークの外に移動された各プレイヤーには `xim_player_left_state_change` が表示されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-242">On those devices, they will similarly see a `xim_player_left_state_change` for each player that is moved out of the network.</span></span>

<span data-ttu-id="e661a-243">上記で説明した方法を必要な回数だけ使用して、引き続き XIM ネットワーク間で移動できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-243">You can continue moving from XIM network to XIM network in the above-described manner as many times as desired.</span></span>

<span data-ttu-id="e661a-244">パフォーマンス上、Xbox Live サービスは、直接ピア ツー ピア接続を確立できないデバイス上でプレイヤーのグループのマッチングを試行することはありません。</span><span class="sxs-lookup"><span data-stu-id="e661a-244">For performance, the Xbox Live service will not try to match groups of players on devices that are unlikely to be able to establish any direct peer-to-peer connections.</span></span> <span data-ttu-id="e661a-245">標準の Xbox Live マルチプレイヤーをサポートするように適切に構成されていないネットワーク環境で開発している場合、マッチメイキング条件を満たし、同一のローカル環境にあるすべてのデバイスを移動中および使用中のプレイヤーが十分にいる場合でも、正常なマッチメイキングが行われることなく、マッチメイキングを使用した新しいネットワークへの移動操作が無期限に続くことがあります。</span><span class="sxs-lookup"><span data-stu-id="e661a-245">If you're developing in a network environment that's not properly configured to support standard Xbox Live multiplayer, the move to new network using matchmaking operation might continue indefinitely without successful matching even when you're certain you have sufficient players meeting the matchmaking criteria who are all moving and all using devices in the same local environment.</span></span> <span data-ttu-id="e661a-246">必ずネットワーク設定領域/Xbox アプリケーションでマルチプレイヤーの接続テストを実行し、特に "Strict NAT" についての問題を報告する場合の推奨事項に従ってください。</span><span class="sxs-lookup"><span data-stu-id="e661a-246">Be sure to run the multiplayer connectivity test in the network settings area/Xbox application and follow its recommendations if it reports trouble, particularly regarding a "Strict NAT".</span></span>

## <a name="disabling-matchmaking-nat-rule-for-debugging-purposes"></a><span data-ttu-id="e661a-247">デバッグ目的でのマッチメイキング NAT 規則の無効化</span><span class="sxs-lookup"><span data-stu-id="e661a-247">Disabling matchmaking NAT rule for debugging purposes</span></span>

<span data-ttu-id="e661a-248">ネットワーク管理者が環境に必要な変更を行って XIM の NAT 規則をサポートすることができない場合は、Xbox One 開発キットでテストのブロックを解除できます。そのためには、"Open NAT" デバイスを 一切指定せずに "ストリクト NAT" デバイスをマッチングできるように XIM を構成します。</span><span class="sxs-lookup"><span data-stu-id="e661a-248">If your network administrator is unable to make the necessary environment changes to support XIM's NAT rules, you can unblock your matchmaking testing on Xbox One development kits by configuring XIM to allow matching "Strict NAT" devices without at least one "Open NAT" device.</span></span> <span data-ttu-id="e661a-249">これを行うには、すべての Xbox One 本体上の "title scratch" ドライブのルートに "xim_disable_matchmaking_nat_rule" と呼ばれるファイル (内容は問いません) を配置します。</span><span class="sxs-lookup"><span data-stu-id="e661a-249">This is done by placing a file called "xim_disable_matchmaking_nat_rule" (contents don't matter) at the root of the "title scratch" drive on all Xbox One consoles.</span></span> <span data-ttu-id="e661a-250">配置する方法のひとつとして、アプリを起動する前に XDK コマンド プロンプトから以下を実行し、プレースホルダー "{console_name_or_ip_address}" を適宜各コンソールに置き換える方法があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-250">One example way to do that is by executing the following from an XDK command prompt before launching your app, replacing the placeholder "{console_name_or_ip_address}" for each console as appropriate:</span></span>

```bat
echo.>%TEMP%\emptyfile.txt
copy %TEMP%\emptyfile.txt \\{console_name_or_ip_address}\TitleScratch\xim_disable_matchmaking_nat_rule
del %TEMP%\emptyfile.txt
```

> [!NOTE]
> この開発上の回避策は、現在 Xbox One 排他リソース アプリケーションでのみ使用することができ、ユニバーサル Windows アプリではサポートされません。 また、本体でこの設定を使用している場合は、ネットワーク環境にかかわらず、このファイルも存在しないデバイスにマッチングすることはないため、ファイルは、あらゆる場所で追加および削除することができます。

## <a name="leaving-a-xim-network-and-cleaning-up"></a><span data-ttu-id="e661a-253">XIM ネットワークの退出およびクリーンアップ</span><span class="sxs-lookup"><span data-stu-id="e661a-253">Leaving a XIM network and cleaning up</span></span>

<span data-ttu-id="e661a-254">ローカル ユーザーが XIM ネットワークに参加している場合、新しい XIM ネットワークに移動するだけで、ローカル ユーザー、招待されたユーザー、"フォローされている" ユーザーはその XIM ネットワークに参加できるため、引き続きフレンドと協力して次のアクティビティに進むことができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-254">When local users are done participating in a XIM network, often they will simply move into a new XIM network that allows local users, invited users, and "followed" users to join so they can continue coordinating with their friends in finding the next activity.</span></span> <span data-ttu-id="e661a-255">しかし、ユーザーがマルチプレイヤー経験の大半を終えている場合、アプリは、XIM ネットワークの退出を開始し、`xim::initialize()` および `xim::set_intended_local_xbox_user_ids()` が呼び出されたかのように、その状態に戻る場合があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-255">But if the user is completely done with all multiplayer experiences, then your app may want to begin leaving the XIM network altogether and return to the state as if only `xim::initialize()` and `xim::set_intended_local_xbox_user_ids()` had been called.</span></span> <span data-ttu-id="e661a-256">この処理を実行するには、`xim::leave_network()` メソッドを使います。</span><span class="sxs-lookup"><span data-stu-id="e661a-256">This is done using the `xim::leave_network()` method:</span></span>

```cpp
xim::singleton_instance().leave_network();
```

<span data-ttu-id="e661a-257">このメソッドでは、他の参加者から非同期的に切断するプロセスを正常に開始します。</span><span class="sxs-lookup"><span data-stu-id="e661a-257">This method begins the process of asynchronously disconnecting from the other participants gracefully.</span></span> <span data-ttu-id="e661a-258">これにより、リモート デバイスで切断されたローカル プレイヤーごとに `xim_player_left_state_change` が生成されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-258">This will cause the remote devices to be provided a `xim_player_left_state_change` for each local player that disconnected.</span></span> <span data-ttu-id="e661a-259">ローカル デバイスでは、切断されたローカル プレイヤーおよびリモート プレイヤーごとに `xim_player_left_state_change` も生成されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-259">The local device will be also be provided a `xim_player_left_state_change` for each local and remote player that has disconnected.</span></span> <span data-ttu-id="e661a-260">すべての接続操作が完了すると、最後に `xim_network_exited_state_change` が送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-260">When all disconnect operations have finished, a final `xim_network_exited_state_change` will be provided.</span></span> <span data-ttu-id="e661a-261">その後、アプリで `xim::cleanup()` を呼び出してリソースをすべて解放し、未初期化状態に戻すことができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-261">The app can then call \`xim::cleanup()\`\` to free all resources and return to the uninitialized state:</span></span>

```cpp
xim::singleton_instance().cleanup();
```

<span data-ttu-id="e661a-262">`xim_network_exited_state_change` がまだ送信されていない場合は、`xim::leave_network()` を呼び出し、`xim_network_exited_state_change` を待機して、XIM ネットワークを正常終了することを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e661a-262">Invoking `xim::leave_network()` and waiting for the `xim_network_exited_state_change` in order to exit a XIM network gracefully is always highly recommended when a `xim_network_exited_state_change` has not already been provided.</span></span>

<span data-ttu-id="e661a-263">`xim::leave_network()` を呼び出さずに `xim::cleanup()` が直接呼び出された場合、残りの参加者に対して通信パフォーマンスの問題が発生します。`xim::cleanup()` を呼び出すことで "消えた" デバイスに対して配信不能なメッセージの送信が強制されるためです。</span><span class="sxs-lookup"><span data-stu-id="e661a-263">If `xim::cleanup()` is called directly without `xim::leave_network()` being called, then communication performance problems for the remaining participants will occur since they will be forced to send non-deliverable messages to the device that simply "disappeared" by calling `xim::cleanup()`.</span></span>

## <a name="sending-and-receiving-messages"></a><span data-ttu-id="e661a-264">メッセージの送信と受信</span><span class="sxs-lookup"><span data-stu-id="e661a-264">Sending and receiving messages</span></span>

<span data-ttu-id="e661a-265">XIM とその基になっているコンポーネントによって、インターネット経由で手間をかけずに安全な通信チャネルを確立することができるため、接続の問題や、一部のプレイヤーが受信できない可能性があることを心配する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="e661a-265">XIM and its underlying components do all the tedious work of establishing secure communication channels over the Internet so you don't have to worry about connectivity problems or being able to reach some but not all players.</span></span> <span data-ttu-id="e661a-266">ピア ツー ピア接続の基盤に問題がある場合、XIM ネットワークへの移動は成功しません。</span><span class="sxs-lookup"><span data-stu-id="e661a-266">If there are any fundamental peer-to-peer connectivity issues, moving to a XIM network will not succeed.</span></span>

<span data-ttu-id="e661a-267">XIM ネットワークが形成されて `xim_move_to_network_succeeded_state_change` によって確認された場合、参加しているすべてのデバイス間のアプリのすべてのインスタンスには、`xim_player` が XIM ネットワークに接続するために通知を受け取ることが保証され、そのどれにもメッセージを送信できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-267">When a XIM network is formed and confirmed with `xim_move_to_network_succeeded_state_change`, all instances of your app across all joined devices are guaranteed to be informed of every `xim_player` connected to the XIM network, and can send messages to any of them.</span></span>

<span data-ttu-id="e661a-268">XIM ネットワーク経由でメッセージを送信する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="e661a-268">Let's demonstrate how to send messages across the XIM network.</span></span> <span data-ttu-id="e661a-269">次の例では、'sendingPlayer' 変数が有効なローカル プレイヤー オブジェクトへのポインターであると想定しています。</span><span class="sxs-lookup"><span data-stu-id="e661a-269">The following example assumes the 'sendingPlayer' variable is a pointer to a valid local player object.</span></span> <span data-ttu-id="e661a-270">'sendingPlayer' は `local()` を呼び出し、`send_data_to_other_players()` を呼び出してメッセージ構造体 'msgData' をすべてのプレイヤー (ローカルとリモートのどちらも) に、保証されたシーケンシャル配信で送信します。</span><span class="sxs-lookup"><span data-stu-id="e661a-270">'sendingPlayer' invokes `local()` and calls `send_data_to_other_players()` to send the message structure 'msgData' to all players (both local and remote) with guaranteed, sequential delivery.</span></span> <span data-ttu-id="e661a-271">特定のプレイヤーのリストはメソッドに渡されていないため、すべてのプレイヤーに送信されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="e661a-271">Please note that it goes to all players because a list of specific players was not passed into the method:</span></span>

```cpp
sendingPlayer->local()->send_data_to_other_players(sizeof(msgData), &msgData, 0, nullptr, xim_send_type::guaranteed_and_sequential);
```

<span data-ttu-id="e661a-272">特定のプレイヤーの配列をメソッドに渡さなければ、`send_data_to_other_players()` を使用してすべてのプレイヤーにメッセージを配信できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-272">Messages can be delivered to all players using `send_data_to_other_players()` by not passing an array of specific players to the method.</span></span>

<span data-ttu-id="e661a-273">メッセージのすべての受信者には、データのコピーへのポインターおよびメッセージを送信してローカルに受信する対応する xim_player オブジェクトへのポインターを含む `xim_player_to_player_data_received_state_change` が提供されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-273">All recipients of the message are provided a `xim_player_to_player_data_received_state_change` that includes a pointer to a copy of the data, as well as pointers to the corresponding xim_player object that sent it and are locally receiving it.</span></span>

<span data-ttu-id="e661a-274">もちろん保証されたシーケンシャル配信は便利ですが、インターネットでパケットがドロップされたりパケットの順序が正しくない場合は XIM はメッセージを再送信または遅延する必要があるため、効率的ではない送信タイプでもあります。</span><span class="sxs-lookup"><span data-stu-id="e661a-274">Of course, guaranteed, sequential delivery is convenient, but it can also be an inefficient send type, since XIM needs to retransmit or delay messages if packets are dropped or disordered by the Internet.</span></span> <span data-ttu-id="e661a-275">アプリがパケットのドロップや順序の間違いを許容できるメッセージに対しては他の送信タイプの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="e661a-275">Be sure to consider using the other send types for messages that your app can tolerate losing or having arrive out of order.</span></span> <span data-ttu-id="e661a-276">メッセージ データはリモート コンピューターから送られてくるので、データ形式を明確に定義 (特定のバイト オーダー ("エンディアン") でマルチバイト値をパッキングするなど) するのがベスト プラクティスです。</span><span class="sxs-lookup"><span data-stu-id="e661a-276">Since message data comes from a remote machine, the best practice is to have clearly defined data formats, such as packing multi-byte values in a particular byte order ("endianness").</span></span> <span data-ttu-id="e661a-277">アプリでは、処理する前にデータを検証する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="e661a-277">The app should also validate the data before acting on it.</span></span>

<span data-ttu-id="e661a-278">XIM には、ネットワーク レベルのセキュリティが備わっているため、追加の暗号化または署名スキームは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="e661a-278">XIM provides network-level security so there is no need for additional encryption or signature schemes.</span></span> <span data-ttu-id="e661a-279">ただし、予想外のアプリケーションのバグから保護して、異なるバージョンのアプリケーション プロトコルの共存 (開発、コンテンツの更新などのとき) を徐々に処理できるように、常に "きめ細かい防御" を採用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e661a-279">However, we recommend always to employ "defense-in-depth" in order to protect against accidental application bugs and to be able to handle different versions of your application protocol coexisting gracefully (during development, content updates, etc.).</span></span> <span data-ttu-id="e661a-280">ユーザーのインターネット接続も、常に変わり続ける限られたリソースです。</span><span class="sxs-lookup"><span data-stu-id="e661a-280">Users' Internet connections can be limited and ever-changing resources.</span></span> <span data-ttu-id="e661a-281">有益なメッセージ データ形式を使用し、すべての UI フレームを送信するような設計にしないことを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e661a-281">We strongly recommend the use of efficient message data formats and avoiding designs that send every UI frame.</span></span>

## <a name="assessing-data-pathway-quality"></a><span data-ttu-id="e661a-282">データ経路の品質の評価</span><span class="sxs-lookup"><span data-stu-id="e661a-282">Assessing data pathway quality</span></span>

<span data-ttu-id="e661a-283">2 人のプレイヤー間における現在のデータ経路の品質の詳細は、`xim_player::network_path_information()` メソッドを呼び出して確認できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-283">To learn about the current quality of the data pathway between two players, call the `xim_player::network_path_information()` method.</span></span> <span data-ttu-id="e661a-284">以下の例では、`xim_network_path_information` 構造体のポインターを取得し、'remotePlayer' 変数に含まれる `xim_player` ポインターを操作します。</span><span class="sxs-lookup"><span data-stu-id="e661a-284">The following example retrieves a pointer to the `xim_network_path_information` structure for a `xim_player` pointer contained in the 'remotePlayer' variable:</span></span>

```cpp
 const xim_network_path_information * networkPathInfo = remotePlayer->network_path_information();
```

<span data-ttu-id="e661a-285">返される構造体には、予想される往復遅延時間に加え、接続上の理由からその時点で追加データを送信できない場合に送信できるように、ローカルのキューに入ったままのメッセージ数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="e661a-285">The returned structure includes the estimated round trip latency and how many messages are still queued locally for transmission in the case that the connection can't support transmitting more data for that moment.</span></span>

<span data-ttu-id="e661a-286">特定の 'xim_player' のキューがバックアップ中であると表示される場合は、データの送信速度を抑える必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-286">If you see that the queues are backing up for a particular 'xim_player', you should reduce the rate at which you're sending data.</span></span>

<span data-ttu-id="e661a-287">`xim_network_path_information::round_trip_latency_in_milliseconds` フィールドは、基盤のネットワークの待機時間と、キューを経由しない場合の XIM の推定待機時間を表します。</span><span class="sxs-lookup"><span data-stu-id="e661a-287">The `xim_network_path_information::round_trip_latency_in_milliseconds` field represents the latency of the underlying network and XIM's estimated latency without queuing.</span></span> <span data-ttu-id="e661a-288">実際の遅延時間は、`xim_network_path_information::send_queue_size_in_messages` が大きくなり、XIM がキュー経由で動作するようになるにつれて増加します。</span><span class="sxs-lookup"><span data-stu-id="e661a-288">Effective latency increases as `xim_network_path_information::send_queue_size_in_messages` grows and XIM works through the queue.</span></span>

<span data-ttu-id="e661a-289">ゲームの使用状況と要件に基づいて、`send_data_to_other_players` の呼び出しの調整を開始する適切なポイントを選択してください。</span><span class="sxs-lookup"><span data-stu-id="e661a-289">Choose a reasonable point to start throttling calls to `send_data_to_other_players` based on the game's usage and requirements.</span></span> <span data-ttu-id="e661a-290">送信キューにメッセージがあるということは、実際のネットワーク待機時間が増えることを意味します。</span><span class="sxs-lookup"><span data-stu-id="e661a-290">Every message in the send queue represents an increase in the effective network latency.</span></span>

<span data-ttu-id="e661a-291">XIM の上限 (現在は 3,500 件のメッセージ) に近い値は、ほとんどのゲームにとっては大きすぎ、`send_data_to_other_players` の呼び出し頻度と各データ ペイロードの大きさに応じて、データが送信されるまでに数秒の待機時間が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-291">A value close to XIM’s max limit (currently 3500 messages) is far too high for most games and likely represents several seconds of data waiting to be sent depending on the rate of calling `send_data_to_other_players` and how big each data payload is.</span></span> <span data-ttu-id="e661a-292">代わりに、ゲームの待機時間の要件と、ゲームでの `send_data_to_other_players` の呼び出しパターンの頻度を合わせて考慮して、適切な数値を選択してください。</span><span class="sxs-lookup"><span data-stu-id="e661a-292">Instead, choose a number that takes into account the game's latency requirements along with how jittery the game's `send_data_to_other_players` calling pattern is.</span></span>

## <a name="sharing-data-using-player-custom-properties"></a><span data-ttu-id="e661a-293">プレイヤーのカスタム プロパティを使ったデータの共有</span><span class="sxs-lookup"><span data-stu-id="e661a-293">Sharing data using player custom properties</span></span>

<span data-ttu-id="e661a-294">データの受信者や、データを受信すべきタイミング、システムがパケットの損失を処理する方法を大部分コントロールできるため、ほとんどのアプリにおいて、データ交換には `xim_player::xim_local::send_data_to_other_players()` メソッドが使用されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-294">Most app data exchanges happen with the `xim_player::xim_local::send_data_to_other_players()` method since it allows the most control over who receives data, when they should receive that data, and how the system should deal with packet loss.</span></span> <span data-ttu-id="e661a-295">ただし、プレイヤーにとっては、基本的でまれな変更ステータスを最小限の手間で他者と共有した方が好都合である場合があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-295">However there are times when it would be nice for players to share basic, rarely changing state about themselves with others with minimal fuss.</span></span> <span data-ttu-id="e661a-296">たとえば、すべてのプレイヤーがゲーム内の表現をレンダリングするために使用するマルチプレイヤーを入力する前に選択したキャラクター モデルを表す文字列は、各プレイヤーによって変更される場合があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-296">For example, each player might have a fixed string representing the character model selected before entering multiplayer that all players use to render their in-game representation.</span></span>

<span data-ttu-id="e661a-297">プレイヤーに関するデータがそれほど頻繁に変化しない場合、XIM はカスタム プロパティをプレイヤーに提供します。</span><span class="sxs-lookup"><span data-stu-id="e661a-297">For data that doesn't change very often about a player, XIM provides player custom properties.</span></span> <span data-ttu-id="e661a-298">これらのプロパティは、アプリ定義の名前と値で構成されています。この名前と値は、ローカル プレイヤーに適用でき、変更されると自動的にすべてのデバイスに伝達されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-298">These properties consist of an app-defined name and value, which are null-terminated string pairs that can be applied to the local player and that get automatically propagated to all devices whenever they are changed.</span></span>

<span data-ttu-id="e661a-299">カスタム プレイヤー プロパティの内部的な同期オーバーヘッドは `xim_player::xim_local::send_data_to_other_players()` メソッドより大きくなるため、すぐに変化するデータの場合 (プレーヤーの位置など)、直接送信を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-299">Custom player properties have more internal synchronization overhead than the `xim_player::xim_local::send_data_to_other_players()` method, so for rapidly changing data (i.e. player position), you should still use direct sends.</span></span>

<span data-ttu-id="e661a-300">プレイヤー カスタム プロパティのキー/値ペアの現在の値は、それらのデバイスが XIM ネットワークに参加し、追加したプレイヤーが表示されると、自動的に新しく追加したデバイスに適用されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-300">Player custom properties key-value pairs have their current values automatically provided to new participating devices when these devices join a XIM network and see the player added.</span></span> <span data-ttu-id="e661a-301">値は、名前と値の文字列を指定して `xim_player::xim_local::set_player_custom_property()` を呼び出すことで設定できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-301">Values can be set by calling `xim_player::xim_local::set_player_custom_property()` with name and value strings.</span></span> <span data-ttu-id="e661a-302">次の例では、"model" という名前のプロパティを設定し、変数 'localPlayer' によりポイントされているローカル `xim_player` オブジェクトに値 "brute" を設定します。</span><span class="sxs-lookup"><span data-stu-id="e661a-302">In the following example, we set a property named "model" to have the value "brute" on a local `xim_player` object pointed to by the variable 'localPlayer':</span></span>

```cpp
localPlayer->local()->set_player_custom_property(L"model", L"brute");
```

<span data-ttu-id="e661a-303">プレイヤーのプロパティを変更すると、`xim_player_custom_properties_changed_state_change` がすべてのデバイスに送信され、変更されているプロパティの名前に警告が通知されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-303">Changes to player properties will cause a `xim_player_custom_properties_changed_state_change` to be provided to all devices, alerting them to the names of properties that have changed.</span></span> <span data-ttu-id="e661a-304">指定された名前の値は、`xim_player::get_player_custom_property()` を使用して、ローカルまたはリモートで、どのプレイヤーも取得することができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-304">The value for a given name can be retrieved on any player, local or remote, with `xim_player::get_player_custom_property()`.</span></span> <span data-ttu-id="e661a-305">以下の例は、'ximPlayer' 変数で指定された `xim_player` から、"model" という名前のプロパティの値を取得しています。</span><span class="sxs-lookup"><span data-stu-id="e661a-305">The following example retrieves the value for a property named "model" from a `xim_player` pointed to by the variable 'ximPlayer':</span></span>

```cpp
PCWSTR modelName = ximPlayer->get_player_custom_property(L"model");
```

<span data-ttu-id="e661a-306">指定されたプロパティ名に新しい値を設定すると、既存の値が置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="e661a-306">Setting a new value for a given property name will replace any existing value.</span></span> <span data-ttu-id="e661a-307">プロパティ名を null 値の文字列ポインターの値の設定すると、空の値文字列と同様に処理されます。つまり、まだ指定されていないプロパティと同様です。</span><span class="sxs-lookup"><span data-stu-id="e661a-307">Setting a property name to a value of a null value string pointer is treated the same as an empty value string, which is the same as the property not having been specified yet.</span></span> <span data-ttu-id="e661a-308">名前および値は、XIM で解釈されないため、必要に応じて文字列の内容を検証するアプリに残されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-308">Names and values aren't interpreted by XIM, therefore it's left on the app to validate the string contents as needed.</span></span>

<span data-ttu-id="e661a-309">別の XIM ネットワークに移動すると、カスタム プレイヤー プロパティが必ずリセットされます。</span><span class="sxs-lookup"><span data-stu-id="e661a-309">Custom player properties are always reset when moving from one XIM network to another.</span></span> <span data-ttu-id="e661a-310">ただし、XIM ネットワークに参加した新しいプレイヤーは、いくつかが設定されているすべてのプレイヤーの最新のカスタム プレイヤー プロパティを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="e661a-310">However, new players that join the XIM network will receive current custom player properties for all players who have some set.</span></span>

## <a name="sharing-data-using-network-custom-properties"></a><span data-ttu-id="e661a-311">ネットワークのカスタム プロパティを使ったデータの共有</span><span class="sxs-lookup"><span data-stu-id="e661a-311">Sharing data using network custom properties</span></span>

<span data-ttu-id="e661a-312">ネットワーク カスタム プロパティは、頻繁に変わらない XIM ネットワークに固有のデータを簡単に同期できるように用意されています。</span><span class="sxs-lookup"><span data-stu-id="e661a-312">Network custom properties are intended as a convenience synchronizing data specific to the XIM network which doesn't change frequently.</span></span> <span data-ttu-id="e661a-313">ネットワーク カスタム プロパティは、`xim::set_network_custom_property()` を使用して XIM シングルトン オブジェクトで設定されている場合を除き、[プレイヤー カスタム プロパティ](#sharing-data-using-player-custom-properties)と同様に使用できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-313">Network custom properties work identically to [player custom properties](#sharing-data-using-player-custom-properties), except they're set on the XIM singleton object with `xim::set_network_custom_property()`.</span></span> <span data-ttu-id="e661a-314">以下の例では、値が "stronghold" になるように "map" プロパティを設定しています。</span><span class="sxs-lookup"><span data-stu-id="e661a-314">The following example sets a "map" property to have the value "stronghold":</span></span>

```cpp
xim::singleton_instance().set_network_custom_property(L"map", L"stronghold");
```

<span data-ttu-id="e661a-315">ネットワークのプロパティを変更すると、`xim_network_custom_properties_changed_state_change` がすべてのデバイスに送信され、変更されているプロパティの名前に警告が通知されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-315">Changes to network properties will cause a `xim_network_custom_properties_changed_state_change` to be provided to all devices, alerting them to the names of properties that have changed.</span></span> <span data-ttu-id="e661a-316">指定した名前の値は、以下の例で "map" というプロパティの値を取得しているように、`xim::get_network_custom_property()` を使用して取得できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-316">The value for a given name can be retrieved with `xim::get_network_custom_property()`, like in the following example that retrieves the value for a property named "map":</span></span>

```cpp
PCWSTR mapName = xim::singleton_instance().get_network_custom_property(L"map");
```

<span data-ttu-id="e661a-317">[プレイヤー カスタム プロパティ](#sharing-data-using-player-custom-properties)と同様、指定されたプロパティ名に新しい値を設定すると、既存の値が置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="e661a-317">Just like [player custom properties](#sharing-data-using-player-custom-properties), setting a new value for a given property name will replace any existing value.</span></span> <span data-ttu-id="e661a-318">プロパティ名を null 値の文字列ポインターの値の設定すると、空の値文字列と同様に処理されます。つまり、まだ指定されていないプロパティと同様です。</span><span class="sxs-lookup"><span data-stu-id="e661a-318">Setting a property name to a value of a null value string pointer is treated the same as an empty value string, which is the same as the property not having been specified yet.</span></span> <span data-ttu-id="e661a-319">名前および値は、XIM で解釈されないため、必要に応じて文字列の内容を検証するアプリに残されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-319">Names and values aren't interpreted by XIM, therefore it's left on the app to validate the string contents as needed.</span></span>

<span data-ttu-id="e661a-320">新しく作成された XIM ネットワークは常に、ネットワーク カスタム プロパティが設定されていない状態で開始されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-320">Newly created XIM networks always start with no network custom properties set.</span></span> <span data-ttu-id="e661a-321">ただし、既存の XIM ネットワークに参加する新しいプレイヤーは、その XIM ネットワークに設定されたネットワーク カスタム プロパティの最新の値を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="e661a-321">However, new players that join an existing XIM network will receive the current values of the network custom properties set for that XIM network.</span></span>

## <a name="matchmaking-using-per-player-skill"></a><span data-ttu-id="e661a-322">プレイヤーごとのスキルによるマッチメイキング</span><span class="sxs-lookup"><span data-stu-id="e661a-322">Matchmaking using per-player skill</span></span>

<span data-ttu-id="e661a-323">固有のアプリ指定のゲーム モードの共通の関心を使用したプレイヤーのマッチングは、優れた基本戦略です。</span><span class="sxs-lookup"><span data-stu-id="e661a-323">Matching players by common interest in a particular app-specified game mode is a good base strategy.</span></span> <span data-ttu-id="e661a-324">利用可能なプレイヤーのプールが大きくなるにつれて、ベテラン プレイヤーが、他のベテランと正当な対戦を楽しめるように、ゲームの個人スキル、または体験に基づいて、マッチプレイヤーを考慮する必要がありますが、新しいプレイヤーは、同様の能力の他者と対戦することで、レベルを上げることができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-324">As the pool of available players grows, you should consider also matching players based on their personal skill or experience with your game so that veteran players can enjoy the challenge of healthy competition with other veterans, while newer players can grow by competing against others with similar abilities.</span></span>

<span data-ttu-id="e661a-325">これを行うにはまず、マッチメイキングを使用して XIM ネットワークに移動し始める前に、`xim_player::xim_local::set_matchmaking_configuration()` の呼び出しで指定されるプレイヤーごとのマッチメイキング設定構造体で、すべてのローカル プレイヤーにスキル レベルを提供します。</span><span class="sxs-lookup"><span data-stu-id="e661a-325">To do this, start by providing the skill level for all local players in their per-player matchmaking configuration structure specified in calls to `xim_player::xim_local::set_matchmaking_configuration()` prior to starting a move to a XIM network using matchmaking.</span></span> <span data-ttu-id="e661a-326">スキル レベルはアプリ固有の概念であり、数が XIM で解釈されることはありません。例外として、マッチメイキングでまず同一のスキル値を持つプレイヤーを探してから、定期的に +/- 10 単位で検索対象の増減を行い、そのスキル範囲内でスキル値を宣言する他のプレイヤーを探すことができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-326">Skill level is an app-specific concept and the number is not interpreted by XIM, except that matchmaking will first try to find players with the same skill value, and then periodically widen its search in increments of +/- 10 to try to find other players declaring skill values within a range around that skill.</span></span> <span data-ttu-id="e661a-327">以下の例では、ローカルの `xim_player` オブジェクトを想定しています。このオブジェクトのポインターは 'localPlayer' であり、ローカルまたは Xbox Live のストレージから 'playerSkillValue' と呼ばれる変数に対して取得されたアプリ固有のスキル値 uint32_t が格納されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-327">The following example assumes that the local `xim_player` object, whose pointer is 'localPlayer', has an associated app-specific uint32_t skill value retrieved from local or Xbox Live storage into a variable called 'playerSkillValue':</span></span>

```cpp
 xim_player_matchmaking_configuration playerMatchmakingConfiguration = { 0 };
 playerMatchmakingConfiguration.skill = playerSkillValue;

 localPlayer->local()->set_matchmaking_configuration(&playerMatchmakingConfiguration);
```

<span data-ttu-id="e661a-328">これが完了すると、この `xim_player` によってプレイヤーごとのマッチメイキング設定が変更されたことを示す `xim_player_matchmaking_configuration_changed_state_change` が、すべての参加者に送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-328">When this completes, all participants will be provided a `xim_player_matchmaking_configuration_changed_state_change` indicating this `xim_player` has changed its per-player matchmaking configuration.</span></span> <span data-ttu-id="e661a-329">新しい値を取得するには、`xim_player::matchmaking_configuration()` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e661a-329">The new value can be retrieved by calling `xim_player::matchmaking_configuration()`.</span></span> <span data-ttu-id="e661a-330">すべてのプレイヤーに null 以外のマッチメイキング設定が適用されたら、`xim::move_to_network_using_matchmaking()` に渡された `xim_matchmaking_configuration` 構造体の `require_player_matchmaking_configuration` フィールドに true 値を指定してマッチメイキングを使用することで XIM に移動できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-330">When all players have non-null matchmaking configuration applied, you can move to a XIM network using matchmaking with a value of true for the `require_player_matchmaking_configuration` field of the `xim_matchmaking_configuration` structure passed into `xim::move_to_network_using_matchmaking()`.</span></span>

<span data-ttu-id="e661a-331">次の例では、no-teams free-for-all 用に合計 2 ～ 8 人のプレイヤーを探すマッチメイキング構成を事前設定します。</span><span class="sxs-lookup"><span data-stu-id="e661a-331">The following example populates a matchmaking configuration to find a total of 2-8 players for a no-teams free-for-all.</span></span> <span data-ttu-id="e661a-332">さらに、この例では、フィルターで除外するゲーム モードを表す、アプリによって定義された定数 (型は uint64_t、名前は MYGAMEMODE_DEATHMATCH) を使います。</span><span class="sxs-lookup"><span data-stu-id="e661a-332">Additionally, this example uses an app-defined constant, which is of type uint64_t and named MYGAMEMODE_DEATHMATCH, that represents the game-mode to filter off of.</span></span> <span data-ttu-id="e661a-333">XIM ネットワークのプレイヤーと、同じ値を指定しており、プレイヤーごとのマッチメイキング構成を必要とする他のプレイヤーをマッチングするようにマッチメイキングが構成されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-333">This configures matchmaking to match the players of the XIM network with other players specifying those same values, as well as requiring per-player matchmaking configuration.</span></span>

```cpp
xim_matchmaking_configuration matchmakingConfiguration = { 0 };
matchmakingConfiguration.team_matchmaking_mode = xim_team_matchmaking_mode::no_teams_8_players_minimum_2;
matchmakingConfiguration.custom_game_mode = MYGAMEMODE_DEATHMATCH;
matchmakingConfiguration.require_player_matchmaking_configuration = true;
```

<span data-ttu-id="e661a-334">この構造体が `xim::move_to_network_using_matchmaking()` に送信されると、移動するプレイヤーによって、null 以外の `xim_player_matchmaking_configuration` ポインターを使用して `xim_player::xim_local::set_matchmaking_configuration()` が呼び出されている限り、この移動操作は正常に開始されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-334">When this structure is provided to `xim::move_to_network_using_matchmaking()`, the move operation will start normally as long as players moving have called `xim_player::xim_local::set_matchmaking_configuration()` with a non-null `xim_player_matchmaking_configuration` pointer.</span></span> <span data-ttu-id="e661a-335">これが行われていないプレイヤーがいる場合、マッチメイキング処理は一時停止され、`xim_matchmaking_status::waiting_for_player_matchmaking_configuration` 値が指定された `xim_matchmaking_progress_updated_state_change` がすべての参加者に送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-335">If any player hasn't, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_matchmaking_configuration` value.</span></span> <span data-ttu-id="e661a-336">これには、マッチメイキングが完了する前に、事前に送信された招待または他のソーシャルな手段 (`xim::move_to_network_using_joinable_xbox_user_id` の呼び出しなど) で、XIM ネットワークに途中参加したプレイヤーも含まれます。</span><span class="sxs-lookup"><span data-stu-id="e661a-336">This includes players that subsequently join the XIM network through a previously sent invitation or through other social means (e.g., a call to `xim::move_to_network_using_joinable_xbox_user_id`) before matchmaking has completed.</span></span> <span data-ttu-id="e661a-337">すべてのプレイヤーが `xim_player_matchmaking_configuration` 構造体を送信した時点で、マッチメイキングが再開されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-337">Once all players have supplied their `xim_player_matchmaking_configuration` structures, matchmaking will resume.</span></span>

<span data-ttu-id="e661a-338">次のセクションで説明するように、プレイヤーごとのスキルを使うマッチメイキングを、プレイヤーごとのロールを使うマッチメイキングと組み合わせることもできます。</span><span class="sxs-lookup"><span data-stu-id="e661a-338">Matchmaking using per-player skill can also be combined with matchmaking user per-player role, as explained in the next section.</span></span> <span data-ttu-id="e661a-339">いずれかのみ指定する場合は、他のマッチメイキングに値 0 を指定できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-339">If only one is desired, you can specify a value of 0 for the other.</span></span> <span data-ttu-id="e661a-340">これは、スキル値 `xim_player_matchmaking_configuration` が 0 であると宣言するすべてのプレイヤーは必ず互いにマッチングされるためです。</span><span class="sxs-lookup"><span data-stu-id="e661a-340">This is because all players declaring they have a `xim_player_matchmaking_configuration` skill value of 0 will always match each other.</span></span>

<span data-ttu-id="e661a-341">`xim::move_to_network_using_matchmaking()` や、その他すべての XIM ネットワークの移動操作が完了すると、すべてのプレイヤーの `xim_player_matchmaking_configuration` 構造体は、自動的に null ポインターにクリアされます (付随して `xim_player_matchmaking_configuration_changed_state_change` 通知が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="e661a-341">Once the `xim::move_to_network_using_matchmaking()` or any other XIM network move operation has completed, all players' `xim_player_matchmaking_configuration` structures will automatically be cleared to a null pointer (with an accompanying `xim_player_matchmaking_configuration_changed_state_change` notification).</span></span> <span data-ttu-id="e661a-342">プレイヤーごとの設定が必要なマッチメイキングを使用して、別の XIM ネットワークに移動する場合、常に最新の情報を含む新しい構造体のポインターで、再度 `xim_player::xim_local::set_matchmaking_configuration()` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e661a-342">If you plan to move to another XIM network using matchmaking that requires per-player configuration, you'll need to call `xim_player::xim_local::set_matchmaking_configuration()` again with a new structure pointer containing the most up-to-date information.</span></span>

## <a name="matchmaking-using-per-player-role"></a><span data-ttu-id="e661a-343">プレイヤーごとのロールによるマッチメイキング</span><span class="sxs-lookup"><span data-stu-id="e661a-343">Matchmaking using per-player role</span></span>

<span data-ttu-id="e661a-344">プレイヤーごとのマッチメイキング設定を使用してユーザーのマッチメイキング エクスペリエンスを高める別の方法として、必要なプレイヤー ロールを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-344">Another method of using per-player matchmaking configuration to improve users' matchmaking experience is through the use of required player roles.</span></span> <span data-ttu-id="e661a-345">これは、さまざまな協力型プレイ スタイルを提案するキャラクター タイプを選択できるゲームに最も適しています。</span><span class="sxs-lookup"><span data-stu-id="e661a-345">This is best suited to games that provide selectable character types that encourage different cooperative play styles.</span></span> <span data-ttu-id="e661a-346">これらのキャラクター タイプは、ゲーム内のグラフィカル表現をただ変更するのではなく、代わりにプレイヤーのゲームプレイ スタイルを変更するものです。</span><span class="sxs-lookup"><span data-stu-id="e661a-346">These character types are ones which don't simply alter in-game graphical representation and, instead, alter the gameplay style for the player.</span></span> <span data-ttu-id="e661a-347">ユーザーは、専門分野としてプレイする場合があるということを意味します。</span><span class="sxs-lookup"><span data-stu-id="e661a-347">Users' may prefer to play as a particular specialization.</span></span> <span data-ttu-id="e661a-348">しかし、各ロールを満たす者が存在せずに、機能的に目的を完了させることができないようにゲームが設計されている場合は、任意のプレイヤーをまとめてマッチングさせるよりもそのようなプレイヤーをまとめてマッチングさせ、集まった時点でプレイヤー間でプレイ スタイルを検討する方が望ましい場合があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-348">However, if your game is designed such that it's functionally not possible to complete objectives without at least one person fulfilling each role, sometimes it's better to match such players together first than to match any players together then require them to negotiate play styles among themselves once gathered.</span></span> <span data-ttu-id="e661a-349">これを行うには、指定のプレイヤーの `xim_player_matchmaking_configuration` 構造体で指定される各ロールを表す一意のビット フラグを最初に定義します。</span><span class="sxs-lookup"><span data-stu-id="e661a-349">You can do this by first defining a unique bit flag representing each role to be specified in a given player's `xim_player_matchmaking_configuration` structure.</span></span>

<span data-ttu-id="e661a-350">以下の例では、ローカルの `xim_player` オブジェクトに対して、アプリ固有のロール値 (型は uint8_t、名前は MYROLEBITFLAG_HEALER) を設定します。このポインターは、'localPlayer' になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-350">The following example sets an app-specific role value, which is of type uint8_t and named MYROLEBITFLAG_HEALER, for the local `xim_player` object, whose pointer is 'localPlayer':</span></span>

```cpp

xim_player_matchmaking_configuration playerMatchmakingConfiguration = { 0 };
playerMatchmakingConfiguration.roles = MYROLEBITFLAG_HEALER;
localPlayer->local()->set_matchmaking_configuration(&playerMatchmakingConfiguration);

```

<span data-ttu-id="e661a-351">これが完了すると、この `xim_player` によってプレイヤーごとのマッチメイキング設定が変更されたことを示す `xim_player_matchmaking_configuration_changed_state_change` が、すべての参加者に送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-351">When this completes, all participants will be provided a `xim_player_matchmaking_configuration_changed_state_change` indicating this `xim_player` has changed its per-player matchmaking configuration.</span></span> <span data-ttu-id="e661a-352">新しい値を取得するには、`xim_player::matchmaking_configuration()` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e661a-352">The new value can be retrieved by calling `xim_player::matchmaking_configuration()`.</span></span>

<span data-ttu-id="e661a-353">`xim::move_to_network_using_matchmaking()` に指定されたグローバル構造体 `xim_matchmaking_configuration` には、ビットごとの OR を使用して結合されたすべての必要なロール フラグや、require_player_matchmaking_configuration フィールドに対する true 値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="e661a-353">The global `xim_matchmaking_configuration` structure specified to `xim::move_to_network_using_matchmaking()` should have all the required roles flags combined using bitwise-OR, and a value of true for the require_player_matchmaking_configuration field.</span></span>

<span data-ttu-id="e661a-354">次の例では、no-teams free-for-all 用に合計 3 人のプレイヤーを探すマッチメイキング構成を事前設定します。</span><span class="sxs-lookup"><span data-stu-id="e661a-354">The following example populates a matchmaking configuration that will find a total of 3 players for a no-teams free-for-all.</span></span> <span data-ttu-id="e661a-355">さらに、この例では、フィルターで除外するゲーム モードを表す、アプリによって定義された定数 (型は uint64_t、名前は MYGAMEMODE_COOPERATIVE) を使います。</span><span class="sxs-lookup"><span data-stu-id="e661a-355">Additionally, this example uses an app-defined constant, which is of type uint64_t and named MYGAMEMODE_COOPERATIVE, that represents the game-mode to filter off of.</span></span> <span data-ttu-id="e661a-356">さらに、プレイヤーごとのマッチメイキング構成を要求する構成がセットアップされます。この構成では、1 人以上のプレイヤーが各アプリ固有の uint8_t ロールを果たします。これらのロールにはまとめてビット単位で OR が適用されて構成に配置されます (MYROLEBITFLAG_HEALER、MYROLEBITFLAG_MELEE、MYROLEBITFLAG_RANGE)。</span><span class="sxs-lookup"><span data-stu-id="e661a-356">Also, the configuration is set up to require per-player matchmaking configuration where at least one player fulfills each app-specific uint8_t roles which were bitwise-OR'd together and placed in the configuration (MYROLEBITFLAG_HEALER, MYROLEBITFLAG_MELEE, and MYROLEBITFLAG_RANGE):</span></span>

```cpp
xim_matchmaking_configuration matchmakingConfiguration = { 0 };
matchmakingConfiguration.team_matchmaking_mode = xim_team_matchmaking_mode::no_teams_3_players_minimum_3;
matchmakingConfiguration.custom_game_mode = MYGAMEMODE_COOPERATIVE;
matchmakingConfiguration.required_roles = MYROLEBITFLAG_HEALER | MYROLEBITFLAG_MELEE | MYROLEBITFLAG_RANGE;
matchmakingConfiguration.require_player_matchmaking_configuration = true;
```

<span data-ttu-id="e661a-357">この構造体が `xim::move_to_network_using_matchmaking()` に送信されると、上記のように移動操作が開始されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-357">When this structure is provided to `xim::move_to_network_using_matchmaking()`, the move operation will start as described above.</span></span>

<span data-ttu-id="e661a-358">プレイヤーごとのロールを使うマッチメイキングを、プレイヤーごとのスキールを使うマッチメイキングと組み合わせることもできます。</span><span class="sxs-lookup"><span data-stu-id="e661a-358">Matchmaking using per-player role can also be combined with matchmaking user per-player skill.</span></span> <span data-ttu-id="e661a-359">いずれかのみ指定する場合は、他の構造体に値 0 を指定します。</span><span class="sxs-lookup"><span data-stu-id="e661a-359">If only one is desired, specify a value of 0 for the other.</span></span> <span data-ttu-id="e661a-360">これは、`xim_player_matchmaking_configuration` スキル値が 0 であると宣言しているすべてのプレイヤーが常に互いに一致するためであり、`xim_matchmaking_configuration` の required_roles フィールドのすべてのビットがゼロの場合は、一致させるためのロール ビットは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="e661a-360">This is because all players declaring they have a `xim_player_matchmaking_configuration` skill value of 0 will always match each other; and, if all bits are zero in the `xim_matchmaking_configuration` required_roles field, then no role bits are needed in order to match.</span></span>

<span data-ttu-id="e661a-361">`xim::move_to_network_using_matchmaking()` や、その他すべての XIM ネットワークの移動操作が完了すると、すべてのプレイヤーの `xim_player_matchmaking_configuration` 構造体は、自動的に null ポインターにクリアされます (付随して `xim_player_matchmaking_configuration_changed_state_change` 通知が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="e661a-361">Once the `xim::move_to_network_using_matchmaking()` or any other XIM network move operation has completed, all players' `xim_player_matchmaking_configuration` structures will automatically be cleared to a null pointer (with an accompanying `xim_player_matchmaking_configuration_changed_state_change` notification).</span></span> <span data-ttu-id="e661a-362">プレイヤーごとの設定が必要なマッチメイキングを使用して、別の XIM ネットワークに移動する場合、常に最新の情報を含む新しい構造体のポインターで、再度 `xim_player::xim_local::set_matchmaking_configuration()` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e661a-362">If you plan to move to another XIM network using matchmaking that requires per-player configuration, you'll need to call `xim_player::xim_local::set_matchmaking_configuration()` again with a new structure pointer containing the most up-to-date information.</span></span>

## <a name="how-xim-works-with-player-teams"></a><span data-ttu-id="e661a-363">XIM とプレイヤー チームの連携について</span><span class="sxs-lookup"><span data-stu-id="e661a-363">How XIM works with player teams</span></span>

<span data-ttu-id="e661a-364">マルチプレイヤーのゲームでは、プレイヤーを相手チームに組み込むことも必要になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-364">Multiplayer gaming often involves players organized onto opposing teams.</span></span> <span data-ttu-id="e661a-365">XIM では、指定の設定で 2 つ以上のチームを要求する `xim_team_matchmaking_mode` 値を使用してマッチメイキングを行う際にチームを割り当てやすくなります。</span><span class="sxs-lookup"><span data-stu-id="e661a-365">XIM makes it easy to assign teams when matchmaking by using a `xim_team_matchmaking_mode` value requesting two or more teams in the specified configuration.</span></span> <span data-ttu-id="e661a-366">以下の例では、2 チーム 4 人ずつ (4 人見つからない場合は 1 ～ 3 人でも許容可能) の合計 8 人のプレイヤーを探すように構成されたマッチメイキングを使用して移動を開始します。</span><span class="sxs-lookup"><span data-stu-id="e661a-366">The following example initiates a move using matchmaking configured to find a total of 8 players to place on two teams of 4 (although if 4 aren't found, 1-3 players are also acceptable).</span></span> <span data-ttu-id="e661a-367">さらに、この例では、フィルターで除外するゲーム モードを表す、アプリによって定義された定数 (型は uint64_t、名前は MYGAMEMODE_CAPTURETHEFLAG) を使います。</span><span class="sxs-lookup"><span data-stu-id="e661a-367">Additionally, this example uses an app-defined constant, which is of type uint64_t and named MYGAMEMODE_CAPTURETHEFLAG, that represents the game-mode to filter off of.</span></span>  <span data-ttu-id="e661a-368">さらに、ソーシャルな方法で参加したすべてのプレイヤーを現在の XIM ネットワークから移動するように構成がセットアップされます。</span><span class="sxs-lookup"><span data-stu-id="e661a-368">Also, the configuration is set up to bring along all socially-joined players from the current XIM network:</span></span>

```cpp
xim_matchmaking_configuration matchmakingConfiguration = { 0 };
matchmakingConfiguration.team_matchmaking_mode = two_teams_4v4_minimum_1_per_team;
matchmakingConfiguration.custom_game_mode = MYGAMEMODE_CAPTURETHEFLAG;

xim::singleton_instance().move_to_network_using_matchmaking(matchmakingConfiguration, xim_players_to_move::bring_existing_social_players);
```

<span data-ttu-id="e661a-369">このような XIM ネットワークの移動操作が完了すると、リクエストされたチーム数に対応して、プレイヤーに 1 から {n} のチーム インデックス値が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="e661a-369">When such a XIM network move operation completes, the players will be assigned a team index value 1 through {n} corresponding to the {n} teams requested.</span></span> <span data-ttu-id="e661a-370">特定のチーム インデックス値の本当の意味は、アプリごとに設定できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-370">The true meaning of any particular team index value is up to the app.</span></span> <span data-ttu-id="e661a-371">プレイヤーのチーム インデックスの値は、`xim_player::team_index()` を使用して取得されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-371">A player's team index value is retrieved via `xim_player::team_index()`.</span></span> <span data-ttu-id="e661a-372">2 つ以上のチームで `xim_team_matchmaking_mode` を使用している場合、`xim::move_to_network_using_matchmaking()` の呼び出しで、プレイヤーにチームインデックス値 0 が割り当てられることはありません。</span><span class="sxs-lookup"><span data-stu-id="e661a-372">When using a `xim_team_matchmaking_mode` with two or more teams, players will never be assigned a team index value of zero by the call to `xim::move_to_network_using_matchmaking()`.</span></span> <span data-ttu-id="e661a-373">これは、他の構成や種類の移動操作 (招待の承認によるプロトコルのアクティブ化など) で XIM ネットワークに追加されるプレイヤーと対照的です。これらのプレイヤーには、常にチーム インデックス値 0 が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="e661a-373">This is in contrast to players that are added to the XIM network with any other configuration or type of move operation (such as through a protocol activation resulting from accepting an invitation), who will always have a zero team index.</span></span> <span data-ttu-id="e661a-374">インデックス 0 のチームを特別な "未割り当て" チームとして扱うと便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-374">It may be helpful to treat team index 0 as a special "unassigned" team.</span></span>

<span data-ttu-id="e661a-375">以下の例では、ポインターが 'ximPlayer' 変数にある xim_player オブジェクトのチーム インデックスを取得します。</span><span class="sxs-lookup"><span data-stu-id="e661a-375">The following example retrieves the team index for a xim_player object whose pointer is in the 'ximPlayer' variable:</span></span>

```cpp
uint8_t playerTeamIndex = ximPlayer->team_index();
```

<span data-ttu-id="e661a-376">Xbox Live のマッチメイキング サービスでは、(プレイヤーによる否定的な行動の機会を制限するだけではなく) 望ましいユーザー エクスペリエンスを実現するために、一緒に XIM ネットワークに移動する複数のプレイヤーが別々のチームに分割されることはありません。</span><span class="sxs-lookup"><span data-stu-id="e661a-376">For the preferred user experience (not to mention reduced opportunity for negative player behavior), the Xbox Live matchmaking service will never split players who are moving to a XIM network together onto different teams.</span></span>

<span data-ttu-id="e661a-377">マッチメイキングによって最初に割り当てられているチームのインデックス値は単なる推奨値であり、アプリではいつでも `xim_player::xim_local::set_team_index()` を使用してローカル プレイヤーの値を変更できます。</span><span class="sxs-lookup"><span data-stu-id="e661a-377">The team index value assigned initially by matchmaking is only a recommendation and the app can change it for local players at any time using `xim_player::xim_local::set_team_index()`.</span></span> <span data-ttu-id="e661a-378">これは、マッチメイキングを一切使用していない XIM ネットワークで呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="e661a-378">This can also be called in XIM networks that don't use matchmaking at all.</span></span> <span data-ttu-id="e661a-379">以下の例では、新しいチーム インデックス値として 1 が設定されるように、プレイヤーのポインター 'localPlayer' を構成します。</span><span class="sxs-lookup"><span data-stu-id="e661a-379">The following example configures a player pointer 'localPlayer' to have a new team index value of one:</span></span>

```cpp
localPlayer->local()->set_team_index(1);
```

<span data-ttu-id="e661a-380">プレイヤーに新しいチーム インデックス値が設定された場合、すべてのデバイスは、プレイヤーの `xim_player_team_index_changed_state_change` を受信することで通知されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-380">All devices are informed that the player has a new team index value in effect when they're provided a `xim_player_team_index_changed_state_change` for that player.</span></span> <span data-ttu-id="e661a-381">`xim_player::xim_local::set_team_index()` は、いつでも呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-381">You can call `xim_player::xim_local::set_team_index()` at any time.</span></span>

<span data-ttu-id="e661a-382">マッチメイキングでは、チームとは別に各プレイヤーに必要なロールが評価されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-382">Matchmaking evaluates required per-player roles independently from teams.</span></span> <span data-ttu-id="e661a-383">チームはプレイヤーに割り当てられたロールではなくプレイヤーの数で調整されるため、マッチメイキング構成条件として、チームと必要なロールの両方を同時に使用することはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="e661a-383">Therefore it's not recommended to use both teams and required roles as simultaneous matchmaking configuration criteria because the teams will be balanced by player count, not by fulfilled player roles.</span></span>

## <a name="working-with-chat"></a><span data-ttu-id="e661a-384">チャットの操作</span><span class="sxs-lookup"><span data-stu-id="e661a-384">Working with chat</span></span>

<span data-ttu-id="e661a-385">XIM ネットワーク内のプレイヤー間の音声およびテキスト チャット通信は、自動的に有効になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-385">Voice and text chat communication are automatically enabled among players in a XIM network.</span></span> <span data-ttu-id="e661a-386">XIM は、すべての音声ヘッドセットとマイクのハードウェアとの通信を操作します。</span><span class="sxs-lookup"><span data-stu-id="e661a-386">XIM handles interacting with all voice headset and microphone hardware for you.</span></span> <span data-ttu-id="e661a-387">チャットを使用するために必要な設定はアプリにありませんが、テキスト チャットに関する要件が 1 つあります。入力および表示をサポートしていることです。</span><span class="sxs-lookup"><span data-stu-id="e661a-387">Your app doesn't need to do much for chat, but it does have one requirement regarding text chat: supporting input and display.</span></span> <span data-ttu-id="e661a-388">テキスト入力が必須なのは、従来、物理キーボードを広範的に使用していないプラットフォームやゲーム ジャンルでも、プレイヤーはこのシステムで、音声合成の支援技術を使用する場合があるためです。</span><span class="sxs-lookup"><span data-stu-id="e661a-388">Text input is required because, even on platforms or game genres that historically haven't had widespread physical keyboard use, players may configure the system to use text-to-speech assistive technologies.</span></span> <span data-ttu-id="e661a-389">同様に、プレイヤーは音声からテキストの変換を使用できるようにこのシステムを設定する場合があるため、テキスト表示にも対応している必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-389">Similarly, text display is required because players may configure the system to use speech-to-text.</span></span>

<span data-ttu-id="e661a-390">`xim_player::xim_local::chat_text_to_speech_conversion_preference_enabled()` および `xim_player::xim_local::chat_speech_to_text_conversion_preference_enabled()` を呼び出すと、ローカル プレーヤーがこれらの設定を検出できます。必要に応じて、テキストのメカニズムを有効にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="e661a-390">These preferences can be detected on local players by calling `xim_player::xim_local::chat_text_to_speech_conversion_preference_enabled()` and `xim_player::xim_local::chat_speech_to_text_conversion_preference_enabled()`, and you may wish to conditionally enable text mechanisms.</span></span> <span data-ttu-id="e661a-391">ただし、テキスト入力および表示オプションを常に有効にすることを検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e661a-391">However, we recommend that you consider making text input and display options that are always available.</span></span>

 `Windows::Xbox::UI::Accessability` <span data-ttu-id="e661a-392">は、テキストから音声の変換支援技術を搭載したゲーム内のテキストチャットを単純にレンダリングできるように特別に設計された Xbox One のクラスです。</span><span class="sxs-lookup"><span data-stu-id="e661a-392">is an Xbox One class specifically designed to provide simple rendering of in-game text chat with a focus on speech-to-text assistive technologies.</span></span>

<span data-ttu-id="e661a-393">現実のキーボードまたは仮想キーボードで入力されたテキストを取得したら、その文字列を `xim_player::xim_local::send_chat_text()` メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="e661a-393">Once you have text input provided by a real or virtual keyboard, pass the string to the `xim_player::xim_local::send_chat_text()` method.</span></span> <span data-ttu-id="e661a-394">以下のコードは、'localPlayer' 変数によって指定されたローカルの `xim_player` オブジェクトからハード コードされたサンプル文字列の送信を示します。</span><span class="sxs-lookup"><span data-stu-id="e661a-394">The following code shows sending an example hard-coded string from a local `xim_player` object pointed to by the variable 'localPlayer':</span></span>

```cpp
localPlayer->local()->send_chat_text(L"Example chat text");
```

<span data-ttu-id="e661a-395">このチャット テキストは、発信元のローカル プレイヤーからチャット通信を受信できる、XIM ネットワーク内のすべてのプレイヤーに送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-395">This chat text is delivered to all players in the XIM network that can receive chat communication from the originating local player.</span></span> <span data-ttu-id="e661a-396">また、音声に合成され、`xim_chat_text_received_state_change` として送信されることもあります。</span><span class="sxs-lookup"><span data-stu-id="e661a-396">It might be synthesized to speech audio and it might be provided as a `xim_chat_text_received_state_change`.</span></span>

<span data-ttu-id="e661a-397">アプリは、受け取ったテキスト文字列のコピーを作成し、発信元プレイヤーの ID の一部と共に、適切な長さの時間 (またはスクロール可能なウインドウで) 表示する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-397">Your app should make a copy of any text string received and display it along with some identification of the originating player for an appropriate amount of time (or in a scrollable window).</span></span>

<span data-ttu-id="e661a-398">チャットに関するベスト プラクティスは他にもいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="e661a-398">There are also some best practices regarding chat.</span></span> <span data-ttu-id="e661a-399">特にスコアボードなどのゲーマータグのリストにプレイヤーの位置を表示するだけでなく、ユーザーへのフィードバックとして、ミュート済み/発声中のアイコンを併せて表示することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e661a-399">It's recommended that anywhere players are shown, particularly in a list of gamertags such as a scoreboard, that you also display muted/speaking icons as feedback for the user.</span></span> <span data-ttu-id="e661a-400">これを行うには、`xim_player::chat_indicator()` を呼び出し、プレイヤーのチャットの現在の瞬間的なステータスを表す `xim_player_chat_indicator` を取得します。</span><span class="sxs-lookup"><span data-stu-id="e661a-400">This is done by calling `xim_player::chat_indicator()` to retrieve a `xim_player_chat_indicator` representing the current, instantaneous status of chat for that player.</span></span> <span data-ttu-id="e661a-401">次の例では、特定のアイコンの定数値を決めて 'iconToShow' 変数に割り当てるために、'ximPlayer' 変数で指定した `xim_player` オブジェクトのインジケーター値の取得を示します。</span><span class="sxs-lookup"><span data-stu-id="e661a-401">The following example demonstrates retrieving the indicator value for a `xim_player` object pointed to by the variable 'ximPlayer' to determine a particular icon constant value to assign to an 'iconToShow' variable:</span></span>

```cpp
switch (ximPlayer->chat_indicator())
{
   case xim_player_chat_indicator::silent:
   {
       iconToShow = Icon_InactiveSpeaker;
       break;
   }

   case xim_player_chat_indicator::talking:
   {
       iconToShow = Icon_ActiveSpeaker;
       break;
   }

   case xim_player_chat_indicator::muted:
   {
       iconToShow = Icon_MutedSpeaker;
       break;
   }
   ...
}
```

<span data-ttu-id="e661a-402">`xim_player::chat_indicator()` によって報告される値は、プレイヤーの発声開始から終了までを頻繁に変更することを想定しています。</span><span class="sxs-lookup"><span data-stu-id="e661a-402">The value reported by `xim_player::chat_indicator()` is expected to change frequently as players start and stop talking, for example.</span></span> <span data-ttu-id="e661a-403">そのため、すべての UI フレームをポーリングできるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="e661a-403">It is designed to support apps polling it every UI frame as a result.</span></span>

> [!NOTE]
> デバイス設定のためにローカル ユーザーが十分な通信権限を持っていない場合、`xim_player::chat_indicator()` は `xim_player_chat_indicator::platform_restricted` を返します。 プラットフォームに期待される要件は、音声チャットやメッセージのプラットフォーム制限を示すアイコンや問題をユーザーに示すメッセージをアプリに表示することです。 推奨されるメッセージの例は、"申し訳ございません。現在チャットは許可されていません" です。

## <a name="muting-players"></a><span data-ttu-id="e661a-407">プレイヤーを消音する</span><span class="sxs-lookup"><span data-stu-id="e661a-407">Muting players</span></span>

<span data-ttu-id="e661a-408">もう 1 つのベスト プラクティスは、プレイヤーのミュートをサポートすることです。</span><span class="sxs-lookup"><span data-stu-id="e661a-408">Another best practice is to support muting players.</span></span> <span data-ttu-id="e661a-409">XIM では、ユーザーはプレイヤー カードを使用してシステムを自動的にミュートできますが、`xim_player::set_chat_muted()` メソッドを経由してゲーム UI 内で実行されるゲーム固有の一時的なミュートをアプリでもサポートしている必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-409">XIM automatically handles system muting initiated by users through player cards, but apps should support game-specific transient muting that can be performed within the game UI via the `xim_player::set_chat_muted()` method.</span></span> <span data-ttu-id="e661a-410">以下の例では、'remotePlayer 変数でリモートの `xim_player` オブジェクトを指定し、ミュートを開始します。これにより、ボイス チャットが聞こえず、テキスト チャットを受け取らない状態になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-410">The following example begins muting a remote `xim_player` object pointed to by the variable 'remotePlayer' so that no voice chat is heard and no text chat is received from it:</span></span>

```cpp
remotePlayer->set_chat_muted(true);
```

<span data-ttu-id="e661a-411">ミュートは、すぐに適用され、`xim_state_change` とは関連付けられません。</span><span class="sxs-lookup"><span data-stu-id="e661a-411">The muting takes effect immediately and there is no `xim_state_change` associated with it.</span></span> <span data-ttu-id="e661a-412">取り消すには、false 値を指定して `xim_player::set_chat_muted()` を再度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e661a-412">It can be undone by calling `xim_player::set_chat_muted()` again with the false value.</span></span> <span data-ttu-id="e661a-413">以下の例では、'remotePlayer' 変数によって指定されているリモートの `xim_player` オブジェクトのミュートを解除します。</span><span class="sxs-lookup"><span data-stu-id="e661a-413">The following example unmutes a remote `xim_player` object pointed to by the variable 'remotePlayer':</span></span>

```cpp
remotePlayer->set_chat_muted(false);
```

<span data-ttu-id="e661a-414">そのプレイヤーで新しい XIM ネットワークに移動する場合など、`xim_player` が存在している限り、ミュート設定は引き続き有効です。</span><span class="sxs-lookup"><span data-stu-id="e661a-414">Mutes remain in effect for as long as the `xim_player` exists, including when moving to a new XIM network with the player.</span></span> <span data-ttu-id="e661a-415">プレイヤーが退出し、同じユーザーが (新しい `xim_player` インスタンスとして) 再参加する場合は、保持されません。</span><span class="sxs-lookup"><span data-stu-id="e661a-415">It is not persisted if the player leaves and the same user rejoins (as a new `xim_player` instance).</span></span>

<span data-ttu-id="e661a-416">プレイヤーは、通常、ミュートを解除した状態で開始します。</span><span class="sxs-lookup"><span data-stu-id="e661a-416">Players typically start in the unmuted state.</span></span> <span data-ttu-id="e661a-417">ゲームプレイ上の理由から、ミュートした状態でプレイヤーを開始する場合は、該当する `xim_player_joined_state_change` の処理を終了する前に、`xim_player` オブジェクトの `xim_player::set_chat_muted()` を呼び出します。これにより、XIM では、無期限にプレイヤーから音声オーディオが聞こえなくなります。</span><span class="sxs-lookup"><span data-stu-id="e661a-417">If your app wants to start a player in the muted state for gameplay reasons, it can call `xim_player::set_chat_muted()` on the `xim_player` object before finishing processing the associated `xim_player_joined_state_change`, and XIM will guarantee there will be no period of time where voice audio from the player can be heard.</span></span>

<span data-ttu-id="e661a-418">リモート プレーヤーが XIM ネットワークに参加すると、プレイヤーの評判に基づいて、自動ミュート チェックが行われます。</span><span class="sxs-lookup"><span data-stu-id="e661a-418">An automatic mute check based on player reputation occurs when a remote player joins the XIM network.</span></span> <span data-ttu-id="e661a-419">プレイヤーに不適切な評判のフラグがある場合、プレイヤーは自動的にミュートされます。</span><span class="sxs-lookup"><span data-stu-id="e661a-419">If the player has a bad reputation flag, the player is automatically muted.</span></span> <span data-ttu-id="e661a-420">ミュートは、ローカル状態にのみ影響を及ぼすため、プレイヤーがネットワーク間を移動する場合は変更されません。</span><span class="sxs-lookup"><span data-stu-id="e661a-420">Muting only affects local state and therefore persists if a player moves across networks.</span></span> <span data-ttu-id="e661a-421">評判ベースの自動ミュート チェックは 1 度のみ行われ、`xim_player` が有効である限り、再評価されることはありません。</span><span class="sxs-lookup"><span data-stu-id="e661a-421">The automatic reputation-based mute check is performed once and not re-evaluated again for as long as the `xim_player` remains valid.</span></span>

## <a name="configuring-chat-targets-using-player-teams"></a><span data-ttu-id="e661a-422">プレイヤーのチームを使ったチャット ターゲットの構成</span><span class="sxs-lookup"><span data-stu-id="e661a-422">Configuring chat targets using player teams</span></span>

<span data-ttu-id="e661a-423">このドキュメントの「[XIM とプレイヤー チームの連携について](#how-xim-works-with-player-teams)」で説明したように、特定のチーム インデックス値の本当の意味はアプリ次第です。</span><span class="sxs-lookup"><span data-stu-id="e661a-423">As stated in the [How XIM works with player teams](#how-xim-works-with-player-teams) section of this document, the true meaning of any particular team index value is up to the app.</span></span> <span data-ttu-id="e661a-424">チャット ターゲット構成の同等比較に使用する場合を除き、XIM によるチーム インデックス値の解釈は行われません。</span><span class="sxs-lookup"><span data-stu-id="e661a-424">XIM doesn't interpret them except for equality comparisons with respect to chat target configuration.</span></span> <span data-ttu-id="e661a-425">`xim::chat_targets()` で報告されたチャット ターゲット構成が現在 `xim_chat_targets::same_team_index_only` であれば、プレイヤーが相手とチャット通信を行うのは、`xim_player::team_index()` で報告された同一値が両者に設定されている (加えて、プライバシー/ポリシーで許可される) 場合のみです。</span><span class="sxs-lookup"><span data-stu-id="e661a-425">If the chat target configuration reported by `xim::chat_targets()` is currently `xim_chat_targets::same_team_index_only`, then any given player will only exchange chat communication with another if the two have the same value reported by `xim_player::team_index()` (and privacy/ policy also permit it).</span></span>

<span data-ttu-id="e661a-426">競争力のあるシナリオを堅実にサポートするために、新しく作成された XIM ネットワークは既定値が `xim_chat_targets::same_team_index_only` になるように自動的に構成されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-426">To be conservative and support competitive scenarios, newly created XIM networks are automatically configured to default to `xim_chat_targets::same_team_index_only`.</span></span> <span data-ttu-id="e661a-427">ただし、対戦後の "ロビー" などで、負けた相手チームとのチャットが望まれることもあります。</span><span class="sxs-lookup"><span data-stu-id="e661a-427">However, chatting with vanquished opponents on the other team may be desirable, for example, in a post-game "lobby".</span></span> <span data-ttu-id="e661a-428">(プライバシーやポリシーで許可されていれば) すべてのユーザーがほかのすべてのユーザーと対話できるように XIM を設定するには、`xim::set_chat_targets()` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e661a-428">You can instruct XIM to allow everyone to talk to everyone else (where privacy and policy permit) by calling `xim::set_chat_targets()`.</span></span> <span data-ttu-id="e661a-429">以下のサンプルでは、`xim_chat_targets::all_players` 値が使用されるように、XIM ネットワーク内のすべての参加者を設定します。</span><span class="sxs-lookup"><span data-stu-id="e661a-429">The following sample begins configuring all participants in the XIM network to use a `xim_chat_targets::all_players` value:</span></span>

```cpp
xim::singleton_instance().set_chat_targets(xim_chat_targets::all_players);
```

<span data-ttu-id="e661a-430">新しいターゲット設定が有効になった場合、すべての参加者は、`xim_chat_targets_changed_state_change` を受信することで通知されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-430">All participants are informed that a new target setting is in effect when they're provided a `xim_chat_targets_changed_state_change`.</span></span>

<span data-ttu-id="e661a-431">前述のように、XIM ネットワークのほとんどの移動タイプで、最初はインデックス値 0 がすべてのプレイヤーに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="e661a-431">As noted earlier, most XIM network move types will initially assign all players the team index value of zero.</span></span> <span data-ttu-id="e661a-432">これは、既定では `xim_chat_targets::same_team_index_only` の設定を `xim_chat_targets::all_players` と区別できない可能性が高いことを意味します。</span><span class="sxs-lookup"><span data-stu-id="e661a-432">This means a configuration of `xim_chat_targets::same_team_index_only` is likely indistinguishable from `xim_chat_targets::all_players` by default.</span></span> <span data-ttu-id="e661a-433">ただし、マッチメイキング構成の `xim_team_matchmaking_mode` 値で 2 つ以上のチームが宣言されている場合、マッチメイキングを使用して XIM ネットワークに移動するプレイヤーには異なるチーム インデックス値が設定されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-433">However, players that move to a XIM network using matchmaking will have differing team index values if the matchmaking configuration's `xim_team_matchmaking_mode` value declared two or more teams.</span></span> <span data-ttu-id="e661a-434">また、`xim_player::xim_local::set_team_index()` は、上記のようにいつでも呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-434">You can also call `xim_player::xim_local::set_team_index()` at any time as shown above.</span></span> <span data-ttu-id="e661a-435">アプリでこれらのメソッドのいずれかを使用して、0 以外のチーム インデックス値を使用している場合は、必ずチャットのターゲット設定を適切に管理してください。</span><span class="sxs-lookup"><span data-stu-id="e661a-435">If your app is using non-zero team index values through either of these methods, don't forget to manage the current chat targets setting appropriately.</span></span>

## <a name="automatic-background-filling-of-player-slots-backfill-matchmaking"></a><span data-ttu-id="e661a-436">プレイヤー スロットの自動バックグラウンド設定 ("バックフィル" マッチメイキング)</span><span class="sxs-lookup"><span data-stu-id="e661a-436">Automatic background filling of player slots ("backfill" matchmaking)</span></span>

<span data-ttu-id="e661a-437">異なるプレイヤー グループが同時に `xim::move_to_network_using_matchmaking()` を呼び出すことで、Xbox Live マッチメイキング サービスで新しく最適な XIM ネットワークをすばやく構成するための柔軟性が最大になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-437">Disparate groups of players calling `xim::move_to_network_using_matchmaking()` at the same time gives the Xbox Live matchmaking service the greatest flexibility to organize them into new, optimal XIM networks quickly.</span></span> <span data-ttu-id="e661a-438">ただし、ゲームプレイ シナリオによっては、特定の XIM ネットワークが変更されない状態で維持する必要があり、追加プレイヤーのマッチメイキングが行われるのは空いているプレイヤー スロットを満たす場合のみというケースもあります。</span><span class="sxs-lookup"><span data-stu-id="e661a-438">However, some gameplay scenarios would like to keep a particular XIM network intact, and only matchmake additional players just to fill vacant player slots.</span></span> <span data-ttu-id="e661a-439">XIM では、`xim::set_backfill_matchmaking_configuration()` メソッドを使用して自動バックグラウンド設定モードで動作するマッチメイキングの構成 ("バックフィリング") もサポートされます。</span><span class="sxs-lookup"><span data-stu-id="e661a-439">XIM supports configuring matchmaking to operate in an automatic background filling mode, or "backfilling", by using the `xim::set_backfill_matchmaking_configuration()` method.</span></span>

<span data-ttu-id="e661a-440">次の例では、マッチメイキング構成を事前設定し、バックフィル マッチメイキングを構成することにより、no-teams free-for-all 用に合計 8 人のプレイヤーを探します (8 人見つからない場合は、2 ～ 7 人でも許容)。</span><span class="sxs-lookup"><span data-stu-id="e661a-440">The following example populates a matchmaking configuration and configures backfill matchmaking to try to find a total of 8 players for a no-teams free-for-all (although if 8 aren't found, 2-7 players are also acceptable).</span></span> <span data-ttu-id="e661a-441">さらに、この例では、フィルターで除外するゲーム モードを表す、アプリによって定義された定数 (型は uint64_t、名前は MYGAMEMODE_DEATHMATCH) を使います。</span><span class="sxs-lookup"><span data-stu-id="e661a-441">Additionally, this example uses an app-defined constant, which is of type uint64_t and named MYGAMEMODE_DEATHMATCH, that represents the game-mode to filter off of:</span></span>

```cpp
 xim_matchmaking_configuration matchmakingConfiguration = { 0 };
 matchmakingConfiguration.team_matchmaking_mode = xim_team_matchmaking_mode::no_teams_8_players_minimum_2;
 matchmakingConfiguration.custom_game_mode = MYGAMEMODE_DEATHMATCH;

 xim::singleton_instance().set_backfill_matchmaking_configuration(&matchmakingConfiguration);
```

<span data-ttu-id="e661a-442">これにより、通常の方法で `xim::move_to_network_using_matchmaking()` を呼び出すデバイスが既存の XIM ネットワークを利用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="e661a-442">This makes the existing XIM network available to devices calling `xim::move_to_network_using_matchmaking()` in the normal manner.</span></span> <span data-ttu-id="e661a-443">これらのデバイスでは、動作の変更がありません。</span><span class="sxs-lookup"><span data-stu-id="e661a-443">Those devices see no behavior change.</span></span> <span data-ttu-id="e661a-444">バックフィリング中の XIM ネットワークにいる参加者は移動できませんが、これらの参加者には、バックフィルが有効になったことを表す <`xim_backfill_matchmaking_configuration_changed_state_change` や複数の `xim_matchmaking_progress_updated_state_change` 通知 (該当する場合) が送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-444">The participants in the backfilling XIM network will not move, but will be provided a `xim_backfill_matchmaking_configuration_changed_state_change` signifying backfill turning on, as well as multiple `xim_matchmaking_progress_updated_state_change` notifications when applicable.</span></span> <span data-ttu-id="e661a-445">マッチメイキングで見つかったプレイヤーは、通常の `xim_player_joined_state_change` を使用して XIM ネットワークに追加されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-445">Any matchmade player will be added to the XIM network using the normal `xim_player_joined_state_change`.</span></span>

<span data-ttu-id="e661a-446">既定では、バックフィル マッチメイキングは無期限に有効になります (XIM ネットワークで既に最大プレイヤー数が `xim_team_matchmaking_mode` 値で指定されている場合はプレイヤーが追加されることはありません)。</span><span class="sxs-lookup"><span data-stu-id="e661a-446">By default, backfill matchmaking remains enabled indefinitely, although it won't try to add players if the XIM network already has the maximum number of players specified by the `xim_team_matchmaking_mode` value.</span></span> <span data-ttu-id="e661a-447">バックフィルは、null ポインターで `xim::set_backfill_matchmaking_configuration()` を呼び出して無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="e661a-447">Backfilling can be disabled by calling `xim::set_backfill_matchmaking_configuration()` with a null pointer:</span></span>

```cpp
 xim::singleton_instance().set_backfill_matchmaking_configuration(nullptr);
```

<span data-ttu-id="e661a-448">対応する `xim_backfill_matchmaking_configuration_changed_state_change` がすべてのデバイスに送信され、この非同期処理が完了すると、マッチメイキングされたプレイヤーがこれ以上 XIM ネットワークに追加されないことを表す `xim_matchmaking_status::none` で最終的な `xim_matchmaking_progress_updated_state_change` が送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-448">A corresponding `xim_backfill_matchmaking_configuration_changed_state_change` will be provided to all devices, and once this asynchronous process has completed, a final `xim_matchmaking_progress_updated_state_change` will be provided with `xim_matchmaking_status::none` to signify that no further matchmade players will be added to the XIM network.</span></span>

<span data-ttu-id="e661a-449">2 つ以上のチームを宣言する `xim_team_matchmaking_mode` を使用してバックフィル マッチメイキングを有効にする場合、既存のすべてのプレイヤーに有効なチームインデックス値 (1 ～チーム数) が必要になります。</span><span class="sxs-lookup"><span data-stu-id="e661a-449">When enabling backfill matchmaking with a `xim_team_matchmaking_mode` value that declares two or more teams, all existing players must have a valid team index that is between 1 and the number of teams.</span></span> <span data-ttu-id="e661a-450">これには、`xim_player::xim_local::set_team_index()` を呼び出してカスタム値を指定したプレイヤーや、招待または他のソーシャルな手段 (例: `xim::move_to_network_using_joinable_xbox_user_id` の呼び出し) によって参加して既定のインデックス値 0 が追加されたプレイヤーも含まれます。</span><span class="sxs-lookup"><span data-stu-id="e661a-450">This includes players who have called `xim_player::xim_local::set_team_index()` to specify a custom value or who have joined using an invitation or through other social means (e.g., a call to `xim::move_to_network_using_joinable_xbox_user_id`) and have been added with a default team index value of 0.</span></span> <span data-ttu-id="e661a-451">有効なチームインデックス値を持つプレイヤーがいない場合、マッチメイキング処理は保留され、`xim_matchmaking_status::waiting_for_player_team_index` 値が指定された `xim_matchmaking_progress_updated_state_change` がすべての参加者に送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-451">If any player doesn't have a valid team index, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_team_index` value.</span></span> <span data-ttu-id="e661a-452">すべてのプレイヤーについて、`xim_player::xim_local::set_team_index()` でチーム インデックス値が指定または修正されると、バックフィル マッチメイキングが再開されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-452">Once all players have supplied or corrected their team index values with `xim_player::xim_local::set_team_index()`, backfill matchmaking will resume.</span></span> <span data-ttu-id="e661a-453">詳しくは、このドキュメントの「[XIM とプレイヤー チームの連携について](#how-xim-works-with-player-teams)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="e661a-453">More information can be found in the [How XIM works with player teams](#how-xim-works-with-player-teams) section of this document.</span></span>

<span data-ttu-id="e661a-454">同様に、require_player_matchmaking_configuration フィールドでロールまたはスキルが true に設定されている `xim_matchmaking_configuration` 構造体を使用してバックフィル マッチメイキングを有効にする場合、すべてのプレイヤーについて、プレイヤーごとのマッチメイキング構成が null 以外に指定されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="e661a-454">Similarly, when enabling backfill matchmaking with a `xim_matchmaking_configuration` structure with the require_player_matchmaking_configuration field set to true for roles or skill, then all players must have specified a non-null per-player matchmaking configuration.</span></span> <span data-ttu-id="e661a-455">これが行われていないプレイヤーがいる場合、マッチメイキング処理は一時停止され、`xim_matchmaking_status::waiting_for_player_matchmaking_configuration` 値が指定された `xim_matchmaking_progress_updated_state_change` がすべての参加者に送信されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-455">If any player hasn't, then the matchmaking process will be paused and all participants will be provided a `xim_matchmaking_progress_updated_state_change` with a `xim_matchmaking_status::waiting_for_player_matchmaking_configuration` value.</span></span> <span data-ttu-id="e661a-456">すべてのプレイヤーが `xim_player_matchmaking_configuration` 構造体を送信した時点で、バックフィル マッチメイキングが再開されます。</span><span class="sxs-lookup"><span data-stu-id="e661a-456">Once all players have supplied their `xim_player_matchmaking_configuration` structures, backfill matchmaking will resume.</span></span> <span data-ttu-id="e661a-457">詳しくは、このドキュメントの「[プレイヤーごとのスキルまたはロールによるマッチメイキング](#matchmaking-using-per-player-skill)」と「[プレイヤーごとのロールによるマッチメイキング](#matchmaking-using-per-player-role)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="e661a-457">More information can be found in the [Matchmaking using per-player skill](#matchmaking-using-per-player-skill) and [Matchmaking using per-player role](#matchmaking-using-per-player-role) sections of this document.</span></span>
