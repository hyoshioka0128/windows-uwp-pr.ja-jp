---
title: 接続ストレージのベスト プラクティス
author: aablackm
description: 接続ストレージによってパフォーマンスとエクスペリエンスを最大限に高める方法に関する推奨事項
ms.author: aablackm
ms.date: 02/27/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: xbox live, xbox, ゲーム, uwp, windows 10, xbox one, 接続ストレージ
ms.localizationpriority: medium
ms.openlocfilehash: 936b0333e826d3f9047a6905e7374e1ce9ec47ca
ms.sourcegitcommit: d10fb9eb5f75f2d10e1c543a177402b50fe4019e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/12/2018
ms.locfileid: "4567494"
---
# <a name="connected-storage-best-practices"></a><span data-ttu-id="62e1a-104">接続ストレージのベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="62e1a-104">Connected Storage best practices</span></span>

<span data-ttu-id="62e1a-105">デベロッパーは、単一のセーブ データを書き込むのではなく、セーブ データを、単独で更新可能な論理グループに分割する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-105">Developers should divide save data into logical groupings which are independently updateable rather than writing monolithic saves.</span></span> <span data-ttu-id="62e1a-106">そうすることで、タイトルでさまざまな状況において書き込むデータの量を削減し、ローカル リソースの消費とアップロードでの帯域幅使用の両方を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-106">This allows titles to reduce the amount of data they write in various situations, reducing both local resource consumption and upload bandwidth usage.</span></span> <span data-ttu-id="62e1a-107">この API を使用して、タイトルで、完全に成功するか、または (セーブ中に致命的なエラーが発生した場合などに) まったく効力を生じないことが保証されるアトミック操作で複数のデータ アイテムを更新することもできます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-107">The API also allows titles to update more than one data item in an atomic operation which is guaranteed to succeed entirely or not take effect at all (for instance in the case of catastrophic failure mid-save).</span></span>

<span data-ttu-id="62e1a-108">Xbox One では、ユーザーがタイトルをすばやく切り替えることができるため、デベロッパーは、事実上常に発生する可能性のある一時停止イベントの受け取りを見越して、すぐに現在の状態を保存できるようにタイトルを設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-108">Because Xbox One allows users to quickly switch among titles, developers should design their title to keep their current state ready to save on short notice in anticipation of receiving a Suspend event, which can happen virtually at any time.</span></span> <span data-ttu-id="62e1a-109">接続ストレージ API では、短い一時停止期間中のタイトルの書き込み速度を最大限に高めるために、タイトル用に予約されていない部分の RAM を保存の最初のポイントとして使用します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-109">The Connected Storage API uses RAM outside of the title reservation as the first point of storage in order to maximize title write speed during the short suspend time window.</span></span> <span data-ttu-id="62e1a-110">その後、システムはデータを永続的なストレージに保持して、ストレージと最後のアップロード以降のその他のデータ書き込みを照合し、データのアップロードをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="62e1a-110">The system then persists the data to durable storage, reconciles it with any other data writes since the last upload, and schedules data uploads.</span></span> <span data-ttu-id="62e1a-111">格納され、キューに入れられてアップロードされると、システムは、ネットワーク接続の損失や電源障害などのさまざまな障害に対して堅牢になります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-111">Once stored and queued for upload, the system is robust to various failures such as network connectivity loss or power failure.</span></span>

## <a name="when-to-load-a-users-connected-storage-space-data"></a><span data-ttu-id="62e1a-112">ユーザーの接続ストレージ領域データを読み込むタイミング</span><span class="sxs-lookup"><span data-stu-id="62e1a-112">When to load a user's Connected Storage space data</span></span>

<span data-ttu-id="62e1a-113">ユーザーの接続ストレージ データ領域を読み込むための実行時間は変動する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-113">The execution time for loading a user's Connected Storage data space can vary.</span></span> <span data-ttu-id="62e1a-114">アプリでは、ユーザーがサインアウトを開始したことに対する応答、またはシステムから一時停止通知を受け取ったことに対する応答としてではなく、メインの実行中にこの処理を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-114">Apps should take this action during main execution, rather than in response to a user's starting to sign out or in response to receiving a suspend notification from the system.</span></span>
<span data-ttu-id="62e1a-115">セーブ機能が必要でないことが明らかなモードにゲームがなっていない限り、通常は、ユーザーがサインインし、プレイする意思を示した時点でアプリは接続ストレージ領域を読み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-115">Generally, apps should load a Connected Storage space as a user signs in and indicates desire to play, unless the game is in a mode in which it's certain no save functionality is needed.</span></span> <span data-ttu-id="62e1a-116">接続ストレージ領域の読み込みを、長い一連のデータ読み込みに合わせることで、並列処理を可能にすることも検討してください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-116">You should also consider aligning the loading of a Connected Storage space with long sequences of data loading, so that the operations can execute in parallel.</span></span>
<span data-ttu-id="62e1a-117">アプリでは、ユーザーの接続ストレージ領域データを読み込んだら、将来のセーブで使用するためにこの値を保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-117">Once your app has loaded a user's Connected Storage space data, it should retain this value for future saves.</span></span> <span data-ttu-id="62e1a-118">接続ストレージ領域を長時間保持しても、パフォーマンスや堅牢性への悪影響はありません。</span><span class="sxs-lookup"><span data-stu-id="62e1a-118">Retaining a Connected Storage space over time does not have negative effects on performance or robustness.</span></span> <span data-ttu-id="62e1a-119">システムがオンラインの場合、接続ストレージ領域の読み込み時にクラウドとの同期チェックが行われるため、ネットワークが低速または信頼性が低いときにユーザーの接続ストレージ領域を解放および再読み込みすると、システムがタイムアウトするまで、ユーザーに同期 UI が表示される場合があります。クラウドの同期を実行させるために接続ストレージ領域を明示的に解放する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="62e1a-119">Because loading a Connected Storage space causes a synchronization check with the cloud if the system is online, releasing and re-loading a user's Connected Storage space during slow or unreliable network conditions might cause the user to see a synchronization UI until the system times out. Connected Storage spaces do not need to be freed explicitly to cause cloud synchronization.</span></span> <span data-ttu-id="62e1a-120">`SubmitUpdatesAsync` 呼び出しで指定された完了ハンドラーから `AsyncStatus::Completed` が返されると、アプリが `ConnectedStorageSpace` オブジェクトを解放するかどうかにかかわらず、システムがクラウドとの同期を処理します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-120">Once the completion handler specified in a `SubmitUpdatesAsync` call has returned with `AsyncStatus::Completed`, the system takes care of synchronization with the cloud whether or not the app frees the `ConnectedStorageSpace` object.</span></span>

## <a name="when-to-save"></a><span data-ttu-id="62e1a-121">セーブするタイミング</span><span class="sxs-lookup"><span data-stu-id="62e1a-121">When to save</span></span>

<span data-ttu-id="62e1a-122">アプリで一時停止通知を受け取るたびに、アプリでは少なくとも、関連データをセーブして、システムがコンテキストに応じてユーザーの適切な状態に戻れるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-122">Whenever an app receives a suspend notification, the app should at least save relevant data, enabling the system to return to a contextually appropriate state for the user.</span></span>

<span data-ttu-id="62e1a-123">定期的な、自動的な、またはユーザーが開始するセーブをゲームの設計で使用している場合、一時停止通知を受け取ったとき以外にも接続ストレージを呼び出すことができます。これは、停電やクラッシュなどでデータが失われるリスクを低減できるため推奨されます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-123">If your game design uses periodic, automatic, or user-initiated saves, Connected Storage can be called more often than when receiving a suspend notification; doing so is a good way to reduce the risk of data loss due to power loss or a crash.</span></span>
<span data-ttu-id="62e1a-124">XDK を使ってゲームを開発している場合、ユーザーがサインアウトした場合でも、そのユーザーの User オブジェクトは有効なままであり、その時点でアプリは接続ストレージを使用して最終的なセーブ操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-124">If you're developing your game with the XDK, when a user signs out, the User object for that user remains valid, and at that time the app may perform final save operations by using Connected Storage.</span></span>

## <a name="robustness"></a><span data-ttu-id="62e1a-125">信頼性</span><span class="sxs-lookup"><span data-stu-id="62e1a-125">Robustness</span></span>

<span data-ttu-id="62e1a-126">セーブ データは常にクラウドに同期されるため、アプリのクラッシュの原因になるバグがセーブ データやアプリのコードに含まれると、そのバグがクラウドにバックアップされ、複数のデバイスに波及する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-126">Because saved data is always synchronized to the cloud, a bug in saved data and app code that causes the app to crash could be backed up in the cloud and distributed across devices.</span></span> <span data-ttu-id="62e1a-127">起動のたびにクラッシュするアプリがユーザーの手に渡らないようにするために、以下が保証されるようアプリを設計してください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-127">To prevent users from having an app that crashes on every launch, design the app to ensure that:</span></span>

-   <span data-ttu-id="62e1a-128">セーブ データの一部の形式が正しくない場合でも、ユーザーはアプリ内のあるポイントまで到達して、セーブ状態を管理することができます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-128">Users can reach a point in the app at which they can manage saved state, even if some saved data is malformed.</span></span>
-   <span data-ttu-id="62e1a-129">アプリは破損したデータを自動的に処理して、できるだけ多くのデータを復元し、他のデータはすべて安全な状態に再初期化することができます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-129">The app can handle corrupt data automatically, recovering as much data as it can and reinitializing everything else to a safe state.</span></span>

## <a name="use-cases-for-save-game-designs"></a><span data-ttu-id="62e1a-130">ゲーム セーブ設計の使用事例</span><span class="sxs-lookup"><span data-stu-id="62e1a-130">Use cases for save-game designs</span></span>

<span data-ttu-id="62e1a-131">接続ストレージ領域内のコンテナーを最大限に活用するゲーム セーブ システムの設計は、アプリのタイプによって異なります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-131">The design of a game saving system that makes the best use of containers in Connected Storage space depends on the type of app:</span></span>

### <a name="single-save"></a><span data-ttu-id="62e1a-132">単一のセーブ</span><span class="sxs-lookup"><span data-stu-id="62e1a-132">Single save</span></span>

<span data-ttu-id="62e1a-133">単一のキャンペーン スタイルのセーブ システムを使用するアプリ (一人称視点のシューティング ゲームなど) の場合:</span><span class="sxs-lookup"><span data-stu-id="62e1a-133">For apps that use a single, campaign-style save system, like a first person shooter:</span></span>

-   <span data-ttu-id="62e1a-134">すべてのデータを単一のコンテナーに格納し、常に、名前で識別される同じコンテナーに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-134">Put all of the data into a single container and always write to the same container, identified by name.</span></span>
-   <span data-ttu-id="62e1a-135">ユーザーが、これまでの進行状況を保持せずにアプリを最初からプレイすることを希望した場合のために、ユーザーのすべてのセーブ データをクリアするための、全データをリセットするオプションを公開することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-135">Consider exposing an option to reset all data that will clear all of a user's saved data, in case he or she wants to start playing the app from the beginning, with no previous progress being retained.</span></span>

### <a name="multiple-saves"></a><span data-ttu-id="62e1a-136">複数のセーブ</span><span class="sxs-lookup"><span data-stu-id="62e1a-136">Multiple saves</span></span>

<span data-ttu-id="62e1a-137">一定数のセーブ スロット (たとえば、5 つ) があるアプリの場合は、コンテナーを使用してゲーム データをセーブするための方法が 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-137">For apps that have a fixed number of save slots, let's say five, there are two ways to use containers to save game data:</span></span>

-   <span data-ttu-id="62e1a-138">セーブ スロットごとに 1 つの BLOB を使用して、名前が固定された 1 つのコンテナー内に 5 つのスロットすべてを格納します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-138">Store all 5 slots within one fixed-name container by using 1 blob for each save slot.</span></span> <span data-ttu-id="62e1a-139">この方法を使うと、5 つスロットすべてが完全に同期され、利用可能になります。または、何らかの時点で同期が失敗した場合、どのスロットも同期されず、以前の状態のままになります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-139">Using this method all 5 slots will be fully synchronized and available, or, in the case that synchronization fails at any point, none of the slots will be synchronized and will remain in their previous state.</span></span> <span data-ttu-id="62e1a-140">ユーザーが 2 台の異なる本体でアプリをオフラインでプレイし、進行状況を 1 台目の本体のスロット 1 と 2 台目の本体のスロット 2 にセーブした場合、ユーザーは、両方の本体を Xbox Live に接続したときにどちらのデータを保持するかを選択する必要があります。コンテナーの結合ロジックで競合が発生するためです。</span><span class="sxs-lookup"><span data-stu-id="62e1a-140">If a user plays the app offline on two different consoles, saving progress in slot 1 on the first console and in slot 2 on the second console, the user must choose which data to retain on connecting both consoles to Xbox Live; the merge logic for containers will produce a conflict.</span></span>
-   <span data-ttu-id="62e1a-141">各スロットをそれぞれ独自の名前を持つコンテナーに格納します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-141">Store each slot in a container with its own name.</span></span> <span data-ttu-id="62e1a-142">これにより、オフラインになる可能性のある複数のマシン上でも、独立した進行状況が各スロットに保持されます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-142">This allows independent progress in each slot, even on multiple machines that might be offline.</span></span> <span data-ttu-id="62e1a-143">ただし、ユーザーが同期を途中でキャンセルした場合、そのセッション中は一部のスロットしか使用できなくなる場合があります。一部のコンテナーでダウンロードが完了していない可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="62e1a-143">However, if a user cancels partway through a synchronization, it's possible that only some of the slots will be available during that session; some of the containers might not have completed downloading.</span></span> <span data-ttu-id="62e1a-144">そのような場合、ユーザーには、同期が完了しなかったことと、クラウド データの一部がローカルの本体に存在しないことが通知されます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-144">In such a case, the user is notified that the synchronization was incomplete, and that some of the cloud data isn't on the local console.</span></span>

<span data-ttu-id="62e1a-145">どちらの方法を使用する場合でも、アプリでは、個々のセーブ データをスロットから削除するための UI をユーザーに提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-145">Whichever approach is used, the app should provide the user with UI to delete individual saves from slots.</span></span>

### <a name="warning"></a><span data-ttu-id="62e1a-146">警告</span><span class="sxs-lookup"><span data-stu-id="62e1a-146">Warning</span></span>

**<span data-ttu-id="62e1a-147">依存関係のあるデータをコンテナーをまたいで格納しないでください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-147">Do not store dependent data across containers.</span></span>** <span data-ttu-id="62e1a-148">依存関係のあるデータを複数のコンテナーをまたいで格納しないでください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-148">Do not store data with dependencies across more than one container.</span></span> <span data-ttu-id="62e1a-149">不完全な同期、停電、またはその他のエラー状況によって、コンテナーが分離される場合があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-149">Containers can be separated due to incomplete synchronization, power loss, or other error conditions.</span></span> <span data-ttu-id="62e1a-150">1 つのコンテナーに格納されるデータは、そのコンテナー内で自足し、一貫している必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-150">Data stored in a single container must be self-sufficient and self-consistent.</span></span>

### <a name="tips"></a><span data-ttu-id="62e1a-151">ヒント</span><span class="sxs-lookup"><span data-stu-id="62e1a-151">Tips</span></span>

**<span data-ttu-id="62e1a-152">ユーザーが本体の電源を切ったり、アプリを離れたりすることを妨げないでください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-152">Do not discourage users from turning off the console or navigating away.</span></span>** <span data-ttu-id="62e1a-153">タイトルでは、セーブ時にユーザーが本体の電源を切ったり、アプリを離れたりすることを妨げないでください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-153">Your title should not discourage users from turning off the console or navigating away from your app when saving.</span></span> <span data-ttu-id="62e1a-154">Xbox 360 では、タイトルでセーブが実行されているときにユーザーがシステムの電源を切ると、ユーザーのデータはセーブされません。</span><span class="sxs-lookup"><span data-stu-id="62e1a-154">On Xbox 360, if a user turns off the system while your title is saving, the user's data is not saved.</span></span> <span data-ttu-id="62e1a-155">Xbox One では、タイトルは一時停止イベントを受信し、接続ストレージ API を使用して状態をセーブする時間が 1 秒あります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-155">On Xbox One, your title receives a suspend event and has 1 second to use the Connected Storage API to save state.</span></span> <span data-ttu-id="62e1a-156">システムが完全にシャットダウンするか低電力状態になる前に、データがハード ドライブに適切にコミットされることがシステムで保証されています。</span><span class="sxs-lookup"><span data-stu-id="62e1a-156">The system ensures that data is properly committed to the hard drive before it shuts down completely or enters its low-power state.</span></span> <span data-ttu-id="62e1a-157">ユーザーが別のタイトルをプレイするためにタイトルのディスクを取り出した場合も、同じ一時停止プロセスが実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-157">The same suspension process occurs if the user ejects your title's disc to play another one.</span></span>

**<span data-ttu-id="62e1a-158">接続ストレージ領域を保持します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-158">Retain Connected Storage spaces.</span></span>** <span data-ttu-id="62e1a-159">ConnectedStorageSpace オブジェクトを、読み取りまたは書き込みイベントが発生するたびに読み込むのではなく、保持するようにします。</span><span class="sxs-lookup"><span data-stu-id="62e1a-159">Retain ConnectedStorageSpace objects rather than try to load them every time a read or write event occurs.</span></span> <span data-ttu-id="62e1a-160">ConnectedStorageSpace オブジェクトを長期間保持することによってパフォーマンスや堅牢性に悪影響が出ることはありません。</span><span class="sxs-lookup"><span data-stu-id="62e1a-160">There are no negative effects on performance or robustness caused by retaining a ConnectedStorageSpace object for an extended time.</span></span>

**<span data-ttu-id="62e1a-161">データ サイズを小さくします。</span><span class="sxs-lookup"><span data-stu-id="62e1a-161">Keep data sizes small.</span></span>** <span data-ttu-id="62e1a-162">セーブ データのサイズを小さくします。</span><span class="sxs-lookup"><span data-stu-id="62e1a-162">Keep the size of saved data small.</span></span> <span data-ttu-id="62e1a-163">本体がオンラインのときに、接続ストレージ内のすべてのユーザー データがクラウドにアップロードされます。</span><span class="sxs-lookup"><span data-stu-id="62e1a-163">All user data in Connected Storage is uploaded to the cloud when the console is online.</span></span> <span data-ttu-id="62e1a-164">データ形式を最適化して、遅延と帯域幅の使用量が最小限に抑えられるようにしてください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-164">Optimize your data formats to ensure minimal delays and bandwidth usage.</span></span>

**<span data-ttu-id="62e1a-165">ユーザーがセーブを必要としていないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-165">Verify that users don't mind not saving.</span></span>** <span data-ttu-id="62e1a-166">GetForUserAsync および SubmitUpdatesAsync から OutOfLocalStorage エラーが返されていないかどうかをチェックし、ユーザーに質問して、本当にセーブせずにプレイするかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-166">Check for OutOfLocalStorage errors returned from GetForUserAsync and SubmitUpdatesAsync, and query users to see if they really want to play without saving.</span></span> <span data-ttu-id="62e1a-167">ユーザーがゲームをセーブすることを希望する場合は、操作を再試行します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-167">If a user indicates wanting to save games, retry the operation.</span></span>

**<span data-ttu-id="62e1a-168">ユーザーのクォータをチェックし、領域をクリアするよう要求します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-168">Check the user's quota and prompt to clear space.</span></span>** <span data-ttu-id="62e1a-169">SubmitUpdatesAsync によって QuotaExceeded エラーが返されていないかチェックします。</span><span class="sxs-lookup"><span data-stu-id="62e1a-169">Check for a QuotaExceeded error returned by SubmitUpdatesAsync.</span></span> <span data-ttu-id="62e1a-170">アプリでこのメッセージを受け取った場合は、領域をいくらか空けるまで新しいデータをセーブできないことをユーザーに通知し、そのための UI を表示します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-170">If your app receives this message, notify users that they cannot save any more data until they have freed up some space and present them with UI that enables them to do so.</span></span> <span data-ttu-id="62e1a-171">各ユーザーにはアプリあたり 256 MB または 64 MB のデータ領域が割り当てられ、各 XDK タイトルにはマシンあたり 64 MB のストレージが割り当てられます (本体に対してローカル)。</span><span class="sxs-lookup"><span data-stu-id="62e1a-171">Each user gets 256 or 64 MB of data per app, and each XDK title gets 64 MB of per-machine storage that is local to the console.</span></span>

**<span data-ttu-id="62e1a-172">後で復元できるようにメニューの状態を保存します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-172">Save the state of menus for restoration later.</span></span>** <span data-ttu-id="62e1a-173">コアのゲーム データに加えて、メニューの状態およびその他のアプリ設定を保存します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-173">Save menu state and other app settings in addition to saving core game data.</span></span> <span data-ttu-id="62e1a-174">ユーザーが別のアプリをプレイしてから元のアプリに戻ってきた場合、コンテキストに応じて適切なメニュー状態を復元します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-174">If the user plays another app and then comes back to yours, restore them to a contextually appropriate menu state.</span></span>
<span data-ttu-id="62e1a-175">サインインしているユーザーの変化に対応します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-175">Respond to signed-in user changes.</span></span> <span data-ttu-id="62e1a-176">アプリが一時停止されている間にユーザーがサインアウトする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-176">Users can sign out while your app is suspended.</span></span> <span data-ttu-id="62e1a-177">アプリが再開されるとき、サインインしていた一連のユーザーが変わっていないかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-177">When the app is resumed, it should determine if the set of signed-in users has changed.</span></span> <span data-ttu-id="62e1a-178">変わっている場合にメニューなどのアプリ内の適切な位置に移動することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-178">Consider navigating to an appropriate location within the app, such as a menu, when this occurs.</span></span>

**<span data-ttu-id="62e1a-179">セーブ データを管理するための UI を提供します。</span><span class="sxs-lookup"><span data-stu-id="62e1a-179">Provide UI for managing saved data.</span></span>** <span data-ttu-id="62e1a-180">アプリでは、ユーザーがアプリ内でセーブ データを管理できる UI を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-180">Your app should provide UI that allows users to manage their saved data within the app.</span></span> <span data-ttu-id="62e1a-181">自動セーブ システムを備えたアプリの場合は、ユーザーが既定のプレイ状態にリセットできるように、セーブ データをリセットするオプションを提供してください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-181">For apps with an automatic save system, the app should offer an option to reset saved data to enable users to reset to a default play state.</span></span>

**<span data-ttu-id="62e1a-182">セーブ データを管理するための UI にユーザーが常にアクセスできるようにします。</span><span class="sxs-lookup"><span data-stu-id="62e1a-182">Ensure that users can always reach UI to manage saved games.</span></span>** <span data-ttu-id="62e1a-183">アプリでは、バグのあるセーブ データが存在する場合でも、セーブ データの管理 UI にユーザーが常にアクセスできるようにしてください。</span><span class="sxs-lookup"><span data-stu-id="62e1a-183">Ensure that your app can always reach its management UI for saved games, even in the presence of buggy saved data.</span></span> <span data-ttu-id="62e1a-184">アプリのバグまたはデータの破損によってユーザーのセーブ データが読み取り不可能になった場合に、アプリでは、クラッシュが発生しない状態、またはプレイが阻止されない状態にまで、ユーザーが回復できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e1a-184">If a user's saved data becomes unreadable due to an app bug or data corruption, the app should allow users to recover to a state that doesn't crash or prevent them from playing.</span></span>