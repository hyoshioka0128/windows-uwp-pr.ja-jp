---
title: "接続ストレージ"
author: KevinAsgari
description: "接続ストレージを使ってデバイス間でゲーム データの保存と読み込みを行う方法について説明します。"
ms.assetid: a0bacf59-120a-4ffc-85e1-fbeec5db1308
ms.author: kevinasg
ms.date: 04-04-2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: "xbox live, xbox, ゲーム, uwp, windows 10, xbox one, 接続ストレージ"
ms.openlocfilehash: 847030bdaaeba59e9a0091152bea37351892ebb9
ms.sourcegitcommit: 2b436dc5e5681b8884e0531ee303f851a3e3ccf2
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/18/2017
---
# <a name="connected-storage"></a><span data-ttu-id="7abb5-104">接続ストレージ</span><span class="sxs-lookup"><span data-stu-id="7abb5-104">Connected Storage</span></span>

| <span data-ttu-id="7abb5-105">注</span><span class="sxs-lookup"><span data-stu-id="7abb5-105">Note</span></span>                                                                                |
|--------------------------------------------------------------------------------------------------|
| <span data-ttu-id="7abb5-106">このドキュメントはもともと、Xbox One デベロッパー向けに書かれたものです。</span><span class="sxs-lookup"><span data-stu-id="7abb5-106">This document was originally written for Xbox One developers.</span></span>  <span data-ttu-id="7abb5-107">Windows 上の UWP の場合、ローカルおよびタイトル ストレージなど、一部の Xbox One 固有の内容は無視することができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-107">Some of the Xbox One specific content like Local and Title storage can be ignored for UWP on Windows.</span></span>  <span data-ttu-id="7abb5-108">このドキュメントに記載した概念的な内容や API は依然として関係があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-108">The conceptual content and API in this document are still relevant.</span></span>  <span data-ttu-id="7abb5-109">ご質問がある場合は、担当の DAM にお問い合わせください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-109">Please contact your DAM with any questions.</span></span> |


<span data-ttu-id="7abb5-110">Xbox One のストレージ モデルとセーブ モデルは、Xbox 360 のモデルとは大きく異なります。Xbox One には、高速アプリケーション切り替え、複数の同時アプリケーション、およびアプリの迅速な一時停止と再開をサポートする、より柔軟なアプリケーション モデルが備わっています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-110">The storage and save models on Xbox One are much different from those on Xbox 360; Xbox One has a more flexible application model that supports fast application switching, multiple simultaneous applications, and quick suspend and resume of apps.</span></span> <span data-ttu-id="7abb5-111">接続ストレージ API を使用して格納されたデータは、ユーザー用に複数の Xbox One 本体に自動的にローミングされ、オフラインでも使用できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-111">Data stored by using the Connected Storage API automatically roams for users across multiple Xbox One consoles, and is also available for use offline.</span></span>

<span data-ttu-id="7abb5-112">このトピックでは、次の内容について説明します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-112">This topic covers:</span></span>

-   <span data-ttu-id="7abb5-113">Xbox One で接続ストレージ API を使用してゲームのセーブ データおよびアプリ データを格納する方法。</span><span class="sxs-lookup"><span data-stu-id="7abb5-113">Using the Connected Storage API to store saved games and app data on Xbox One.</span></span>
-   <span data-ttu-id="7abb5-114">Xbox One のアプリケーション モデルによって提供されるユーザー エクスペリエンスのメリットと適合するようにアプリのセーブ システムを設計するためのベスト プラクティス。</span><span class="sxs-lookup"><span data-stu-id="7abb5-114">Best practices for the design of app save systems, so that they integrate well with the user experience benefits provided by the Xbox One application model.</span></span>
-   <span data-ttu-id="7abb5-115">接続ストレージ システムが、アプリがセーブ データを保存できる速度を最大化するしくみ。</span><span class="sxs-lookup"><span data-stu-id="7abb5-115">How the connected storage system maximizes the speed with which your app can save data</span></span>
-   <span data-ttu-id="7abb5-116">アプリの UI を必要とすることなく、システムが複数の本体からのデータの同期および競合を処理するしくみ。</span><span class="sxs-lookup"><span data-stu-id="7abb5-116">How the system handles data synchronization and data conflicts from multiple consoles without requiring app UI.</span></span>
-   <span data-ttu-id="7abb5-117">接続ストレージの復元モデル。このモデルは、ネットワーク接続の中断または停電が発生した場合でも、アプリでは、個々のコンテナーに格納されたデータの一貫性が常に確保されるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-117">The Connected Storage resiliency model, which is designed so that the app always has a self-consistent view of data stored in individual containers even in the case of interrupted network connectivity or power loss.</span></span>

| <span data-ttu-id="7abb5-118">注</span><span class="sxs-lookup"><span data-stu-id="7abb5-118">Note</span></span>                                                                                |
|--------------------------------------------------------------------------------------------------|
| <span data-ttu-id="7abb5-119">ここで使用する "*アプリ*" という用語は、ゲームを含めた、本体上で実行されるあらゆるアプリケーションを指します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-119">The term *app*, as used here, refers to any application running on the console, including games.</span></span> |

## <a name="overview"></a><span data-ttu-id="7abb5-120">概要</span><span class="sxs-lookup"><span data-stu-id="7abb5-120">Overview</span></span>

<span data-ttu-id="7abb5-121">Xbox One のアプリケーション モデルでは、ユーザーは複数のアプリケーションを同時に使用できます。これは、本体の電源をオフにする、または別のアプリケーションに切り替える前に、データがセーブされるのを待機するようユーザーに要求することはできないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-121">The Xbox One application model allows users to use multiple apps at once, which means your app can't ask a user to wait for data to be saved before turning off the console or moving on to another app.</span></span> <span data-ttu-id="7abb5-122">Xbox One ユーザーは、そのデータを複数の本体に自動的にローミングさせ、どの Xbox One 本体も自身の Xbox One 本体のように使用することができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-122">Xbox One users will also enjoy having their data roam automatically across consoles so that every Xbox One console feels like their own console.</span></span> <span data-ttu-id="7abb5-123">Xbox One プラットフォームでは、アプリケーションでこれらの要件を満たすことができるようにする接続ストレージ API が用意されています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-123">The Xbox One platform provides the Connected Storage API to help your app satisfy these requirements.</span></span>

<span data-ttu-id="7abb5-124">接続ストレージ システムにより、アプリはデータを 1 つ以上の *BLOB* として*コンテナー*に格納できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-124">The connected storage system allows apps to store data as one or more *blobs* in *containers*.</span></span> <span data-ttu-id="7abb5-125">アプリでデータがセーブされると、データはすぐに排他的パーティションから共有パーティションにコピーされるため、データをディスクに格納し、Xbox Live タイトル ストレージにアップロードするタスクをアプリの有効期間外に処理できるようになります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-125">When an app saves data, it is quickly copied from the exclusive partition into the shared partition so that the tasks of storing the data on disk and uploading it to Xbox Live Title Storage can be handled outside the lifetime of your app.</span></span>

<span data-ttu-id="7abb5-126">アプリが接続ストレージ システムから特定のユーザーのデータを要求すると、システムは自動的にクラウドに更新されたデータがあるかどうかをチェックし、データのダウンロードを待機する必要がある場合はユーザーに通知します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-126">When your app requests a specific user's data from the connected storage system, the system automatically checks with the cloud for updated data and notifies users if they need to wait for data to download.</span></span> <span data-ttu-id="7abb5-127">また、システムは、場合によっては (ユーザーが複数の本体でオフラインでプレイした場合や、別の本体でそのユーザーのセーブ データがアップロードされている場合など)、競合するデータから選択するようユーザーに要求します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-127">The system also asks users to choose between conflicting data in some cases, such as when a user has played off-line on more than one console, or when another console is uploading saved data for that user.</span></span>

<span data-ttu-id="7abb5-128">アプリでは、すべてのユーザーに専用の、ただし限られた容量のクラウド ストレージ領域が用意されるため、ユーザーは、別のアプリのセーブ用に領域を確保するために、あるアプリのデータを完全に削除するという難しい選択をせずに済みます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-128">Your app also has a dedicated, but limited, amount of cloud storage space for every user, so users will not have to make hard choices about permanently deleting data from one app to make space for another app's saves.</span></span> <span data-ttu-id="7abb5-129">ただし、セーブをローカルにキャッシュするための Xbox One ハード ドライブ上のストレージ領域の量は限定されているため、システムには、ローカル キャッシュ領域を解放するためのユーザー エクスペリエンスが用意されています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-129">There is, however, a limited amount of storage space on the Xbox One hard drive for caching saves locally, so the system provides a user experience for freeing up local cache space.</span></span> <span data-ttu-id="7abb5-130">何がローカルにキャッシュされるかはユーザーが制御します。オフラインでプレイしているときにユーザーが必要なデータにアクセスできなくなることはありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-130">Users are in control of what is cached locally; they never lose access to data they care about when they're playing offline.</span></span> <span data-ttu-id="7abb5-131">接続ストレージ システムでは、アプリ用に、ユーザーに依存しない少量のデータをローカルに格納することもできます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-131">The connected storage system also allows a small amount of user-independent data to be stored locally for the app.</span></span> <span data-ttu-id="7abb5-132">このマシンごとのデータはローミングされず、クラウドにアップロードされません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-132">This per-machine data does not roam and is not uploaded to the cloud.</span></span>

<span data-ttu-id="7abb5-133">Xbox One の接続ストレージ システムではシステムの電源管理が行われ、保留中のハード ディスクへの書き込みおよびクラウドへのアップロードは自動的に処理されるため、タイトルで "セーブが進行中です。本体の電源を切らないでください" のような UI を表示する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-133">The Xbox One connected storage system takes care of system power management so that pending writes to the hard disk and uploads to the cloud are handled automatically—there is no need for titles to display UI to say "save in progress, please do not turn off your console."</span></span>

<span data-ttu-id="7abb5-134">最後に、Xbox One では、すべてのセーブ データの管理はアプリの責任です。Xbox 360 にあるような一元化されたセーブ管理 UI はありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-134">Finally, your app is responsible for managing all saved data on Xbox One; there is no centralized save management UI, as there is on Xbox 360.</span></span> <span data-ttu-id="7abb5-135">アプリでは、アプリが専用のストレージ領域を使い果たした場合などに、ユーザーがアプリ内からセーブ データを削除してストレージ領域を空けることができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-135">Your app must enable users to delete saved data from within the app to free storage space when, for example, the app runs out of dedicated storage space.</span></span>


### <a name="the-xbox-one-app-model-and-app-navigation"></a><span data-ttu-id="7abb5-136">Xbox One のアプリ モデルとアプリ ナビゲーション</span><span class="sxs-lookup"><span data-stu-id="7abb5-136">The Xbox One app model and app navigation</span></span>

<span data-ttu-id="7abb5-137">Xbox One では、ユーザーが複数のアプリケーションをすばやく切り替えることができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-137">Xbox One allows users to switch quickly between multiple applications.</span></span> <span data-ttu-id="7abb5-138">適切に作成されたアプリケーションでは、ユーザーが最後にアクセスしたとき以降アプリがシャットダウンされていた場合でも、ユーザーは前回のアクティビティ時に終了した場所から再開し、関連するコンテキストをすぐに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-138">Well-written applications let users pick up where they left off during their last activity with relevant context loading quickly, even if the app was shut down since the last time the user accessed it.</span></span>

<span data-ttu-id="7abb5-139">Xbox One 本体では、排他的パーティションでは一度に 1 つのアプリしか実行できません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-139">Xbox One consoles can run only one app in the exclusive partition at a time.</span></span> <span data-ttu-id="7abb5-140">アプリを高速に切り替えるユーザー エクスペリエンスを提供するには、ユーザーが別のアプリを実行しようとしたときに、現在実行されている排他的アプリをすぐにシャットダウンする必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-140">Presenting a fast-switching user experience requires the currently running exclusive app to shut down quickly when the user wants to run another one.</span></span> <span data-ttu-id="7abb5-141">ユーザーが別のアプリに切り替えようとすると、システムはアクティブなアプリに一時停止通知を送信します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-141">When a user tries to switch to another app, the system sends the active app a suspend notification.</span></span> <span data-ttu-id="7abb5-142">この際、アプリは関連する状態を保存し、その Suspend 関数から戻る必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-142">During this time, the app should save the relevant state and return from its Suspend function.</span></span> <span data-ttu-id="7abb5-143">システムにより、この操作には最大で 1 秒の時間制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-143">The system enforces a maximum time limit of 1 second for this operation.</span></span> <span data-ttu-id="7abb5-144">1 秒以内にアプリが戻らなかった場合、システムはアプリケーションを強制的に終了します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-144">If the app has not returned within 1 second, the system forcibly terminates the application.</span></span> <span data-ttu-id="7abb5-145">最新のスマートフォンやタブレットのナビゲーション モデルと同様に、アプリでユーザーがアプリから離れることを阻止することはできません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-145">Apps cannot stop users from navigating away, as with the navigation model on modern smartphones and tablets.</span></span>

<span data-ttu-id="7abb5-146">ユーザーが本体の電源ボタンを押してシステムがアイドル状態または低電力状態になる場合など、排他的アプリが一時停止される場合もあります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-146">There are also other cases in which an exclusive app is suspended, such as the system's entering an idle or low power state when the user presses the power button on the console.</span></span> <span data-ttu-id="7abb5-147">アプリは、一時停止された場合、システムによってアンロードされることなく再開できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-147">Once the app is suspended, it may be resumed without being unloaded by the system.</span></span> <span data-ttu-id="7abb5-148">これにより、迅速に再開する機能が実現されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-148">This enables quick-resume functionality.</span></span> <span data-ttu-id="7abb5-149">理解しておくべき重要な点として、一時停止されたアプリは、終了される場合もあれば再開される場合もあります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-149">The important thing to know is that suspended apps may also be terminated or resumed.</span></span> <span data-ttu-id="7abb5-150">終了される場合に備えてアプリでは常に状態を保存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-150">The app must always save state in case it is terminated.</span></span>

<span data-ttu-id="7abb5-151">Xbox One のアプリケーション モデルで適切に動作させるには、1 秒間の一時停止時間枠内に関連する状態をセーブできるように、アプリで状態をメモリー バッファーに迅速にシリアル化できるように備えておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-151">To work well with the Xbox One application model, apps should be prepared to serialize state into a memory buffer quickly so that relevant state can be saved within the 1 second suspend time-frame.</span></span>

<span data-ttu-id="7abb5-152">ユーザーのゲームプレイに関するセーブ データと、メニュー内の場所のようなアプリの状態に関するデータには違いがある点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-152">Note that there is a difference between saved data about user gameplay, and data about the state of the app, such as location within menus.</span></span> <span data-ttu-id="7abb5-153">アプリが一時停止されたときにゲームプレイをセーブすることに加えて、メインのゲーム エンジン外でユーザーが設定中、またはキャラクターをカスタマイズ中である場合にメニューの状態を保持することを検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-153">In addition to saving gameplay when the app is suspended, you should consider persisting menu state if the user is in the middle of configuring a setting or customizing a character outside the main game engine.</span></span>

<span data-ttu-id="7abb5-154">ユーザーは非常に長い時間、ゲームを一時停止したままにする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-154">Users can leave a game suspended for a very long time.</span></span> <span data-ttu-id="7abb5-155">長い一時停止の後にゲームが再開されたときは、別のエクスペリエンスを提供することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-155">Consider offering a different experience when the game is resumed following a long suspension.</span></span> <span data-ttu-id="7abb5-156">ユーザーが 2 週間プレイしていなかった場合、プレイしていたキャンペーンの銃撃戦の中に戻されることは不快かつ予想外の体験になる可能性があります。一方で、1 時間の休憩はよくあることであり、その場合はすぐにゲームプレイに戻っても問題ありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-156">Dropping a user back into a firefight from their campaign might be a jarring and unexpected experience if the user hasn't played for two weeks, whereas a one-hour break would be more common and warrant a quick return to gameplay.</span></span>

<span data-ttu-id="7abb5-157">Xbox One のアプリケーション モデルの詳細については、以下のリソースを参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-157">For more information about the Xbox One app model, see the following resources:</span></span>

-   <span data-ttu-id="7abb5-158">『[リビング ルーム用の最新のアプリケーション切り替え](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Documents/Xfest%202012/Xfest%202012%20-%20Modern%20Application%20Switching%20for%20the%20Living%20Room.pptx)』(Xfest 2012 のプレゼンテーション)</span><span class="sxs-lookup"><span data-stu-id="7abb5-158">[Modern Application Switching for the Living Room](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Documents/Xfest%202012/Xfest%202012%20-%20Modern%20Application%20Switching%20for%20the%20Living%20Room.pptx), a presentation at Xfest 2012</span></span>
-   <span data-ttu-id="7abb5-159">『[シェル エクスペリエンス](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=PROD-D_Experience.pptx&folder=platform\xfest2013)』(Xfest 2013 のプレゼンテーション)</span><span class="sxs-lookup"><span data-stu-id="7abb5-159">[The Shell Experience](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=PROD-D_Experience.pptx&folder=platform\xfest2013), a presentation at Xfest 2013</span></span>
-   <span data-ttu-id="7abb5-160">『[Process Lifetime Management for Xbox One](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx)』、GDN にあるホワイト ペーパー</span><span class="sxs-lookup"><span data-stu-id="7abb5-160">[Process Lifetime Management for Xbox One](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx), a white paper on GDN</span></span>

| <span data-ttu-id="7abb5-161">注</span><span class="sxs-lookup"><span data-stu-id="7abb5-161">Note</span></span>                                                                                                                                                                                                                                                                                                                               |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="7abb5-162">[Xfest 2012](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2012.aspx) および [Xfest 2013](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2013.aspx) の一部のプレゼンテーションには、Xbox One でのオフライン プレイのサポートが発表されたことにより古くなった情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-162">Some presentations at [Xfest 2012](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2012.aspx) and [Xfest 2013](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2013.aspx) contain information that is out of date due to the announcement that Xbox One supports off-line play.</span></span> |


### <a name="storage-options-on-xbox-one"></a><span data-ttu-id="7abb5-163">Xbox One のストレージ オプション</span><span class="sxs-lookup"><span data-stu-id="7abb5-163">Storage options on Xbox One</span></span>

<span data-ttu-id="7abb5-164">Xbox One ではいくつかのストレージ オプションが用意されており、それぞれに固有の利点と制約があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-164">Xbox One provides several storage options, each with its own benefits and constraints.</span></span> <span data-ttu-id="7abb5-165">アプリでは、アプリの要件に応じて、オプションを組み合わせて使用することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-165">Apps may need to use a combination of options depending on the apps' requirements.</span></span>


<a name="connected-storage"></a><span data-ttu-id="7abb5-166">接続ストレージ</span><span class="sxs-lookup"><span data-stu-id="7abb5-166">Connected storage</span></span>
-----------------

<span data-ttu-id="7abb5-167">接続ストレージは、複数の本体間でローミングされる必要がある Xbox One のゲームプレイ データや他の関連するアプリの状態データを保存できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-167">Connected storage is designed to help apps save Xbox One gameplay data and other relevant app states-data that should roam between consoles.</span></span> <span data-ttu-id="7abb5-168">接続ストレージ API は Xbox One に固有であり、そのデータの保存およびアップロードを支援します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-168">The Connected Storage API, specific to Xbox One, assists with saving and uploading that data.</span></span> <span data-ttu-id="7abb5-169">API は Xbox One アプリケーション モデルとの組み合わせで機能します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-169">The API works in combination with the Xbox One application model.</span></span>

<span data-ttu-id="7abb5-170">接続ストレージ API は、次の機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-170">The Connected Storage API provides the following features:</span></span>

-   <span data-ttu-id="7abb5-171">アプリでは一度に最大 16 MB のデータをシステム パーティション内のメモリー バッファーにすばやく保存できます。その後データはシステムによって HDD のローカルにキャッシュされ、クラウドにアップロードされます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-171">Apps can quickly save up to 16 MB of data at a time into a memory buffer in the system partition, which is then cached locally on the HDD by the system and uploaded to the cloud.</span></span>
- <span data-ttu-id="7abb5-172">対象パートナーおよび ID@Xbox 開発者向け:</span><span class="sxs-lookup"><span data-stu-id="7abb5-172">For managed partners and ID@Xbox developers:</span></span>
  - <span data-ttu-id="7abb5-173">ユーザー/アプリごとに 256 MB のクラウド ストレージ。</span><span class="sxs-lookup"><span data-stu-id="7abb5-173">256 MB per user/app of cloud storage.</span></span>
- <span data-ttu-id="7abb5-174">Xbox Live クリエーターズ プログラム開発者向け:</span><span class="sxs-lookup"><span data-stu-id="7abb5-174">For Xbox Live Creators Program developers:</span></span>
  - <span data-ttu-id="7abb5-175">ユーザー/アプリごとに 64 MB のクラウド ストレージ。</span><span class="sxs-lookup"><span data-stu-id="7abb5-175">64 MB per user/app of cloud storage.</span></span>
-   <span data-ttu-id="7abb5-176">電源障害に対する堅牢な応答 - アプリでは、データの一部しか保存されないケースに対処する必要がありません</span><span class="sxs-lookup"><span data-stu-id="7abb5-176">Robust response to power failures—apps don't have to deal with partial data being saved.</span></span>
-   <span data-ttu-id="7abb5-177">アプリが実行されていない場合を含め、データはクラウドに自動的にアップロードされます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-177">Data is automatically uploaded to the cloud, even when the app isn't running.</span></span>
-   <span data-ttu-id="7abb5-178">データは、Xbox Live に接続されている複数の Xbox One 本体で使用できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-178">Data is available across Xbox One consoles that are connected to Xbox Live.</span></span>
-   <span data-ttu-id="7abb5-179">Xbox Live によってデバイス間の同期と競合の管理が処理されるため、アプリケーションが関与する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-179">Xbox Live handles cross-device syncing and conflict management without requiring involvement by the app.</span></span>

<span data-ttu-id="7abb5-180">接続ストレージ API の詳細については、Xbox Live SDK に含まれる xblesdk.chm (Xbox Live Extension SDK API のドキュメント) の該当するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-180">For more information about the Connected Storage API, see the appropriate section in xblesdk.chm (which documents the Xbox Live Extension SDK APIs) in the Xbox Live SDK.</span></span>


<a name="xbox-live-title-storage"></a><span data-ttu-id="7abb5-181">Xbox Live タイトル ストレージ</span><span class="sxs-lookup"><span data-stu-id="7abb5-181">Xbox Live Title Storage</span></span>
-----------------------

<span data-ttu-id="7abb5-182">タイトル ストレージ サービスでは、以下の機能を持つデータ ストレージ用のクロスプラットフォーム REST API が提供されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-182">The Title Storage service offers a cross-platform REST API for data storage with the following capabilities:</span></span>

-   <span data-ttu-id="7abb5-183">ユーザー間、アプリ間、およびさまざまなプラットフォーム間でのデータ共有を提供します</span><span class="sxs-lookup"><span data-stu-id="7abb5-183">Provides data sharing across users, apps, and various platforms</span></span>
-   <span data-ttu-id="7abb5-184">バイナリ ファイル、JSON ファイル、および構成ファイルをサポートします</span><span class="sxs-lookup"><span data-stu-id="7abb5-184">Supports binary, JSON and configuration files</span></span>
-   <span data-ttu-id="7abb5-185">対象パートナーおよび ID@Xbox 開発者向け:</span><span class="sxs-lookup"><span data-stu-id="7abb5-185">For managed partners and ID@Xbox developers:</span></span>
    - <span data-ttu-id="7abb5-186">ユーザー/アプリごとに 256 MB のクラウド ストレージ</span><span class="sxs-lookup"><span data-stu-id="7abb5-186">256 MB per user/app of cloud storage</span></span>
    - <span data-ttu-id="7abb5-187">タイトルごとに 256 MB のグローバル ストレージ</span><span class="sxs-lookup"><span data-stu-id="7abb5-187">256 MB of per title global storage</span></span>
- <span data-ttu-id="7abb5-188">Xbox Live Creators Program 開発者向け:</span><span class="sxs-lookup"><span data-stu-id="7abb5-188">For Xbox Live Creators Program developers:</span></span>
  -   <span data-ttu-id="7abb5-189">ユーザー/アプリごとに 64 MB のクラウド ストレージ</span><span class="sxs-lookup"><span data-stu-id="7abb5-189">64 MB per user/app of cloud storage</span></span>
  -   <span data-ttu-id="7abb5-190">タイトルごとに 256 MB のグローバル ストレージ</span><span class="sxs-lookup"><span data-stu-id="7abb5-190">256 MB of per title global storage</span></span>

<span data-ttu-id="7abb5-191">サービスを使用するための要件:</span><span class="sxs-lookup"><span data-stu-id="7abb5-191">Requirements for using the service:</span></span>

-   <span data-ttu-id="7abb5-192">サービスにアクセスするために Xbox One 本体がオンラインである必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-192">Xbox One console must be online in order to access the service</span></span>
-   <span data-ttu-id="7abb5-193">サービスとの相互作用はすべて、アプリの実行中に完了する必要があります。データ転送がバックグラウンドで自動的に完了することはありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-193">All service interactions must be completed while the app is running; data transfer is not completed automatically in the background.</span></span>

<span data-ttu-id="7abb5-194">詳細については、XDK ドキュメントの「*Xbox Live Title Storage*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-194">For more information, see *Xbox Live Title Storage*, in the XDK documentation.</span></span>


<a name="local-temporary-storage"></a><span data-ttu-id="7abb5-195">ローカル一時ストレージ</span><span class="sxs-lookup"><span data-stu-id="7abb5-195">Local temporary storage</span></span>
-----------------------

<span data-ttu-id="7abb5-196">本体上で、アプリは、以下の特性を持つローカル一時ストレージにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-196">On the console, an app has access to local temporary storage with the following characteristics:</span></span>

-   <span data-ttu-id="7abb5-197">パス T:\\ によってアクセス可能な 2 GB の専用ハード ドライブ ストレージ。</span><span class="sxs-lookup"><span data-stu-id="7abb5-197">2 GB of dedicated hard drive storage, accessible by the path T:\\.</span></span>
-   <span data-ttu-id="7abb5-198">アプリが実行されていないときにこのストレージのコンテンツを削除可能。</span><span class="sxs-lookup"><span data-stu-id="7abb5-198">Contents of this storage may be evicted when the app is not running.</span></span>

<span data-ttu-id="7abb5-199">ローカル ストレージの詳細については、XDK ドキュメントの「Local Storage」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-199">For more information about local storage, see Local Storage, in the XDK documentation.</span></span>


<a name="configuring-your-app-for-connected-storage"></a><span data-ttu-id="7abb5-200">接続ストレージのためのアプリの構成</span><span class="sxs-lookup"><span data-stu-id="7abb5-200">Configuring your app for connected storage</span></span>
------------------------------------------

<span data-ttu-id="7abb5-201">接続ストレージ API を使用する場合、すべての読み取りおよび書き込み操作は Xbox Live プライマリー サービス構成 ID (SCID) と関連付けられます。SCID はアプリのマニフェスト ファイル AppXManifest.xml で次のように定義されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-201">When you use the Connected Storage API, all read and write operations are associated with an Xbox Live Primary Service Configuration ID (SCID), defined in your app's manifest file, AppXManifest.xml:</span></span>

```xml
      <Extensions>
        <mx:Extension Category="xbox.live">
        <mx:XboxLive TitleId="<your title ID>" PrimaryServiceConfigId="<your SCID>"
        RequireXboxLive="<boolean indicating Live requirement>" />
        </mx:Extension>
      </Extensions>
```

<span data-ttu-id="7abb5-202">アプリのタイトル ID および SCID を取得する方法の詳細については、XDK ドキュメントの「*Xbox Live 開発のためのサンドボックスのセットアップ*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-202">For more information about acquiring the title ID and SCID for your app, see *Setting Up Sandboxes for Xbox Live Development*, in the XDK documentation.</span></span>



## <a name="connected-storage-system-concepts"></a><span data-ttu-id="7abb5-203">接続ストレージ: システムの概念</span><span class="sxs-lookup"><span data-stu-id="7abb5-203">Connected storage: system concepts</span></span>

<span data-ttu-id="7abb5-204">ここでは、接続ストレージ システムの構成要素、その関係性、および適切な使用方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-204">This section describes the components of the connected storage system, their relationships, and their proper uses.</span></span>

### <a name="connected-storage-space"></a><span data-ttu-id="7abb5-205">接続ストレージ領域</span><span class="sxs-lookup"><span data-stu-id="7abb5-205">Connected storage space</span></span>

<span data-ttu-id="7abb5-206">大まかに言えば、接続ストレージ システム内のすべてのデータは、ユーザーまたはマシン (個々の Xbox One 本体など) のいずれかに関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-206">At a high level, all data in the connected storage system is associated with either a user or a machine (for example, an individual Xbox One console).</span></span> <span data-ttu-id="7abb5-207">アプリによって保存される、特定のユーザーまたはマシンのすべてのデータは、接続ストレージ領域に保存されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-207">All data saved by an app for a particular user or machine is stored in a connected storage space.</span></span>

<span data-ttu-id="7abb5-208">アプリの各ユーザーは接続ストレージ領域を取得しますが、合計で 256 MB の容量に制限されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-208">Each user of your app gets a connected storage space with a limit of 256 MB total storage.</span></span> <span data-ttu-id="7abb5-209">重要な注意点として、このストレージはアプリ専用であり、他のアプリとは共有されません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-209">It's important to note that this storage is dedicated to your app alone—it is not shared with other apps.</span></span>

<span data-ttu-id="7abb5-210">アプリには、ローカルの接続ストレージ領域内にマシン用の 64 MB の領域も割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-210">Your app also has 64 MB of space in a local connected storage space for the machine.</span></span> <span data-ttu-id="7abb5-211">このストレージ領域は、ユーザーとは無関係であり、サインインしているユーザーがいない場合でもアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-211">This storage space is independent of users and can be accessed even if no users are signed in.</span></span>

<span data-ttu-id="7abb5-212">接続ストレージ領域を取得するには、アプリで *ConnectedStorageSpace.GetForUserAsync メソッド*または *ConnectedStorageSpace.GetForMachineAsync メソッド*を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-212">To acquire a connected storage space, the app calls the *ConnectedStorageSpace.GetForUserAsync Method* or the *ConnectedStorageSpace.GetForMachineAsync Method*.</span></span> <span data-ttu-id="7abb5-213">この処理は、特にユーザーがあるデバイス上でデータを保存しており、別のデバイス上で初めてゲームプレイを再開する場合に、実行時間が長くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-213">This a potentially long-running operation, especially if the user has saved data on one device and is resuming gameplay for the first time on another device.</span></span> <span data-ttu-id="7abb5-214">このプロセスと、接続ストレージ領域の取得をアプリが待機している間に発生する可能性があるエラー状況の詳細については、このホワイト ペーパーで後述されている「*接続ストレージ領域の同期*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-214">For details about this process, and the possible error conditions that can occur while the app is waiting to acquire a connected storage space, see *Synchronizing a connected storage space*, later in this paper.</span></span>

<span data-ttu-id="7abb5-215">アプリが **ConnectedStorageSpace** オブジェクトを取得した後、そのオブジェクトまたはそのオブジェクトから派生する他のオブジェクトを使用する、*Windows.Storage 名前空間*配下のすべてのメソッドの呼び出しは、Web サービスからの応答に依存せずに完了できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-215">After the app acquires a **ConnectedStorageSpace** object, calls to all methods under the *Windows.Storage Namespace* which use that object, or other objects derived from it, do not depend on a response from web services to complete.</span></span> <span data-ttu-id="7abb5-216">ただし、Xbox One HDD へのアクセスはアクティブなアプリに限定されていないため、これらのメソッドで最大限のパフォーマンスが実現されることは保証されません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-216">However, because access to the Xbox One HDD is not exclusive to the active app, strict upper bounds on the performance of these methods cannot be guaranteed.</span></span>


### <a name="connected-storage-containers-and-blobs"></a><span data-ttu-id="7abb5-217">接続ストレージ: コンテナーと BLOB</span><span class="sxs-lookup"><span data-stu-id="7abb5-217">Connected storage: containers and blobs</span></span>

<span data-ttu-id="7abb5-218">*接続ストレージ コンテナー* (または単に*コンテナー*) はストレージの基本単位です。</span><span class="sxs-lookup"><span data-stu-id="7abb5-218">The *connected storage container*, or *container* for short, is the basic unit of storage.</span></span> <span data-ttu-id="7abb5-219">次の図に示されているように、それぞれの接続ストレージ領域には多数のコンテナーを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-219">Each connected storage space can contain numerous containers, as shown in the following diagram.</span></span>

**<span data-ttu-id="7abb5-220">図 1: </span><span class="sxs-lookup"><span data-stu-id="7abb5-220">Figure 1.</span></span>  <span data-ttu-id="7abb5-221">接続ストレージ領域 (タイトル/マシンごとまたはタイトル/ユーザーごと)</span><span class="sxs-lookup"><span data-stu-id="7abb5-221">Connected storage space (per-title/machine or per-title/user)</span></span>**

![](../../images/connected_storage/connected_storage_space_containers.png)
<span data-ttu-id="7abb5-222">データは、*BLOB* と呼ばれる 1 つ以上のバッファーとしてコンテナー内に保存されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-222">Data is stored in containers as one or more buffers called *blobs*.</span></span> <span data-ttu-id="7abb5-223">次の図は、ディスク上のコンテナーの内部システム表現を示しています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-223">The following diagram illustrates the internal system representation of containers on disk.</span></span> <span data-ttu-id="7abb5-224">コンテナーごとに、コンテナー内の各 BLOB に対応するデータ ファイルへの参照を含むコンテナー ファイルがあります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-224">For each container, there is a container file that contains references to the data file for each blob in the container.</span></span>

**<span data-ttu-id="7abb5-225">図 2.</span><span class="sxs-lookup"><span data-stu-id="7abb5-225">Figure 2.</span></span>  <span data-ttu-id="7abb5-226">コンテナーの図</span><span class="sxs-lookup"><span data-stu-id="7abb5-226">Diagram of a container</span></span>**

![](../../images/connected_storage/container_storage_blobs.png)

<span data-ttu-id="7abb5-227">コンテナーにデータを格納するには、名前および BLOB (Buffer オブジェクト) のマップを指定して *ConnectedStorageContainer.SubmitUpdatesAsync メソッド*を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-227">To store data in a container, call the *ConnectedStorageContainer.SubmitUpdatesAsync Method*, providing a map of names and blobs (Buffer objects).</span></span> <span data-ttu-id="7abb5-228">**SubmitUpdatesAsync** 呼び出しで記述されたすべての変更はアトミックに適用されます。つまり、要求どおりすべての BLOB が更新されるか、操作全体が中止されてコンテナーが呼び出しの前の状態のままとなるかのどちらかです。</span><span class="sxs-lookup"><span data-stu-id="7abb5-228">All changes described in a **SubmitUpdatesAsync** call are applied atomically, that is, either all the blobs are updated as requested, or the entire operation is terminated and the container remains in its state prior to the call.</span></span>

<span data-ttu-id="7abb5-229">**SubmitUpdatesAsync** を使用する個々の保存処理では、一度に 16 MB のデータに制限されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-229">Individual save operations that use **SubmitUpdatesAsync** are limited to 16 MB of data at a time.</span></span>


### <a name="submitupdatesasync-behavior"></a><span data-ttu-id="7abb5-230">SubmitUpdatesAsync の動作</span><span class="sxs-lookup"><span data-stu-id="7abb5-230">SubmitUpdatesAsync behavior</span></span>

<span data-ttu-id="7abb5-231">**SubmitUpdatesAsync** が呼び出されると、呼び出しで指定されたバッファーが、アプリケーション パーティションからシステム パーティションの専用のメモリー領域にすぐにコピーされます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-231">When **SubmitUpdatesAsync** is called, the buffers provided to the call are quickly copied from the app partition into a dedicated memory space in the system partition.</span></span> <span data-ttu-id="7abb5-232">メモリーがシステム パーティションに正常にコピーされると、**SubmitUpdatesAsync** 呼び出しで指定された完了ハンドラーがアプリ内で呼び出され、データ用にローカルで割り当てたメモリーを解放しても安全であることがアプリに伝えられます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-232">Once the memory has successfully been copied into the system partition, the completion handler provided in the **SubmitUpdatesAsync** call is invoked within the app, indicating to the app that it is safe to free the memory it allocated locally for the data.</span></span>

<span data-ttu-id="7abb5-233">その後、システムが BLOB を本体のハード ドライブに保存し、そのコンテナーでの操作全体をコミットする最終的なコンテナーの更新を実行して操作を完了します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-233">The system then saves the blobs to the console's hard drive and completes the operation with a final container update that commits the entire operation on that container.</span></span>

<span data-ttu-id="7abb5-234">**SubmitUpdatesAsync** データを受け取るための共有パーティション内のメモリーには 16MB の上限があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-234">There is a 16 MB cap on the memory in the shared partition for receiving **SubmitUpdatesAsync** data.</span></span> <span data-ttu-id="7abb5-235">専用の 16 MB バッファー内に空きメモリーが十分にないために、システムが **SubmitUpdatesAsync** の呼び出しを即座に処理できない場合、呼び出しは処理のキューに入れられます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-235">If a call to **SubmitUpdatesAsync** cannot be immediately serviced by the system because there is not enough memory free in the dedicated 16 MB buffer, the call is queued for servicing.</span></span> <span data-ttu-id="7abb5-236">システムによって 16 MB のバッファーからハード ドライブにデータが継続的に転送され、16 MB のバッファー内の領域が使用できるようになると、キューに入れられた更新が要求された順序で処理されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-236">The system continuously transfers data from the 16 MB buffer to the hard drive, and queued updates are serviced in the order they were requested as space becomes available in the 16 MB buffer.</span></span>

**<span data-ttu-id="7abb5-237">図 3: </span><span class="sxs-lookup"><span data-stu-id="7abb5-237">Figure 3.</span></span>  <span data-ttu-id="7abb5-238">SubmitUpdatesAsync の動作</span><span class="sxs-lookup"><span data-stu-id="7abb5-238">SubmitUpdatesAsync behavior</span></span>**

![](../../images/connected_storage/submitupdatesasync_behavior.png)
<span data-ttu-id="7abb5-239">クラウドへのアップロードも同様の方法で行われます。個々の BLOB がサービスにアップロードされ、更新操作は、他のすべてのアップロードされた BLOB を参照するコンテナー ファイルの最終的な更新によってコミットされます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-239">Uploading to the cloud happens in a similar way: Individual blobs are uploaded to the service, and the update operation is committed by a final update to a container file that references all the other uploaded blobs.</span></span> <span data-ttu-id="7abb5-240">クラウドへのアップロードでは、このように 1 回の最終的な更新に統合することで、**SubmitUpdatesAsync** 呼び出しで参照されているすべてのデータが完全にコミットされるか、コンテナーが変更されないままになるかのどちらかになります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-240">In an upload to the cloud, this consolidation into a single and final update ensures that all data referenced in a **SubmitUpdatesAsync** call is either committed in its entirety or the container is left unchanged.</span></span> <span data-ttu-id="7abb5-241">このようにすることで、アップロード処理中にシステムがオフラインになったり、電源が切断されたりした場合でも、ユーザーは別の Xbox One 本体にアクセスして、クラウドからデータをダウンロードし、すべてのコンテナーが一貫した状態でプレイを続行できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-241">In this way, even if a system goes offline or loses power during an upload operation, a user could go to another Xbox One console, download data from the cloud, and continue play with a consistent view of all containers.</span></span>

| <span data-ttu-id="7abb5-242">重要</span><span class="sxs-lookup"><span data-stu-id="7abb5-242">Important</span></span>                                                                                |
|--------------------------------------------------------------------------------------------------|
| <span data-ttu-id="7abb5-243">コンテナーをまたいだデータの依存性は安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-243">Data dependencies across containers are not safe.</span></span>  <span data-ttu-id="7abb5-244">個々の *SubmitUpdatesAsync* 呼び出しの結果は、完全に適用されるか、まったく適用されないかのどちらかになることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-244">The results of individual *SubmitUpdatesAsync* calls are guaranteed to be applied entirely, or not at all.</span></span> |

<span data-ttu-id="7abb5-245">**SubmitUpdatesAsync** 呼び出しでは、コンテナーの有効な状態を保つために、その後の **SubmitUpdatesAsync** 呼び出しが正常に完了することを想定しないでください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-245">**SubmitUpdatesAsync** calls must not assume that a future **SubmitUpdatesAsync** call will be completed successfully in order to leave the container in a valid state.</span></span> <span data-ttu-id="7abb5-246">つまり、アプリは、必要なすべてのデータをコンテナーに保存するために複数の **SubmitUpdatesAsync** 呼び出しに依存することはできません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-246">In other words, apps cannot rely on more than one **SubmitUpdatesAsync** call to save all required data into a container.</span></span> <span data-ttu-id="7abb5-247">各 **SubmitUpdatesAsync** 呼び出しで、指定されたコンテナーの内容を有効な状態にし、アプリケーションが後で読み取ることができるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-247">Each **SubmitUpdatesAsync** call must leave the contents of the specified container in a valid state for the app to read later.</span></span>

<span data-ttu-id="7abb5-248">この問題を説明するために、Bob というキャラクターが所有するゴールドと食料の量をコンテナーで追跡するシナリオについて考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="7abb5-248">To illustrate this issue, consider a scenario where a container tracks the amount of gold and food held by a character named Bob.</span></span> <span data-ttu-id="7abb5-249">タイトルでは、*food* と *gold* という 2 つの BLOB を格納できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-249">The title can store two blobs, named *food* and *gold*.</span></span> <span data-ttu-id="7abb5-250">Bob はインベントリーに 100 ゴールドあり、食料はない状態でスタートします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-250">Bob starts with 100 gold and no food in his inventory.</span></span>

**<span data-ttu-id="7abb5-251">図 4: </span><span class="sxs-lookup"><span data-stu-id="7abb5-251">Figure 4.</span></span>  <span data-ttu-id="7abb5-252">サンプル シナリオ: Bob は 100 ゴールドがある状態でスタートする。</span><span class="sxs-lookup"><span data-stu-id="7abb5-252">Example scenario: Bob starts with 100 gold.</span></span>**

![](../../images/connected_storage/submitupdatesasync_example_scenario1.png)

<span data-ttu-id="7abb5-253">ここで、Bob が 50 ゴールドを消費します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-253">Now Bob spends 50 gold.</span></span> <span data-ttu-id="7abb5-254">タイトルは、金の BLOB の値を 50 に更新する **SubmitUpdatesAsync** 呼び出しを準備します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-254">The title prepares a **SubmitUpdatesAsync** call, which updates the value of the gold blob to 50.</span></span>

<span data-ttu-id="7abb5-255">システムは、更新された BLOB とコンテナー更新に関する情報を更新バッファーにキャプチャーします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-255">The system captures both the updated blob and information about the container update to the updates buffer.</span></span> <span data-ttu-id="7abb5-256">システムは新しい BLOB の値をハード ドライブにコピーします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-256">Then the system copies the value of the new blob to the hard drive.</span></span>

**<span data-ttu-id="7abb5-257">図 5: </span><span class="sxs-lookup"><span data-stu-id="7abb5-257">Figure 5.</span></span>  <span data-ttu-id="7abb5-258">システムが更新された情報をキャプチャーし、値をハード ドライブにコピーする。</span><span class="sxs-lookup"><span data-stu-id="7abb5-258">The system captures the updated information and copies the values to the hard drive.</span></span>**

![](../../images/connected_storage/submitupdatesasync_example_scenario2.png)

<span data-ttu-id="7abb5-259">最後に、システムは、新しい BLOB を参照するように HDD 上のコンテナー ファイルを更新します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-259">Finally, the system updates the container file on the HDD to reference the new blob.</span></span> <span data-ttu-id="7abb5-260">最終的に、システムは、参照されていない BLOB をガベージ コレクション操作で削除します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-260">Eventually, the system removes the unreferenced blob in a garbage collection operation.</span></span>

**<span data-ttu-id="7abb5-261">図 6: </span><span class="sxs-lookup"><span data-stu-id="7abb5-261">Figure 6.</span></span>  <span data-ttu-id="7abb5-262">システムが HDD 上のコンテナー ファイルを更新し、参照されていない BLOB を削除する。</span><span class="sxs-lookup"><span data-stu-id="7abb5-262">The system updates the container file on the HDD and removes the unreferenced blob.</span></span>**

![](../../images/connected_storage/submitupdatesasync_example_scenario3.png)

<span data-ttu-id="7abb5-263">1 つの **SubmitUpdatesAsync** 呼び出しで使用する BLOB が増えれば増えるほど、データを確実に格納するために必要なアトミックなファイル システム処理の完了に要する時間は長くなります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-263">Note that the more blobs you use per **SubmitUpdatesAsync** call, the more time is required to complete the necessary atomic operations of the file system operations to store the data robustly.</span></span> <span data-ttu-id="7abb5-264">前の例でのデータ ストレージの粒度は非常に小さなものですが、これは、1 つのコンテナー内の複数の BLOB をアトミック更新する動作を明確に示すことを意図しています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-264">The granularity of data storage in the preceding example is far too small, but it is intended to clearly illustrate the behavior of the atomic update of multiple blobs in one container.</span></span>


### <a name="updating-multiple-blobs--the-wrong-way"></a><span data-ttu-id="7abb5-265">複数の BLOB の更新 – 間違ったやり方</span><span class="sxs-lookup"><span data-stu-id="7abb5-265">Updating multiple blobs — the wrong way</span></span>

<span data-ttu-id="7abb5-266">Bob が食料を購入するシナリオを考えます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-266">Consider a scenario in which Bob wants to buy some food.</span></span> <span data-ttu-id="7abb5-267">わかりやすくするために、1 単位のゴールドで 1 単位の食料を買うことができ、Bob が 25 単位の食料を買うことにします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-267">For simplicity, we'll say that 1 unit of gold buys 1 unit of food, and Bob wants to buy 25 units of food.</span></span> <span data-ttu-id="7abb5-268">アプリでは、25 単位の食料を追加する **SubmitUpdatesAsync** 呼び出しと、25 単位のゴールドを Bob\_Inventory コンテナーから差し引く別の呼び出しを発行できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-268">The app could issue one **SubmitUpdatesAsync** call to add 25 units of food and then another one to subtract 25 units of gold from the Bob\_Inventory container.</span></span> <span data-ttu-id="7abb5-269">ただし、両方の **SubmitUpdatesAsync** 呼び出しの完了ハンドラーが呼び出された場合でも、ハード ドライブへのデータの書き込みを停止させる可能性がある停電や、クラウドへの不完全な同期などが原因で、誤った結果となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-269">But even if the completed handlers for both **SubmitUpdatesAsync** calls have been called, there is a potential for incorrect results due to events like power loss, which might stop the data from being written to the hard drive, or an incomplete sync to the cloud.</span></span> <span data-ttu-id="7abb5-270">以下の図は、システムによって実行される手順と、いずれかの手順で停電が発生した場合の結果について説明しています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-270">The following diagrams explain the steps taken by the system, and the result of a power loss at any one of the steps.</span></span>

<span data-ttu-id="7abb5-271">両方の **SubmitUpdatesAsync** 呼び出しからのデータはシステムの更新バッファーに既に含まれており、両方の呼び出しのタイトルの完了ハンドラーが呼び出されたものと仮定します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-271">Assume that the data from both **SubmitUpdatesAsync** calls is already in the system's update buffer, and the title's completion handlers for both calls have been invoked.</span></span>

<span data-ttu-id="7abb5-272">まず、システムが食料の BLOB の新しい値のデータをディスクに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-272">First the system writes the data for the new value of the food blob to disk.</span></span>

**<span data-ttu-id="7abb5-273">図 7: </span><span class="sxs-lookup"><span data-stu-id="7abb5-273">Figure 7.</span></span>  <span data-ttu-id="7abb5-274">システムが食料の BLOB の値をディスクに書き込む。</span><span class="sxs-lookup"><span data-stu-id="7abb5-274">The system writes the value of the food blob to disk.</span></span>**

![](../../images/connected_storage/update_method_wrong_way_1.png)
<span data-ttu-id="7abb5-275">次に、システムは、新しく書き込まれた値を参照するようにコンテナーを更新します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-275">Next, the system updates the container to reference the newly written value.</span></span> <span data-ttu-id="7abb5-276">次の図に示されているように、この手順の実行後、次の手順の前に電源が失われた場合、Bob は、対応するゴールドをインベントリーから差し引かれずに 25 単位の食料を得るという得な取引をすることになります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-276">As the following diagram illustrates, if power were lost after this step and before the next one, Bob would end up with a good deal, gaining 25 food without having the corresponding gold deducted from his inventory.</span></span>

**<span data-ttu-id="7abb5-277">図 8: </span><span class="sxs-lookup"><span data-stu-id="7abb5-277">Figure 8.</span></span>  <span data-ttu-id="7abb5-278">新しく書き込まれた値を参照するようにシステムがコンテナーを更新する。</span><span class="sxs-lookup"><span data-stu-id="7abb5-278">The system updates the container to reference the newly written value.</span></span>**

![](../../images/connected_storage/update_method_wrong_way_2.png)

<span data-ttu-id="7abb5-279">次に、システムはゴールドの BLOB の新しい値のデータをディスクに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-279">Next, the system writes the data for the new value of the gold blob to disk.</span></span> <span data-ttu-id="7abb5-280">Bob\_Inventory コンテナーによって参照されるゴールドの値がまだ更新されていないため、Bob は本来よりも 25 単位多いゴールドを持っていますが、目的の結果に一歩近づきました。</span><span class="sxs-lookup"><span data-stu-id="7abb5-280">The value for gold referenced by the Bob\_Inventory container still hasn't been updated, and Bob has 25 more gold than he should—but we're one step closer to the desired result.</span></span>

**<span data-ttu-id="7abb5-281">図 9: </span><span class="sxs-lookup"><span data-stu-id="7abb5-281">Figure 9.</span></span>  <span data-ttu-id="7abb5-282">システムがゴールドの BLOB の新しい値のデータをディスクに書き込む。</span><span class="sxs-lookup"><span data-stu-id="7abb5-282">The system writes the data for the new value of the gold blob to disk.</span></span>**

![](../../images/connected_storage/update_method_wrong_way_3.png)

<span data-ttu-id="7abb5-283">最後に、システムは新しく書き込まれたゴールドの BLOB を参照するようにコンテナー ファイルを更新し、これで意図した結果が実現されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-283">Finally, the system updates the container file to reference the newly written blob for gold—the intended result.</span></span>

**<span data-ttu-id="7abb5-284">図 10: </span><span class="sxs-lookup"><span data-stu-id="7abb5-284">Figure 10.</span></span>  <span data-ttu-id="7abb5-285">新しく書き込まれたゴールドの BLOB を参照するようにシステムがコンテナー ファイルを更新する。</span><span class="sxs-lookup"><span data-stu-id="7abb5-285">The system updates the container file to reference the newly written gold blob.</span></span>**

![](../../images/connected_storage/update_method_wrong_way_4.png)

### <a name="updating-multiple-blobs--the-right-way"></a><span data-ttu-id="7abb5-286">複数の BLOB の更新 – 正しいやり方</span><span class="sxs-lookup"><span data-stu-id="7abb5-286">Updating multiple blobs — the right way</span></span>

<span data-ttu-id="7abb5-287">停電によって誤った中間状態が発生する可能性がないように、Bob のインベントリーのゴールドと食料の量がアトミックに更新されるようにする適切な方法は、1 回の **SubmitUpdatesAsync** 呼び出しで両方の BLOB を更新することです。</span><span class="sxs-lookup"><span data-stu-id="7abb5-287">The proper way to ensure the amount of gold and food in Bob's inventory is atomically updated, with no possibility of incorrect intermediate state due to power loss, is to update both blobs in a single **SubmitUpdatesAsync** call.</span></span> <span data-ttu-id="7abb5-288">この場合、システムでは次のような手順が実行されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-288">The system will then take the following steps.</span></span>

<span data-ttu-id="7abb5-289">まず、システムが食料の BLOB の新しい値のデータをディスクに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-289">First the system writes the data for the new value of the food blob to disk.</span></span>

**<span data-ttu-id="7abb5-290">図 11: </span><span class="sxs-lookup"><span data-stu-id="7abb5-290">Figure 11.</span></span>  <span data-ttu-id="7abb5-291">システムが食料の BLOB の新しい値のデータを書き込む。</span><span class="sxs-lookup"><span data-stu-id="7abb5-291">The system writes the data for the new value of the food blob.</span></span>**

![](../../images/connected_storage/update_method_right_way_1.png)
<span data-ttu-id="7abb5-292">次に、システムはゴールドの BLOB の新しい値のデータをディスクに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-292">Then the system writes the data for the new value of the gold blob to disk.</span></span>

**<span data-ttu-id="7abb5-293">図 12.</span><span class="sxs-lookup"><span data-stu-id="7abb5-293">Figure 12.</span></span>  <span data-ttu-id="7abb5-294">システムがゴールドの BLOB の新しい値のデータを書き込む。</span><span class="sxs-lookup"><span data-stu-id="7abb5-294">The system writes the data for the new value of the gold blob.</span></span>**

![](../../images/connected_storage/update_method_right_way_2.png)
<span data-ttu-id="7abb5-295">最後に、システムが、両方の新しい BLOB を参照するようにコンテナー ファイルを更新します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-295">Finally, the system updates the container file to reference both of the new blobs.</span></span>

**<span data-ttu-id="7abb5-296">図 13.</span><span class="sxs-lookup"><span data-stu-id="7abb5-296">Figure 13.</span></span>  <span data-ttu-id="7abb5-297">両方の新しい BLOB を参照するようにシステムがコンテナー ファイルを更新する。</span><span class="sxs-lookup"><span data-stu-id="7abb5-297">The system updates the container file to reference both new blobs.</span></span>**

![](../../images/connected_storage/update_method_right_way_3.png)
<span data-ttu-id="7abb5-298">この例は非常に単純ですが、目的の更新をすべて含む 1 回の **SubmitUpdatesAsync** 呼び出しを発行することで、コンテナー内のデータに対してアトミックに適用されるべきすべての変更を実行することの重要性を示しています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-298">While this example is very simple, it illustrates the importance of making all modifications to the data in a container which must be atomically applied by issuing a single **SubmitUpdatesAsync** call with all the desired updates.</span></span> <span data-ttu-id="7abb5-299">ゴールドで食料を購入するケースをこのように処理することで、アプリでは、誤って一方の値のみが更新され、本来よりも多いゴールドがキャラクターに残る可能性がある競合条件を回避します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-299">By doing so for the case of purchasing food with gold, the app avoids a potential race condition that could incorrectly update only one of the values and leave the character with too much gold.</span></span>

### <a name="performance-characteristics-and-considerations"></a><span data-ttu-id="7abb5-300">パフォーマンス特性と考慮事項</span><span class="sxs-lookup"><span data-stu-id="7abb5-300">Performance characteristics and considerations</span></span>

<span data-ttu-id="7abb5-301">共有パーティションの 16 MB の更新バッファーでは、限られた数の更新処理を非常に迅速に実行できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-301">The 16 MB update buffer in the shared partition allows a limited number of update operations to be performed very quickly.</span></span> <span data-ttu-id="7abb5-302">システムがデータをディスクに保存できる速度は、バッファー内のデータ量と BLOB の数の両方によって異なります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-302">The speed at which the system can persist the data to disk depends on both the amount of data in the buffer and the number of blobs.</span></span> <span data-ttu-id="7abb5-303">各 BLOB は復元性が確保されるようにディスクに書き込まれるため、バッファー内の BLOB 数が多くなればなるほど、ディスクへの保存にかかる時間は長くなります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-303">Because each blob is written to disk with resiliency, the larger the number of blobs in the buffer, the more time it takes to persist them to disk.</span></span>

<span data-ttu-id="7abb5-304">図 13 は、システムで他のハード ドライブ処理がない場合に、2 秒ごとに **SubmitUpdatesAsync** 操作で 2 回の 512 K の BLOB 更新と 1 回の 1,024 K の BLOB 更新を処理した場合の時間の例を示しています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-304">Figure 13 shows an example for the processing time for a **SubmitUpdatesAsync** operation every 2 seconds with two 512k blob updates and one 1024k blob update, when there is no other hard drive activity on the system.</span></span> <span data-ttu-id="7abb5-305">システムは安定状態で稼働でき、各更新を 14 ～ 18 ミリ秒以内に処理します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-305">The system can operate at a steady state, processing each update within 14–18ms.</span></span>

**<span data-ttu-id="7abb5-306">図 14.</span><span class="sxs-lookup"><span data-stu-id="7abb5-306">Figure 14.</span></span>  <span data-ttu-id="7abb5-307">他のハード ドライブ アクティビティがない場合に、2 秒ごとに SubmitUpdatesAsync 操作で 2 回の 512 K の BLOB 更新と 1 回の 1,024 K の BLOB 更新を処理した場合の時間。</span><span class="sxs-lookup"><span data-stu-id="7abb5-307">Processing time for a SubmitUpdatesAsync operation every 2 seconds with two 512k blob updates and one 1024k blob update, and no other hard drive activity.</span></span>**

![](../../images/connected_storage/submitupdatesasync_proc_time_mixed_size_fixed_interval.png)
<span data-ttu-id="7abb5-308">図 14 は、さまざまな時間間隔で 3 つの 1,024 K の BLOB を処理した場合の時間を示しています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-308">Figure 14 shows the processing time for three 1024k blobs at various time intervals.</span></span>

<span data-ttu-id="7abb5-309">システムは、3 秒間隔では 87 ミリ秒の安定状態でこれらの更新を処理できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-309">The system can process these updates at intervals of 3 seconds at 87ms steady state.</span></span> <span data-ttu-id="7abb5-310">頻度を 2 秒間隔に上げても、システムは 87 ミリ秒以内の安定状態で更新を処理できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-310">Increasing the frequency to once every 2 seconds, the system can still process updates within 87ms steady state.</span></span>

<span data-ttu-id="7abb5-311">更新間隔を 1 秒に縮めると、安定状態の動作が変わります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-311">Reducing the interval to 1 second between updates alters the steady state behavior.</span></span> <span data-ttu-id="7abb5-312">システムは、60 個の更新までは更新あたり 87 ミリ秒で処理できますが、それ以降は各更新にかかる時間が非常に長くなり、大幅な変動を伴って、更新あたりの処理時間が 500 ミリ秒の安定状態に達します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-312">The system can process 60 updates at 87ms per update, but every update beyond that takes significantly longer, reaching a steady state processing time of 500 milliseconds second per update, with significant fluctuation.</span></span> <span data-ttu-id="7abb5-313">これは、データがディスクにフラッシュされるよりも速く 16 MB のメモリー バッファーがいっぱいになり、更新処理で、前の更新が書き込まれるのを待機しなければならないことが原因です。</span><span class="sxs-lookup"><span data-stu-id="7abb5-313">This is because the 16 MB memory buffer is being filled faster than it can flush the data to disk; updates are forced to wait for previous updates to be written.</span></span>

<span data-ttu-id="7abb5-314">0.5 秒間隔で 1 回の更新を実行すると、影響は劇的に大きくなります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-314">The effect increases dramatically when updating the interval to one update every 0.5 second.</span></span> <span data-ttu-id="7abb5-315">この間隔では、システムは、非常に大きな変動を伴いながら、各更新の処理に 1 秒を超える時間がかかる安定状態に達するまで、更新あたり 87 ミリ秒で 7 回の更新しか処理できません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-315">The system can process only 7 updates at this interval, again at 87ms per update, before reaching a steady state in which each update takes more than 1 second to be processed, with very high variations.</span></span>

**<span data-ttu-id="7abb5-316">図 15: </span><span class="sxs-lookup"><span data-stu-id="7abb5-316">Figure 15.</span></span>  <span data-ttu-id="7abb5-317">さまざまな時間間隔で 3 つの 1,024 K の BLOB を処理した場合の時間。</span><span class="sxs-lookup"><span data-stu-id="7abb5-317">Processing time of three 1024k blobs at various time intervals.</span></span>**

![](../../images/connected_storage/submitupdatesasync_proc_time_fixed_size_various_intervals.png)
<span data-ttu-id="7abb5-318">これらは説明のための例にすぎません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-318">These are illustrative examples only.</span></span> <span data-ttu-id="7abb5-319">通常、アプリはこのような頻度でデータを保存するべきではありませんが、ディスク I/O のない環境で動作することも通常はありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-319">Your app generally shouldn't be saving data this often, yet it also won't generally be operating in an environment free of disk I/O.</span></span>

<span data-ttu-id="7abb5-320">以上の例に基づいてシステムの特性を理解すること、すなわち、さまざまな稼働条件下でアプリを計測し、アプリの一時停止ハンドラーの実行中に 1 秒未満で保存操作を完了できるようにすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="7abb5-320">It's important to understand the characteristics of the system based on these examples—to measure the app under various operating conditions, ensuring that your save operations can complete in less than 1 second during your app's suspend handler.</span></span>


## <a name="synchronizing-a-connected-storage-space"></a><span data-ttu-id="7abb5-321">接続ストレージ領域の同期</span><span class="sxs-lookup"><span data-stu-id="7abb5-321">Synchronizing a connected storage space</span></span>

-   <span data-ttu-id="7abb5-322">接続のチェック</span><span class="sxs-lookup"><span data-stu-id="7abb5-322">Connectivity check</span></span>
-   <span data-ttu-id="7abb5-323">ロックの取得</span><span class="sxs-lookup"><span data-stu-id="7abb5-323">Lock acquisition</span></span>
-   <span data-ttu-id="7abb5-324">コンテナーの一覧表示、比較、および結合ロジック</span><span class="sxs-lookup"><span data-stu-id="7abb5-324">Container listing, comparison, and merger logic</span></span>
-   <span data-ttu-id="7abb5-325">コンテナーのダウンロード</span><span class="sxs-lookup"><span data-stu-id="7abb5-325">Container download</span></span>

<span data-ttu-id="7abb5-326">アプリから接続ストレージ領域へのアクセスを要求されると、システムは同期プロセスを実行し、Xbox One 本体間でユーザーのセーブ データが一貫した状態で維持されるようにし、そのデータをオフライン プレイで使用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-326">When your app requests access to a connected storage space, the system performs a synchronizing process to keep the user's saved data in a consistent state across Xbox One consoles and to make his or her data available for offline play.</span></span> <span data-ttu-id="7abb5-327">同期は、その所要時間が変動する可能性があり、ユーザーの判断を必要とする場合があるため、そのプロセスのさまざまな段階でシステムからユーザーに UI が表示されることがあります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-327">Because synchronizing can take varying amounts of time and might require the user to make decisions, the system might display UI to the user at various stages of the process.</span></span>

<span data-ttu-id="7abb5-328">同期 UI がアクティブな場合でも、ユーザーは Xbox ボタンを押していつでもアプリを離れることができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-328">The user can navigate away from your app by pressing the Xbox button at any time, even if synchronization UI is active.</span></span> <span data-ttu-id="7abb5-329">システムは UI を非表示にし、ユーザーの操作なしで可能な範囲で同期は続行されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-329">The system hides the UI, and the synchronization continues as far as it can without user interaction.</span></span> <span data-ttu-id="7abb5-330">ユーザーがアプリに戻ると、同期が完了していない限り、UI が再度表示されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-330">When the user navigates back to the app, the UI is displayed again unless the synchronization has completed.</span></span> <span data-ttu-id="7abb5-331">UI が非表示のときに、ユーザーの選択をシステムが勝手に推測することはありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-331">The system never makes an assumption about a user selection when the UI is hidden.</span></span>

<span data-ttu-id="7abb5-332">ユーザーがホーム画面にいるときはシステムは同期 UI を表示せず、アプリのレンダリングは大きなアプリ タイルに表示され続けるため、**GetForUserAsync** 呼び出しの完了を待っている間、アプリでは状況に応じて適切なビジュアルをレンダリングすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="7abb5-332">Because the system displays no synchronization UI when the user is at the Home screen, and your app's rendering is still visible in the Big App Tile, it's important that the app render contextually appropriate visuals while a **GetForUserAsync** call is completing.</span></span> <span data-ttu-id="7abb5-333">レンダリングを続行することで、アプリがまだインタラクティブであり、データの読み込みを待機していることがユーザーに示されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-333">The continued rendering indicates to the user that the app is still interactive and is waiting for data to load.</span></span>

<span data-ttu-id="7abb5-334">次の図は、アプリから接続ストレージ領域を要求されたときの、システムのシーケンスを大まかに示しています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-334">The following diagram outlines the high-level sequence the system follows when an app requests a connected storage space.</span></span> <span data-ttu-id="7abb5-335">シーケンス全体に数秒以上かかる場合は、システムによって同期 UI が表示されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-335">If the entire sequence takes more than a few seconds, the system-drawn synchronization UI is displayed.</span></span>

**<span data-ttu-id="7abb5-336">図 16: </span><span class="sxs-lookup"><span data-stu-id="7abb5-336">Figure 16.</span></span>  <span data-ttu-id="7abb5-337">アプリから接続ストレージ領域を要求されたときのシステムのシーケンス。</span><span class="sxs-lookup"><span data-stu-id="7abb5-337">Sequence followed by the system when an app requests connected storage space.</span></span>**

![](../../images/connected_storage/app_requests_connected_storage_space.png)
<span data-ttu-id="7abb5-338">システムは、以下の段階を経て **GetForUserAsync** 要求を処理します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-338">The system goes through the following stages when it services a **GetForUserAsync** request:</span></span>

-   <span data-ttu-id="7abb5-339">接続のチェック</span><span class="sxs-lookup"><span data-stu-id="7abb5-339">Connectivity check</span></span>
-   <span data-ttu-id="7abb5-340">ロックの取得</span><span class="sxs-lookup"><span data-stu-id="7abb5-340">Lock acquisition</span></span>
-   <span data-ttu-id="7abb5-341">コンテナーの一覧表示、比較、および結合ロジック</span><span class="sxs-lookup"><span data-stu-id="7abb5-341">Container listing, comparison, and merger logic</span></span>
-   <span data-ttu-id="7abb5-342">コンテナーのダウンロード</span><span class="sxs-lookup"><span data-stu-id="7abb5-342">Container download</span></span>

### <a name="connectivity-check"></a><span data-ttu-id="7abb5-343">接続のチェック</span><span class="sxs-lookup"><span data-stu-id="7abb5-343">Connectivity check</span></span>

<span data-ttu-id="7abb5-344">**GetForUserAsync** 要求の処理を開始するために、システムは接続をチェックします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-344">To start servicing a **GetForUserAsync** request, the system checks for connectivity.</span></span> <span data-ttu-id="7abb5-345">本体がオフラインの場合、同期プロセス全体が省略され、現在のセッションの間、指定されたユーザーの接続ストレージ領域はオフラインとマークされます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-345">If the console is offline, the entire synchronization process is skipped, and the connected storage space for the specified user is marked as offline for the current session.</span></span> <span data-ttu-id="7abb5-346">次にアプリが同じユーザーの接続ストレージ領域にアクセスし、システムがタイトル ストレージ サービスに到達できたときに、変更されたデータがクラウド ストレージと照合されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-346">Any data modified will be reconciled with cloud storage the next time your app accesses the same user's connected storage space and the system can reach the Title Storage service.</span></span> <span data-ttu-id="7abb5-347">この場合、UI は表示されません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-347">No UI is ever shown for this case.</span></span>

<span data-ttu-id="7abb5-348">接続ストレージのコンテキスト以外でのオフライン処理の詳細については、『*Xbox One タイトルのサービス中断からの復帰性*』を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-348">For more information about offline handling outside the context of connected storage, see *Service Interruption Resiliency for Xbox One Titles*.</span></span>

### <a name="lock-acquisition"></a><span data-ttu-id="7abb5-349">ロックの取得</span><span class="sxs-lookup"><span data-stu-id="7abb5-349">Lock acquisition</span></span>

<span data-ttu-id="7abb5-350">接続の確認後、システムは、アプリおよび現在のユーザーに関連付けられているクラウド ストレージ領域への排他的アクセスを取得しようとします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-350">After verifying connectivity, the system attempts to acquire exclusive access to the cloud storage space associated with your app and the current user.</span></span> <span data-ttu-id="7abb5-351">これは、タイトル ストレージの接続ストレージ領域にロック ファイルを配置することで実行されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-351">This is accomplished by placing a lock file in the connected storage area of your Title Storage.</span></span> <span data-ttu-id="7abb5-352">本体がオンラインで、サービスに到達可能であり、短時間でロックを取得できる場合、UI は表示されず、同期プロセスが続行されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-352">If the console is online, can reach the service, and is able to acquire the lock in a short period of time, no UI is presented, and the synchronization process continues.</span></span>

<span data-ttu-id="7abb5-353">システムが特定の接続ストレージ領域のロックを取得し、接続ストレージ領域のインスタンスをアプリに返した場合、Web 要求の成功時には、その接続ストレージ領域内のデータに対して実行されるアプリの API 呼び出しはいずれもブロックされません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-353">Once the system has acquired a lock for a particular connected storage space and returned an instance of a connected storage space to your app, none of your app's API calls operating on data within that connected storage space will block on successful web requests.</span></span> <span data-ttu-id="7abb5-354">ロックによって十分な保護が提供されるため、アプリが接続ストレージ領域を取得した後にユーザーがシステムからネットワーク ケーブルを取り外しても、API 呼び出しはローカルで使用可能なデータに基づいて動作します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-354">The lock provides sufficient protection, so that even if a user were to unplug the network cable from the system after your app has acquired a connected storage space, the API calls will operate based on the locally available data.</span></span>

<span data-ttu-id="7abb5-355">ロックの取得手順中に発生する可能性があるエラー シナリオがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-355">There are a few possible error scenarios during the lock acquisition step:</span></span>

 <span data-ttu-id="7abb5-356">**同期 UI** 本体はオンラインであるが、短時間でサービスからロックが取得されなかった場合、"同期中"の UI が表示されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-356">**Syncing UI** If the console is online but has not acquired the lock from the service within a short time, a "syncing" UI is displayed.</span></span>

 <span data-ttu-id="7abb5-357">**ロックの解除** ユーザーが、アプリを現在の本体で最後にプレイしてから別の本体でプレイした場合は、別の本体がストレージ領域への排他的アクセスを所有していて、データのアップロード中である場合があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-357">**Breaking the lock** If the user has played the app on another console since he or she last played on the current one, it's possible that the other console has exclusive access to the storage space and is in the middle of uploading data.</span></span> <span data-ttu-id="7abb5-358">また、別の本体でデータのアップロードが開始されたが、終了する前にその接続または電源が失われた可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-358">It's also possible that another console has started uploading data but has lost its connection or power before finishing.</span></span>

<span data-ttu-id="7abb5-359">どちらのケースも*ロックの競合*と呼ばれ、いずれのケースでも、別の本体がデータのアップロード中であることを説明する UI がシステムによって表示されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-359">Both of these cases are referred to as *lock contention*, and in either case, the system presents UI to explain that another console is uploading data.</span></span> <span data-ttu-id="7abb5-360">ユーザーは、このプロセスが完了するのを待機するか、クラウド内の現時点で利用可能なデータを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-360">The user can wait for this process to complete or work with the data currently available in the cloud.</span></span> <span data-ttu-id="7abb5-361">ユーザーがクラウド データを使用することを選択した場合、システムはそのシステム用のロックを取得して (ロックを解除して)、ユーザーおよびアプリのクラウド ストレージへの排他的アクセスを取得します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-361">If the user chooses to work with cloud data, the system takes the lock for itself (breaks the lock), acquiring exclusive access to the cloud storage for the user and app.</span></span> <span data-ttu-id="7abb5-362">他の本体からのアップロードはキャンセルされ、同期プロセスが続行されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-362">The upload from the other console is canceled, and the synchronization process continues.</span></span>

### <a name="container-listing-comparison-and-merger-logic"></a><span data-ttu-id="7abb5-363">コンテナーの一覧表示、比較、および結合ロジック</span><span class="sxs-lookup"><span data-stu-id="7abb5-363">Container listing, comparison, and merger logic</span></span>

<span data-ttu-id="7abb5-364">ロックの取得後、システムは指定されたアプリおよびユーザーのクラウド内のすべてのコンテナーの一覧表示を要求します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-364">After acquiring a lock, the system requests a listing of all containers in the cloud for the given app and user.</span></span> <span data-ttu-id="7abb5-365">次に、ローカル ハード ドライブの内容とクラウド内のデータを比較し、比較の結果に応じて処理を進めます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-365">It then compares the contents of the local hard drive with the data in the cloud and proceeds according to the results of the comparison:</span></span>

 <span data-ttu-id="7abb5-366">**ローカル データがクラウドと一致する場合** 他の本体からの変更がなく、クラウドとローカル ハード ドライブ内のデータが同じである場合、同期は完了しており、この時点で **GetForUserAsync** 呼び出しの完了ハンドラーが呼び出され、アプリは読み込みとセーブを開始することができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-366">**Local data matches the cloud** If there have been no changes from other consoles, and the data in the cloud and local hard drive is identical, then the synchronization is complete, the completion handler of the **GetForUserAsync** call is invoked at this time, and your app can proceed with loads and saves.</span></span>

 <span data-ttu-id="7abb5-367">**ローカル データがない場合** クラウドにはデータがあるが、ローカルの本体にはない場合、データがクラウドからローカルにダウンロードされます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-367">**No local data** If the cloud has data but the local console doesn't have any, the data from the cloud is downloaded locally.</span></span> <span data-ttu-id="7abb5-368">これが発生する可能性があるのは、ユーザーが友人の家で初めてプレイする場合などです。</span><span class="sxs-lookup"><span data-stu-id="7abb5-368">This could occur, for example, when the user is playing at a friend's house for the first time.</span></span>

 <span data-ttu-id="7abb5-369">**同じコンテナーがローカルとクラウドで変更された場合** ユーザーが、別の本体でプレイしてクラウド内のコンテナーを変更し、現在の本体をオフラインで使用して同じコンテナーを変更した場合、データは自動的に結合されません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-369">**Same containers, modified locally and in the cloud** If the user has modified containers in the cloud by playing on another console and has modified the same containers when using the current console offline, the data cannot be merged automatically.</span></span> <span data-ttu-id="7abb5-370">ユーザーは保持するデータを選択するよう求められます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-370">The user will be asked to choose which data to keep.</span></span> <span data-ttu-id="7abb5-371">競合が発生した場合、ユーザーは置き換えポリシーを選択できます。ローカル データまたはクラウド データのどちらかが常に保持されるようにするか、**キャンセル**を選択して決断を先送りできます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-371">In the event of conflicts, the user can choose a replacement policy: Either the local data or cloud data is always kept, or the user can select **cancel** and defer making the choice.</span></span> <span data-ttu-id="7abb5-372">ユーザーが置き換えポリシーとしてクラウド データまたはローカル データのどちらかを選択した場合、同じ名前であるが内容が異なるコンテナーは、そのポリシーに従って解決されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-372">If the user chooses either the cloud or local data as a replacement policy, containers with the same name—but with different contents—will be resolved accordingly.</span></span>

<span data-ttu-id="7abb5-373">ユーザーが**キャンセル**を選択した場合、ユーザーがオフラインでプレイしていたかのように、タイトルは未解決状態のセーブ システムにアクセスできるようになります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-373">If the user selects **cancel**, the title will have access to the save system in a non-resolved state, as if the user were playing offline.</span></span> <span data-ttu-id="7abb5-374">この場合、次に、本体がオンラインである場合にアプリが接続ストレージ領域へのアクセスを要求したときに、競合解決 UI が再度表示されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-374">In this case, the conflict resolution UI is presented again the next time the app requests access to the connected storage space, if the console is online.</span></span>

### <a name="container-download"></a><span data-ttu-id="7abb5-375">コンテナーのダウンロード</span><span class="sxs-lookup"><span data-stu-id="7abb5-375">Container download</span></span>

<span data-ttu-id="7abb5-376">競合が解決されると、システムでは、クラウドからダウンロードする必要があるコンテナーを識別するために必要なすべての情報が整います。</span><span class="sxs-lookup"><span data-stu-id="7abb5-376">After any conflicts have been resolved, the system has all the information necessary to identify which containers need to be downloaded from the cloud.</span></span> <span data-ttu-id="7abb5-377">必要なすべてのコンテナーがダウンロードされ、この時点で *ConnectedStorageSpace.GetForUserAsync Method* 呼び出しの完了ハンドラーが呼び出され、アプリは読み込みとセーブを開始できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-377">All the required containers will be downloaded, the completion handler of the *ConnectedStorageSpace.GetForUserAsync Method* will be invoked at this time, and your app can proceed with loads and saves.</span></span>

<span data-ttu-id="7abb5-378">この手順中、いくつかのエラーが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-378">Some possible errors during this step:</span></span>

**<span data-ttu-id="7abb5-379">ローカル ストレージの不足</span><span class="sxs-lookup"><span data-stu-id="7abb5-379">Insufficient local storage</span></span>**  
<span data-ttu-id="7abb5-380">必要なコンテナーのためのローカル ハード ドライブ領域が不足している場合、ローカルに保存されているデータを削除してディスク領域を空けるよう求める UI がユーザーに表示されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-380">In the case of insufficient local hard drive space for the required containers, users are presented with UI asking them to free disk space by removing locally saved data.</span></span> <span data-ttu-id="7abb5-381">クラウドにバックアップされていない重要なデータをユーザーが完全に削除してしまわないように、UI では、単なるローカル キャッシュであるデータと現在の本体のみに保持されているデータが明確に示されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-381">To help them avoid permanently deleting important data that isn't backed up in the cloud, the UI clearly indicates data that is simply local cache and data that is unique to the current console.</span></span>

<span data-ttu-id="7abb5-382">ユーザーに UI が表示されたときの処理は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="7abb5-382">When the UI is presented to the user:</span></span>

-   <span data-ttu-id="7abb5-383">ユーザーが十分な領域を解放した場合、同期が続行され、完了します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-383">If the user frees up sufficient space, the synchronization continues and completes.</span></span>
-   <span data-ttu-id="7abb5-384">ユーザーが十分な領域を解放せずに UI をキャンセルした場合、**GetForUserAsync** 呼び出しの完了ハンドラーは **OutOfLocalStorage** を返します (「*ConnectedStorageErrorStatus Enumeration*」を参照)。</span><span class="sxs-lookup"><span data-stu-id="7abb5-384">If the user cancels out of the UI without freeing sufficient space, the completion handler of the **GetForUserAsync** call returns **OutOfLocalStorage**—see *ConnectedStorageErrorStatus Enumeration*.</span></span> <span data-ttu-id="7abb5-385">アプリでは、データをセーブできない状態でプレイしようとしていることをユーザーに確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-385">The app should confirm that the user intends to play without being able to save data.</span></span> <span data-ttu-id="7abb5-386">ユーザーが同意した場合、アプリではそのユーザーのデータをセーブせずに処理を進める必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-386">If the user agrees, the app should proceed without saving data for that user.</span></span> <span data-ttu-id="7abb5-387">ユーザーがプレイ中にデータをセーブすることを希望した場合、アプリでは再び **GetForUserAsync** を呼び出して、領域を解放するための UI を表示させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-387">If the user indicates he or she wants to save data while playing, the app should repeat the **GetForUserAsync** call, which will then display the UI to free up space.</span></span>

**<span data-ttu-id="7abb5-388">ユーザーが同期をキャンセルする</span><span class="sxs-lookup"><span data-stu-id="7abb5-388">User cancels synchronization</span></span>**  
<span data-ttu-id="7abb5-389">ユーザーが同期の完了を待たずにキャンセルを選択した場合、すべてのセーブ データが使用できるようにはならないことがユーザーに通知されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-389">If the user does not want to wait for the synchronization to complete, and selects cancel, the user is informed that not all of the saved data will be available.</span></span> <span data-ttu-id="7abb5-390">この時点で **GetForUserAsync** 呼び出しの完了ハンドラーが呼び出され、アプリは読み込みとセーブを開始できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-390">The completion handler of the **GetForUserAsync** call will be invoked at this time, and the app can proceed with loads and saves.</span></span>

**<span data-ttu-id="7abb5-391">ネットワーク タイムアウト</span><span class="sxs-lookup"><span data-stu-id="7abb5-391">Network timeout</span></span>**  
<span data-ttu-id="7abb5-392">ネットワーク接続またはサービスの可用性の問題が原因でデータのダウンロードがタイムアウトになった場合、ユーザーには、同期を再試行するオプションが提供されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-392">If the data download times out due to a problem with network connectivity or service availability, the user is given the option to retry the synchronization.</span></span> <span data-ttu-id="7abb5-393">再試行しないことを選択した場合、すべてのセーブ データが使用できるようにはならないことがユーザーに通知されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-393">If he or she chooses not to, the user is informed that not all of the saved data will be available.</span></span> <span data-ttu-id="7abb5-394">この時点で **GetForUserAsync** 呼び出しの完了ハンドラーが呼び出され、アプリは読み込みとセーブを開始できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-394">The completion handler of the **GetForUserAsync** call will be invoked at this time, and the app can proceed with loads and saves.</span></span>


## <a name="when-to-acquire-a-connected-storage-space"></a><span data-ttu-id="7abb5-395">接続ストレージ領域を取得するタイミング</span><span class="sxs-lookup"><span data-stu-id="7abb5-395">When to acquire a connected storage space</span></span>

<span data-ttu-id="7abb5-396">ユーザーの接続ストレージ領域を取得するための実行時間は変動する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-396">The execution time for acquiring a user's connected storage space can vary.</span></span> <span data-ttu-id="7abb5-397">アプリでは、ユーザーがサインアウトを開始したことに対する応答、またはシステムから一時停止通知を受け取ったことに対する応答としてではなく、メインの実行中にこの処理を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-397">Apps should take this action during main execution, rather than in response to a user's starting to sign out or in response to receiving a suspend notification from the system.</span></span>

<span data-ttu-id="7abb5-398">セーブ機能が必要でないことが明らかなモードにゲームがなっていない限り、通常は、ユーザーがサインインし、プレイする意思を示した時点でアプリは接続ストレージ領域を取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-398">Generally, apps should acquire a connected storage space as a user signs in and indicates desire to play, unless the game is in a mode in which it's certain no save functionality is needed.</span></span> <span data-ttu-id="7abb5-399">接続ストレージ領域の取得を、長い一連のデータ読み込みに合わせることで、並列に処理できるようにすることも検討してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-399">You should also consider aligning the acquisition of connected storage space with long sequences of data loading, so that the operations can execute in parallel.</span></span>

<span data-ttu-id="7abb5-400">アプリでは、接続ストレージ領域を取得したら、将来のセーブで使用するためにこの値を保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-400">Once your app has acquired a connected storage space, it should retain this value for future saves.</span></span> <span data-ttu-id="7abb5-401">接続ストレージ領域を長時間保持しても、パフォーマンスや堅牢性への悪影響はありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-401">Retaining a connected storage space over time does not have negative effects on performance or robustness.</span></span> <span data-ttu-id="7abb5-402">システムがオンラインの場合、接続ストレージ領域の取得時にクラウドとの同期チェックが行われるため、ネットワークが低速または信頼性が低いときにユーザーの接続ストレージ領域を解放および再取得すると、システムがタイムアウトするまで、ユーザーに同期 UI が表示される場合があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-402">Because acquiring a connected storage space causes a synchronization check with the cloud if the system is online, releasing and re-acquiring a user's connected storage space during slow or unreliable network conditions might cause the user to see a synchronization UI until the system times out.</span></span>

<span data-ttu-id="7abb5-403">クラウドの同期を実行させるために接続ストレージ領域を明示的に解放する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-403">Connected storage spaces do not need to be freed explicitly to cause cloud synchronization.</span></span> <span data-ttu-id="7abb5-404">**SubmitUpdatesAsync** 呼び出しで指定された完了ハンドラーから **AsyncStatus::Completed** が返されると、アプリが ConnectedStorageSpace オブジェクトを解放するかどうかにかかわらず、システムがクラウドとの同期を処理します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-404">Once the completion handler specified in a **SubmitUpdatesAsync** call has returned with **AsyncStatus::Completed**, the system takes care of synchronization with the cloud whether or not the app frees the ConnectedStorageSpace object.</span></span>


## <a name="when-to-save"></a><span data-ttu-id="7abb5-405">セーブするタイミング</span><span class="sxs-lookup"><span data-stu-id="7abb5-405">When to save</span></span>

<span data-ttu-id="7abb5-406">アプリで一時停止通知を受け取るたびに、アプリでは少なくとも、関連データをセーブして、システムがコンテキストに応じてユーザーの適切な状態に戻れるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-406">Whenever an app receives a suspend notification, the app should at least save relevant data, enabling the system to return to a contextually appropriate state for the user.</span></span>

<span data-ttu-id="7abb5-407">定期的な、自動的な、またはユーザーが開始するセーブをゲームの設計で使用している場合、一時停止通知を受け取ったとき以外にも接続ストレージを呼び出すことができます。これは、停電やクラッシュなどでデータが失われるリスクを低減できるため推奨されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-407">If your game design uses periodic, automatic, or user-initiated saves, connected storage can be called more often than when receiving a suspend notification; doing so is a good way to reduce the risk of data loss due to power loss or a crash.</span></span>

<span data-ttu-id="7abb5-408">ユーザーがサインアウトした場合でも、そのユーザーの User オブジェクトは有効なままであり、その時点でアプリは接続ストレージを使用して最終的なセーブ操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-408">When a user signs out, the User object for that user remains valid, and at that time the app may perform final save operations by using connected storage.</span></span> <span data-ttu-id="7abb5-409">このオブジェクトの詳細については、*User クラス*を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-409">For more information on this object, see *User Class*.</span></span>


## <a name="robustness"></a><span data-ttu-id="7abb5-410">信頼性</span><span class="sxs-lookup"><span data-stu-id="7abb5-410">Robustness</span></span>

<span data-ttu-id="7abb5-411">セーブ データは常にクラウドに同期されるため、アプリのクラッシュの原因になるバグがセーブ データやアプリのコードに含まれると、そのバグがクラウドにバックアップされ、複数のデバイスに波及する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-411">Because saved data is always synchronized to the cloud, a bug in saved data and app code that causes the app to crash could be backed up in the cloud and distributed across devices.</span></span> <span data-ttu-id="7abb5-412">起動のたびにクラッシュするアプリがユーザーの手に渡らないようにするために、以下が保証されるようアプリを設計してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-412">To prevent users from having an app that crashes on every launch, design the app to ensure that:</span></span>

-   <span data-ttu-id="7abb5-413">セーブ データの一部の形式が正しくない場合でも、ユーザーはアプリ内のあるポイントまで到達して、セーブ状態を管理することができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-413">Users can reach a point in the app at which they can manage saved state, even if some saved data is malformed.</span></span>
-   <span data-ttu-id="7abb5-414">アプリは破損したデータを自動的に処理して、できるだけ多くのデータを復元し、他のデータはすべて安全な状態に再初期化することができます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-414">The app can handle corrupt data automatically, recovering as much data as it can and reinitializing everything else to a safe state.</span></span>


## <a name="use-cases-for-save-game-designs"></a><span data-ttu-id="7abb5-415">ゲーム セーブ設計の使用事例</span><span class="sxs-lookup"><span data-stu-id="7abb5-415">Use cases for save-game designs</span></span>

<span data-ttu-id="7abb5-416">接続ストレージ領域内のコンテナーを最大限に活用するゲーム セーブ システムの設計は、アプリのタイプによって異なります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-416">The design of a game saving system that makes the best use of containers in connected storage space depends on the type of app:</span></span>

### <a name="single-save"></a><span data-ttu-id="7abb5-417">単一のセーブ</span><span class="sxs-lookup"><span data-stu-id="7abb5-417">Single save</span></span>

<span data-ttu-id="7abb5-418">単一のキャンペーン スタイルのセーブ システムを使用するアプリ (一人称視点のシューティング ゲームなど) の場合:</span><span class="sxs-lookup"><span data-stu-id="7abb5-418">For apps that use a single, campaign-style save system, like a first person shooter:</span></span>

-   <span data-ttu-id="7abb5-419">すべてのデータを単一のコンテナーに格納し、常に、名前で識別される同じコンテナーに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-419">Put all of the data into a single container and always write to the same container, identified by name.</span></span>
-   <span data-ttu-id="7abb5-420">ユーザーが、これまでの進行状況を保持せずにアプリを最初からプレイすることを希望した場合のために、ユーザーのすべてのセーブ データをクリアするための、全データをリセットするオプションを公開することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-420">Consider exposing an option to reset all data that will clear all of a user's saved data, in case he or she wants to start playing the app from the beginning, with no previous progress being retained.</span></span>

### <a name="multiple-saves"></a><span data-ttu-id="7abb5-421">複数のセーブ</span><span class="sxs-lookup"><span data-stu-id="7abb5-421">Multiple saves</span></span>

<span data-ttu-id="7abb5-422">一定数のセーブ スロット (たとえば、5 つ) があるアプリの場合は、コンテナーを使用してゲーム データをセーブするための方法が 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-422">For apps that have a fixed number of save slots—5, for these examples—there are two ways to use containers to save game data:</span></span>

-   <span data-ttu-id="7abb5-423">セーブ スロットごとに 1 つの BLOB を使用して、名前が固定された 1 つのコンテナー内に 5 つのスロットすべてを格納します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-423">Store all 5 slots within one fixed-name container by using 1 blob for each save slot.</span></span> <span data-ttu-id="7abb5-424">これは、5 つのスロットすべてが完全に同期されて使用できるようになるか、同期が途中で失敗してコンテナーの内容が不完全な場合にはどのスロットも使用できないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-424">This means that all 5 slots are either fully synchronized and available, or none is available, if synchronization failed halfway through and the container was incomplete.</span></span> <span data-ttu-id="7abb5-425">ユーザーが 2 台の異なる本体でアプリをオフラインでプレイし、進行状況を 1 台目の本体のスロット 1 と 2 台目の本体のスロット 2 にセーブした場合、ユーザーは、両方の本体を Xbox Live に接続したときにどちらのデータを保持するかを選択する必要があります。コンテナーの結合ロジックで競合が発生するためです。</span><span class="sxs-lookup"><span data-stu-id="7abb5-425">If a user plays the app offline on two different consoles, saving progress in slot 1 on the first console and in slot 2 on the second console, the user must choose which data to retain on connecting both consoles to Xbox Live; the merge logic for containers will produce a conflict.</span></span>
-   <span data-ttu-id="7abb5-426">各スロットをそれぞれ独自の名前を持つコンテナーに格納します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-426">Store each slot in a container with its own name.</span></span> <span data-ttu-id="7abb5-427">これにより、オフラインになる可能性のある複数のマシン上でも、独立した進行状況が各スロットに保持されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-427">This allows independent progress in each slot, even on multiple machines that might be offline.</span></span> <span data-ttu-id="7abb5-428">ただし、ユーザーが同期を途中でキャンセルした場合、そのセッション中は一部のスロットしか使用できなくなる場合があります。一部のコンテナーでダウンロードが完了していない可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="7abb5-428">However, if a user cancels partway through a synchronization, it's possible that only some of the slots will be available during that session; some of the containers might not have completed downloading.</span></span> <span data-ttu-id="7abb5-429">そのような場合、ユーザーには、同期が完了しなかったことと、クラウド データの一部がローカルの本体に存在しないことが通知されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-429">In such a case, the user is notified that the synchronization was incomplete, and that some of the cloud data isn't on the local console.</span></span>

<span data-ttu-id="7abb5-430">どちらの方法を使用する場合でも、アプリでは、個々のセーブ データをスロットから削除するための UI をユーザーに提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-430">Whichever approach is used, the app should provide the user with UI to delete individual saves from slots.</span></span>


## <a name="development-tools"></a><span data-ttu-id="7abb5-431">開発ツール</span><span class="sxs-lookup"><span data-stu-id="7abb5-431">Development tools</span></span>

<span data-ttu-id="7abb5-432">XbStorage と Fiddler という 2 つのツールが、接続ストレージを使用するアプリの開発に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-432">Two tools will help you with developing your app's use of connected storage: XbStorage and Fiddler.</span></span>

### <a name="managing-connected-storage-with-xbstorage"></a><span data-ttu-id="7abb5-433">XbStorage を使用した接続ストレージの管理</span><span class="sxs-lookup"><span data-stu-id="7abb5-433">Managing connected storage with XbStorage</span></span>

<span data-ttu-id="7abb5-434">XbStorage は、Xbox One 開発キット上のローカルの接続ストレージ データを開発用 PC から管理するための開発ツールです。</span><span class="sxs-lookup"><span data-stu-id="7abb5-434">XbStorage is a development tool that enables managing the local connected storage data on an Xbox One development kit from a development PC.</span></span>

<span data-ttu-id="7abb5-435">このツールでは、ローカルの接続ストレージ領域をハード ドライブから消去したり、XML ファイルを使用して個々のユーザーまたはマシンの接続ストレージ領域をインポートおよびエクスポートしたりできます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-435">The tool allows clearing local connected storage spaces from the hard drive, as well as importing and exporting individual user- or machine-connected storage spaces by using XML files.</span></span>

<span data-ttu-id="7abb5-436">ローカルの接続ストレージ領域で操作が実行されると、システムは、その処理がアプリ自体によって実行された場合と同様に動作します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-436">When an operation is performed on a local connected storage space, the system behaves as if that operation had been performed by the app itself.</span></span> <span data-ttu-id="7abb5-437">接続ストレージ領域からローカル ファイルにデータをコピーすると、コピーの前にクラウドとの同期が行われます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-437">Copying the data from a connected storage space to a local file causes synchronization with the cloud prior to copying.</span></span>

<span data-ttu-id="7abb5-438">同様に、開発用 PC 上の XML ファイルから Xbox One 開発キット上の接続ストレージ コンテナーにデータをコピーすると、そのデータをクラウドにアップロードする処理が本体によって開始されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-438">Similarly, copying data from an XML file on the development PC to a connected storage container on the Xbox One dev kit causes the console to start uploading that data to the cloud.</span></span> <span data-ttu-id="7abb5-439">1 つの例外があります。開発キットがロックを取得できない場合、つまり、本体上のコンテナーとクラウド上のコンテナーの間で競合がある場合です。</span><span class="sxs-lookup"><span data-stu-id="7abb5-439">There is one exception: if the dev kit cannot acquire the lock, or if there is a conflict between the containers on the console and those in the cloud.</span></span> <span data-ttu-id="7abb5-440">そのような場合、本体は、(保持するコンテナーのバージョンを選択するなどして) ユーザーが競合を解決しないと決定した場合と同様に動作し、次にタイトルが起動されるまで、オフラインでプレイする場合と同様に動作します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-440">In such a case, the console behaves as if the user had decided not to resolve the conflict-for example, by picking one version of the container to keep-and the console behaves as if it were playing offline until the next time the title is started.</span></span>

<span data-ttu-id="7abb5-441">XbStorage の reset コマンドは、すべての SCID およびユーザーのセーブ データのローカル ストレージを消去しますが、クラウドに格納されているデータは変更しません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-441">XbStorage's reset command clears the local storage of all SCIDs' and users' saved data but does not alter the data stored in the cloud.</span></span> <span data-ttu-id="7abb5-442">これは、ユーザーが別の本体にローミングして、タイトルのプレイ時にクラウドからデータをダウンロードする状態に本体を設定する際に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-442">This is useful for setting a console to the state it would be in if a user were roaming to a console and downloading data from the cloud upon playing a title.</span></span>

<span data-ttu-id="7abb5-443">XbStorage の詳細については、XDK ドキュメントの「*接続ストレージの管理 (xbstorage.exe)*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-443">For more information about XbStorage, see *Manage Connected Storage (xbstorage.exe)*, in the XDK documentation.</span></span>

### <a name="monitoring-connected-storage-network-activity-using-fiddler"></a><span data-ttu-id="7abb5-444">Fiddler を使用した接続ストレージのネットワーク アクティビティの監視</span><span class="sxs-lookup"><span data-stu-id="7abb5-444">Monitoring connected storage network activity using Fiddler</span></span>

<span data-ttu-id="7abb5-445">クラウド ストレージの処理の実行時に、本体がサービスとやり取りしているかどうかを確認できると便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-445">It can be helpful to determine whether your console is interacting with the service when cloud storage operations are performed.</span></span> <span data-ttu-id="7abb5-446">Fiddler を使用すると、本体でサービスの呼び出しが正常に行われているかどうか、または本体で承認エラーが発生しているかどうかの確認に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-446">Using Fiddler can help determine whether your console is making calls to the service successfully or if it is encountering authorization errors.</span></span> <span data-ttu-id="7abb5-447">Xbox One での Fiddler の設定方法については、この XDK ドキュメントの「*Xbox One で Fiddler を使用する方法*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-447">For information about setting up Fiddler on an Xbox One, see *How to use Fiddler with Xbox One*, in this XDK documentation.</span></span>


## <a name="best-practices"></a><span data-ttu-id="7abb5-448">ベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="7abb5-448">Best practices</span></span>

<span data-ttu-id="7abb5-449">以下で説明されているプラクティスに従うと、応答性と堅牢性に優れ、複数の本体へのローミング時にユーザーにとってわかりやすいアプリのセーブ機能を実装できます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-449">Observing the practices described below will help you implement save functionality for your app that is responsive, robust, and understandable for users as they roam across consoles.</span></span>

### <a name="warning"></a><span data-ttu-id="7abb5-450">警告</span><span class="sxs-lookup"><span data-stu-id="7abb5-450">Warning</span></span>

 <span data-ttu-id="7abb5-451">**依存関係のあるデータをコンテナーをまたいで格納しない** 依存関係のあるデータを複数のコンテナーをまたいで格納しないでください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-451">**Do not store dependent data across containers** Do not store data with dependencies across more than one container.</span></span> <span data-ttu-id="7abb5-452">不完全な同期、停電、またはその他のエラー状況によって、コンテナーが分離される場合があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-452">Containers can be separated due to incomplete synchronization, power loss, or other error conditions.</span></span> <span data-ttu-id="7abb5-453">1 つのコンテナーに格納されるデータは、そのコンテナー内で自足し、一貫している必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-453">Data stored in a single container must be self-sufficient and self-consistent.</span></span>

### <a name="good-practices"></a><span data-ttu-id="7abb5-454">推奨されるプラクティス</span><span class="sxs-lookup"><span data-stu-id="7abb5-454">Good practices</span></span>

 <span data-ttu-id="7abb5-455">**ユーザーが本体の電源を切ったり、アプリを離れたりすることを妨げない** タイトルでは、セーブ時にユーザーが本体の電源を切ったり、アプリを離れたりすることを妨げないでください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-455">**Do not discourage users from turning off the console or navigating away** Your title should not discourage users from turning off the console or navigating away from your app when saving.</span></span> <span data-ttu-id="7abb5-456">Xbox 360 では、タイトルでセーブが実行されているときにユーザーがシステムの電源を切ると、ユーザーのデータはセーブされません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-456">On Xbox 360, if a user turns off the system while your title is saving, the user's data is not saved.</span></span> <span data-ttu-id="7abb5-457">Xbox One では、タイトルは一時停止イベントを受信し、**接続ストレージ API** を使用して状態をセーブする時間が 1 秒あります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-457">On Xbox One, your title receives a suspend event and has 1 second to use the **Connected Storage API** to save state.</span></span> <span data-ttu-id="7abb5-458">システムが完全にシャットダウンするか低電力状態になる前に、データがハード ドライブに適切にコミットされることがシステムで保証されています。</span><span class="sxs-lookup"><span data-stu-id="7abb5-458">The system ensures that data is properly committed to the hard drive before it shuts down completely or enters its low-power state.</span></span> <span data-ttu-id="7abb5-459">ユーザーが別のタイトルをプレイするためにタイトルのディスクを取り出した場合も、同じ一時停止プロセスが実行されます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-459">The same suspension process occurs if the user ejects your title's disc to play another one.</span></span>

 <span data-ttu-id="7abb5-460">**アプリがデータを読み込もうとしているときにユーザーに通知する** アプリが **GetForUserAsync** 呼び出しの完了を待機しているときに、アプリがデータを読み込もうとしていることをユーザーに視覚的に示してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-460">**Tell the user when the app is trying to load data** When your app is waiting for a **GetForUserAsync** call to complete, visually indicate to the user that the app is trying to load data.</span></span> <span data-ttu-id="7abb5-461">アプリが全画面表示で実行されているとき、システムは同期プロセス中に UI を表示しますが、ユーザーがホーム画面に移動すると、この UI は非表示になります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-461">Though the system provides UI during the synchronization process when your app is running full-screen, this UI is hidden if the user navigates to the Home screen.</span></span> <span data-ttu-id="7abb5-462">この状況が発生する可能性が高いのは、システムが、要求された接続ストレージ領域の大量のデータを同期している場合です。</span><span class="sxs-lookup"><span data-stu-id="7abb5-462">This situation is likely if the system is synchronizing a lot of data for the requested connected storage space.</span></span>

 <span data-ttu-id="7abb5-463">**接続ストレージ領域を保持する** **ConnectedStorageSpace** オブジェクトを、読み取りまたは書き込みイベントが発生するたびに取得するのではなく、保持するようにします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-463">**Retain connected storage spaces** Retain **ConnectedStorageSpace** objects rather than try to acquire them every time a read or write event occurs.</span></span> <span data-ttu-id="7abb5-464">**ConnectedStorageSpace** オブジェクトを長期間保持することによってパフォーマンスや堅牢性に悪影響が出ることはありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-464">There are no negative effects on performance or robustness caused by retaining a **ConnectedStorageSpace** object for an extended time.</span></span>

 <span data-ttu-id="7abb5-465">**データ サイズを小さくする** セーブ データのサイズを小さくします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-465">**Keep data sizes small** Keep the size of saved data small.</span></span> <span data-ttu-id="7abb5-466">本体がオンラインのときに、接続ストレージ内のすべてのユーザー データがクラウドにアップロードされます。</span><span class="sxs-lookup"><span data-stu-id="7abb5-466">All user data in connected storage is uploaded to the cloud when the console is online.</span></span> <span data-ttu-id="7abb5-467">データ形式を最適化して、遅延と帯域幅の使用量が最小限に抑えられるようにしてください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-467">Optimize your data formats to ensure minimal delays and bandwidth usage.</span></span>

 <span data-ttu-id="7abb5-468">**ユーザーがセーブを必要としていないことを確認する** **GetForUserAsync** および **SubmitUpdatesAsync** から OutOfLocalStorage エラーが返されていないかどうかをチェックし、ユーザーに質問して、本当にセーブせずにプレイするかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-468">**Verify that users don't mind not saving** Check for OutOfLocalStorage errors returned from **GetForUserAsync** and **SubmitUpdatesAsync**, and query users to see if they really want to play without saving.</span></span> <span data-ttu-id="7abb5-469">ユーザーがゲームをセーブすることを希望する場合は、操作を再試行します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-469">If a user indicates wanting to save games, retry the operation.</span></span>

 <span data-ttu-id="7abb5-470">**ユーザーのクォータをチェックし、領域をクリアするよう要求する** **SubmitUpdatesAsync** によって **QuotaExceeded** エラーが返されていないかチェックします。</span><span class="sxs-lookup"><span data-stu-id="7abb5-470">**Check the user's quota and prompt to clear space** Check for a **QuotaExceeded** error returned by **SubmitUpdatesAsync**.</span></span> <span data-ttu-id="7abb5-471">アプリでこのメッセージを受け取った場合は、領域をいくらか空けるまで新しいデータをセーブできないことをユーザーに通知し、そのための UI を表示します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-471">If your app receives this message, notify users that they cannot save any more data until they have freed up some space; present them with UI that enables them to do so.</span></span> <span data-ttu-id="7abb5-472">各ユーザーにはアプリあたり 256 MB のデータ領域が割り当てられ、各アプリにはマシンあたり 64 MB のストレージが割り当てられます (本体に対してローカル)。</span><span class="sxs-lookup"><span data-stu-id="7abb5-472">Each user gets 256 MB of data per app, and each app gets 64 MB of per-machine storage that is local to the console.</span></span>

 <span data-ttu-id="7abb5-473">**後で復元できるようにメニューの状態を保存する** コアのゲーム データに加えて、メニューの状態およびその他のアプリ設定を保存します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-473">**Save the state of menus for restoration later** Save menu state and other app settings in addition to saving core game data.</span></span> <span data-ttu-id="7abb5-474">ユーザーが別のアプリをプレイしてから元のアプリに戻ってきた場合、コンテキストに応じて適切なメニュー状態を復元します。</span><span class="sxs-lookup"><span data-stu-id="7abb5-474">If the user plays another app and then comes back to yours, restore them to a contextually appropriate menu state.</span></span>

 <span data-ttu-id="7abb5-475">**サインインしているユーザーの変化に対応する** アプリが一時停止されている間にユーザーがサインアウトする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-475">**Respond to signed-in user changes** Users can sign out while your app is suspended.</span></span> <span data-ttu-id="7abb5-476">アプリが再開されるとき、サインインしていた一連のユーザーが変わっていないかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-476">When the app is resumed, it should determine if the set of signed-in users has changed.</span></span> <span data-ttu-id="7abb5-477">変わっている場合にメニューなどのアプリ内の適切な位置に移動することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-477">Consider navigating to an appropriate location within the app, such as a menu, when this occurs.</span></span>

### <a name="important-practices"></a><span data-ttu-id="7abb5-478">重要なプラクティス</span><span class="sxs-lookup"><span data-stu-id="7abb5-478">Important practices</span></span>

 <span data-ttu-id="7abb5-479">**セーブ データを管理するための UI を提供する** Xbox 360 とは異なり、Xbox One には、セーブ データを管理するためにシステムによってホストされる UI はありません。</span><span class="sxs-lookup"><span data-stu-id="7abb5-479">**Provide UI for managing saved data** Unlike Xbox 360, Xbox One has no system-hosted UI for managing saved games.</span></span> <span data-ttu-id="7abb5-480">アプリでは、ユーザーがアプリ内でセーブ データを管理できる UI を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-480">Your app should provide UI that allows users to manage their saved data within the app.</span></span> <span data-ttu-id="7abb5-481">自動セーブ システムを備えたアプリの場合は、ユーザーが既定のプレイ状態にリセットできるように、セーブ データをリセットするオプションを提供してください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-481">For apps with an automatic save system, the app should offer an option to reset saved data to enable users to reset to a default play state.</span></span>

 <span data-ttu-id="7abb5-482">**セーブ データを管理するための UI にユーザーが常にアクセスできるようにする** アプリでは、バグのあるセーブ データが存在する場合でも、セーブ データの管理 UI にユーザーが常にアクセスできるようにしてください。</span><span class="sxs-lookup"><span data-stu-id="7abb5-482">**Ensure that users can always reach UI to manage saved games** Ensure that your app can always reach its management UI for saved games, even in the presence of buggy saved data.</span></span> <span data-ttu-id="7abb5-483">アプリのバグまたはデータの破損によってユーザーのセーブ データが読み取り不可能になった場合に、アプリでは、クラッシュが発生しない状態、またはプレイが阻止されない状態にまで、ユーザーが回復できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-483">If a user's saved data becomes unreadable due to an app bug or data corruption, the app should allow users to recover to a state that doesn't crash or prevent them from playing.</span></span>


## <a name="resources"></a><span data-ttu-id="7abb5-484">リソース</span><span class="sxs-lookup"><span data-stu-id="7abb5-484">Resources</span></span>

<span data-ttu-id="7abb5-485">これまでに示したリソースに加えて、以下のものがアプリまたはタイトルの開発に役立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="7abb5-485">In addition to resources suggested above, the following may be helpful in developing your app or title:</span></span>

-   <span data-ttu-id="7abb5-486">XDK ドキュメントの「接続ストレージの概要」</span><span class="sxs-lookup"><span data-stu-id="7abb5-486">Connected Storage Overview, in the XDK documentation</span></span>
-   <span data-ttu-id="7abb5-487">Game Developer Network (GDN) の「Samples」から入手可能な [Process Lifetime Management](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=ProcessLifetimeManagement_08_2013_qfe5.zip&folder=platform\aug2013xdk_qfe5\samples) サンプル</span><span class="sxs-lookup"><span data-stu-id="7abb5-487">[Process Lifetime Management](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=ProcessLifetimeManagement_08_2013_qfe5.zip&folder=platform\aug2013xdk_qfe5\samples), a sample available from Samples on Game Developer Network (GDN)</span></span>
-   <span data-ttu-id="7abb5-488">GDN の「ホワイト ペーパー」で提供されているホワイト ペーパー『[Xbox One のプロセス ライフタイム管理 (PLM)](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx)』</span><span class="sxs-lookup"><span data-stu-id="7abb5-488">["Process Lifetime Management (PLM) for Xbox One"](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx), a white paper available from White Papers on GDN</span></span>
