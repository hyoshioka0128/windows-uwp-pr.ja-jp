---
author: TylerMSFT
ms.assetid: 3a3ea86e-fa47-46ee-9e2e-f59644c0d1db
description: この記事では、アプリがバックグラウンドに移動したときにメモリ使用量を削減する方法について説明します。
title: アプリがバックグラウンド状態に移行したときのメモリ使用量の削減
ms.author: twhitney
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: eef1edc4e5c725756cdef788bf555f706621741d
ms.sourcegitcommit: ed0304b8a214c03b8aab74b8ef12c9f82b8e3c5f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/19/2018
ms.locfileid: "7288731"
---
# <a name="free-memory-when-your-app-moves-to-the-background"></a><span data-ttu-id="36384-104">アプリがバックグラウンドに移動したときのメモリの解放</span><span class="sxs-lookup"><span data-stu-id="36384-104">Free memory when your app moves to the background</span></span>

<span data-ttu-id="36384-105">この記事では、アプリが一時停止にされたり、場合によっては終了にされたりすることがないように、バックグラウンド状態に移行したアプリで使用するメモリの量を削減する方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="36384-105">This article shows you how to reduce the amount of memory that your app uses when it moves to the background state so that it won't be suspended and possibly terminated.</span></span>

## <a name="new-background-events"></a><span data-ttu-id="36384-106">新しいバックグラウンド イベント</span><span class="sxs-lookup"><span data-stu-id="36384-106">New background events</span></span>

<span data-ttu-id="36384-107">Windows 10 バージョン 1607 では、2 つ新しいアプリケーション ライフ サイクル イベント [**EnteredBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.EnteredBackground) および [**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground) が導入されています。</span><span class="sxs-lookup"><span data-stu-id="36384-107">Windows 10, version 1607, introduces two new application lifecycle events, [**EnteredBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.EnteredBackground) and [**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground).</span></span> <span data-ttu-id="36384-108">これらのイベントによって、バックグラウンドへの移行とバックグラウンドからの移行をアプリに通知できます。</span><span class="sxs-lookup"><span data-stu-id="36384-108">These events let your app know when it is entering and leaving the background.</span></span>

<span data-ttu-id="36384-109">アプリがバックグラウンドに移行すると、システムにより強制されるメモリ制限が変化する場合があります。</span><span class="sxs-lookup"><span data-stu-id="36384-109">When your app moves into the background, the memory constraints enforced by the system may change.</span></span> <span data-ttu-id="36384-110">これらのイベントを使用することで、バックグラウンドに移行しているアプリが中断されたり、場合によっては終了されたりしないように、現在のメモリ消費量を確認してリソースを解放し、制限値を下回っている状態を保ちます。</span><span class="sxs-lookup"><span data-stu-id="36384-110">Use these events to check your current memory consumption and free resources in order to stay below the limit so that your app won't be suspended and possibly terminated while it is in the background.</span></span>

### <a name="events-for-controlling-your-apps-memory-usage"></a><span data-ttu-id="36384-111">アプリのメモリ使用量を制御するイベント</span><span class="sxs-lookup"><span data-stu-id="36384-111">Events for controlling your app's memory usage</span></span>

<span data-ttu-id="36384-112">[MemoryManager.AppMemoryUsageLimitChanging](https://msdn.microsoft.com/library/windows/apps/windows.system.memorymanager.appmemoryusagelimitchanging.aspx) は、アプリで使用できる合計メモリの制限が変更される直前に発生します。</span><span class="sxs-lookup"><span data-stu-id="36384-112">[MemoryManager.AppMemoryUsageLimitChanging](https://msdn.microsoft.com/library/windows/apps/windows.system.memorymanager.appmemoryusagelimitchanging.aspx) is raised just before the limit of total memory the app can use is changed.</span></span> <span data-ttu-id="36384-113">たとえば、アプリがバックグラウンドに移行し、それが Xbox 上である場合、メモリ制限が 1024 MB から 128 MB に変更されます。</span><span class="sxs-lookup"><span data-stu-id="36384-113">For example, when the app moves into the background and on the Xbox the memory limit changes from 1024MB to 128MB.</span></span>  
<span data-ttu-id="36384-114">プラットフォームによってアプリが中断または終了されることを回避するには、このイベントを処理することが最も重要になります。</span><span class="sxs-lookup"><span data-stu-id="36384-114">This is the most important event to handle to keep the platform from suspending or terminating the app.</span></span>

<span data-ttu-id="36384-115">[MemoryManager.AppMemoryUsageIncreased](https://msdn.microsoft.com/library/windows/apps/windows.system.memorymanager.appmemoryusageincreased.aspx) は、アプリのメモリ消費量が [AppMemoryUsageLevel](https://msdn.microsoft.com/library/windows/apps/windows.system.appmemoryusagelevel.aspx) 列挙値の高い値まで増加したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="36384-115">[MemoryManager.AppMemoryUsageIncreased](https://msdn.microsoft.com/library/windows/apps/windows.system.memorymanager.appmemoryusageincreased.aspx) is raised when the app's memory consumption has increased to a higher value in the [AppMemoryUsageLevel](https://msdn.microsoft.com/library/windows/apps/windows.system.appmemoryusagelevel.aspx) enumeration.</span></span> <span data-ttu-id="36384-116">たとえば、**Low** から **Medium** まで増加した場合です。</span><span class="sxs-lookup"><span data-stu-id="36384-116">For example, from **Low** to **Medium**.</span></span> <span data-ttu-id="36384-117">このイベントの処理は省略可能ですが、制限未満に留まることについてはまだアプリに責任があるため、処理することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="36384-117">Handling this event is optional but recommended because the application is still responsible for staying under the limit.</span></span>

<span data-ttu-id="36384-118">[MemoryManager.AppMemoryUsageDecreased](https://msdn.microsoft.com/library/windows/apps/windows.system.memorymanager.appmemoryusagedecreased.aspx) は、アプリのメモリ消費量が **AppMemoryUsageLevel** 列挙値の低い値まで減少したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="36384-118">[MemoryManager.AppMemoryUsageDecreased](https://msdn.microsoft.com/library/windows/apps/windows.system.memorymanager.appmemoryusagedecreased.aspx) is raised when the app's memory consumption has decreased to a lower value in the **AppMemoryUsageLevel** enumeration.</span></span> <span data-ttu-id="36384-119">たとえば、**High** から **Low** まで減少した場合です。</span><span class="sxs-lookup"><span data-stu-id="36384-119">For example, from **High** to **Low**.</span></span> <span data-ttu-id="36384-120">このイベントの処理は省略可能ですが、処理することによって必要に応じてアプリで追加のメモリを割り当てられる可能性があることが示されます。</span><span class="sxs-lookup"><span data-stu-id="36384-120">Handling this event is optional but indicates the application may be able to allocate additional memory if needed.</span></span>

## <a name="handle-the-transition-between-foreground-and-background"></a><span data-ttu-id="36384-121">フォアグラウンドとバックグラウンドの間の移行の処理</span><span class="sxs-lookup"><span data-stu-id="36384-121">Handle the transition between foreground and background</span></span>

<span data-ttu-id="36384-122">アプリがフォアグラウンドからバックグラウンドに移動すると、[**EnteredBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.EnteredBackground) イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="36384-122">When your app moves from the foreground to the background, the [**EnteredBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.EnteredBackground) event is raised.</span></span> <span data-ttu-id="36384-123">アプリがフォアグラウンドに戻るときには、[**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground) イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="36384-123">When your app returns to the foreground, the [**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground) event is raised.</span></span> <span data-ttu-id="36384-124">アプリの作成時にこれらのイベントのハンドラーを登録できます。</span><span class="sxs-lookup"><span data-stu-id="36384-124">You can register handlers for these events when your app is created.</span></span> <span data-ttu-id="36384-125">既定のプロジェクト テンプレートでは、これは、App.xaml.cs の **App** クラス コンストラクターで行われます。</span><span class="sxs-lookup"><span data-stu-id="36384-125">In the default project template, this is done in the **App** class constructor in App.xaml.cs.</span></span>

<span data-ttu-id="36384-126">バックグラウンドで実行すると、アプリが保持することを許可されているメモリ リソースが減少するため、[**AppMemoryUsageIncreased**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageIncreased) と [**AppMemoryUsageLimitChanging**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageLimitChanging) イベントについても登録する必要があります。これらは、アプリの現在のメモリ使用量と、現在の制限を確認するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="36384-126">Because running in the background will reduce the memory resources your app is allowed to retain, you should also register for the [**AppMemoryUsageIncreased**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageIncreased) and [**AppMemoryUsageLimitChanging**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageLimitChanging) events which you can use to check your app's current memory usage and the current limit.</span></span> <span data-ttu-id="36384-127">これらのイベントのハンドラーを、次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="36384-127">The handlers for these events are shown in the following examples.</span></span> <span data-ttu-id="36384-128">UWP アプリのアプリケーション ライフサイクルについて詳しくは、「[アプリのライフサイクル](..//launch-resume/app-lifecycle.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="36384-128">For more information on the application lifecycle for UWP apps, see [App lifecycle](..//launch-resume/app-lifecycle.md).</span></span>

[!code-cs[RegisterEvents](./code/ReduceMemory/cs/App.xaml.cs#SnippetRegisterEvents)]

<span data-ttu-id="36384-129">[**EnteredBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.EnteredBackground) イベントが発生したときに、現在バックグラウンドで実行していることを示す追跡変数を設定します。</span><span class="sxs-lookup"><span data-stu-id="36384-129">When the [**EnteredBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.EnteredBackground) event is raised, set the tracking variable to indicate that you are currently running in the background.</span></span> <span data-ttu-id="36384-130">これは、メモリ使用量を削減するためのコードを記述する際に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="36384-130">This will be useful when you write the code for reducing memory usage.</span></span>

[!code-cs[EnteredBackground](./code/ReduceMemory/cs/App.xaml.cs#SnippetEnteredBackground)]

<span data-ttu-id="36384-131">アプリがバックグラウンドに移行するときに、現在のフォアグラウンド アプリが応答性の高いユーザー エクスペリエンスを提供するために十分なリソースを確保できるように、システムによってアプリのメモリ制限が低減されます。</span><span class="sxs-lookup"><span data-stu-id="36384-131">When your app transitions to the background, the system reduces the memory limit for the app to ensure that the current foreground app has sufficient resources to provide a responsive user experience</span></span>

<span data-ttu-id="36384-132">[**AppMemoryUsageLimitChanging**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageLimitChanging) イベント ハンドラーによって、割り当てられたメモリが削減されたことをアプリに通知することができ、ハンドラーに渡されるイベント引数で新しい制限を提供します。</span><span class="sxs-lookup"><span data-stu-id="36384-132">The [**AppMemoryUsageLimitChanging**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageLimitChanging) event handler lets your app know that its allotted memory has been reduced and provides the new limit in the event arguments passed into the handler.</span></span> <span data-ttu-id="36384-133">アプリの現在のメモリ使用量を提供する [**MemoryManager.AppMemoryUsage**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsage) プロパティと、新しい制限を指定するイベント引数の [**NewLimit**](https://msdn.microsoft.com/library/windows/apps/Windows.System.AppMemoryUsageLimitChangingEventArgs.NewLimit) プロパティを比較してください。</span><span class="sxs-lookup"><span data-stu-id="36384-133">Compare the [**MemoryManager.AppMemoryUsage**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsage) property, which provides your app's current usage, to the [**NewLimit**](https://msdn.microsoft.com/library/windows/apps/Windows.System.AppMemoryUsageLimitChangingEventArgs.NewLimit) property of the event arguments, which specifies the new limit.</span></span> <span data-ttu-id="36384-134">メモリ使用量が制限を超えている場合は、メモリ使用量を削減する必要があります。</span><span class="sxs-lookup"><span data-stu-id="36384-134">If your memory usage exceeds the limit, you need to reduce your memory usage.</span></span>

<span data-ttu-id="36384-135">この例では、この処理はヘルパー メソッド **ReduceMemoryUsage** で実行されます。このメソッドの定義については、後で説明します。</span><span class="sxs-lookup"><span data-stu-id="36384-135">In this example, this is done in the helper method **ReduceMemoryUsage**, which is defined later in this article.</span></span>

[!code-cs[MemoryUsageLimitChanging](./code/ReduceMemory/cs/App.xaml.cs#SnippetMemoryUsageLimitChanging)]

> [!NOTE]
> <span data-ttu-id="36384-136">デバイス構成によって、システム リソースが不足するまで新しいメモリ制限でアプリケーションの実行を続けることができる場合とできない場合があります。</span><span class="sxs-lookup"><span data-stu-id="36384-136">Some device configurations will allow an application to continue running over the new memory limit until the system experiences resource pressure, and some will not.</span></span> <span data-ttu-id="36384-137">特に Xbox では、アプリが 2 秒以内にメモリ使用量を新しい制限未満に減らさない場合、アプリは中断または終了されます。</span><span class="sxs-lookup"><span data-stu-id="36384-137">On Xbox, in particular, apps will be suspended or terminated if they do not reduce memory to under the new limits within 2 seconds.</span></span> <span data-ttu-id="36384-138">つまり、このイベントを使用して、イベントの発生から 2 秒以内にリソースの使用量を制限未満に減らすことにより、幅広いデバイスで最適なエクスペリエンスを提供できます。</span><span class="sxs-lookup"><span data-stu-id="36384-138">This means that you can deliver the best experience across the broadest range of devices by using this event to reduce resource usage below the limit within 2 seconds of the event being raised.</span></span>

<span data-ttu-id="36384-139">アプリが最初にバックグラウンドに移行した時点でアプリの現在のメモリ使用量がバックグラウンド アプリのメモリ制限を下回っていても、時間の経過と共にメモリ消費量が増加し、この制限に接近し始める可能性があります。</span><span class="sxs-lookup"><span data-stu-id="36384-139">It is possible that although your app's memory usage is currently under the memory limit for background apps when it first transitions to the background, it may increase its memory consumption over time and begin to approach the limit.</span></span> <span data-ttu-id="36384-140">[**AppMemoryUsageIncreased**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageIncreased) ハンドラーによって、メモリ使用量が増加したときに現在の使用量を確認し、必要に応じて、メモリを解放する機会を得ることができます。</span><span class="sxs-lookup"><span data-stu-id="36384-140">The handler the [**AppMemoryUsageIncreased**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageIncreased) provides an opportunity to check your current usage when it increases and, if necessary, free memory.</span></span>

<span data-ttu-id="36384-141">[**AppMemoryUsageLevel**](https://msdn.microsoft.com/library/windows/apps/Windows.System.AppMemoryUsageLevel) が **High** または **OverLimit** になっていないかどうかを確認し、これらの値になっている場合はメモリ使用量を減らします。</span><span class="sxs-lookup"><span data-stu-id="36384-141">Check to see if the [**AppMemoryUsageLevel**](https://msdn.microsoft.com/library/windows/apps/Windows.System.AppMemoryUsageLevel) is **High** or **OverLimit**, and if so, reduce your memory usage.</span></span> <span data-ttu-id="36384-142">この例では、これはヘルパー メソッド **ReduceMemoryUsage** によって処理されます。</span><span class="sxs-lookup"><span data-stu-id="36384-142">In this example this is handled by the helper method, **ReduceMemoryUsage**.</span></span> <span data-ttu-id="36384-143">[**AppMemoryUsageDecreased**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageDecreased) イベントを受信登録して、アプリのメモリ使用量が制限未満であるかどうかを確認でき、制限未満である場合は追加のリソースを割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="36384-143">You can also subscribe to the [**AppMemoryUsageDecreased**](https://msdn.microsoft.com/library/windows/apps/Windows.System.MemoryManager.AppMemoryUsageDecreased) event, check to see if your app is under the limit, and if so then you know you can allocate additional resources.</span></span>

[!code-cs[MemoryUsageIncreased](./code/ReduceMemory/cs/App.xaml.cs#SnippetMemoryUsageIncreased)]

<span data-ttu-id="36384-144">**ReduceMemoryUsage** は、バックグラウンドで実行されているアプリがメモリ使用量の制限を超えている場合にメモリを解放するために実装できるヘルパー メソッドです。</span><span class="sxs-lookup"><span data-stu-id="36384-144">**ReduceMemoryUsage** is a helper method that you can implement to release memory when your app is over the usage limit while running in the background.</span></span> <span data-ttu-id="36384-145">メモリを解放する方法はアプリの仕様によって異なりますが、推奨されるメモリ解放の方法の 1 つは、UI と、アプリ ビューに関連付けられている他のリソースを破棄することです。</span><span class="sxs-lookup"><span data-stu-id="36384-145">How you release memory depends on the specifics of your app, but one recommended way to free up memory is to dispose of your UI and the other resources associated with your app view.</span></span> <span data-ttu-id="36384-146">そのためには、バックグラウンド状態で実行されていることを確認してから、アプリのウィンドウの [**Content**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Window.Content) プロパティを `null` に設定します。次に、UI イベント ハンドラーを登録解除し、存在する可能性があるそのページへのその他の参照をすべて削除します。</span><span class="sxs-lookup"><span data-stu-id="36384-146">To do so, ensure that you are running in the background state then set the [**Content**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Window.Content) property of your app's window to `null` and unregister your UI event handlers and remove any other references you may have to the page.</span></span> <span data-ttu-id="36384-147">UI イベント ハンドラーの登録を解除しないで、存在する可能性があるそのページへのその他の参照をすべてクリアすると、ページ リソースが解放されません。</span><span class="sxs-lookup"><span data-stu-id="36384-147">Failing to unregister your UI event handlers and clearing any other references you may have to the page will prevent the page resources from being released.</span></span> <span data-ttu-id="36384-148">次に、**GC.Collect** を呼び出して、解放されたメモリをすぐに再利用します。</span><span class="sxs-lookup"><span data-stu-id="36384-148">Then call **GC.Collect** to reclaim the freed up memory immediately.</span></span> <span data-ttu-id="36384-149">通常、ガベージ コレクションはシステムが処理するため、強制的に実行したくはありません。</span><span class="sxs-lookup"><span data-stu-id="36384-149">Typically you don't force garbage collection because the system will take care of it for you.</span></span> <span data-ttu-id="36384-150">この特定のケースでは、アプリケーションをバックグラウンドに移行する際にこのアプリケーションに割り当てられるメモリ量を減らすことで、メモリを再利用するためにアプリケーションを終了する必要があるとシステムが判断する可能性を減らしています。</span><span class="sxs-lookup"><span data-stu-id="36384-150">In this specific case, we are reducing the amount of memory charged to this application as it goes into the background to reduce the likelihood that the system will determine that it should terminate the app to reclaim memory.</span></span>

[!code-cs[UnloadViewContent](./code/ReduceMemory/cs/App.xaml.cs#SnippetUnloadViewContent)]

<span data-ttu-id="36384-151">ウィンドウのコンテンツが収集されると、各フレームでは、その切断プロセスが開始されます。</span><span class="sxs-lookup"><span data-stu-id="36384-151">When the window content is collected, each Frame begins its disconnection process.</span></span> <span data-ttu-id="36384-152">ビジュアル オブジェクト ツリーで、ウィンドウのコンテンツの下に Page がある場合、これらはその Unloaded イベントを発生を開始します。</span><span class="sxs-lookup"><span data-stu-id="36384-152">If there are Pages in the visual object tree under the window content, these will begin firing their Unloaded event.</span></span> <span data-ttu-id="36384-153">Page は、Page へのすべての参照を削除しない限り、メモリから完全には消去できません。</span><span class="sxs-lookup"><span data-stu-id="36384-153">Pages cannot be completely cleared from memory unless all references to them are removed.</span></span> <span data-ttu-id="36384-154">Unloaded コールバックでは、メモリが直ちに解放されるように次の処理を行います。</span><span class="sxs-lookup"><span data-stu-id="36384-154">In the Unloaded callback, do the following to ensure that memory is quickly freed:</span></span>
* <span data-ttu-id="36384-155">Page 内の大規模なデータ構造体を消去して `null` に設定します。</span><span class="sxs-lookup"><span data-stu-id="36384-155">Clear and set any large data structures in your Page to `null`.</span></span>
* <span data-ttu-id="36384-156">Page 内でコールバック メソッドを持つすべてのイベント ハンドラーの登録を解除します。</span><span class="sxs-lookup"><span data-stu-id="36384-156">Unregister all event handlers that have callback methods within the Page.</span></span> <span data-ttu-id="36384-157">Page の Loaded イベント ハンドラーで、これらのコールバックを確実に登録します。</span><span class="sxs-lookup"><span data-stu-id="36384-157">Make sure to register those callbacks during the Loaded event handler for the Page.</span></span> <span data-ttu-id="36384-158">Loaded イベントは、UI が再構築され、Page がビジュアル オブジェクト ツリーに追加されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="36384-158">The Loaded event is raised when the UI has been reconstituted and the Page has been added to the visual object tree.</span></span>
* <span data-ttu-id="36384-159">Unloaded コールバックの最後に `GC.Collect` を呼び出して、先ほど `null` に設定した大規模なデータ構造体のガベージ コレクションをすばやく実行します。</span><span class="sxs-lookup"><span data-stu-id="36384-159">Call `GC.Collect` at the end of the Unloaded callback to quickly garbage collect any of the large data structures you have just set to `null`.</span></span> <span data-ttu-id="36384-160">通常、ガベージ コレクションはシステムが処理するため、強制的に実行したくはありません。</span><span class="sxs-lookup"><span data-stu-id="36384-160">Again, typically you don't force garbage collection because the system will take care of it for you.</span></span> <span data-ttu-id="36384-161">この特定のケースでは、アプリケーションをバックグラウンドに移行する際にこのアプリケーションに割り当てられるメモリ量を減らすことで、メモリを再利用するためにアプリケーションを終了する必要があるとシステムが判断する可能性を減らしています。</span><span class="sxs-lookup"><span data-stu-id="36384-161">In this specific case, we are reducing the amount of memory charged to this application as it goes into the background to reduce the likelihood that the system will determine that it should terminate the app to reclaim memory.</span></span>

[!code-cs[MainPageUnloaded](./code/ReduceMemory/cs/App.xaml.cs#SnippetMainPageUnloaded)]

<span data-ttu-id="36384-162">[**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground) イベント ハンドラーで、アプリがバックグラウンドで実行されなくなったことを示すために追跡変数 (`isInBackgroundMode`) を設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="36384-162">In the [**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground) event handler, set the tracking variable (`isInBackgroundMode`) to indicate that your app is no longer running in the background.</span></span> <span data-ttu-id="36384-163">次に、現在のウィンドウの [**Content**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Window.Content) が `null` であるかどうかを確認します。バックグラウンドでの実行中にメモリを消去するためにアプリ ビューを破棄した場合は、null になります。</span><span class="sxs-lookup"><span data-stu-id="36384-163">Next, check to see if the [**Content**](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Window.Content) of the current window is `null`-- which it will be if you disposed of your app views in order to clear up memory while you were running in the background.</span></span> <span data-ttu-id="36384-164">ウィンドウのコンテンツが `null` の場合は、アプリ ビューを再構築します。</span><span class="sxs-lookup"><span data-stu-id="36384-164">If the window content is `null`, rebuild your app view.</span></span> <span data-ttu-id="36384-165">この例では、ウィンドウのコンテンツは、**CreateRootFrame** ヘルパー メソッドで作成されます。</span><span class="sxs-lookup"><span data-stu-id="36384-165">In this example, the window content is created in the helper method **CreateRootFrame**.</span></span>

[!code-cs[LeavingBackground](./code/ReduceMemory/cs/App.xaml.cs#SnippetLeavingBackground)]

<span data-ttu-id="36384-166">**CreateRootFrame** ヘルパー メソッドは、アプリ ビューのコンテンツを再作成します。</span><span class="sxs-lookup"><span data-stu-id="36384-166">The **CreateRootFrame** helper method recreates the view content for your app.</span></span> <span data-ttu-id="36384-167">このメソッドのコードは、既定のプロジェクト テンプレートで提供される [**OnLaunched**](https://msdn.microsoft.com/library/windows/apps/br242335) ハンドラーのコードとほぼ同じです。</span><span class="sxs-lookup"><span data-stu-id="36384-167">The code in this method is nearly identical to the [**OnLaunched**](https://msdn.microsoft.com/library/windows/apps/br242335) handler code provided in the default project template.</span></span> <span data-ttu-id="36384-168">1 つ異なる点は、**Launching** ハンドラーが [**LaunchActivatedEventArgs**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Activation.LaunchActivatedEventArgs) の [**PreviousExecutionState**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.PreviousExecutionState) プロパティから以前の実行状態を特定するのに対して、**CreateRootFrame** メソッドは単に引数として渡される以前の実行状態を取得します。</span><span class="sxs-lookup"><span data-stu-id="36384-168">The one difference is that the **Launching** handler determines the previous execution state from the [**PreviousExecutionState**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Activation.LaunchActivatedEventArgs.PreviousExecutionState) property of the [**LaunchActivatedEventArgs**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Activation.LaunchActivatedEventArgs) and the **CreateRootFrame** method simply gets the previous execution state passed in as an argument.</span></span> <span data-ttu-id="36384-169">重複するコードを最小限に抑えるには、既定の **Launching** イベント ハンドラーのコードをリファクタリングして、**CreateRootFrame** を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="36384-169">To minimize duplicated code, you can refactor the default **Launching** event handler code to call **CreateRootFrame**.</span></span>

[!code-cs[CreateRootFrame](./code/ReduceMemory/cs/App.xaml.cs#SnippetCreateRootFrame)]

## <a name="guidelines"></a><span data-ttu-id="36384-170">ガイドライン</span><span class="sxs-lookup"><span data-stu-id="36384-170">Guidelines</span></span>

### <a name="moving-from-the-foreground-to-the-background"></a><span data-ttu-id="36384-171">フォアグラウンドからバックグラウンドへの移動</span><span class="sxs-lookup"><span data-stu-id="36384-171">Moving from the foreground to the background</span></span>

<span data-ttu-id="36384-172">アプリがフォアグラウンドからバックグラウンドに移動すると、アプリの代わりにシステムによって、必要のないバックグラウンドのリソースを解放する動作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="36384-172">When an app moves from the foreground to the background, the system does work on behalf of the app to free up resources that are not needed in the background.</span></span> <span data-ttu-id="36384-173">たとえば、アプリに代わって UI フレームワークによってキャッシュ済みのテクスチャがフラッシュされ、ビデオ サブシステムによって割り当て済みのメモリが解放されます。</span><span class="sxs-lookup"><span data-stu-id="36384-173">For example, the UI frameworks flush cached textures and the video subsystem frees memory allocated on behalf of the app.</span></span> <span data-ttu-id="36384-174">ただし、システムによって中断されたり終了されたりすることを避けるために、アプリでは引き続きメモリ使用量を注意深く監視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="36384-174">However, an app will still need to carefully monitor its memory usage to avoid being suspended or terminated by the system.</span></span>

<span data-ttu-id="36384-175">アプリがフォアグラウンドからバックグラウンドに移動すると、アプリはまず **EnteredBackground** イベントを受け取り、次に **AppMemoryUsageLimitChanging** イベントを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="36384-175">When an app moves from the foreground to the background it will first get an **EnteredBackground** event and then a **AppMemoryUsageLimitChanging** event.</span></span>

- <span data-ttu-id="36384-176">**必ず**、**EnteredBackground** イベントを使用して、バックグラウンドでの実行中にアプリで必要とされないことがわかっている UI リソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="36384-176">**Do** use the **EnteredBackground** event to free up UI resources that you know your app does not need while running in the background.</span></span> <span data-ttu-id="36384-177">たとえば、曲のカバー アート画像を解放できます。</span><span class="sxs-lookup"><span data-stu-id="36384-177">For example, you could free the cover art image for a song.</span></span>
- <span data-ttu-id="36384-178">**必ず**、**AppMemoryUsageLimitChanging** イベントを使用して、アプリで使用しているメモリが新しいバックグラウンド制限を下回っていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="36384-178">**Do** use the **AppMemoryUsageLimitChanging** event to ensure that your app is using less memory than the new background limit.</span></span> <span data-ttu-id="36384-179">下回っていない場合は必ずリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="36384-179">Make sure that you free up resources if not.</span></span> <span data-ttu-id="36384-180">解放しなければ、デバイス固有のポリシーに従ってアプリが中断または終了される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="36384-180">If you do not, your app may be suspended or terminated according to device specific policy.</span></span>
- <span data-ttu-id="36384-181">**必ず**、**AppMemoryUsageLimitChanging** イベントの発生時にアプリで新しいメモリ制限を超えている場合は手動でガーベジ コレクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="36384-181">**Do** manually invoke the garbage collector if your app is over the new memory limit when the **AppMemoryUsageLimitChanging** event is raised.</span></span>
- <span data-ttu-id="36384-182">メモリ使用量の変化が予測される場合は、**必ず**、**AppMemoryUsageIncreased** イベントを使用して、バックグラウンドで実行中のアプリのメモリ使用量を継続的に監視します。</span><span class="sxs-lookup"><span data-stu-id="36384-182">**Do** use the **AppMemoryUsageIncreased** event to continue to monitor your app’s memory usage while running in the background if you expect it to change.</span></span> <span data-ttu-id="36384-183">**AppMemoryUsageLevel** が **High** または **OverLimit** の場合は、リソースが解放されるようにします。</span><span class="sxs-lookup"><span data-stu-id="36384-183">If the **AppMemoryUsageLevel** is **High** or **OverLimit** make sure that you free up resources.</span></span>
- <span data-ttu-id="36384-184">パフォーマンス最適化として、**EnteredBackground** ハンドラーではなく、**AppMemoryUsageLimitChanging** イベント ハンドラーで UI リソースを解放することを**考慮**します。</span><span class="sxs-lookup"><span data-stu-id="36384-184">**Consider** freeing UI resources in the **AppMemoryUsageLimitChanging** event handler instead of in the **EnteredBackground** handler as a performance optimization.</span></span> <span data-ttu-id="36384-185">**EnteredBackground/LeavingBackground** イベント ハンドラーでブール値セットを使用し、アプリがバックグラウンドで動作しているかフォアグラウンドで動作しているかを追跡します。</span><span class="sxs-lookup"><span data-stu-id="36384-185">Use a boolean value set in the **EnteredBackground/LeavingBackground** event handlers to track whether the app is in the background or foreground.</span></span> <span data-ttu-id="36384-186">次に、**AppMemoryUsageLimitChanging** イベント ハンドラーで、**AppMemoryUsage** が制限を超えていて、アプリがバックグラウンドで動作している場合は (ブール値に基づく)、UI リソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="36384-186">Then in the **AppMemoryUsageLimitChanging** event handler, if **AppMemoryUsage** is over the limit and the app is in the background (based on the Boolean value) you can free UI resources.</span></span>
- <span data-ttu-id="36384-187">**EnteredBackground** イベントでは時間がかかる操作を実行**しないでください**。アプリケーション間の移行がユーザーに対して遅く表示される可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="36384-187">**Do not** perform long running operations in the **EnteredBackground** event because you can cause the transition between applications to appear slow to the user.</span></span>

### <a name="moving-from-the-background-to-the-foreground"></a><span data-ttu-id="36384-188">バックグラウンドからフォアグラウンドへの移動</span><span class="sxs-lookup"><span data-stu-id="36384-188">Moving from the background to the foreground</span></span>

<span data-ttu-id="36384-189">アプリがバックグラウンドからフォアグラウンドに移動すると、アプリはまず **AppMemoryUsageLimitChanging** イベントを受け取り、次に **LeavingBackground** イベントを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="36384-189">When an app moves from the background to the foreground, the app will first get an **AppMemoryUsageLimitChanging** event and then a **LeavingBackground** event.</span></span>

- <span data-ttu-id="36384-190">**必ず**、**LeavingBackground** イベントを使用して、バックグラウンドに移動したときに破棄した UI リソースを再作成します。</span><span class="sxs-lookup"><span data-stu-id="36384-190">**Do** use the **LeavingBackground** event to recreate UI resources that your app discarded when moving into the background.</span></span>

## <a name="related-topics"></a><span data-ttu-id="36384-191">関連トピック</span><span class="sxs-lookup"><span data-stu-id="36384-191">Related topics</span></span>

* <span data-ttu-id="36384-192">[バックグラウンド メディア再生のサンプル](http://go.microsoft.com/fwlink/p/?LinkId=800141) - アプリがバックグラウンド状態に移行するときにメモリを解放する方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="36384-192">[Background media playback sample](http://go.microsoft.com/fwlink/p/?LinkId=800141) - shows how to free memory when your app moves to the background state.</span></span>
* <span data-ttu-id="36384-193">[診断ツール](https://blogs.msdn.microsoft.com/visualstudioalm/2015/01/16/diagnostic-tools-debugger-window-in-visual-studio-2015/) - 診断ツールを使用して、ガベージ コレクション イベントを監視し、予想される方法によりアプリでメモリが解放されているかどうかを検証します。</span><span class="sxs-lookup"><span data-stu-id="36384-193">[Diagnostic Tools](https://blogs.msdn.microsoft.com/visualstudioalm/2015/01/16/diagnostic-tools-debugger-window-in-visual-studio-2015/) - use the diagnostic tools to observe garbage collection events and validate that your app is releasing memory the way you expect it to.</span></span>
