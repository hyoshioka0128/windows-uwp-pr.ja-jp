---
author: TylerMSFT
title: Windows 10 UWP アプリのライフサイクル
description: このトピックでは、Windows 10 ユニバーサル Windows プラットフォーム (UWP) アプリのライフサイクル (アプリがアクティブ化されたときから、アプリが閉じられるまで) について説明します。
keywords: アプリのライフサイクル 中断 再開 起動 アクティブ化
ms.assetid: 6C469E77-F1E3-4859-A27B-C326F9616D10
ms.author: twhitney
ms.date: 01/23/2018
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: cf8496393c5b500ab30d08608e90a0e156422ce3
ms.sourcegitcommit: e814a13978f33654d8e995584f4b047cb53e0aef
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/05/2018
ms.locfileid: "6035644"
---
# <a name="windows-10-universal-windows-platform-uwp-app-lifecycle"></a><span data-ttu-id="fbb31-104">Windows 10 ユニバーサル Windows プラットフォーム (UWP) アプリのライフサイクル</span><span class="sxs-lookup"><span data-stu-id="fbb31-104">Windows 10 universal Windows platform (UWP) app lifecycle</span></span>


<span data-ttu-id="fbb31-105">このトピックでは、ユニバーサル Windows プラットフォーム (UWP) アプリのライフサイクル (アプリが起動されたときから、アプリが閉じられるまで) について説明します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-105">This topic describes the lifecycle of a Universal Windows Platform (UWP) app from the time it is launched until it is closed.</span></span>

## <a name="a-little-history"></a><span data-ttu-id="fbb31-106">簡単な経緯</span><span class="sxs-lookup"><span data-stu-id="fbb31-106">A little history</span></span>

<span data-ttu-id="fbb31-107">Windows 8 より前は、アプリのライフサイクルは単純でした。</span><span class="sxs-lookup"><span data-stu-id="fbb31-107">Before Windows 8, apps had a simple lifecycle.</span></span> <span data-ttu-id="fbb31-108">Win32 アプリや .NET アプリは、実行されているか、実行されていないかのどちらかです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-108">Win32 and .NET apps are either running or not running.</span></span> <span data-ttu-id="fbb31-109">ユーザーがアプリを最小化し、他のアプリに切り替えても、アプリは引き続き実行されています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-109">When a user minimizes them, or switches away from them, they continue to run.</span></span> <span data-ttu-id="fbb31-110">ポータブル デバイスが台頭し、電源管理がますます重要になるまでは、これで問題はありませんでした。</span><span class="sxs-lookup"><span data-stu-id="fbb31-110">This was fine until portable devices and power management became increasingly important.</span></span>

<span data-ttu-id="fbb31-111">Windows 8 では、UWP アプリにより新しいアプリケーション モデルが導入されました。</span><span class="sxs-lookup"><span data-stu-id="fbb31-111">Windows 8 introduced a new application model with UWP apps.</span></span> <span data-ttu-id="fbb31-112">大まかに言うと、新しい中断状態が追加されました。</span><span class="sxs-lookup"><span data-stu-id="fbb31-112">At a high level, a new suspended state was added.</span></span> <span data-ttu-id="fbb31-113">UWP アプリは、ユーザーがアプリを最小化するか、別のアプリに切り替えた後、すぐに中断されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-113">A UWP app is suspended shortly after the user minimizes it or switches to another app.</span></span> <span data-ttu-id="fbb31-114">つまり、アプリのスレッドは停止し、オペレーティング システムがリソースを再利用する必要がある場合を除き、アプリはメモリ内に残ります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-114">This means that the app's threads are stopped and the app is left in memory unless the operating system needs to reclaim resources.</span></span> <span data-ttu-id="fbb31-115">ユーザーが元のアプリに切り替えると、アプリはすばやく実行中の状態に復元されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-115">When the user switches back to the app, it can be quickly restored to a running state.</span></span>

<span data-ttu-id="fbb31-116">アプリがバックグラウンドにあるときに、アプリの実行を継続する必要がある場合、さまざまな方法があります。[バックグラウンド タスク](support-your-app-with-background-tasks.md)、[延長実行](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.extendedexecution.aspx)、アクティビティ スポンサード実行 (たとえば、アプリが[バックグラウンドでのメディアの再生](https://msdn.microsoft.com/windows/uwp/audio-video-camera/background-audio)を続行できるようにする **BackgroundMediaEnabled** 機能) などです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-116">There are various ways for apps that need to continue to run when they are in the background such as [background tasks](support-your-app-with-background-tasks.md), [extended execution](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.extendedexecution.aspx), and activity sponsored execution (for example, the **BackgroundMediaEnabled** capability which allows an app to continue to [play media in the background](https://msdn.microsoft.com/windows/uwp/audio-video-camera/background-audio)).</span></span> <span data-ttu-id="fbb31-117">また、バックグラウンド転送操作は、アプリが中断または終了した場合でも続行できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-117">Also, background transfer operations can continue even if your app is suspended or even terminated.</span></span> <span data-ttu-id="fbb31-118">詳しくは、「[ファイルのダウンロード方法](https://msdn.microsoft.com/library/windows/apps/xaml/jj152726.aspx#downloading_a_file_using_background_transfer)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-118">For more info, see [How to download a file](https://msdn.microsoft.com/library/windows/apps/xaml/jj152726.aspx#downloading_a_file_using_background_transfer).</span></span>

<span data-ttu-id="fbb31-119">既定では、フォアグラウンドにないアプリは中断され、その結果として、電力が節約され、現在フォアグラウンドにあるアプリが利用できるリソースが増加します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-119">By default, apps that are not in the foreground are suspended which results in power savings and more resources available for the app currently in the foreground.</span></span>

<span data-ttu-id="fbb31-120">中断状態では、オペレーティング システムはリソースを解放するためには中断中のアプリを終了することがあるため、開発者にとっては新しい要件が追加されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-120">The suspended state adds new requirements for you as a developer because the operating system may elect to terminate a suspended app in order to free up resources.</span></span> <span data-ttu-id="fbb31-121">終了されたアプリは、引き続きタスク バーに表示されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-121">The terminated app will still appear in the task bar.</span></span> <span data-ttu-id="fbb31-122">ユーザーがこのアプリをクリックした場合、アプリは終了される前の状態を復元する必要があります。ユーザーは、システムがアプリを閉じたことを認識できないためです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-122">When the user click on it, the app must restore the state that it was in before it was terminated because the user will not be aware that the system closed the app.</span></span> <span data-ttu-id="fbb31-123">ユーザーは、他の作業を行っている間、アプリがバックグラウンドで待機していたと考え、他のアプリに切り替えたときと同じ状態であることを期待しています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-123">They will think that it has been waiting in the background while they were doing other things and will expect it to be in the same state it was in when they left it.</span></span> <span data-ttu-id="fbb31-124">このトピックでは、これを実現する方法について取り上げます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-124">In this topic we will look at how to accomplish that.</span></span>

<span data-ttu-id="fbb31-125">Windows 10 バージョン 1607 では、もう 2 つのアプリ モデルの状態が導入されています。**フォアグラウンドでの実行**と**バックグラウンドでの実行**です。</span><span class="sxs-lookup"><span data-stu-id="fbb31-125">Windows 10, version 1607, introduces two more app model states: **Running in foreground** and **Running in background**.</span></span> <span data-ttu-id="fbb31-126">以下のセクションでこれらの新しい状態についても説明します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-126">We will also look at these new states in the sections that follow.</span></span>

## <a name="app-execution-state"></a><span data-ttu-id="fbb31-127">アプリの実行状態</span><span class="sxs-lookup"><span data-stu-id="fbb31-127">App execution state</span></span>

<span data-ttu-id="fbb31-128">次の図は、Windows 10、バージョン 1607 以降での、可能なアプリ モデルの状態を表しています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-128">This illustration represents the possible app model states starting in Windows 10, version 1607.</span></span> <span data-ttu-id="fbb31-129">UWP アプリの一般的なライフサイクルを順に見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="fbb31-129">Let's walk through the typical lifecycle of a UWP app.</span></span>

![アプリの実行状態が切り替わるようすを示す状態図](images/updated-lifecycle.png)

<span data-ttu-id="fbb31-131">アプリは、起動またはアクティブ化されると、バックグラウンドでの実行状態になります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-131">Apps enter the running in background state when they are launched or activated.</span></span> <span data-ttu-id="fbb31-132">アプリを取得し、アプリがフォアグラウンドで起動したためにフォアグラウンドに移動する必要がある場合、アプリは [**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground) イベントを取得します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-132">If the app needs to move into the foreground due to a foreground app launch, the app then gets the [**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground) event.</span></span>

<span data-ttu-id="fbb31-133">「起動」と「アクティブ化」の用語は似ているように見えますが、オペレーティング システムがアプリを起動する際の異なる方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-133">Although "launched" and "activated" may seem like similar terms, they refer to different ways the operating system may start your app.</span></span> <span data-ttu-id="fbb31-134">まず、アプリの起動を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="fbb31-134">Let's first look at launching an app.</span></span>

## <a name="app-launch"></a><span data-ttu-id="fbb31-135">アプリの起動</span><span class="sxs-lookup"><span data-stu-id="fbb31-135">App launch</span></span>

<span data-ttu-id="fbb31-136">アプリが起動されると、[**OnLaunched**](https://msdn.microsoft.com/library/windows/apps/br242335) メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-136">The [**OnLaunched**](https://msdn.microsoft.com/library/windows/apps/br242335) method is called when an app is launched.</span></span> <span data-ttu-id="fbb31-137">このメソッドに [**LaunchActivatedEventArgs**](https://msdn.microsoft.com/library/windows/apps/br224731) パラメーターが渡されます。このパラメーターは、特に、アプリに渡された引数、アプリを起動したタイルの識別子、アプリの以前の状態を提供します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-137">It is passed a [**LaunchActivatedEventArgs**](https://msdn.microsoft.com/library/windows/apps/br224731) parameter which provides, among other things, the arguments passed to the app, the identifier of the tile that launched the app, and the previous state that the app was in.</span></span>

<span data-ttu-id="fbb31-138">アプリの以前の状態は、[ApplicationExecutionState](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.applicationexecutionstate.aspx) を返す [LaunchActivatedEventArgs.PreviousExecutionState](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.launchactivatedeventargs.previousexecutionstate) から取得します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-138">Get the previous state of your app from [LaunchActivatedEventArgs.PreviousExecutionState](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.launchactivatedeventargs.previousexecutionstate) which returns an [ApplicationExecutionState](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.applicationexecutionstate.aspx).</span></span> <span data-ttu-id="fbb31-139">その値とその状態に対する適切なアクションは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-139">Its values and the appropriate action to take due to that state are as follows:</span></span>

| <span data-ttu-id="fbb31-140">ApplicationExecutionState</span><span class="sxs-lookup"><span data-stu-id="fbb31-140">ApplicationExecutionState</span></span> | <span data-ttu-id="fbb31-141">説明</span><span class="sxs-lookup"><span data-stu-id="fbb31-141">Explanation</span></span> | <span data-ttu-id="fbb31-142">実行するアクション</span><span class="sxs-lookup"><span data-stu-id="fbb31-142">Action to take</span></span> |
|-------|-------------|----------------|
| **<span data-ttu-id="fbb31-143">NotRunning</span><span class="sxs-lookup"><span data-stu-id="fbb31-143">NotRunning</span></span>** | <span data-ttu-id="fbb31-144">アプリがこの状態になるのは、ユーザーが前回再起動するか、ログインしてから、アプリが起動されていないためである可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-144">An app could be in this state because it hasn't been launched since the last time the user rebooted or logged in.</span></span> <span data-ttu-id="fbb31-145">また、アプリが実行中であったがクラッシュした場合や、ユーザーが以前にアプリを閉じたために、この状態になっている可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-145">It can also be in this state if it was running but then crashed, or because the user closed it earlier.</span></span>| <span data-ttu-id="fbb31-146">現在のユーザー セッションで初めて実行する場合と同様に、アプリを初期化します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-146">Initialize the app as if it is running for the first time in the current user session.</span></span> |
|**<span data-ttu-id="fbb31-147">Suspended</span><span class="sxs-lookup"><span data-stu-id="fbb31-147">Suspended</span></span>** | <span data-ttu-id="fbb31-148">ユーザーがアプリを最小化したか、アプリを切り替えてから、数秒以内にそのアプリに戻っていません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-148">The user either minimized or switched away from your app and didn't return to it within a few seconds.</span></span> | <span data-ttu-id="fbb31-149">アプリが中断されると、アプリの状態はメモリ内に保持されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-149">When the app was suspended, its state remained in memory.</span></span> <span data-ttu-id="fbb31-150">必要な処理は、アプリが中断されたときに解放したファイル ハンドルやその他のリソースを再取得することだけです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-150">You only need to reacquire any file handles or other resources you released when the app was suspended.</span></span> |
| **<span data-ttu-id="fbb31-151">Terminated</span><span class="sxs-lookup"><span data-stu-id="fbb31-151">Terminated</span></span>** | <span data-ttu-id="fbb31-152">アプリは、以前に中断されましたが、システムがメモリを再利用する必要があったため、ある時点でシャットダウンされました。</span><span class="sxs-lookup"><span data-stu-id="fbb31-152">The app was previously suspended but was then shutdown at some point because the system needed to reclaim memory.</span></span> | <span data-ttu-id="fbb31-153">ユーザーがアプリを切り替えたときのアプリの状態を復元します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-153">Restore the state that the app was in when the user switched away from it.</span></span>|
|**<span data-ttu-id="fbb31-154">ClosedByUser</span><span class="sxs-lookup"><span data-stu-id="fbb31-154">ClosedByUser</span></span>** | <span data-ttu-id="fbb31-155">ユーザーは、タブレット モードでの閉じるジェスチャや、Alt キーを押しながら F4 キーを押すことによって、アプリを終了しました。</span><span class="sxs-lookup"><span data-stu-id="fbb31-155">The user closed the app with the close gesture in tablet mode, or with Alt+F4.</span></span> <span data-ttu-id="fbb31-156">ユーザーがアプリを閉じた場合、アプリはまず中断され、次に終了します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-156">When the user closes the app, it is first suspended and then terminated.</span></span> | <span data-ttu-id="fbb31-157">アプリは基本的に Terminated 状態に至る手順と同じ手順に従うため、Terminated 状態と同じ方法でこれを処理します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-157">Because the app has essentially gone through the same steps that lead to the Terminated state, handle this the same way you would the Terminated state.</span></span>|
|**<span data-ttu-id="fbb31-158">Running</span><span class="sxs-lookup"><span data-stu-id="fbb31-158">Running</span></span>** | <span data-ttu-id="fbb31-159">ユーザーがアプリを起動しようとしたときに、アプリは既に開いていました。</span><span class="sxs-lookup"><span data-stu-id="fbb31-159">The app was already open when the user tried to launch it again.</span></span> | <span data-ttu-id="fbb31-160">なし。</span><span class="sxs-lookup"><span data-stu-id="fbb31-160">Nothing.</span></span> <span data-ttu-id="fbb31-161">アプリの別のインスタンスが起動されないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-161">Note that another instance of your app is not launched.</span></span> <span data-ttu-id="fbb31-162">既に実行中のインスタンスが、単にアクティブ化されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-162">The already running instance is simply activated.</span></span> |

<span data-ttu-id="fbb31-163">\**注:\*\*\*現在のユーザー セッション*は、Windows ログオンに基づいています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-163">\**Note\*\*\*Current user session* is based on Windows logon.</span></span> <span data-ttu-id="fbb31-164">現在のユーザーがログオフ、Windows のシャットダウンや再起動を行っていない限り、現在のユーザー セッションは、ロック画面認証やユーザーの切り替えなどのイベント間で保持されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-164">As long as the current user hasn't logged off, shut down, or restarted Windows, the current user session persists across events such as lock screen authentication, switch-user, and so on.</span></span> 

<span data-ttu-id="fbb31-165">注意すべき重要な状況が 1 つあります。デバイスに十分なリソースがある場合、応答性の最適化のために事前起動がオプトインされている、使用頻度の高いアプリをオペレーティング システムが事前起動することです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-165">One important circumstance to be aware of is that if the device has sufficient resources, the operating system will prelaunch frequently used apps that have opted in for that behavior in order to optimize responsiveness.</span></span> <span data-ttu-id="fbb31-166">事前起動されたアプリは、バックグラウンドで起動され、すぐに中断されます。これにより、ユーザーがこれらのアプリに切り替えたときに、アプリを起動するよりも高速に再開することができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-166">Apps that are prelaunched are launched in the background and then quickly suspended so that when the user switches to them, they can be resumed which is faster than launching the app.</span></span>

<span data-ttu-id="fbb31-167">事前起動のために、アプリの **OnLaunched()** メソッドは、ユーザーではなく、システムによって開始される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-167">Because of prelaunch, the app’s **OnLaunched()** method may be initiated by the system rather than by the user.</span></span> <span data-ttu-id="fbb31-168">アプリはバックグラウンドで事前起動されるため、**OnLaunched()** で異なるアクションが必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-168">Because the app is prelaunched in the background you may need to take different action in **OnLaunched()**.</span></span> <span data-ttu-id="fbb31-169">たとえば、アプリが起動時に音楽の再生を開始する場合、アプリはバックグラウンドで事前起動されるため、どこから音楽が再生されているのかわかりません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-169">For example, if your app starts playing music when launched, they will not know where it is coming from because the app is prelaunched in the background.</span></span> <span data-ttu-id="fbb31-170">アプリがバックグラウンドで事前起動されたら、続けて **Application.Suspending** を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-170">Once your app is prelaunched in the background, it is followed by a call to **Application.Suspending**.</span></span> <span data-ttu-id="fbb31-171">その後、ユーザーがアプリを起動したときに、**OnLaunched()** メソッドと共に再開イベントが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-171">Then, when the user does launch the app, the resuming event is invoked as well as the **OnLaunched()** method.</span></span> <span data-ttu-id="fbb31-172">事前起動のシナリオを処理する方法について詳しくは、「[アプリの事前起動の処理](handle-app-prelaunch.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-172">See [Handle app prelaunch](handle-app-prelaunch.md) for additional information about how to handle the prelaunch scenario.</span></span> <span data-ttu-id="fbb31-173">オプトインしているアプリだけが事前起動されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-173">Only apps that opt-in are prelaunched.</span></span>

<span data-ttu-id="fbb31-174">Windows によって、アプリの起動時に、アプリのスプラッシュ画面が表示されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-174">Windows displays a splash screen for the app when it is launched.</span></span> <span data-ttu-id="fbb31-175">スプラッシュ画面を構成するには、「[スプラッシュ画面の追加](https://msdn.microsoft.com/library/windows/apps/xaml/hh465331)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-175">To configure the splash screen, see [Adding a splash screen](https://msdn.microsoft.com/library/windows/apps/xaml/hh465331).</span></span>

<span data-ttu-id="fbb31-176">スプラッシュ画面が表示されているときに、アプリはイベント ハンドラーを登録し、最初のページに必要なカスタム UI を設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-176">While the splash screen is displayed, your app should register event handlers and set up any custom UI it needs for the initial page.</span></span> <span data-ttu-id="fbb31-177">アプリのコンストラクターや **OnLaunched()** で実行されるこれらのタスクが数秒以内に完了することを確認します。数秒以内に完了しない場合、システムはアプリが応答していないと判断し、アプリを終了する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-177">See that these tasks running in the application’s constructor and **OnLaunched()** are completed within a few seconds or the system may think your app is unresponsive and terminate it.</span></span> <span data-ttu-id="fbb31-178">アプリがネットワーク経由でデータを要求したり、ディスクから大量のデータを取得したりする必要がある場合、こうしたアクティビティは起動とは別に実行してください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-178">If an app needs to request data from the network or needs to retrieve large amounts of data from disk, these activities should be completed outside of launch.</span></span> <span data-ttu-id="fbb31-179">実行に時間がかかる操作が完了するまでの間、アプリでは、アプリ独自のカスタム読み込み UI や追加のスプラッシュ画面を使うことができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-179">An app can use its own custom loading UI or an extended splash screen while it waits for long running operations to finish.</span></span> <span data-ttu-id="fbb31-180">詳しくは、「[スプラッシュ画面の表示時間の延長](create-a-customized-splash-screen.md)」や「[スプラッシュ画面のサンプル](http://go.microsoft.com/fwlink/p/?linkid=234889)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-180">See [Display a splash screen for more time](create-a-customized-splash-screen.md) and the [Splash screen sample](http://go.microsoft.com/fwlink/p/?linkid=234889) for more info.</span></span>

<span data-ttu-id="fbb31-181">アプリの起動が完了すると、アプリが **Running** 状態になり、スプラッシュ画面は消えて、スプラッシュ画面のすべてのリソースとオブジェクトは消去されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-181">After the app completes launching, it enters the **Running** state and the splash screen disappears and all splash screen resources and objects are cleared.</span></span>

## <a name="app-activation"></a><span data-ttu-id="fbb31-182">アプリのアクティブ化</span><span class="sxs-lookup"><span data-stu-id="fbb31-182">App activation</span></span>

<span data-ttu-id="fbb31-183">ユーザーによる起動とは対照的には、システムによってアプリをアクティブ化できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-183">In contrast to being launched by the user, an app can be activated by the system.</span></span> <span data-ttu-id="fbb31-184">アプリは、共有コントラクトなどのコントラクトによってアクティブ化される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-184">An app may be activated by a contract such as the share contract.</span></span> <span data-ttu-id="fbb31-185">また、カスタム URI プロトコルや、アプリが処理するように登録されている拡張子を持つファイルを処理するためにアクティブ化される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-185">Or it may be activated to handle a custom URI protocol or a file with an extension that your app is registered to handle.</span></span> <span data-ttu-id="fbb31-186">アプリをアクティブ化する方法の一覧については、「[**ActivationKind**](https://msdn.microsoft.com/library/windows/apps/br224693)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-186">For a list of ways your app can be activated, see [**ActivationKind**](https://msdn.microsoft.com/library/windows/apps/br224693).</span></span>

<span data-ttu-id="fbb31-187">[**Windows.UI.Xaml.Application**](https://msdn.microsoft.com/library/windows/apps/br242324) クラスで定義されているメソッドをオーバーライドして、アプリをアクティブ化するさまざまな方法に対応することができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-187">The [**Windows.UI.Xaml.Application**](https://msdn.microsoft.com/library/windows/apps/br242324) class defines methods you can override to handle the various ways your app may be activated.</span></span>
<span data-ttu-id="fbb31-188">[**OnActivated**](https://msdn.microsoft.com/library/windows/apps/br242330) は、発生する可能性があるすべてのアクティブ化の種類を処理できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-188">[**OnActivated**](https://msdn.microsoft.com/library/windows/apps/br242330) can handle all possible activation types.</span></span> <span data-ttu-id="fbb31-189">ただし、最も一般的なアクティブ化の種類を処理する場合は特定のメソッドを使い、あまり一般的ではないアクティブ化の種類を処理する際の代替手段としてのみ **OnActivated** を使うことが多くあります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-189">However, it's more common to use specific methods to handle the most common activation types, and use **OnActivated** as the fallback method for the less common activation types.</span></span> <span data-ttu-id="fbb31-190">特定のアクティブ化については、次のような追加のメソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-190">These are the additional methods for specific activations:</span></span>

[**<span data-ttu-id="fbb31-191">OnCachedFileUpdaterActivated</span><span class="sxs-lookup"><span data-stu-id="fbb31-191">OnCachedFileUpdaterActivated</span></span>**](https://msdn.microsoft.com/library/windows/apps/hh701797)  
[**<span data-ttu-id="fbb31-192">OnFileActivated</span><span class="sxs-lookup"><span data-stu-id="fbb31-192">OnFileActivated</span></span>**](https://msdn.microsoft.com/library/windows/apps/br242331)  
<span data-ttu-id="fbb31-193">[**OnFileOpenPickerActivated**](https://msdn.microsoft.com/library/windows/apps/hh701799)  [**OnFileSavePickerActivated**](https://msdn.microsoft.com/library/windows/apps/hh701801)</span><span class="sxs-lookup"><span data-stu-id="fbb31-193">[**OnFileOpenPickerActivated**](https://msdn.microsoft.com/library/windows/apps/hh701799)  [**OnFileSavePickerActivated**](https://msdn.microsoft.com/library/windows/apps/hh701801)</span></span>  
[**<span data-ttu-id="fbb31-194">OnSearchActivated</span><span class="sxs-lookup"><span data-stu-id="fbb31-194">OnSearchActivated</span></span>**](https://msdn.microsoft.com/library/windows/apps/br242336)  
[**<span data-ttu-id="fbb31-195">OnShareTargetActivated</span><span class="sxs-lookup"><span data-stu-id="fbb31-195">OnShareTargetActivated</span></span>**](https://msdn.microsoft.com/library/windows/apps/hh701806)

<span data-ttu-id="fbb31-196">これらのメソッドのイベント データには、既に説明した同じ [**PreviousExecutionState**](https://msdn.microsoft.com/library/windows/apps/br224729) プロパティが含まれており、アプリがアクティブ化される前の状態を確認することができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-196">The event data for these methods includes the same  [**PreviousExecutionState**](https://msdn.microsoft.com/library/windows/apps/br224729) property that we saw above, which tells you which state your app was in before it was activated.</span></span> <span data-ttu-id="fbb31-197">前の「[アプリの起動](#app-launch)」セクションで説明した方法と同じ方法で、状態と対処を解釈します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-197">Interpret the state and what you should do it the same way as described above in the [App launch](#app-launch) section.</span></span>

<span data-ttu-id="fbb31-198">**注:** 場合は、コンピューターの管理者アカウントを使用してログオンには、UWP アプリをアクティブ化することはできません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-198">**Note**If you log on using the computer's Administrator account, you can't activate UWP apps.</span></span>

## <a name="running-in-the-background"></a><span data-ttu-id="fbb31-199">バックグラウンドでの実行</span><span class="sxs-lookup"><span data-stu-id="fbb31-199">Running in the background</span></span> ##

<span data-ttu-id="fbb31-200">Windows 10 バージョン 1607 以降では、アプリは、アプリ自体と同じプロセスでバックグラウンド タスクを実行できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-200">Starting with Windows 10, version 1607, apps can run background tasks within the same process as the app itself.</span></span> <span data-ttu-id="fbb31-201">詳しくは、[シングル プロセス モデルでのバックグラウンド アクティビティに関する記事](https://blogs.windows.com/buildingapps/2016/06/07/background-activity-with-the-single-process-model/#tMmI7wUuYu5CEeRm.99)をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-201">Read more about it in [Background activity with the Single Process Model](https://blogs.windows.com/buildingapps/2016/06/07/background-activity-with-the-single-process-model/#tMmI7wUuYu5CEeRm.99).</span></span> <span data-ttu-id="fbb31-202">インプロセスのバックグラウンド処理については、この記事では詳しく説明しませんが、アプリのライフサイクルへの影響として、アプリをバックグラウンドで実行する場合に関連する 2 つの新しいイベントが追加されています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-202">We won't go into in-process background processing in this article, but how this impacts the app lifecycle is that two new events have been added related to when your app is in the background.</span></span> <span data-ttu-id="fbb31-203">[**EnteredBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.EnteredBackground) と [**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground) です。</span><span class="sxs-lookup"><span data-stu-id="fbb31-203">They are: [**EnteredBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.EnteredBackground) and [**LeavingBackground**](https://msdn.microsoft.com/library/windows/apps/Windows.ApplicationModel.Core.CoreApplication.LeavingBackground).</span></span>

<span data-ttu-id="fbb31-204">これらのイベントは、アプリの UI を表示するかどうかも反映します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-204">These events also reflect whether the user can see your app's UI.</span></span>

<span data-ttu-id="fbb31-205">バックグラウンドでの実行は、アプリが起動、アクティブ化、再開されたときの既定の状態です。</span><span class="sxs-lookup"><span data-stu-id="fbb31-205">Running in the background is the default state that an application is launched, activated, or resumed into.</span></span> <span data-ttu-id="fbb31-206">この状態では、アプリの UI はまだ表示されません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-206">In this state your application UI is not visible yet.</span></span>

## <a name="running-in-the-foreground"></a><span data-ttu-id="fbb31-207">フォアグラウンドでの実行</span><span class="sxs-lookup"><span data-stu-id="fbb31-207">Running in the foreground</span></span> ##

<span data-ttu-id="fbb31-208">フォアグラウンドでの実行は、アプリの UI が表示されていることを意味します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-208">Running in the foreground means that your app's UI is visible.</span></span>

<span data-ttu-id="fbb31-209">**LeavingBackground** イベントは、アプリの UI が表示される直前で、フォアグラウンドでの実行状態になる前に発生します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-209">The **LeavingBackground** event is fired just before your application UI is visible and before entering the running in foreground state.</span></span> <span data-ttu-id="fbb31-210">また、ユーザーが元のアプリに切り替えるときにも発生します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-210">It also fires when the user switches back to your app.</span></span>

<span data-ttu-id="fbb31-211">以前は、UI のアセットを読み込むのに最適な場所が、**Activated** または **Resuming** イベント ハンドラーでした。</span><span class="sxs-lookup"><span data-stu-id="fbb31-211">Previously, the best location to load UI assets was in the **Activated** or **Resuming** event handlers.</span></span> <span data-ttu-id="fbb31-212">現在は、**LeavingBackground** が UI の準備ができていることを確認するのに最適な場所です。</span><span class="sxs-lookup"><span data-stu-id="fbb31-212">Now **LeavingBackground** is the best place to verify that your UI is ready.</span></span>

<span data-ttu-id="fbb31-213">この時点でビジュアル アセットの準備が完了していることを確認すること重要です。これが、ユーザーに対してアプリが表示される前に処理を実行する最後の機会であるためです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-213">It is important to check that visual assets are ready by this time because this is the last opportunity to do work before your application is visible to the user.</span></span> <span data-ttu-id="fbb31-214">このイベント ハンドラー内でのすべての UI 処理は、迅速に完了する必要があります。これは、ユーザーが経験する起動時間や再開時間に影響を与えるためです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-214">All UI work in this event handler should complete quickly, as it impacts the launch and resume time that the user experiences.</span></span> <span data-ttu-id="fbb31-215">**LeavingBackground** は、UI の最初のフレームの準備ができていることを確認するタイミングです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-215">**LeavingBackground** is the time to ensure the first frame of UI is ready.</span></span> <span data-ttu-id="fbb31-216">その後、このイベント ハンドラーが制御を戻すことができるように、長時間にわたるストレージやネットワークの呼び出し処理を非同期的に処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-216">Then, long-running storage or network calls should be handled asynchronously so that the event handler may return.</span></span>

<span data-ttu-id="fbb31-217">ユーザーが他のアプリに切り替えると、元のアプリは再びバックグラウンドでの実行状態に戻ります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-217">When the user switches away from your application, your app reenters the running in background state.</span></span>

## <a name="reentering-the-background-state"></a><span data-ttu-id="fbb31-218">バックグラウンド状態に戻る</span><span class="sxs-lookup"><span data-stu-id="fbb31-218">Reentering the background state</span></span>

<span data-ttu-id="fbb31-219">**EnteredBackground**イベントは、アプリがフォアグラウンドに表示されなくなったことを示します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-219">The **EnteredBackground** event indicates that your app is no longer visible in the foreground.</span></span> <span data-ttu-id="fbb31-220">デスクトップでは、**EnteredBackground** はアプリが最小化されたときに発生します。電話では、ホーム画面や別のアプリに切り替えたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-220">On the desktop **EnteredBackground** fires when your app is minimized; on phone, when switching to the home screen or another app.</span></span>

### <a name="reduce-your-apps-memory-usage"></a><span data-ttu-id="fbb31-221">アプリのメモリ使用量を減らす</span><span class="sxs-lookup"><span data-stu-id="fbb31-221">Reduce your app's memory usage</span></span>

<span data-ttu-id="fbb31-222">アプリがユーザーに表示されなくなったため、これは UI のレンダリング処理とアニメーションを停止するのに最適な場所です。</span><span class="sxs-lookup"><span data-stu-id="fbb31-222">Since your app is no longer visible to the user, this is the best place to stop UI rendering work and animations.</span></span> <span data-ttu-id="fbb31-223">**LeavingBackground** を使って、もう一度その作業を開始できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-223">You can use **LeavingBackground** to start that work again.</span></span>

<span data-ttu-id="fbb31-224">バックグラウンドで処理を実行する場合、ここで処理を準備することができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-224">If you are going to do work in the background, this is the place to prepare for it.</span></span> <span data-ttu-id="fbb31-225">[MemoryManager.AppMemoryUsageLevel](https://msdn.microsoft.com/library/windows/apps/windows.system.memorymanager.appmemoryusagelevel.aspx) を確認し、必要に応じてバックグラウンドでの実行時のアプリのメモリ使用量を減らすことにより、システムがリソースを解放するためにアプリを終了するリスクを下げることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fbb31-225">It is best to check [MemoryManager.AppMemoryUsageLevel](https://msdn.microsoft.com/library/windows/apps/windows.system.memorymanager.appmemoryusagelevel.aspx) and, if needed, reduce the amount of memory being used by your app when it is running in the background so that your app doesn't risk being terminated by the system to free up resources.</span></span>

<span data-ttu-id="fbb31-226">詳しくは、[アプリがバックグラウンドの状態に移行したときにメモリ使用量を減らす方法に関する記事](reduce-memory-usage.md)をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-226">See [Reduce memory usage when your app moves to the background state](reduce-memory-usage.md) for more details.</span></span>

### <a name="save-your-state"></a><span data-ttu-id="fbb31-227">状態を保存する</span><span class="sxs-lookup"><span data-stu-id="fbb31-227">Save your state</span></span>

<span data-ttu-id="fbb31-228">中断イベント ハンドラーは、アプリの状態を保存するのに最適な場所です。</span><span class="sxs-lookup"><span data-stu-id="fbb31-228">The suspending event handler is the best place to save your app state.</span></span> <span data-ttu-id="fbb31-229">しかし、バックグラウンドでの処理を行う場合 (オーディオの再生、延長実行セッションの使用、インプロセス バックグラウンド タスクなど) は、**EnteredBackground** イベント ハンドラーから非同期的にデータを保存することもお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fbb31-229">However, if you are doing work in the background (for example, audio playback, using an extended execution session or in-proc background task), it is also a good practice to save your data asynchronously from your **EnteredBackground** event handler.</span></span> <span data-ttu-id="fbb31-230">これは、アプリがバックグラウンドにある間に優先順位が低く、アプリが終了される可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-230">This is because it is possible for your app to be terminated while it is at a lower priority in the background.</span></span> <span data-ttu-id="fbb31-231">また、その場合、アプリは中断状態を経ないため、データは失われます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-231">And because the app will not have gone through the suspended state in that case, your data will be lost.</span></span>

<span data-ttu-id="fbb31-232">バックグラウンド アクティビティが開始される前に、**EnteredBackground** イベント ハンドラーでデータを保存することにより、ユーザーがアプリをフォアグラウンドに戻したときに、優れたユーザー エクスペリエンスを提供できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-232">Saving your data in your **EnteredBackground** event handler, before background activity begins, ensures a good user experience when the user brings your app back to the foreground.</span></span> <span data-ttu-id="fbb31-233">アプリケーション データ API を使用して、データと設定を保存することができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-233">You can use the application data APIs to save data and settings.</span></span> <span data-ttu-id="fbb31-234">詳しくは、「[設定と他のアプリ データを保存して取得する](https://msdn.microsoft.com/library/windows/apps/mt299098)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-234">For more info, see [Store and retrieve settings and other app data](https://msdn.microsoft.com/library/windows/apps/mt299098).</span></span>

<span data-ttu-id="fbb31-235">データを保存した後、メモリ使用量の上限を超えている場合、後で再読み込みできるため、メモリからデータを解放できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-235">After you save your data, if you are over your memory usage limit, then you can release your data from memory since you can reload it later.</span></span> <span data-ttu-id="fbb31-236">これによりメモリが解放され、バックグラウンド アクティビティに必要なアセットで使用できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-236">That will free memory that can be used by the assets needed for background activity.</span></span>

<span data-ttu-id="fbb31-237">アプリのバックグラウンド アクティビティで進行中である場合、中断状態を経ずに、バックグラウンドでの実行状態からフォアグラウンドでの実行状態に移行できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-237">Be aware that if your app has background activity in progress that it can move from the running in the background state to the running in the foreground state without ever reaching the suspended state.</span></span>

### <a name="asynchronous-work-and-deferrals"></a><span data-ttu-id="fbb31-238">非同期処理と保留</span><span class="sxs-lookup"><span data-stu-id="fbb31-238">Asynchronous work and Deferrals</span></span>

<span data-ttu-id="fbb31-239">ハンドラー内で非同期呼び出しを行う場合、制御はその非同期呼び出しからすぐに戻ります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-239">If you make an asynchronous call within your handler, control returns immediately from that asynchronous call.</span></span> <span data-ttu-id="fbb31-240">つまり、非同期呼び出しがまだ完了していない場合でも、イベント ハンドラーから制御が戻り、アプリを次の状態に移行できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-240">That means that execution can then return from your event handler and your app will move to the next state even though the asynchronous call hasn't completed yet.</span></span> <span data-ttu-id="fbb31-241">イベント ハンドラーに渡される [**EnteredBackgroundEventArgs**](http://aka.ms/Ag2yh4) オブジェクトの [**GetDeferral**](http://aka.ms/Kt66iv) メソッドを使用して、[**Windows.Foundation.Deferral**](https://msdn.microsoft.com/library/windows/apps/windows.foundation.deferral.aspx) オブジェクトの [**Complete**](https://msdn.microsoft.com/library/windows/apps/windows.foundation.deferral.complete.aspx) メソッドを呼び出した後まで中断を延期することができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-241">Use the [**GetDeferral**](http://aka.ms/Kt66iv) method on the [**EnteredBackgroundEventArgs**](http://aka.ms/Ag2yh4) object that is passed to your event handler to delay suspension until after you call the [**Complete**](https://msdn.microsoft.com/library/windows/apps/windows.foundation.deferral.complete.aspx) method on the returned [**Windows.Foundation.Deferral**](https://msdn.microsoft.com/library/windows/apps/windows.foundation.deferral.aspx) object.</span></span>

<span data-ttu-id="fbb31-242">遅延では、アプリが終了する前に、実行する必要があるコードの量を増やす必要はありません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-242">A deferral doesn't increase the amount you have to run your code before your app is terminated.</span></span> <span data-ttu-id="fbb31-243">遅延の *Complete* メソッドが呼び出されるか、または期限になるか、*どちらか早い方*まで、終了が延期されるだけです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-243">It only delays termination until either the deferral's *Complete* method is called, or the deadline passes-*whichever comes first*.</span></span>

<span data-ttu-id="fbb31-244">状態を保存するためにより多くの時間が必要な場合は、アプリがバックグラウンドの状態になる前に、段階的に状態を保存し、**EnteredBackground** イベント ハンドラーで保存する状態の情報を少なくする方法を調べます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-244">If you need more time to save your state, investigate ways to save your state in stages before your app enters the background state so that there is less to save in your **EnteredBackground** event handler.</span></span> <span data-ttu-id="fbb31-245">または、[ExtendedExecutionSession](https://msdn.microsoft.com/magazine/mt590969.aspx) を呼び出して、より多くの時間を取得します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-245">Or you may request an [ExtendedExecutionSession](https://msdn.microsoft.com/magazine/mt590969.aspx) to get more time.</span></span> <span data-ttu-id="fbb31-246">ただし、要求が許可される保証はないため、状態を保存するために必要な時間を最小限に抑える方法を見つけることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fbb31-246">There is no guarantee that the request will be granted, however, so it is best to find ways to minimize the amount of time you need to save your state.</span></span>

## <a name="app-suspend"></a><span data-ttu-id="fbb31-247">アプリの中断</span><span class="sxs-lookup"><span data-stu-id="fbb31-247">App suspend</span></span>

<span data-ttu-id="fbb31-248">ユーザーがアプリを最小化したとき、Windows は、ユーザーが再び元のアプリに切り替えるかどうかを確認するために数秒待機します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-248">When the user minimizes an app Windows waits a few seconds to see whether the user will switch back to it.</span></span> <span data-ttu-id="fbb31-249">ユーザーがこの時間内に再び元のアプリに切り替えることがなく、延長実行、バックグラウンド タスク、アクティビティ スポンサード実行がどれもアクティブではない場合、Windows はアプリを中断します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-249">If they do not switch back within this time window, and no extended execution, background task, or activity sponsored execution is active, Windows suspends the app.</span></span> <span data-ttu-id="fbb31-250">アプリは、延長実行セッションなどがそのアプリでアクティブではない限り、ロック画面が表示されているときにも中断されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-250">An app is also suspended when the lock screen appears as long as no extended execution session, etc. is active in that app.</span></span>

<span data-ttu-id="fbb31-251">アプリは、中断されると、[**Application.Suspending**](https://msdn.microsoft.com/library/windows/apps/br242341) イベントを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-251">When an app is suspended, it invokes the [**Application.Suspending**](https://msdn.microsoft.com/library/windows/apps/br242341) event.</span></span> <span data-ttu-id="fbb31-252">Visual Studio の UWP プロジェクト テンプレートでは、**App.xaml.cs** に **OnSuspending** と呼ばれるこのイベントのハンドラーが用意されています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-252">Visual Studio’s UWP project templates provide a handler for this event called **OnSuspending** in **App.xaml.cs**.</span></span> <span data-ttu-id="fbb31-253">Windows 10 バージョン 1607 より前のバージョンでは、状態を保存するコードをここに記述していました。</span><span class="sxs-lookup"><span data-stu-id="fbb31-253">Prior to Windows 10, version 1607, you would put the code to save your state here.</span></span> <span data-ttu-id="fbb31-254">現在は、前述のように、バックグラウンド状態に移行するときにアプリの状態を保存することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fbb31-254">Now the recommendation is to save your state when you enter the background state, as described above.</span></span>

<span data-ttu-id="fbb31-255">また、排他リソースとファイル ハンドルを、自分のアプリが中断されているときに他のアプリがアクセスできるように解放することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fbb31-255">You should release exclusive resources and file handles so that other apps can access them while your app is suspended.</span></span> <span data-ttu-id="fbb31-256">排他リソースには、カメラ、I/O デバイス、外部デバイス、ネットワーク リソースなどがあります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-256">Examples of exclusive resources include cameras, I/O devices, external devices, and network resources.</span></span> <span data-ttu-id="fbb31-257">排他リソースとファイル ハンドルを明示的に解放すると、自分のアプリが中断されているときに他のアプリが排他リソースとファイル ハンドルにアクセスできるようになります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-257">Explicitly releasing exclusive resources and file handles helps to ensure that other apps can access them while your app is suspended.</span></span> <span data-ttu-id="fbb31-258">アプリが再開されるときに、排他リソースとファイル ハンドルを再取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-258">When the app is resumed, it should reacquire  its exclusive resources and file handles.</span></span>

### <a name="be-aware-of-the-deadline"></a><span data-ttu-id="fbb31-259">期限に注意する</span><span class="sxs-lookup"><span data-stu-id="fbb31-259">Be aware of the deadline</span></span>

<span data-ttu-id="fbb31-260">高速で応答性の高いデバイスを実現するために、中断イベント ハンドラーでコードを実行する時間には制限があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-260">In order to ensure a fast and responsive device, there is a limit for the amount of time you have to run your code in your suspending event handler.</span></span> <span data-ttu-id="fbb31-261">この制限はデバイスごとに異なり、[**SuspendingOperation**](https://msdn.microsoft.com/library/windows/apps/br224688) オブジェクトの Deadline と呼ばれるプロパティを使って制限を確認できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-261">It is different for each device, and you can find out what it is using a property of the [**SuspendingOperation**](https://msdn.microsoft.com/library/windows/apps/br224688) object called the deadline.</span></span>

<span data-ttu-id="fbb31-262">**EnteredBackground** イベント ハンドラーと同様に、ハンドラーから非同期呼び出しを行う場合、制御はその非同期呼び出しからすぐに戻ります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-262">As with the **EnteredBackground** event handler, if you make an asynchronous call from your handler, control returns immediately from that asynchronous call.</span></span> <span data-ttu-id="fbb31-263">つまり、非同期呼び出しがまだ完了していない場合でも、イベント ハンドラーから制御が戻り、アプリを中断状態に移行できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-263">That means that execution can then return from your event handler and your app will move to the suspend state even though the asynchronous call hasn't completed yet.</span></span> <span data-ttu-id="fbb31-264">返された [**SuspendingDeferral**](https://msdn.microsoft.com/library/windows/apps/br224684) オブジェクトに [**Complete**](https://msdn.microsoft.com/library/windows/apps/br224685) メソッドを呼び出すまで中断状態への移行を遅らせるには、[**SuspendingOperation**](https://msdn.microsoft.com/library/windows/apps/br224688) オブジェクト (イベント引数経由で利用可能) に対して [**GetDeferral**](https://msdn.microsoft.com/library/windows/apps/br224690) メソッドを使います。</span><span class="sxs-lookup"><span data-stu-id="fbb31-264">Use the [**GetDeferral**](https://msdn.microsoft.com/library/windows/apps/br224690) method on the [**SuspendingOperation**](https://msdn.microsoft.com/library/windows/apps/br224688) object (available via the event args) to delay entering the suspended state until after you call the [**Complete**](https://msdn.microsoft.com/library/windows/apps/br224685) method on the returned [**SuspendingDeferral**](https://msdn.microsoft.com/library/windows/apps/br224684) object.</span></span>

<span data-ttu-id="fbb31-265">さらに多くの時間が必要な場合は、[ExtendedExecutionSession](https://msdn.microsoft.com/magazine/mt590969.aspx) を要求することができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-265">If you need more time, you may request an [ExtendedExecutionSession](https://msdn.microsoft.com/magazine/mt590969.aspx).</span></span> <span data-ttu-id="fbb31-266">ただし、要求が許可される保証はないため、**Suspended** イベント ハンドラーで必要な時間を最小限に抑える方法を見つけることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fbb31-266">There is no guarantee that the request will be granted, however, so it is best to find ways to minimize the amount of time you need in your **Suspended** event handler.</span></span>

### <a name="app-terminate"></a><span data-ttu-id="fbb31-267">アプリの終了</span><span class="sxs-lookup"><span data-stu-id="fbb31-267">App terminate</span></span>

<span data-ttu-id="fbb31-268">システムは、アプリの中断中に、アプリとそのデータをメモリに保持するよう試みます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-268">The system attempts to keep your app and its data in memory while it's suspended.</span></span> <span data-ttu-id="fbb31-269">ただし、アプリをメモリに保持するためのリソースがシステムにない場合、システムはアプリを終了します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-269">However, if the system does not have the resources to keep your app in memory, it will terminate your app.</span></span> <span data-ttu-id="fbb31-270">アプリは終了通知を受け取らないため、アプリのデータを保存するには、**OnSuspension** イベント ハンドラーで行うか、**EnteredBackground** ハンドラーで非同期的に行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-270">Apps don't receive a notification that they are being terminated, so the only opportunity you have to save your app's data is in your **OnSuspension** event handler, or asynchronously from your **EnteredBackground** handler.</span></span>

<span data-ttu-id="fbb31-271">終了されたアプリをアクティブ化するとき、アプリが終了する前と同じ状態になるように、保存したアプリのデータを読み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-271">When your app determines that it has been activated after being terminated, it should load the application data that it saved so that the app is in the same state it was in before it was terminated.</span></span> <span data-ttu-id="fbb31-272">中断されてから終了されたアプリにユーザーが戻るとき、アプリは [**OnLaunched**](https://msdn.microsoft.com/library/windows/apps/br242335) メソッドでアプリケーション データを復元する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-272">When the user switches back to a suspended app that has been terminated, the app should restore its application data in its [**OnLaunched**](https://msdn.microsoft.com/library/windows/apps/br242335) method.</span></span> <span data-ttu-id="fbb31-273">アプリが終了されるときは、システムはアプリに通知を送らないので、アプリは中断される前にアプリケーション データを保存し、排他リソースとファイル ハンドルを解放して、アプリが終了後アクティブ化されるときにそれらを復元する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-273">The system doesn't notify an app when it is terminated, so your app must save its application data and release exclusive resources and file handles before it is suspended, and restore them when the app is activated after termination.</span></span>

<span data-ttu-id="fbb31-274">**Visual Studio によるデバッグに関する注意事項:** Visual Studio は、Visual Studio デバッガーにアタッチされているアプリを Windows が中断するのを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-274">**A note about debugging using Visual Studio:** Visual Studio prevents Windows from suspending an app that is attached to the debugger.</span></span> <span data-ttu-id="fbb31-275">これは、アプリが実行されている間、ユーザーが Visual Studio デバッグの UI を確認できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="fbb31-275">This is to allow the user to view the Visual Studio debug UI while the app is running.</span></span> <span data-ttu-id="fbb31-276">アプリのデバッグ中は、Visual Studio を使ってそのアプリに中断イベントを送信できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-276">When you're debugging an app, you can send it a suspend event using Visual Studio.</span></span> <span data-ttu-id="fbb31-277">**[デバッグの場所]** ツール バーが表示されていることを確認し、**[中断]** アイコンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="fbb31-277">Make sure the **Debug Location** toolbar is being shown, then click the **Suspend** icon.</span></span>

## <a name="app-resume"></a><span data-ttu-id="fbb31-278">アプリの再開</span><span class="sxs-lookup"><span data-stu-id="fbb31-278">App resume</span></span>

<span data-ttu-id="fbb31-279">中断中のアプリは、ユーザーがそのアプリに切り替えた場合、またはデバイスが低電力状態から復帰してアクティブなアプリになった場合に再開されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-279">A suspended app is resumed when the user switches to it or when it is the active app when the device comes out of a low power state.</span></span>

<span data-ttu-id="fbb31-280">**Suspended** 状態からアプリを再開するとき、アプリは**バックグラウンドでの実行**状態に移行し、システムはアプリを中断前の状態に復元するので、ユーザーからはアプリがバックグラウンドでずっと実行されていたように見えます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-280">When an app is resumed from the **Suspended** state, it enters the **Running in background** state and the system restores the app where it left off so that it appears to the user as if it has been running all along.</span></span> <span data-ttu-id="fbb31-281">メモリに格納されているアプリのデータは失われません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-281">No app data stored in memory is lost.</span></span> <span data-ttu-id="fbb31-282">したがって、アプリは中断されたときに解放したファイル ハンドルやデバイス ハンドルを再取得し、中断されたときに明示的に解放された状態を復元する必要はありますが、ほとんどのアプリでは再開時に状態を復元する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-282">Therefore, most apps don't need to restore state when they are resumed though they should reacquire any file or device handles that they released when they were suspended, and restore any state that was explicitly released when the app was suspended.</span></span>

<span data-ttu-id="fbb31-283">アプリは、数時間から数日間中断される場合があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-283">You app may be suspended for hours or days.</span></span> <span data-ttu-id="fbb31-284">そのため、アプリのコンテンツやネットワーク接続が無効になっていると考えられる場合は、アプリの再開時にコンテンツやネットワーク接続を更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-284">If your app has content or network connections that may have gone stale, these should be refreshed when the app resumes.</span></span> <span data-ttu-id="fbb31-285">アプリに [**Application.Resuming**](https://msdn.microsoft.com/library/windows/apps/br242339) イベントのイベント ハンドラーが登録されている場合は、アプリが **Suspended** 状態から再開されるとこのイベント ハンドラーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-285">If an app registered an event handler for the [**Application.Resuming**](https://msdn.microsoft.com/library/windows/apps/br242339) event, it is called when the app is resumed from the **Suspended** state.</span></span> <span data-ttu-id="fbb31-286">このイベント ハンドラーでアプリのコンテンツやデータを更新できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-286">You can refresh your app content and data in this event handler.</span></span>

<span data-ttu-id="fbb31-287">中断中のアプリがアクティブ化されてアプリ コントラクトまたは拡張機能に参加する場合は、まず **Resuming** イベントを受け取り、次に **Activated** イベントを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-287">If a suspended app is activated to participate in an app contract or extension, it receives the **Resuming** event first, then the **Activated** event.</span></span>

<span data-ttu-id="fbb31-288">中断中のアプリが終了されていた場合、**Resuming** イベントはなく、代わりに **Terminated** の **ApplicationExecutionState** を使って **OnLaunched()** が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-288">If the suspended app was terminated, there is no **Resuming** event and instead **OnLaunched()** is called with an **ApplicationExecutionState** of **Terminated**.</span></span> <span data-ttu-id="fbb31-289">アプリが中断されたときに状態を保存しているため、ユーザーからはそのアプリから他に切り替えたときと同じに見えるように、**OnLaunched()** でその状態を復元できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-289">Because you saved your state when the app was suspended, you can restore that state during **OnLaunched()** so that your app appears to the user as it was when they switched away from it.</span></span>

<span data-ttu-id="fbb31-290">アプリは、中断されている間、受信登録したネットワーク イベントを受け取りません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-290">While an app is suspended, it does not receive any network events that it registered to receive.</span></span> <span data-ttu-id="fbb31-291">これらのネットワーク イベントはキューに入れられず、受け取ることができません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-291">These network events are not queued--they are simply missed.</span></span> <span data-ttu-id="fbb31-292">そのため、再開時にアプリでネットワーク ステータスをテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-292">Therefore, your app should test the network status when it is resumed.</span></span>

<span data-ttu-id="fbb31-293">**注:**、再開ハンドラーのコードは、UI と通信する場合は、 [**Resuming**](https://msdn.microsoft.com/library/windows/apps/br242339)イベントがないに発生するため、UI スレッドからディスパッチャーを使う必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbb31-293">**Note**Because the [**Resuming**](https://msdn.microsoft.com/library/windows/apps/br242339) event is not raised from the UI thread, a dispatcher must be used if the code in your resume handler communicates with your UI.</span></span> <span data-ttu-id="fbb31-294">これを行う方法のコード例については、[バックグラウンド スレッドからの UI スレッドの更新に関するページ](https://github.com/Microsoft/Windows-task-snippets/blob/master/tasks/UI-thread-access-from-background-thread.md)をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-294">See [Update the UI thread from a background thread](https://github.com/Microsoft/Windows-task-snippets/blob/master/tasks/UI-thread-access-from-background-thread.md) for a code example of how to do this.</span></span>

<span data-ttu-id="fbb31-295">一般的なガイドラインについては、[アプリの中断と再開のガイドラインに関するページ](https://msdn.microsoft.com/library/windows/apps/hh465088)をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-295">For general guidelines, see [Guidelines for app suspend and resume](https://msdn.microsoft.com/library/windows/apps/hh465088).</span></span>

## <a name="app-close"></a><span data-ttu-id="fbb31-296">アプリを閉じる</span><span class="sxs-lookup"><span data-stu-id="fbb31-296">App close</span></span>

<span data-ttu-id="fbb31-297">一般に、アプリを閉じる処理はユーザーが行う必要はなく、Windows で管理されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-297">Generally, users don't need to close apps, they can let Windows manage them.</span></span> <span data-ttu-id="fbb31-298">ただし、ユーザーはジェスチャを使うか、Alt + F4 キーを押すか、Windows Phone でタスク スイッチャーを使って、アプリを閉じることができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-298">However, users can choose to close an app using the close gesture or by pressing Alt+F4 or by using the task switcher on Windows Phone.</span></span>

<span data-ttu-id="fbb31-299">ユーザーがアプリを閉じたことを示すイベントはありません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-299">There is not an event to indicate that the user closed the app.</span></span> <span data-ttu-id="fbb31-300">アプリがユーザーによって閉じられたとき、その状態を保存する機会を提供するために、アプリはまず中断されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-300">When an app is closed by the user, it is first suspended to give you an opportunity to save its state.</span></span> <span data-ttu-id="fbb31-301">Windows8.1 以降では、アプリは、ユーザーによって閉じられると、アプリが画面から削除されると切り替えリストが明示的に終了します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-301">In Windows8.1 and later, after an app has been closed by the user, the app is removed from the screen and switch list but not explicitly terminated.</span></span>

<span data-ttu-id="fbb31-302">**ユーザーによって閉じられた動作:** アプリは、Windows によって閉じられたよりも、ユーザーが閉じたときに、異なる処理を実行する必要がある場合、アプリのユーザーによって、または Windows によって終了されたかどうかを判断する、アクティブ化イベント ハンドラーを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-302">**Closed-by-user behavior:** If your app needs to do something different when it is closed by the user than when it is closed by Windows, you can use the activation event handler to determine whether the app was terminated by the user or by Windows.</span></span> <span data-ttu-id="fbb31-303">[**ApplicationExecutionState**](https://msdn.microsoft.com/library/windows/apps/br224694) 列挙体に関するリファレンスの **ClosedByUser** 状態と **Terminated** 状態の説明をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-303">See the descriptions of **ClosedByUser** and **Terminated** states in the reference for the [**ApplicationExecutionState**](https://msdn.microsoft.com/library/windows/apps/br224694) enumeration.</span></span>

<span data-ttu-id="fbb31-304">必要でない限り、アプリをプログラムで閉じないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fbb31-304">We recommend that apps not close themselves programmatically unless absolutely necessary.</span></span> <span data-ttu-id="fbb31-305">たとえば、メモリ リークが検出された場合などは、ユーザーの個人データのセキュリティを確保するためにアプリ自体で閉じてもかまいません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-305">For example, if an app detects a memory leak, it can close itself to ensure the security of the user's personal data.</span></span>

## <a name="app-crash"></a><span data-ttu-id="fbb31-306">アプリのクラッシュ</span><span class="sxs-lookup"><span data-stu-id="fbb31-306">App crash</span></span>

<span data-ttu-id="fbb31-307">システム クラッシュのエクスペリエンスは、ユーザーがそれまで行っていた作業にできるだけ迅速に戻れるようにすることを目的としています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-307">The system crash experience is designed to get users back to what they were doing as quickly as possible.</span></span> <span data-ttu-id="fbb31-308">ユーザーを待たせることがないように、警告ダイアログなどによる通知は行わないでください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-308">You shouldn't provide a warning dialog or other notification because that will delay the user.</span></span>

<span data-ttu-id="fbb31-309">アプリがクラッシュしたり、応答しなくなったり、例外が生成されたりすると、ユーザーの [フィードバックと診断の設定](http://go.microsoft.com/fwlink/p/?LinkID=614828) に従って、マイクロソフトに問題レポートが送られます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-309">If your app crashes, stops responding, or generates an exception, a problem report is sent to Microsoft per the user's [feedback and diagnostics settings](http://go.microsoft.com/fwlink/p/?LinkID=614828).</span></span> <span data-ttu-id="fbb31-310">Microsoft は、アプリの改善に役立つように、問題レポートに含まれるエラー データの一部を提供しています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-310">Microsoft provides a subset of the error data in the problem report to you so that you can use it to improve your app.</span></span> <span data-ttu-id="fbb31-311">このデータは、ダッシュボードに表示されるアプリの [品質] ページで確認できます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-311">You'll be able to see this data in your app's Quality page in your Dashboard.</span></span>

<span data-ttu-id="fbb31-312">アプリがクラッシュした後にユーザーがアプリをアクティブ化すると、アクティブ化イベント ハンドラーは [**ApplicationExecutionState**](https://msdn.microsoft.com/library/windows/apps/br224694) の値として **NotRunning** を受け取り、アプリの最初の UI とデータを表示します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-312">When the user activates an app after it crashes, its activation event handler receives an [**ApplicationExecutionState**](https://msdn.microsoft.com/library/windows/apps/br224694) value of **NotRunning**, and should display its initial UI and data.</span></span> <span data-ttu-id="fbb31-313">クラッシュの後、**Suspended** に基づく **Resuming** で使ったアプリ データはそのまま使わないでください。これは、そのデータが破損している可能性があるためです。「[アプリの中断と再開のガイドライン](https://msdn.microsoft.com/library/windows/apps/hh465088)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-313">After a crash, don't routinely use the app data you would have used for **Resuming** with **Suspended** because that data could be corrupt; see [Guidelines for app suspend and resume](https://msdn.microsoft.com/library/windows/apps/hh465088).</span></span>

## <a name="app-removal"></a><span data-ttu-id="fbb31-314">アプリの削除</span><span class="sxs-lookup"><span data-stu-id="fbb31-314">App removal</span></span>

<span data-ttu-id="fbb31-315">ユーザーがアプリを削除すると、アプリはすべてのローカル データと共に削除されます。</span><span class="sxs-lookup"><span data-stu-id="fbb31-315">When a user deletes your app, the app is removed, along with all its local data.</span></span> <span data-ttu-id="fbb31-316">アプリの削除は、一般的な場所 (ドキュメント ライブラリやピクチャ ライブラリ内など) に格納されているユーザーのデータには影響しません。</span><span class="sxs-lookup"><span data-stu-id="fbb31-316">Removing an app doesn't affect the user's data that was stored in common locations such as the Documents or Pictures libraries.</span></span>

## <a name="app-lifecycle-and-the-visual-studio-project-templates"></a><span data-ttu-id="fbb31-317">アプリのライフサイクルと Visual Studio のプロジェクト テンプレート</span><span class="sxs-lookup"><span data-stu-id="fbb31-317">App lifecycle and the Visual Studio project templates</span></span>

<span data-ttu-id="fbb31-318">アプリのライフサイクルに関連する基本的なコードは、Visual Studio のプロジェクト テンプレートに用意されています。</span><span class="sxs-lookup"><span data-stu-id="fbb31-318">The basic code that is relevant to the app lifecycle is provided in the Visual Studio project templates.</span></span> <span data-ttu-id="fbb31-319">基本的なアプリでは、起動アクティブ化を処理し、アプリ データを復元するための場所を提供して、独自のコードを追加する前であってもプライマリ UI を表示します。</span><span class="sxs-lookup"><span data-stu-id="fbb31-319">The basic app handles launch activation, provides a place for you to restore your app data, and displays the primary UI even before you've added any of your own code.</span></span> <span data-ttu-id="fbb31-320">詳しくは、「[アプリ用の C#、VB、C++ プロジェクト テンプレート](https://msdn.microsoft.com/library/windows/apps/hh768232)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fbb31-320">For more info, see [C#, VB, and C++ project templates for apps](https://msdn.microsoft.com/library/windows/apps/hh768232).</span></span>

## <a name="key-application-lifecycle-apis"></a><span data-ttu-id="fbb31-321">主要なアプリケーション ライフサイクル API</span><span class="sxs-lookup"><span data-stu-id="fbb31-321">Key application lifecycle APIs</span></span>

-   <span data-ttu-id="fbb31-322">[**Windows.ApplicationModel**](https://msdn.microsoft.com/library/windows/apps/br224691) 名前空間</span><span class="sxs-lookup"><span data-stu-id="fbb31-322">[**Windows.ApplicationModel**](https://msdn.microsoft.com/library/windows/apps/br224691) namespace</span></span>
-   <span data-ttu-id="fbb31-323">[**Windows.ApplicationModel.Activation**](https://msdn.microsoft.com/library/windows/apps/br224766) 名前空間</span><span class="sxs-lookup"><span data-stu-id="fbb31-323">[**Windows.ApplicationModel.Activation**](https://msdn.microsoft.com/library/windows/apps/br224766) namespace</span></span>
-   <span data-ttu-id="fbb31-324">[**Windows.ApplicationModel.Core**](https://msdn.microsoft.com/library/windows/apps/br205865) 名前空間</span><span class="sxs-lookup"><span data-stu-id="fbb31-324">[**Windows.ApplicationModel.Core**](https://msdn.microsoft.com/library/windows/apps/br205865) namespace</span></span>
-   <span data-ttu-id="fbb31-325">[**Windows.UI.Xaml.Application**](https://msdn.microsoft.com/library/windows/apps/br242324) クラス (XAML)</span><span class="sxs-lookup"><span data-stu-id="fbb31-325">[**Windows.UI.Xaml.Application**](https://msdn.microsoft.com/library/windows/apps/br242324) class (XAML)</span></span>
-   <span data-ttu-id="fbb31-326">[**Windows.UI.Xaml.Window**](https://msdn.microsoft.com/library/windows/apps/br209041) クラス (XAML)</span><span class="sxs-lookup"><span data-stu-id="fbb31-326">[**Windows.UI.Xaml.Window**](https://msdn.microsoft.com/library/windows/apps/br209041) class (XAML)</span></span>

## <a name="related-topics"></a><span data-ttu-id="fbb31-327">関連トピック</span><span class="sxs-lookup"><span data-stu-id="fbb31-327">Related topics</span></span>

* [**<span data-ttu-id="fbb31-328">ApplicationExecutionState</span><span class="sxs-lookup"><span data-stu-id="fbb31-328">ApplicationExecutionState</span></span>**](https://msdn.microsoft.com/library/windows/apps/br224694)
* [<span data-ttu-id="fbb31-329">アプリの中断と再開のガイドライン</span><span class="sxs-lookup"><span data-stu-id="fbb31-329">Guidelines for app suspend and resume</span></span>](https://msdn.microsoft.com/library/windows/apps/hh465088)
* [<span data-ttu-id="fbb31-330">アプリの事前起動の処理</span><span class="sxs-lookup"><span data-stu-id="fbb31-330">Handle app prelaunch</span></span>](handle-app-prelaunch.md)
* [<span data-ttu-id="fbb31-331">アプリのアクティブ化の処理</span><span class="sxs-lookup"><span data-stu-id="fbb31-331">Handle app activation</span></span>](activate-an-app.md)
* [<span data-ttu-id="fbb31-332">アプリの中断の処理</span><span class="sxs-lookup"><span data-stu-id="fbb31-332">Handle app suspend</span></span>](suspend-an-app.md)
* [<span data-ttu-id="fbb31-333">アプリの再開の処理</span><span class="sxs-lookup"><span data-stu-id="fbb31-333">Handle app resume</span></span>](resume-an-app.md)
* [<span data-ttu-id="fbb31-334">シングル プロセス モデルでのバックグラウンド アクティビティ</span><span class="sxs-lookup"><span data-stu-id="fbb31-334">Background activity with the Single Process Model</span></span>](https://blogs.windows.com/buildingapps/2016/06/07/background-activity-with-the-single-process-model/#tMmI7wUuYu5CEeRm.99)
* [<span data-ttu-id="fbb31-335">バックグラウンドでのメディアの再生</span><span class="sxs-lookup"><span data-stu-id="fbb31-335">Play media in the Background</span></span>](https://msdn.microsoft.com/windows/uwp/audio-video-camera/background-audio)

 

 
